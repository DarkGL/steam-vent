// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `tf2/tf_gcmessages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:CMsgTFGoldenWrenchBroadcast)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFGoldenWrenchBroadcast {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFGoldenWrenchBroadcast.wrench_number)
    pub wrench_number: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgTFGoldenWrenchBroadcast.deleted)
    pub deleted: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgTFGoldenWrenchBroadcast.user_name)
    pub user_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFGoldenWrenchBroadcast.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFGoldenWrenchBroadcast {
    fn default() -> &'a CMsgTFGoldenWrenchBroadcast {
        <CMsgTFGoldenWrenchBroadcast as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFGoldenWrenchBroadcast {
    pub fn new() -> CMsgTFGoldenWrenchBroadcast {
        ::std::default::Default::default()
    }

    // optional int32 wrench_number = 1;

    pub fn wrench_number(&self) -> i32 {
        self.wrench_number.unwrap_or(0)
    }

    pub fn clear_wrench_number(&mut self) {
        self.wrench_number = ::std::option::Option::None;
    }

    pub fn has_wrench_number(&self) -> bool {
        self.wrench_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wrench_number(&mut self, v: i32) {
        self.wrench_number = ::std::option::Option::Some(v);
    }

    // optional bool deleted = 2;

    pub fn deleted(&self) -> bool {
        self.deleted.unwrap_or(false)
    }

    pub fn clear_deleted(&mut self) {
        self.deleted = ::std::option::Option::None;
    }

    pub fn has_deleted(&self) -> bool {
        self.deleted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deleted(&mut self, v: bool) {
        self.deleted = ::std::option::Option::Some(v);
    }

    // optional string user_name = 3;

    pub fn user_name(&self) -> &str {
        match self.user_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_user_name(&mut self) {
        self.user_name = ::std::option::Option::None;
    }

    pub fn has_user_name(&self) -> bool {
        self.user_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_name(&mut self, v: ::std::string::String) {
        self.user_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_name(&mut self) -> &mut ::std::string::String {
        if self.user_name.is_none() {
            self.user_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.user_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_name(&mut self) -> ::std::string::String {
        self.user_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "wrench_number",
            |m: &CMsgTFGoldenWrenchBroadcast| { &m.wrench_number },
            |m: &mut CMsgTFGoldenWrenchBroadcast| { &mut m.wrench_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deleted",
            |m: &CMsgTFGoldenWrenchBroadcast| { &m.deleted },
            |m: &mut CMsgTFGoldenWrenchBroadcast| { &mut m.deleted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user_name",
            |m: &CMsgTFGoldenWrenchBroadcast| { &m.user_name },
            |m: &mut CMsgTFGoldenWrenchBroadcast| { &mut m.user_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTFGoldenWrenchBroadcast>(
            "CMsgTFGoldenWrenchBroadcast",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTFGoldenWrenchBroadcast {
    const NAME: &'static str = "CMsgTFGoldenWrenchBroadcast";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.wrench_number = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.deleted = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.user_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.wrench_number {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.deleted {
            my_size += 1 + 1;
        }
        if let Some(v) = self.user_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.wrench_number {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.deleted {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.user_name.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFGoldenWrenchBroadcast {
        CMsgTFGoldenWrenchBroadcast::new()
    }

    fn clear(&mut self) {
        self.wrench_number = ::std::option::Option::None;
        self.deleted = ::std::option::Option::None;
        self.user_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFGoldenWrenchBroadcast {
        static instance: CMsgTFGoldenWrenchBroadcast = CMsgTFGoldenWrenchBroadcast {
            wrench_number: ::std::option::Option::None,
            deleted: ::std::option::Option::None,
            user_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTFGoldenWrenchBroadcast {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTFGoldenWrenchBroadcast").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTFGoldenWrenchBroadcast {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFGoldenWrenchBroadcast {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTFSaxxyBroadcast)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFSaxxyBroadcast {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFSaxxyBroadcast.category_number)
    pub category_number: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgTFSaxxyBroadcast.user_name)
    pub user_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFSaxxyBroadcast.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFSaxxyBroadcast {
    fn default() -> &'a CMsgTFSaxxyBroadcast {
        <CMsgTFSaxxyBroadcast as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFSaxxyBroadcast {
    pub fn new() -> CMsgTFSaxxyBroadcast {
        ::std::default::Default::default()
    }

    // optional int32 category_number = 1;

    pub fn category_number(&self) -> i32 {
        self.category_number.unwrap_or(0)
    }

    pub fn clear_category_number(&mut self) {
        self.category_number = ::std::option::Option::None;
    }

    pub fn has_category_number(&self) -> bool {
        self.category_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_category_number(&mut self, v: i32) {
        self.category_number = ::std::option::Option::Some(v);
    }

    // optional string user_name = 2;

    pub fn user_name(&self) -> &str {
        match self.user_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_user_name(&mut self) {
        self.user_name = ::std::option::Option::None;
    }

    pub fn has_user_name(&self) -> bool {
        self.user_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_name(&mut self, v: ::std::string::String) {
        self.user_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_name(&mut self) -> &mut ::std::string::String {
        if self.user_name.is_none() {
            self.user_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.user_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_name(&mut self) -> ::std::string::String {
        self.user_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "category_number",
            |m: &CMsgTFSaxxyBroadcast| { &m.category_number },
            |m: &mut CMsgTFSaxxyBroadcast| { &mut m.category_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user_name",
            |m: &CMsgTFSaxxyBroadcast| { &m.user_name },
            |m: &mut CMsgTFSaxxyBroadcast| { &mut m.user_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTFSaxxyBroadcast>(
            "CMsgTFSaxxyBroadcast",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTFSaxxyBroadcast {
    const NAME: &'static str = "CMsgTFSaxxyBroadcast";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.category_number = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.user_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.category_number {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.user_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.category_number {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.user_name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFSaxxyBroadcast {
        CMsgTFSaxxyBroadcast::new()
    }

    fn clear(&mut self) {
        self.category_number = ::std::option::Option::None;
        self.user_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFSaxxyBroadcast {
        static instance: CMsgTFSaxxyBroadcast = CMsgTFSaxxyBroadcast {
            category_number: ::std::option::Option::None,
            user_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTFSaxxyBroadcast {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTFSaxxyBroadcast").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTFSaxxyBroadcast {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFSaxxyBroadcast {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCTFSpecificItemBroadcast)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCTFSpecificItemBroadcast {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCTFSpecificItemBroadcast.item_def_index)
    pub item_def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCTFSpecificItemBroadcast.was_destruction)
    pub was_destruction: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGCTFSpecificItemBroadcast.user_name)
    pub user_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCTFSpecificItemBroadcast.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCTFSpecificItemBroadcast {
    fn default() -> &'a CMsgGCTFSpecificItemBroadcast {
        <CMsgGCTFSpecificItemBroadcast as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCTFSpecificItemBroadcast {
    pub fn new() -> CMsgGCTFSpecificItemBroadcast {
        ::std::default::Default::default()
    }

    // optional uint32 item_def_index = 1;

    pub fn item_def_index(&self) -> u32 {
        self.item_def_index.unwrap_or(0)
    }

    pub fn clear_item_def_index(&mut self) {
        self.item_def_index = ::std::option::Option::None;
    }

    pub fn has_item_def_index(&self) -> bool {
        self.item_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_index(&mut self, v: u32) {
        self.item_def_index = ::std::option::Option::Some(v);
    }

    // optional bool was_destruction = 2;

    pub fn was_destruction(&self) -> bool {
        self.was_destruction.unwrap_or(false)
    }

    pub fn clear_was_destruction(&mut self) {
        self.was_destruction = ::std::option::Option::None;
    }

    pub fn has_was_destruction(&self) -> bool {
        self.was_destruction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_was_destruction(&mut self, v: bool) {
        self.was_destruction = ::std::option::Option::Some(v);
    }

    // optional string user_name = 3;

    pub fn user_name(&self) -> &str {
        match self.user_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_user_name(&mut self) {
        self.user_name = ::std::option::Option::None;
    }

    pub fn has_user_name(&self) -> bool {
        self.user_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_name(&mut self, v: ::std::string::String) {
        self.user_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_name(&mut self) -> &mut ::std::string::String {
        if self.user_name.is_none() {
            self.user_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.user_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_name(&mut self) -> ::std::string::String {
        self.user_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_def_index",
            |m: &CMsgGCTFSpecificItemBroadcast| { &m.item_def_index },
            |m: &mut CMsgGCTFSpecificItemBroadcast| { &mut m.item_def_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "was_destruction",
            |m: &CMsgGCTFSpecificItemBroadcast| { &m.was_destruction },
            |m: &mut CMsgGCTFSpecificItemBroadcast| { &mut m.was_destruction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user_name",
            |m: &CMsgGCTFSpecificItemBroadcast| { &m.user_name },
            |m: &mut CMsgGCTFSpecificItemBroadcast| { &mut m.user_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCTFSpecificItemBroadcast>(
            "CMsgGCTFSpecificItemBroadcast",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCTFSpecificItemBroadcast {
    const NAME: &'static str = "CMsgGCTFSpecificItemBroadcast";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.was_destruction = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.user_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_index {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.was_destruction {
            my_size += 1 + 1;
        }
        if let Some(v) = self.user_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.was_destruction {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.user_name.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCTFSpecificItemBroadcast {
        CMsgGCTFSpecificItemBroadcast::new()
    }

    fn clear(&mut self) {
        self.item_def_index = ::std::option::Option::None;
        self.was_destruction = ::std::option::Option::None;
        self.user_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCTFSpecificItemBroadcast {
        static instance: CMsgGCTFSpecificItemBroadcast = CMsgGCTFSpecificItemBroadcast {
            item_def_index: ::std::option::Option::None,
            was_destruction: ::std::option::Option::None,
            user_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCTFSpecificItemBroadcast {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCTFSpecificItemBroadcast").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCTFSpecificItemBroadcast {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCTFSpecificItemBroadcast {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTFWorldStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFWorldStatus {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFWorldStatus.beta_stress_test_event_active)
    pub beta_stress_test_event_active: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgTFWorldStatus.event_match_group)
    pub event_match_group: ::std::option::Option<::protobuf::EnumOrUnknown<ETFMatchGroup>>,
    // @@protoc_insertion_point(field:CMsgTFWorldStatus.event_expire_time)
    pub event_expire_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTFWorldStatus.active_client_version)
    pub active_client_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTFWorldStatus.disabled_match_groups)
    pub disabled_match_groups: ::std::vec::Vec<::protobuf::EnumOrUnknown<ETFMatchGroup>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFWorldStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFWorldStatus {
    fn default() -> &'a CMsgTFWorldStatus {
        <CMsgTFWorldStatus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFWorldStatus {
    pub fn new() -> CMsgTFWorldStatus {
        ::std::default::Default::default()
    }

    // optional bool beta_stress_test_event_active = 1;

    pub fn beta_stress_test_event_active(&self) -> bool {
        self.beta_stress_test_event_active.unwrap_or(false)
    }

    pub fn clear_beta_stress_test_event_active(&mut self) {
        self.beta_stress_test_event_active = ::std::option::Option::None;
    }

    pub fn has_beta_stress_test_event_active(&self) -> bool {
        self.beta_stress_test_event_active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_beta_stress_test_event_active(&mut self, v: bool) {
        self.beta_stress_test_event_active = ::std::option::Option::Some(v);
    }

    // optional .ETFMatchGroup event_match_group = 2;

    pub fn event_match_group(&self) -> ETFMatchGroup {
        match self.event_match_group {
            Some(e) => e.enum_value_or(ETFMatchGroup::k_eTFMatchGroup_Invalid),
            None => ETFMatchGroup::k_eTFMatchGroup_Invalid,
        }
    }

    pub fn clear_event_match_group(&mut self) {
        self.event_match_group = ::std::option::Option::None;
    }

    pub fn has_event_match_group(&self) -> bool {
        self.event_match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_match_group(&mut self, v: ETFMatchGroup) {
        self.event_match_group = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional fixed32 event_expire_time = 3;

    pub fn event_expire_time(&self) -> u32 {
        self.event_expire_time.unwrap_or(0u32)
    }

    pub fn clear_event_expire_time(&mut self) {
        self.event_expire_time = ::std::option::Option::None;
    }

    pub fn has_event_expire_time(&self) -> bool {
        self.event_expire_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_expire_time(&mut self, v: u32) {
        self.event_expire_time = ::std::option::Option::Some(v);
    }

    // optional uint32 active_client_version = 4;

    pub fn active_client_version(&self) -> u32 {
        self.active_client_version.unwrap_or(0)
    }

    pub fn clear_active_client_version(&mut self) {
        self.active_client_version = ::std::option::Option::None;
    }

    pub fn has_active_client_version(&self) -> bool {
        self.active_client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_client_version(&mut self, v: u32) {
        self.active_client_version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "beta_stress_test_event_active",
            |m: &CMsgTFWorldStatus| { &m.beta_stress_test_event_active },
            |m: &mut CMsgTFWorldStatus| { &mut m.beta_stress_test_event_active },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_match_group",
            |m: &CMsgTFWorldStatus| { &m.event_match_group },
            |m: &mut CMsgTFWorldStatus| { &mut m.event_match_group },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_expire_time",
            |m: &CMsgTFWorldStatus| { &m.event_expire_time },
            |m: &mut CMsgTFWorldStatus| { &mut m.event_expire_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "active_client_version",
            |m: &CMsgTFWorldStatus| { &m.active_client_version },
            |m: &mut CMsgTFWorldStatus| { &mut m.active_client_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "disabled_match_groups",
            |m: &CMsgTFWorldStatus| { &m.disabled_match_groups },
            |m: &mut CMsgTFWorldStatus| { &mut m.disabled_match_groups },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTFWorldStatus>(
            "CMsgTFWorldStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTFWorldStatus {
    const NAME: &'static str = "CMsgTFWorldStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.beta_stress_test_event_active = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.event_match_group = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                29 => {
                    self.event_expire_time = ::std::option::Option::Some(is.read_fixed32()?);
                },
                32 => {
                    self.active_client_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.disabled_match_groups.push(is.read_enum_or_unknown()?);
                },
                42 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.disabled_match_groups)?
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.beta_stress_test_event_active {
            my_size += 1 + 1;
        }
        if let Some(v) = self.event_match_group {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.event_expire_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.active_client_version {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.disabled_match_groups {
            my_size += ::protobuf::rt::int32_size(5, value.value());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.beta_stress_test_event_active {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.event_match_group {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.event_expire_time {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.active_client_version {
            os.write_uint32(4, v)?;
        }
        for v in &self.disabled_match_groups {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(v))?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFWorldStatus {
        CMsgTFWorldStatus::new()
    }

    fn clear(&mut self) {
        self.beta_stress_test_event_active = ::std::option::Option::None;
        self.event_match_group = ::std::option::Option::None;
        self.event_expire_time = ::std::option::Option::None;
        self.active_client_version = ::std::option::Option::None;
        self.disabled_match_groups.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFWorldStatus {
        static instance: CMsgTFWorldStatus = CMsgTFWorldStatus {
            beta_stress_test_event_active: ::std::option::Option::None,
            event_match_group: ::std::option::Option::None,
            event_expire_time: ::std::option::Option::None,
            active_client_version: ::std::option::Option::None,
            disabled_match_groups: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTFWorldStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTFWorldStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTFWorldStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFWorldStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSOTFDuelSummary)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOTFDuelSummary {
    // message fields
    // @@protoc_insertion_point(field:CSOTFDuelSummary.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFDuelSummary.duel_wins)
    pub duel_wins: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFDuelSummary.duel_losses)
    pub duel_losses: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFDuelSummary.last_duel_account_id)
    pub last_duel_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFDuelSummary.last_duel_timestamp)
    pub last_duel_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFDuelSummary.last_duel_status)
    pub last_duel_status: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOTFDuelSummary.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOTFDuelSummary {
    fn default() -> &'a CSOTFDuelSummary {
        <CSOTFDuelSummary as ::protobuf::Message>::default_instance()
    }
}

impl CSOTFDuelSummary {
    pub fn new() -> CSOTFDuelSummary {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 duel_wins = 2;

    pub fn duel_wins(&self) -> u32 {
        self.duel_wins.unwrap_or(0)
    }

    pub fn clear_duel_wins(&mut self) {
        self.duel_wins = ::std::option::Option::None;
    }

    pub fn has_duel_wins(&self) -> bool {
        self.duel_wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duel_wins(&mut self, v: u32) {
        self.duel_wins = ::std::option::Option::Some(v);
    }

    // optional uint32 duel_losses = 3;

    pub fn duel_losses(&self) -> u32 {
        self.duel_losses.unwrap_or(0)
    }

    pub fn clear_duel_losses(&mut self) {
        self.duel_losses = ::std::option::Option::None;
    }

    pub fn has_duel_losses(&self) -> bool {
        self.duel_losses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duel_losses(&mut self, v: u32) {
        self.duel_losses = ::std::option::Option::Some(v);
    }

    // optional uint32 last_duel_account_id = 4;

    pub fn last_duel_account_id(&self) -> u32 {
        self.last_duel_account_id.unwrap_or(0)
    }

    pub fn clear_last_duel_account_id(&mut self) {
        self.last_duel_account_id = ::std::option::Option::None;
    }

    pub fn has_last_duel_account_id(&self) -> bool {
        self.last_duel_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_duel_account_id(&mut self, v: u32) {
        self.last_duel_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 last_duel_timestamp = 5;

    pub fn last_duel_timestamp(&self) -> u32 {
        self.last_duel_timestamp.unwrap_or(0)
    }

    pub fn clear_last_duel_timestamp(&mut self) {
        self.last_duel_timestamp = ::std::option::Option::None;
    }

    pub fn has_last_duel_timestamp(&self) -> bool {
        self.last_duel_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_duel_timestamp(&mut self, v: u32) {
        self.last_duel_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 last_duel_status = 6;

    pub fn last_duel_status(&self) -> u32 {
        self.last_duel_status.unwrap_or(0)
    }

    pub fn clear_last_duel_status(&mut self) {
        self.last_duel_status = ::std::option::Option::None;
    }

    pub fn has_last_duel_status(&self) -> bool {
        self.last_duel_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_duel_status(&mut self, v: u32) {
        self.last_duel_status = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CSOTFDuelSummary| { &m.account_id },
            |m: &mut CSOTFDuelSummary| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duel_wins",
            |m: &CSOTFDuelSummary| { &m.duel_wins },
            |m: &mut CSOTFDuelSummary| { &mut m.duel_wins },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duel_losses",
            |m: &CSOTFDuelSummary| { &m.duel_losses },
            |m: &mut CSOTFDuelSummary| { &mut m.duel_losses },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_duel_account_id",
            |m: &CSOTFDuelSummary| { &m.last_duel_account_id },
            |m: &mut CSOTFDuelSummary| { &mut m.last_duel_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_duel_timestamp",
            |m: &CSOTFDuelSummary| { &m.last_duel_timestamp },
            |m: &mut CSOTFDuelSummary| { &mut m.last_duel_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_duel_status",
            |m: &CSOTFDuelSummary| { &m.last_duel_status },
            |m: &mut CSOTFDuelSummary| { &mut m.last_duel_status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOTFDuelSummary>(
            "CSOTFDuelSummary",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOTFDuelSummary {
    const NAME: &'static str = "CSOTFDuelSummary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.duel_wins = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.duel_losses = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.last_duel_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.last_duel_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.last_duel_status = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.duel_wins {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.duel_losses {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.last_duel_account_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.last_duel_timestamp {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.last_duel_status {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.duel_wins {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.duel_losses {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.last_duel_account_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.last_duel_timestamp {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.last_duel_status {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOTFDuelSummary {
        CSOTFDuelSummary::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.duel_wins = ::std::option::Option::None;
        self.duel_losses = ::std::option::Option::None;
        self.last_duel_account_id = ::std::option::Option::None;
        self.last_duel_timestamp = ::std::option::Option::None;
        self.last_duel_status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOTFDuelSummary {
        static instance: CSOTFDuelSummary = CSOTFDuelSummary {
            account_id: ::std::option::Option::None,
            duel_wins: ::std::option::Option::None,
            duel_losses: ::std::option::Option::None,
            last_duel_account_id: ::std::option::Option::None,
            last_duel_timestamp: ::std::option::Option::None,
            last_duel_status: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOTFDuelSummary {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOTFDuelSummary").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOTFDuelSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOTFDuelSummary {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSOTFMapContribution)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOTFMapContribution {
    // message fields
    // @@protoc_insertion_point(field:CSOTFMapContribution.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMapContribution.def_index)
    pub def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMapContribution.contribution_level)
    pub contribution_level: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOTFMapContribution.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOTFMapContribution {
    fn default() -> &'a CSOTFMapContribution {
        <CSOTFMapContribution as ::protobuf::Message>::default_instance()
    }
}

impl CSOTFMapContribution {
    pub fn new() -> CSOTFMapContribution {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 def_index = 2;

    pub fn def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 contribution_level = 3;

    pub fn contribution_level(&self) -> u32 {
        self.contribution_level.unwrap_or(0)
    }

    pub fn clear_contribution_level(&mut self) {
        self.contribution_level = ::std::option::Option::None;
    }

    pub fn has_contribution_level(&self) -> bool {
        self.contribution_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contribution_level(&mut self, v: u32) {
        self.contribution_level = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CSOTFMapContribution| { &m.account_id },
            |m: &mut CSOTFMapContribution| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "def_index",
            |m: &CSOTFMapContribution| { &m.def_index },
            |m: &mut CSOTFMapContribution| { &mut m.def_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "contribution_level",
            |m: &CSOTFMapContribution| { &m.contribution_level },
            |m: &mut CSOTFMapContribution| { &mut m.contribution_level },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOTFMapContribution>(
            "CSOTFMapContribution",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOTFMapContribution {
    const NAME: &'static str = "CSOTFMapContribution";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.contribution_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.contribution_level {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.def_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.contribution_level {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOTFMapContribution {
        CSOTFMapContribution::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.def_index = ::std::option::Option::None;
        self.contribution_level = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOTFMapContribution {
        static instance: CSOTFMapContribution = CSOTFMapContribution {
            account_id: ::std::option::Option::None,
            def_index: ::std::option::Option::None,
            contribution_level: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOTFMapContribution {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOTFMapContribution").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOTFMapContribution {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOTFMapContribution {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTFFreeTrialChooseMostHelpfulFriend)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFFreeTrialChooseMostHelpfulFriend {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFFreeTrialChooseMostHelpfulFriend.account_id_friend)
    pub account_id_friend: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFFreeTrialChooseMostHelpfulFriend.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFFreeTrialChooseMostHelpfulFriend {
    fn default() -> &'a CMsgTFFreeTrialChooseMostHelpfulFriend {
        <CMsgTFFreeTrialChooseMostHelpfulFriend as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFFreeTrialChooseMostHelpfulFriend {
    pub fn new() -> CMsgTFFreeTrialChooseMostHelpfulFriend {
        ::std::default::Default::default()
    }

    // optional uint32 account_id_friend = 1;

    pub fn account_id_friend(&self) -> u32 {
        self.account_id_friend.unwrap_or(0)
    }

    pub fn clear_account_id_friend(&mut self) {
        self.account_id_friend = ::std::option::Option::None;
    }

    pub fn has_account_id_friend(&self) -> bool {
        self.account_id_friend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id_friend(&mut self, v: u32) {
        self.account_id_friend = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id_friend",
            |m: &CMsgTFFreeTrialChooseMostHelpfulFriend| { &m.account_id_friend },
            |m: &mut CMsgTFFreeTrialChooseMostHelpfulFriend| { &mut m.account_id_friend },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTFFreeTrialChooseMostHelpfulFriend>(
            "CMsgTFFreeTrialChooseMostHelpfulFriend",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTFFreeTrialChooseMostHelpfulFriend {
    const NAME: &'static str = "CMsgTFFreeTrialChooseMostHelpfulFriend";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id_friend = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id_friend {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id_friend {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFFreeTrialChooseMostHelpfulFriend {
        CMsgTFFreeTrialChooseMostHelpfulFriend::new()
    }

    fn clear(&mut self) {
        self.account_id_friend = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFFreeTrialChooseMostHelpfulFriend {
        static instance: CMsgTFFreeTrialChooseMostHelpfulFriend = CMsgTFFreeTrialChooseMostHelpfulFriend {
            account_id_friend: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTFFreeTrialChooseMostHelpfulFriend {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTFFreeTrialChooseMostHelpfulFriend").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTFFreeTrialChooseMostHelpfulFriend {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFFreeTrialChooseMostHelpfulFriend {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTFRequestTF2Friends)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFRequestTF2Friends {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFRequestTF2Friends.account_ids)
    pub account_ids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFRequestTF2Friends.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFRequestTF2Friends {
    fn default() -> &'a CMsgTFRequestTF2Friends {
        <CMsgTFRequestTF2Friends as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFRequestTF2Friends {
    pub fn new() -> CMsgTFRequestTF2Friends {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "account_ids",
            |m: &CMsgTFRequestTF2Friends| { &m.account_ids },
            |m: &mut CMsgTFRequestTF2Friends| { &mut m.account_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTFRequestTF2Friends>(
            "CMsgTFRequestTF2Friends",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTFRequestTF2Friends {
    const NAME: &'static str = "CMsgTFRequestTF2Friends";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.account_ids)?;
                },
                8 => {
                    self.account_ids.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.account_ids {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.account_ids {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFRequestTF2Friends {
        CMsgTFRequestTF2Friends::new()
    }

    fn clear(&mut self) {
        self.account_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFRequestTF2Friends {
        static instance: CMsgTFRequestTF2Friends = CMsgTFRequestTF2Friends {
            account_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTFRequestTF2Friends {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTFRequestTF2Friends").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTFRequestTF2Friends {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFRequestTF2Friends {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTFRequestTF2FriendsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFRequestTF2FriendsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFRequestTF2FriendsResponse.account_ids)
    pub account_ids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFRequestTF2FriendsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFRequestTF2FriendsResponse {
    fn default() -> &'a CMsgTFRequestTF2FriendsResponse {
        <CMsgTFRequestTF2FriendsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFRequestTF2FriendsResponse {
    pub fn new() -> CMsgTFRequestTF2FriendsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "account_ids",
            |m: &CMsgTFRequestTF2FriendsResponse| { &m.account_ids },
            |m: &mut CMsgTFRequestTF2FriendsResponse| { &mut m.account_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTFRequestTF2FriendsResponse>(
            "CMsgTFRequestTF2FriendsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTFRequestTF2FriendsResponse {
    const NAME: &'static str = "CMsgTFRequestTF2FriendsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.account_ids)?;
                },
                8 => {
                    self.account_ids.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.account_ids {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.account_ids {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFRequestTF2FriendsResponse {
        CMsgTFRequestTF2FriendsResponse::new()
    }

    fn clear(&mut self) {
        self.account_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFRequestTF2FriendsResponse {
        static instance: CMsgTFRequestTF2FriendsResponse = CMsgTFRequestTF2FriendsResponse {
            account_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTFRequestTF2FriendsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTFRequestTF2FriendsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTFRequestTF2FriendsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFRequestTF2FriendsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSOTFPlayerInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOTFPlayerInfo {
    // message fields
    // @@protoc_insertion_point(field:CSOTFPlayerInfo.num_new_users_helped)
    pub num_new_users_helped: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOTFPlayerInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOTFPlayerInfo {
    fn default() -> &'a CSOTFPlayerInfo {
        <CSOTFPlayerInfo as ::protobuf::Message>::default_instance()
    }
}

impl CSOTFPlayerInfo {
    pub fn new() -> CSOTFPlayerInfo {
        ::std::default::Default::default()
    }

    // optional uint32 num_new_users_helped = 1;

    pub fn num_new_users_helped(&self) -> u32 {
        self.num_new_users_helped.unwrap_or(0)
    }

    pub fn clear_num_new_users_helped(&mut self) {
        self.num_new_users_helped = ::std::option::Option::None;
    }

    pub fn has_num_new_users_helped(&self) -> bool {
        self.num_new_users_helped.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_new_users_helped(&mut self, v: u32) {
        self.num_new_users_helped = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_new_users_helped",
            |m: &CSOTFPlayerInfo| { &m.num_new_users_helped },
            |m: &mut CSOTFPlayerInfo| { &mut m.num_new_users_helped },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOTFPlayerInfo>(
            "CSOTFPlayerInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOTFPlayerInfo {
    const NAME: &'static str = "CSOTFPlayerInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.num_new_users_helped = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.num_new_users_helped {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.num_new_users_helped {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOTFPlayerInfo {
        CSOTFPlayerInfo::new()
    }

    fn clear(&mut self) {
        self.num_new_users_helped = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOTFPlayerInfo {
        static instance: CSOTFPlayerInfo = CSOTFPlayerInfo {
            num_new_users_helped: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOTFPlayerInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOTFPlayerInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOTFPlayerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOTFPlayerInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTFThankedBySomeone)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFThankedBySomeone {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFThankedBySomeone.thanker_steam_id)
    pub thanker_steam_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFThankedBySomeone.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFThankedBySomeone {
    fn default() -> &'a CMsgTFThankedBySomeone {
        <CMsgTFThankedBySomeone as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFThankedBySomeone {
    pub fn new() -> CMsgTFThankedBySomeone {
        ::std::default::Default::default()
    }

    // optional uint64 thanker_steam_id = 1;

    pub fn thanker_steam_id(&self) -> u64 {
        self.thanker_steam_id.unwrap_or(0)
    }

    pub fn clear_thanker_steam_id(&mut self) {
        self.thanker_steam_id = ::std::option::Option::None;
    }

    pub fn has_thanker_steam_id(&self) -> bool {
        self.thanker_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thanker_steam_id(&mut self, v: u64) {
        self.thanker_steam_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thanker_steam_id",
            |m: &CMsgTFThankedBySomeone| { &m.thanker_steam_id },
            |m: &mut CMsgTFThankedBySomeone| { &mut m.thanker_steam_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTFThankedBySomeone>(
            "CMsgTFThankedBySomeone",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTFThankedBySomeone {
    const NAME: &'static str = "CMsgTFThankedBySomeone";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.thanker_steam_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.thanker_steam_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.thanker_steam_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFThankedBySomeone {
        CMsgTFThankedBySomeone::new()
    }

    fn clear(&mut self) {
        self.thanker_steam_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFThankedBySomeone {
        static instance: CMsgTFThankedBySomeone = CMsgTFThankedBySomeone {
            thanker_steam_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTFThankedBySomeone {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTFThankedBySomeone").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTFThankedBySomeone {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFThankedBySomeone {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTFThankedSomeone)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFThankedSomeone {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFThankedSomeone.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFThankedSomeone {
    fn default() -> &'a CMsgTFThankedSomeone {
        <CMsgTFThankedSomeone as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFThankedSomeone {
    pub fn new() -> CMsgTFThankedSomeone {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTFThankedSomeone>(
            "CMsgTFThankedSomeone",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTFThankedSomeone {
    const NAME: &'static str = "CMsgTFThankedSomeone";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFThankedSomeone {
        CMsgTFThankedSomeone::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFThankedSomeone {
        static instance: CMsgTFThankedSomeone = CMsgTFThankedSomeone {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTFThankedSomeone {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTFThankedSomeone").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTFThankedSomeone {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFThankedSomeone {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTFFreeTrialConvertedToPremium)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFFreeTrialConvertedToPremium {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFFreeTrialConvertedToPremium.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFFreeTrialConvertedToPremium {
    fn default() -> &'a CMsgTFFreeTrialConvertedToPremium {
        <CMsgTFFreeTrialConvertedToPremium as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFFreeTrialConvertedToPremium {
    pub fn new() -> CMsgTFFreeTrialConvertedToPremium {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTFFreeTrialConvertedToPremium>(
            "CMsgTFFreeTrialConvertedToPremium",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTFFreeTrialConvertedToPremium {
    const NAME: &'static str = "CMsgTFFreeTrialConvertedToPremium";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFFreeTrialConvertedToPremium {
        CMsgTFFreeTrialConvertedToPremium::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFFreeTrialConvertedToPremium {
        static instance: CMsgTFFreeTrialConvertedToPremium = CMsgTFFreeTrialConvertedToPremium {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTFFreeTrialConvertedToPremium {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTFFreeTrialConvertedToPremium").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTFFreeTrialConvertedToPremium {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFFreeTrialConvertedToPremium {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSaxxyAwarded)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSaxxyAwarded {
    // message fields
    // @@protoc_insertion_point(field:CMsgSaxxyAwarded.category)
    pub category: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSaxxyAwarded.winner_names)
    pub winner_names: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSaxxyAwarded.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSaxxyAwarded {
    fn default() -> &'a CMsgSaxxyAwarded {
        <CMsgSaxxyAwarded as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSaxxyAwarded {
    pub fn new() -> CMsgSaxxyAwarded {
        ::std::default::Default::default()
    }

    // optional uint32 category = 1;

    pub fn category(&self) -> u32 {
        self.category.unwrap_or(0)
    }

    pub fn clear_category(&mut self) {
        self.category = ::std::option::Option::None;
    }

    pub fn has_category(&self) -> bool {
        self.category.is_some()
    }

    // Param is passed by value, moved
    pub fn set_category(&mut self, v: u32) {
        self.category = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "category",
            |m: &CMsgSaxxyAwarded| { &m.category },
            |m: &mut CMsgSaxxyAwarded| { &mut m.category },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "winner_names",
            |m: &CMsgSaxxyAwarded| { &m.winner_names },
            |m: &mut CMsgSaxxyAwarded| { &mut m.winner_names },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSaxxyAwarded>(
            "CMsgSaxxyAwarded",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSaxxyAwarded {
    const NAME: &'static str = "CMsgSaxxyAwarded";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.category = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.winner_names.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.category {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.winner_names {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.category {
            os.write_uint32(1, v)?;
        }
        for v in &self.winner_names {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSaxxyAwarded {
        CMsgSaxxyAwarded::new()
    }

    fn clear(&mut self) {
        self.category = ::std::option::Option::None;
        self.winner_names.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSaxxyAwarded {
        static instance: CMsgSaxxyAwarded = CMsgSaxxyAwarded {
            category: ::std::option::Option::None,
            winner_names: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSaxxyAwarded {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSaxxyAwarded").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSaxxyAwarded {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSaxxyAwarded {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgReplaySubmitContestEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgReplaySubmitContestEntry {
    // message fields
    // @@protoc_insertion_point(field:CMsgReplaySubmitContestEntry.youtube_url)
    pub youtube_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgReplaySubmitContestEntry.category)
    pub category: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgReplaySubmitContestEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgReplaySubmitContestEntry {
    fn default() -> &'a CMsgReplaySubmitContestEntry {
        <CMsgReplaySubmitContestEntry as ::protobuf::Message>::default_instance()
    }
}

impl CMsgReplaySubmitContestEntry {
    pub fn new() -> CMsgReplaySubmitContestEntry {
        ::std::default::Default::default()
    }

    // optional string youtube_url = 1;

    pub fn youtube_url(&self) -> &str {
        match self.youtube_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_youtube_url(&mut self) {
        self.youtube_url = ::std::option::Option::None;
    }

    pub fn has_youtube_url(&self) -> bool {
        self.youtube_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_youtube_url(&mut self, v: ::std::string::String) {
        self.youtube_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_youtube_url(&mut self) -> &mut ::std::string::String {
        if self.youtube_url.is_none() {
            self.youtube_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.youtube_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_youtube_url(&mut self) -> ::std::string::String {
        self.youtube_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 category = 2;

    pub fn category(&self) -> u32 {
        self.category.unwrap_or(0)
    }

    pub fn clear_category(&mut self) {
        self.category = ::std::option::Option::None;
    }

    pub fn has_category(&self) -> bool {
        self.category.is_some()
    }

    // Param is passed by value, moved
    pub fn set_category(&mut self, v: u32) {
        self.category = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "youtube_url",
            |m: &CMsgReplaySubmitContestEntry| { &m.youtube_url },
            |m: &mut CMsgReplaySubmitContestEntry| { &mut m.youtube_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "category",
            |m: &CMsgReplaySubmitContestEntry| { &m.category },
            |m: &mut CMsgReplaySubmitContestEntry| { &mut m.category },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgReplaySubmitContestEntry>(
            "CMsgReplaySubmitContestEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgReplaySubmitContestEntry {
    const NAME: &'static str = "CMsgReplaySubmitContestEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.youtube_url = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.category = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.youtube_url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.category {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.youtube_url.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.category {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgReplaySubmitContestEntry {
        CMsgReplaySubmitContestEntry::new()
    }

    fn clear(&mut self) {
        self.youtube_url = ::std::option::Option::None;
        self.category = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgReplaySubmitContestEntry {
        static instance: CMsgReplaySubmitContestEntry = CMsgReplaySubmitContestEntry {
            youtube_url: ::std::option::Option::None,
            category: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgReplaySubmitContestEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgReplaySubmitContestEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgReplaySubmitContestEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgReplaySubmitContestEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgReplaySubmitContestEntryResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgReplaySubmitContestEntryResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgReplaySubmitContestEntryResponse.success)
    pub success: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgReplaySubmitContestEntryResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgReplaySubmitContestEntryResponse {
    fn default() -> &'a CMsgReplaySubmitContestEntryResponse {
        <CMsgReplaySubmitContestEntryResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgReplaySubmitContestEntryResponse {
    pub fn new() -> CMsgReplaySubmitContestEntryResponse {
        ::std::default::Default::default()
    }

    // optional bool success = 1;

    pub fn success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "success",
            |m: &CMsgReplaySubmitContestEntryResponse| { &m.success },
            |m: &mut CMsgReplaySubmitContestEntryResponse| { &mut m.success },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgReplaySubmitContestEntryResponse>(
            "CMsgReplaySubmitContestEntryResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgReplaySubmitContestEntryResponse {
    const NAME: &'static str = "CMsgReplaySubmitContestEntryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgReplaySubmitContestEntryResponse {
        CMsgReplaySubmitContestEntryResponse::new()
    }

    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgReplaySubmitContestEntryResponse {
        static instance: CMsgReplaySubmitContestEntryResponse = CMsgReplaySubmitContestEntryResponse {
            success: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgReplaySubmitContestEntryResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgReplaySubmitContestEntryResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgReplaySubmitContestEntryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgReplaySubmitContestEntryResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CReplayCachedContestData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CReplayCachedContestData {
    // message fields
    // @@protoc_insertion_point(field:CReplayCachedContestData.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CReplayCachedContestData.num_votes_last_day)
    pub num_votes_last_day: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CReplayCachedContestData.video_entry_ids)
    pub video_entry_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CReplayCachedContestData.num_flags_last_day)
    pub num_flags_last_day: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CReplayCachedContestData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CReplayCachedContestData {
    fn default() -> &'a CReplayCachedContestData {
        <CReplayCachedContestData as ::protobuf::Message>::default_instance()
    }
}

impl CReplayCachedContestData {
    pub fn new() -> CReplayCachedContestData {
        ::std::default::Default::default()
    }

    // optional fixed32 timestamp = 1;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 num_votes_last_day = 2;

    pub fn num_votes_last_day(&self) -> u32 {
        self.num_votes_last_day.unwrap_or(0)
    }

    pub fn clear_num_votes_last_day(&mut self) {
        self.num_votes_last_day = ::std::option::Option::None;
    }

    pub fn has_num_votes_last_day(&self) -> bool {
        self.num_votes_last_day.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_votes_last_day(&mut self, v: u32) {
        self.num_votes_last_day = ::std::option::Option::Some(v);
    }

    // optional uint32 num_flags_last_day = 4;

    pub fn num_flags_last_day(&self) -> u32 {
        self.num_flags_last_day.unwrap_or(0)
    }

    pub fn clear_num_flags_last_day(&mut self) {
        self.num_flags_last_day = ::std::option::Option::None;
    }

    pub fn has_num_flags_last_day(&self) -> bool {
        self.num_flags_last_day.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_flags_last_day(&mut self, v: u32) {
        self.num_flags_last_day = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &CReplayCachedContestData| { &m.timestamp },
            |m: &mut CReplayCachedContestData| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_votes_last_day",
            |m: &CReplayCachedContestData| { &m.num_votes_last_day },
            |m: &mut CReplayCachedContestData| { &mut m.num_votes_last_day },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "video_entry_ids",
            |m: &CReplayCachedContestData| { &m.video_entry_ids },
            |m: &mut CReplayCachedContestData| { &mut m.video_entry_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_flags_last_day",
            |m: &CReplayCachedContestData| { &m.num_flags_last_day },
            |m: &mut CReplayCachedContestData| { &mut m.num_flags_last_day },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CReplayCachedContestData>(
            "CReplayCachedContestData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CReplayCachedContestData {
    const NAME: &'static str = "CReplayCachedContestData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                16 => {
                    self.num_votes_last_day = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.video_entry_ids)?;
                },
                24 => {
                    self.video_entry_ids.push(is.read_uint32()?);
                },
                32 => {
                    self.num_flags_last_day = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += 1 + 4;
        }
        if let Some(v) = self.num_votes_last_day {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.video_entry_ids {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        if let Some(v) = self.num_flags_last_day {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.timestamp {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.num_votes_last_day {
            os.write_uint32(2, v)?;
        }
        for v in &self.video_entry_ids {
            os.write_uint32(3, *v)?;
        };
        if let Some(v) = self.num_flags_last_day {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CReplayCachedContestData {
        CReplayCachedContestData::new()
    }

    fn clear(&mut self) {
        self.timestamp = ::std::option::Option::None;
        self.num_votes_last_day = ::std::option::Option::None;
        self.video_entry_ids.clear();
        self.num_flags_last_day = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CReplayCachedContestData {
        static instance: CReplayCachedContestData = CReplayCachedContestData {
            timestamp: ::std::option::Option::None,
            num_votes_last_day: ::std::option::Option::None,
            video_entry_ids: ::std::vec::Vec::new(),
            num_flags_last_day: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CReplayCachedContestData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CReplayCachedContestData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CReplayCachedContestData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CReplayCachedContestData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTFCoaching_AddToCoaches)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFCoaching_AddToCoaches {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFCoaching_AddToCoaches.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFCoaching_AddToCoaches {
    fn default() -> &'a CMsgTFCoaching_AddToCoaches {
        <CMsgTFCoaching_AddToCoaches as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFCoaching_AddToCoaches {
    pub fn new() -> CMsgTFCoaching_AddToCoaches {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTFCoaching_AddToCoaches>(
            "CMsgTFCoaching_AddToCoaches",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTFCoaching_AddToCoaches {
    const NAME: &'static str = "CMsgTFCoaching_AddToCoaches";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFCoaching_AddToCoaches {
        CMsgTFCoaching_AddToCoaches::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFCoaching_AddToCoaches {
        static instance: CMsgTFCoaching_AddToCoaches = CMsgTFCoaching_AddToCoaches {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTFCoaching_AddToCoaches {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTFCoaching_AddToCoaches").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTFCoaching_AddToCoaches {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFCoaching_AddToCoaches {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTFCoaching_RemoveFromCoaches)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFCoaching_RemoveFromCoaches {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFCoaching_RemoveFromCoaches.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFCoaching_RemoveFromCoaches {
    fn default() -> &'a CMsgTFCoaching_RemoveFromCoaches {
        <CMsgTFCoaching_RemoveFromCoaches as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFCoaching_RemoveFromCoaches {
    pub fn new() -> CMsgTFCoaching_RemoveFromCoaches {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTFCoaching_RemoveFromCoaches>(
            "CMsgTFCoaching_RemoveFromCoaches",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTFCoaching_RemoveFromCoaches {
    const NAME: &'static str = "CMsgTFCoaching_RemoveFromCoaches";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFCoaching_RemoveFromCoaches {
        CMsgTFCoaching_RemoveFromCoaches::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFCoaching_RemoveFromCoaches {
        static instance: CMsgTFCoaching_RemoveFromCoaches = CMsgTFCoaching_RemoveFromCoaches {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTFCoaching_RemoveFromCoaches {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTFCoaching_RemoveFromCoaches").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTFCoaching_RemoveFromCoaches {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFCoaching_RemoveFromCoaches {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTFCoaching_FindCoach)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFCoaching_FindCoach {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFCoaching_FindCoach.account_id_friend_as_coach)
    pub account_id_friend_as_coach: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFCoaching_FindCoach.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFCoaching_FindCoach {
    fn default() -> &'a CMsgTFCoaching_FindCoach {
        <CMsgTFCoaching_FindCoach as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFCoaching_FindCoach {
    pub fn new() -> CMsgTFCoaching_FindCoach {
        ::std::default::Default::default()
    }

    // optional uint32 account_id_friend_as_coach = 1;

    pub fn account_id_friend_as_coach(&self) -> u32 {
        self.account_id_friend_as_coach.unwrap_or(0)
    }

    pub fn clear_account_id_friend_as_coach(&mut self) {
        self.account_id_friend_as_coach = ::std::option::Option::None;
    }

    pub fn has_account_id_friend_as_coach(&self) -> bool {
        self.account_id_friend_as_coach.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id_friend_as_coach(&mut self, v: u32) {
        self.account_id_friend_as_coach = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id_friend_as_coach",
            |m: &CMsgTFCoaching_FindCoach| { &m.account_id_friend_as_coach },
            |m: &mut CMsgTFCoaching_FindCoach| { &mut m.account_id_friend_as_coach },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTFCoaching_FindCoach>(
            "CMsgTFCoaching_FindCoach",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTFCoaching_FindCoach {
    const NAME: &'static str = "CMsgTFCoaching_FindCoach";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id_friend_as_coach = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id_friend_as_coach {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id_friend_as_coach {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFCoaching_FindCoach {
        CMsgTFCoaching_FindCoach::new()
    }

    fn clear(&mut self) {
        self.account_id_friend_as_coach = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFCoaching_FindCoach {
        static instance: CMsgTFCoaching_FindCoach = CMsgTFCoaching_FindCoach {
            account_id_friend_as_coach: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTFCoaching_FindCoach {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTFCoaching_FindCoach").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTFCoaching_FindCoach {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFCoaching_FindCoach {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTFCoaching_FindCoachResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFCoaching_FindCoachResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFCoaching_FindCoachResponse.found_coach)
    pub found_coach: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgTFCoaching_FindCoachResponse.num_likes)
    pub num_likes: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTFCoaching_FindCoachResponse.coach_name)
    pub coach_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFCoaching_FindCoachResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFCoaching_FindCoachResponse {
    fn default() -> &'a CMsgTFCoaching_FindCoachResponse {
        <CMsgTFCoaching_FindCoachResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFCoaching_FindCoachResponse {
    pub fn new() -> CMsgTFCoaching_FindCoachResponse {
        ::std::default::Default::default()
    }

    // optional bool found_coach = 1;

    pub fn found_coach(&self) -> bool {
        self.found_coach.unwrap_or(false)
    }

    pub fn clear_found_coach(&mut self) {
        self.found_coach = ::std::option::Option::None;
    }

    pub fn has_found_coach(&self) -> bool {
        self.found_coach.is_some()
    }

    // Param is passed by value, moved
    pub fn set_found_coach(&mut self, v: bool) {
        self.found_coach = ::std::option::Option::Some(v);
    }

    // optional uint32 num_likes = 2;

    pub fn num_likes(&self) -> u32 {
        self.num_likes.unwrap_or(0)
    }

    pub fn clear_num_likes(&mut self) {
        self.num_likes = ::std::option::Option::None;
    }

    pub fn has_num_likes(&self) -> bool {
        self.num_likes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_likes(&mut self, v: u32) {
        self.num_likes = ::std::option::Option::Some(v);
    }

    // optional string coach_name = 3;

    pub fn coach_name(&self) -> &str {
        match self.coach_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_coach_name(&mut self) {
        self.coach_name = ::std::option::Option::None;
    }

    pub fn has_coach_name(&self) -> bool {
        self.coach_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coach_name(&mut self, v: ::std::string::String) {
        self.coach_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_coach_name(&mut self) -> &mut ::std::string::String {
        if self.coach_name.is_none() {
            self.coach_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.coach_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_coach_name(&mut self) -> ::std::string::String {
        self.coach_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "found_coach",
            |m: &CMsgTFCoaching_FindCoachResponse| { &m.found_coach },
            |m: &mut CMsgTFCoaching_FindCoachResponse| { &mut m.found_coach },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_likes",
            |m: &CMsgTFCoaching_FindCoachResponse| { &m.num_likes },
            |m: &mut CMsgTFCoaching_FindCoachResponse| { &mut m.num_likes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "coach_name",
            |m: &CMsgTFCoaching_FindCoachResponse| { &m.coach_name },
            |m: &mut CMsgTFCoaching_FindCoachResponse| { &mut m.coach_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTFCoaching_FindCoachResponse>(
            "CMsgTFCoaching_FindCoachResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTFCoaching_FindCoachResponse {
    const NAME: &'static str = "CMsgTFCoaching_FindCoachResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.found_coach = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.num_likes = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.coach_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.found_coach {
            my_size += 1 + 1;
        }
        if let Some(v) = self.num_likes {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.coach_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.found_coach {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.num_likes {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.coach_name.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFCoaching_FindCoachResponse {
        CMsgTFCoaching_FindCoachResponse::new()
    }

    fn clear(&mut self) {
        self.found_coach = ::std::option::Option::None;
        self.num_likes = ::std::option::Option::None;
        self.coach_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFCoaching_FindCoachResponse {
        static instance: CMsgTFCoaching_FindCoachResponse = CMsgTFCoaching_FindCoachResponse {
            found_coach: ::std::option::Option::None,
            num_likes: ::std::option::Option::None,
            coach_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTFCoaching_FindCoachResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTFCoaching_FindCoachResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTFCoaching_FindCoachResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFCoaching_FindCoachResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTFCoaching_AskCoach)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFCoaching_AskCoach {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFCoaching_AskCoach.account_id_student)
    pub account_id_student: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTFCoaching_AskCoach.student_is_friend)
    pub student_is_friend: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFCoaching_AskCoach.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFCoaching_AskCoach {
    fn default() -> &'a CMsgTFCoaching_AskCoach {
        <CMsgTFCoaching_AskCoach as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFCoaching_AskCoach {
    pub fn new() -> CMsgTFCoaching_AskCoach {
        ::std::default::Default::default()
    }

    // optional uint32 account_id_student = 1;

    pub fn account_id_student(&self) -> u32 {
        self.account_id_student.unwrap_or(0)
    }

    pub fn clear_account_id_student(&mut self) {
        self.account_id_student = ::std::option::Option::None;
    }

    pub fn has_account_id_student(&self) -> bool {
        self.account_id_student.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id_student(&mut self, v: u32) {
        self.account_id_student = ::std::option::Option::Some(v);
    }

    // optional bool student_is_friend = 2;

    pub fn student_is_friend(&self) -> bool {
        self.student_is_friend.unwrap_or(false)
    }

    pub fn clear_student_is_friend(&mut self) {
        self.student_is_friend = ::std::option::Option::None;
    }

    pub fn has_student_is_friend(&self) -> bool {
        self.student_is_friend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_student_is_friend(&mut self, v: bool) {
        self.student_is_friend = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id_student",
            |m: &CMsgTFCoaching_AskCoach| { &m.account_id_student },
            |m: &mut CMsgTFCoaching_AskCoach| { &mut m.account_id_student },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "student_is_friend",
            |m: &CMsgTFCoaching_AskCoach| { &m.student_is_friend },
            |m: &mut CMsgTFCoaching_AskCoach| { &mut m.student_is_friend },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTFCoaching_AskCoach>(
            "CMsgTFCoaching_AskCoach",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTFCoaching_AskCoach {
    const NAME: &'static str = "CMsgTFCoaching_AskCoach";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id_student = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.student_is_friend = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id_student {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.student_is_friend {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id_student {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.student_is_friend {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFCoaching_AskCoach {
        CMsgTFCoaching_AskCoach::new()
    }

    fn clear(&mut self) {
        self.account_id_student = ::std::option::Option::None;
        self.student_is_friend = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFCoaching_AskCoach {
        static instance: CMsgTFCoaching_AskCoach = CMsgTFCoaching_AskCoach {
            account_id_student: ::std::option::Option::None,
            student_is_friend: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTFCoaching_AskCoach {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTFCoaching_AskCoach").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTFCoaching_AskCoach {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFCoaching_AskCoach {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTFCoaching_AskCoachResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFCoaching_AskCoachResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFCoaching_AskCoachResponse.accept_coaching_assignment)
    pub accept_coaching_assignment: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFCoaching_AskCoachResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFCoaching_AskCoachResponse {
    fn default() -> &'a CMsgTFCoaching_AskCoachResponse {
        <CMsgTFCoaching_AskCoachResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFCoaching_AskCoachResponse {
    pub fn new() -> CMsgTFCoaching_AskCoachResponse {
        ::std::default::Default::default()
    }

    // optional bool accept_coaching_assignment = 1;

    pub fn accept_coaching_assignment(&self) -> bool {
        self.accept_coaching_assignment.unwrap_or(false)
    }

    pub fn clear_accept_coaching_assignment(&mut self) {
        self.accept_coaching_assignment = ::std::option::Option::None;
    }

    pub fn has_accept_coaching_assignment(&self) -> bool {
        self.accept_coaching_assignment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accept_coaching_assignment(&mut self, v: bool) {
        self.accept_coaching_assignment = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accept_coaching_assignment",
            |m: &CMsgTFCoaching_AskCoachResponse| { &m.accept_coaching_assignment },
            |m: &mut CMsgTFCoaching_AskCoachResponse| { &mut m.accept_coaching_assignment },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTFCoaching_AskCoachResponse>(
            "CMsgTFCoaching_AskCoachResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTFCoaching_AskCoachResponse {
    const NAME: &'static str = "CMsgTFCoaching_AskCoachResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accept_coaching_assignment = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accept_coaching_assignment {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.accept_coaching_assignment {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFCoaching_AskCoachResponse {
        CMsgTFCoaching_AskCoachResponse::new()
    }

    fn clear(&mut self) {
        self.accept_coaching_assignment = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFCoaching_AskCoachResponse {
        static instance: CMsgTFCoaching_AskCoachResponse = CMsgTFCoaching_AskCoachResponse {
            accept_coaching_assignment: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTFCoaching_AskCoachResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTFCoaching_AskCoachResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTFCoaching_AskCoachResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFCoaching_AskCoachResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTFCoaching_CoachJoinGame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFCoaching_CoachJoinGame {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFCoaching_CoachJoinGame.join_game)
    pub join_game: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgTFCoaching_CoachJoinGame.server_address)
    pub server_address: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTFCoaching_CoachJoinGame.server_port)
    pub server_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTFCoaching_CoachJoinGame.account_id_student)
    pub account_id_student: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFCoaching_CoachJoinGame.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFCoaching_CoachJoinGame {
    fn default() -> &'a CMsgTFCoaching_CoachJoinGame {
        <CMsgTFCoaching_CoachJoinGame as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFCoaching_CoachJoinGame {
    pub fn new() -> CMsgTFCoaching_CoachJoinGame {
        ::std::default::Default::default()
    }

    // optional bool join_game = 1;

    pub fn join_game(&self) -> bool {
        self.join_game.unwrap_or(false)
    }

    pub fn clear_join_game(&mut self) {
        self.join_game = ::std::option::Option::None;
    }

    pub fn has_join_game(&self) -> bool {
        self.join_game.is_some()
    }

    // Param is passed by value, moved
    pub fn set_join_game(&mut self, v: bool) {
        self.join_game = ::std::option::Option::Some(v);
    }

    // optional uint32 server_address = 2;

    pub fn server_address(&self) -> u32 {
        self.server_address.unwrap_or(0)
    }

    pub fn clear_server_address(&mut self) {
        self.server_address = ::std::option::Option::None;
    }

    pub fn has_server_address(&self) -> bool {
        self.server_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_address(&mut self, v: u32) {
        self.server_address = ::std::option::Option::Some(v);
    }

    // optional uint32 server_port = 3;

    pub fn server_port(&self) -> u32 {
        self.server_port.unwrap_or(0)
    }

    pub fn clear_server_port(&mut self) {
        self.server_port = ::std::option::Option::None;
    }

    pub fn has_server_port(&self) -> bool {
        self.server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_port(&mut self, v: u32) {
        self.server_port = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id_student = 4;

    pub fn account_id_student(&self) -> u32 {
        self.account_id_student.unwrap_or(0)
    }

    pub fn clear_account_id_student(&mut self) {
        self.account_id_student = ::std::option::Option::None;
    }

    pub fn has_account_id_student(&self) -> bool {
        self.account_id_student.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id_student(&mut self, v: u32) {
        self.account_id_student = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "join_game",
            |m: &CMsgTFCoaching_CoachJoinGame| { &m.join_game },
            |m: &mut CMsgTFCoaching_CoachJoinGame| { &mut m.join_game },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_address",
            |m: &CMsgTFCoaching_CoachJoinGame| { &m.server_address },
            |m: &mut CMsgTFCoaching_CoachJoinGame| { &mut m.server_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_port",
            |m: &CMsgTFCoaching_CoachJoinGame| { &m.server_port },
            |m: &mut CMsgTFCoaching_CoachJoinGame| { &mut m.server_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id_student",
            |m: &CMsgTFCoaching_CoachJoinGame| { &m.account_id_student },
            |m: &mut CMsgTFCoaching_CoachJoinGame| { &mut m.account_id_student },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTFCoaching_CoachJoinGame>(
            "CMsgTFCoaching_CoachJoinGame",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTFCoaching_CoachJoinGame {
    const NAME: &'static str = "CMsgTFCoaching_CoachJoinGame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.join_game = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.server_address = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.server_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.account_id_student = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.join_game {
            my_size += 1 + 1;
        }
        if let Some(v) = self.server_address {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.server_port {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.account_id_student {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.join_game {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.server_address {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.server_port {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.account_id_student {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFCoaching_CoachJoinGame {
        CMsgTFCoaching_CoachJoinGame::new()
    }

    fn clear(&mut self) {
        self.join_game = ::std::option::Option::None;
        self.server_address = ::std::option::Option::None;
        self.server_port = ::std::option::Option::None;
        self.account_id_student = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFCoaching_CoachJoinGame {
        static instance: CMsgTFCoaching_CoachJoinGame = CMsgTFCoaching_CoachJoinGame {
            join_game: ::std::option::Option::None,
            server_address: ::std::option::Option::None,
            server_port: ::std::option::Option::None,
            account_id_student: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTFCoaching_CoachJoinGame {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTFCoaching_CoachJoinGame").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTFCoaching_CoachJoinGame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFCoaching_CoachJoinGame {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTFCoaching_CoachJoining)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFCoaching_CoachJoining {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFCoaching_CoachJoining.account_id_coach)
    pub account_id_coach: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTFCoaching_CoachJoining.account_id_student)
    pub account_id_student: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFCoaching_CoachJoining.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFCoaching_CoachJoining {
    fn default() -> &'a CMsgTFCoaching_CoachJoining {
        <CMsgTFCoaching_CoachJoining as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFCoaching_CoachJoining {
    pub fn new() -> CMsgTFCoaching_CoachJoining {
        ::std::default::Default::default()
    }

    // optional uint32 account_id_coach = 1;

    pub fn account_id_coach(&self) -> u32 {
        self.account_id_coach.unwrap_or(0)
    }

    pub fn clear_account_id_coach(&mut self) {
        self.account_id_coach = ::std::option::Option::None;
    }

    pub fn has_account_id_coach(&self) -> bool {
        self.account_id_coach.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id_coach(&mut self, v: u32) {
        self.account_id_coach = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id_student = 2;

    pub fn account_id_student(&self) -> u32 {
        self.account_id_student.unwrap_or(0)
    }

    pub fn clear_account_id_student(&mut self) {
        self.account_id_student = ::std::option::Option::None;
    }

    pub fn has_account_id_student(&self) -> bool {
        self.account_id_student.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id_student(&mut self, v: u32) {
        self.account_id_student = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id_coach",
            |m: &CMsgTFCoaching_CoachJoining| { &m.account_id_coach },
            |m: &mut CMsgTFCoaching_CoachJoining| { &mut m.account_id_coach },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id_student",
            |m: &CMsgTFCoaching_CoachJoining| { &m.account_id_student },
            |m: &mut CMsgTFCoaching_CoachJoining| { &mut m.account_id_student },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTFCoaching_CoachJoining>(
            "CMsgTFCoaching_CoachJoining",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTFCoaching_CoachJoining {
    const NAME: &'static str = "CMsgTFCoaching_CoachJoining";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id_coach = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.account_id_student = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id_coach {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.account_id_student {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id_coach {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.account_id_student {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFCoaching_CoachJoining {
        CMsgTFCoaching_CoachJoining::new()
    }

    fn clear(&mut self) {
        self.account_id_coach = ::std::option::Option::None;
        self.account_id_student = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFCoaching_CoachJoining {
        static instance: CMsgTFCoaching_CoachJoining = CMsgTFCoaching_CoachJoining {
            account_id_coach: ::std::option::Option::None,
            account_id_student: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTFCoaching_CoachJoining {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTFCoaching_CoachJoining").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTFCoaching_CoachJoining {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFCoaching_CoachJoining {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTFCoaching_CoachJoined)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFCoaching_CoachJoined {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFCoaching_CoachJoined.account_id_coach)
    pub account_id_coach: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFCoaching_CoachJoined.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFCoaching_CoachJoined {
    fn default() -> &'a CMsgTFCoaching_CoachJoined {
        <CMsgTFCoaching_CoachJoined as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFCoaching_CoachJoined {
    pub fn new() -> CMsgTFCoaching_CoachJoined {
        ::std::default::Default::default()
    }

    // optional uint32 account_id_coach = 1;

    pub fn account_id_coach(&self) -> u32 {
        self.account_id_coach.unwrap_or(0)
    }

    pub fn clear_account_id_coach(&mut self) {
        self.account_id_coach = ::std::option::Option::None;
    }

    pub fn has_account_id_coach(&self) -> bool {
        self.account_id_coach.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id_coach(&mut self, v: u32) {
        self.account_id_coach = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id_coach",
            |m: &CMsgTFCoaching_CoachJoined| { &m.account_id_coach },
            |m: &mut CMsgTFCoaching_CoachJoined| { &mut m.account_id_coach },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTFCoaching_CoachJoined>(
            "CMsgTFCoaching_CoachJoined",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTFCoaching_CoachJoined {
    const NAME: &'static str = "CMsgTFCoaching_CoachJoined";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id_coach = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id_coach {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id_coach {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFCoaching_CoachJoined {
        CMsgTFCoaching_CoachJoined::new()
    }

    fn clear(&mut self) {
        self.account_id_coach = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFCoaching_CoachJoined {
        static instance: CMsgTFCoaching_CoachJoined = CMsgTFCoaching_CoachJoined {
            account_id_coach: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTFCoaching_CoachJoined {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTFCoaching_CoachJoined").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTFCoaching_CoachJoined {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFCoaching_CoachJoined {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTFCoaching_LikeCurrentCoach)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFCoaching_LikeCurrentCoach {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFCoaching_LikeCurrentCoach.like_coach)
    pub like_coach: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFCoaching_LikeCurrentCoach.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFCoaching_LikeCurrentCoach {
    fn default() -> &'a CMsgTFCoaching_LikeCurrentCoach {
        <CMsgTFCoaching_LikeCurrentCoach as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFCoaching_LikeCurrentCoach {
    pub fn new() -> CMsgTFCoaching_LikeCurrentCoach {
        ::std::default::Default::default()
    }

    // optional bool like_coach = 1;

    pub fn like_coach(&self) -> bool {
        self.like_coach.unwrap_or(false)
    }

    pub fn clear_like_coach(&mut self) {
        self.like_coach = ::std::option::Option::None;
    }

    pub fn has_like_coach(&self) -> bool {
        self.like_coach.is_some()
    }

    // Param is passed by value, moved
    pub fn set_like_coach(&mut self, v: bool) {
        self.like_coach = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "like_coach",
            |m: &CMsgTFCoaching_LikeCurrentCoach| { &m.like_coach },
            |m: &mut CMsgTFCoaching_LikeCurrentCoach| { &mut m.like_coach },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTFCoaching_LikeCurrentCoach>(
            "CMsgTFCoaching_LikeCurrentCoach",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTFCoaching_LikeCurrentCoach {
    const NAME: &'static str = "CMsgTFCoaching_LikeCurrentCoach";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.like_coach = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.like_coach {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.like_coach {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFCoaching_LikeCurrentCoach {
        CMsgTFCoaching_LikeCurrentCoach::new()
    }

    fn clear(&mut self) {
        self.like_coach = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFCoaching_LikeCurrentCoach {
        static instance: CMsgTFCoaching_LikeCurrentCoach = CMsgTFCoaching_LikeCurrentCoach {
            like_coach: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTFCoaching_LikeCurrentCoach {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTFCoaching_LikeCurrentCoach").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTFCoaching_LikeCurrentCoach {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFCoaching_LikeCurrentCoach {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTFCoaching_RemoveCurrentCoach)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFCoaching_RemoveCurrentCoach {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFCoaching_RemoveCurrentCoach.account_id_coach)
    pub account_id_coach: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFCoaching_RemoveCurrentCoach.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFCoaching_RemoveCurrentCoach {
    fn default() -> &'a CMsgTFCoaching_RemoveCurrentCoach {
        <CMsgTFCoaching_RemoveCurrentCoach as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFCoaching_RemoveCurrentCoach {
    pub fn new() -> CMsgTFCoaching_RemoveCurrentCoach {
        ::std::default::Default::default()
    }

    // optional uint32 account_id_coach = 1;

    pub fn account_id_coach(&self) -> u32 {
        self.account_id_coach.unwrap_or(0)
    }

    pub fn clear_account_id_coach(&mut self) {
        self.account_id_coach = ::std::option::Option::None;
    }

    pub fn has_account_id_coach(&self) -> bool {
        self.account_id_coach.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id_coach(&mut self, v: u32) {
        self.account_id_coach = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id_coach",
            |m: &CMsgTFCoaching_RemoveCurrentCoach| { &m.account_id_coach },
            |m: &mut CMsgTFCoaching_RemoveCurrentCoach| { &mut m.account_id_coach },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTFCoaching_RemoveCurrentCoach>(
            "CMsgTFCoaching_RemoveCurrentCoach",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTFCoaching_RemoveCurrentCoach {
    const NAME: &'static str = "CMsgTFCoaching_RemoveCurrentCoach";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id_coach = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id_coach {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id_coach {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFCoaching_RemoveCurrentCoach {
        CMsgTFCoaching_RemoveCurrentCoach::new()
    }

    fn clear(&mut self) {
        self.account_id_coach = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFCoaching_RemoveCurrentCoach {
        static instance: CMsgTFCoaching_RemoveCurrentCoach = CMsgTFCoaching_RemoveCurrentCoach {
            account_id_coach: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTFCoaching_RemoveCurrentCoach {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTFCoaching_RemoveCurrentCoach").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTFCoaching_RemoveCurrentCoach {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFCoaching_RemoveCurrentCoach {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTFQuickplay_ScoreServers)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFQuickplay_ScoreServers {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFQuickplay_ScoreServers.servers)
    pub servers: ::std::vec::Vec<cmsg_tfquickplay_score_servers::ServerInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFQuickplay_ScoreServers.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFQuickplay_ScoreServers {
    fn default() -> &'a CMsgTFQuickplay_ScoreServers {
        <CMsgTFQuickplay_ScoreServers as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFQuickplay_ScoreServers {
    pub fn new() -> CMsgTFQuickplay_ScoreServers {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "servers",
            |m: &CMsgTFQuickplay_ScoreServers| { &m.servers },
            |m: &mut CMsgTFQuickplay_ScoreServers| { &mut m.servers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTFQuickplay_ScoreServers>(
            "CMsgTFQuickplay_ScoreServers",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTFQuickplay_ScoreServers {
    const NAME: &'static str = "CMsgTFQuickplay_ScoreServers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.servers.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.servers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.servers {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFQuickplay_ScoreServers {
        CMsgTFQuickplay_ScoreServers::new()
    }

    fn clear(&mut self) {
        self.servers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFQuickplay_ScoreServers {
        static instance: CMsgTFQuickplay_ScoreServers = CMsgTFQuickplay_ScoreServers {
            servers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTFQuickplay_ScoreServers {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTFQuickplay_ScoreServers").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTFQuickplay_ScoreServers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFQuickplay_ScoreServers {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgTFQuickplay_ScoreServers`
pub mod cmsg_tfquickplay_score_servers {
    // @@protoc_insertion_point(message:CMsgTFQuickplay_ScoreServers.ServerInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ServerInfo {
        // message fields
        // @@protoc_insertion_point(field:CMsgTFQuickplay_ScoreServers.ServerInfo.server_address)
        pub server_address: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgTFQuickplay_ScoreServers.ServerInfo.server_port)
        pub server_port: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgTFQuickplay_ScoreServers.ServerInfo.num_users)
        pub num_users: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgTFQuickplay_ScoreServers.ServerInfo.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgTFQuickplay_ScoreServers.ServerInfo.max_users)
        pub max_users: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgTFQuickplay_ScoreServers.ServerInfo.user_score)
        pub user_score: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgTFQuickplay_ScoreServers.ServerInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ServerInfo {
        fn default() -> &'a ServerInfo {
            <ServerInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl ServerInfo {
        pub fn new() -> ServerInfo {
            ::std::default::Default::default()
        }

        // optional uint32 server_address = 1;

        pub fn server_address(&self) -> u32 {
            self.server_address.unwrap_or(0)
        }

        pub fn clear_server_address(&mut self) {
            self.server_address = ::std::option::Option::None;
        }

        pub fn has_server_address(&self) -> bool {
            self.server_address.is_some()
        }

        // Param is passed by value, moved
        pub fn set_server_address(&mut self, v: u32) {
            self.server_address = ::std::option::Option::Some(v);
        }

        // optional uint32 server_port = 2;

        pub fn server_port(&self) -> u32 {
            self.server_port.unwrap_or(0)
        }

        pub fn clear_server_port(&mut self) {
            self.server_port = ::std::option::Option::None;
        }

        pub fn has_server_port(&self) -> bool {
            self.server_port.is_some()
        }

        // Param is passed by value, moved
        pub fn set_server_port(&mut self, v: u32) {
            self.server_port = ::std::option::Option::Some(v);
        }

        // optional uint32 num_users = 3;

        pub fn num_users(&self) -> u32 {
            self.num_users.unwrap_or(0)
        }

        pub fn clear_num_users(&mut self) {
            self.num_users = ::std::option::Option::None;
        }

        pub fn has_num_users(&self) -> bool {
            self.num_users.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_users(&mut self, v: u32) {
            self.num_users = ::std::option::Option::Some(v);
        }

        // optional uint64 steam_id = 4;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional uint32 max_users = 5;

        pub fn max_users(&self) -> u32 {
            self.max_users.unwrap_or(0)
        }

        pub fn clear_max_users(&mut self) {
            self.max_users = ::std::option::Option::None;
        }

        pub fn has_max_users(&self) -> bool {
            self.max_users.is_some()
        }

        // Param is passed by value, moved
        pub fn set_max_users(&mut self, v: u32) {
            self.max_users = ::std::option::Option::Some(v);
        }

        // optional float user_score = 6;

        pub fn user_score(&self) -> f32 {
            self.user_score.unwrap_or(0.)
        }

        pub fn clear_user_score(&mut self) {
            self.user_score = ::std::option::Option::None;
        }

        pub fn has_user_score(&self) -> bool {
            self.user_score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_user_score(&mut self, v: f32) {
            self.user_score = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "server_address",
                |m: &ServerInfo| { &m.server_address },
                |m: &mut ServerInfo| { &mut m.server_address },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "server_port",
                |m: &ServerInfo| { &m.server_port },
                |m: &mut ServerInfo| { &mut m.server_port },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "num_users",
                |m: &ServerInfo| { &m.num_users },
                |m: &mut ServerInfo| { &mut m.num_users },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "steam_id",
                |m: &ServerInfo| { &m.steam_id },
                |m: &mut ServerInfo| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "max_users",
                |m: &ServerInfo| { &m.max_users },
                |m: &mut ServerInfo| { &mut m.max_users },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "user_score",
                |m: &ServerInfo| { &m.user_score },
                |m: &mut ServerInfo| { &mut m.user_score },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServerInfo>(
                "CMsgTFQuickplay_ScoreServers.ServerInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ServerInfo {
        const NAME: &'static str = "ServerInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.server_address = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.server_port = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.num_users = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.steam_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    40 => {
                        self.max_users = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    53 => {
                        self.user_score = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.server_address {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.server_port {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.num_users {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.steam_id {
                my_size += ::protobuf::rt::uint64_size(4, v);
            }
            if let Some(v) = self.max_users {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.user_score {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.server_address {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.server_port {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.num_users {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.steam_id {
                os.write_uint64(4, v)?;
            }
            if let Some(v) = self.max_users {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.user_score {
                os.write_float(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ServerInfo {
            ServerInfo::new()
        }

        fn clear(&mut self) {
            self.server_address = ::std::option::Option::None;
            self.server_port = ::std::option::Option::None;
            self.num_users = ::std::option::Option::None;
            self.steam_id = ::std::option::Option::None;
            self.max_users = ::std::option::Option::None;
            self.user_score = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ServerInfo {
            static instance: ServerInfo = ServerInfo {
                server_address: ::std::option::Option::None,
                server_port: ::std::option::Option::None,
                num_users: ::std::option::Option::None,
                steam_id: ::std::option::Option::None,
                max_users: ::std::option::Option::None,
                user_score: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ServerInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgTFQuickplay_ScoreServers.ServerInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ServerInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ServerInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgTFQuickplay_ScoreServersResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFQuickplay_ScoreServersResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFQuickplay_ScoreServersResponse.servers)
    pub servers: ::std::vec::Vec<cmsg_tfquickplay_score_servers_response::ServerInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFQuickplay_ScoreServersResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFQuickplay_ScoreServersResponse {
    fn default() -> &'a CMsgTFQuickplay_ScoreServersResponse {
        <CMsgTFQuickplay_ScoreServersResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFQuickplay_ScoreServersResponse {
    pub fn new() -> CMsgTFQuickplay_ScoreServersResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "servers",
            |m: &CMsgTFQuickplay_ScoreServersResponse| { &m.servers },
            |m: &mut CMsgTFQuickplay_ScoreServersResponse| { &mut m.servers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTFQuickplay_ScoreServersResponse>(
            "CMsgTFQuickplay_ScoreServersResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTFQuickplay_ScoreServersResponse {
    const NAME: &'static str = "CMsgTFQuickplay_ScoreServersResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.servers.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.servers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.servers {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFQuickplay_ScoreServersResponse {
        CMsgTFQuickplay_ScoreServersResponse::new()
    }

    fn clear(&mut self) {
        self.servers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFQuickplay_ScoreServersResponse {
        static instance: CMsgTFQuickplay_ScoreServersResponse = CMsgTFQuickplay_ScoreServersResponse {
            servers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTFQuickplay_ScoreServersResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTFQuickplay_ScoreServersResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTFQuickplay_ScoreServersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFQuickplay_ScoreServersResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgTFQuickplay_ScoreServersResponse`
pub mod cmsg_tfquickplay_score_servers_response {
    // @@protoc_insertion_point(message:CMsgTFQuickplay_ScoreServersResponse.ServerInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ServerInfo {
        // message fields
        // @@protoc_insertion_point(field:CMsgTFQuickplay_ScoreServersResponse.ServerInfo.server_address)
        pub server_address: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgTFQuickplay_ScoreServersResponse.ServerInfo.server_port)
        pub server_port: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgTFQuickplay_ScoreServersResponse.ServerInfo.total_score)
        pub total_score: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgTFQuickplay_ScoreServersResponse.ServerInfo.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgTFQuickplay_ScoreServersResponse.ServerInfo.options_score)
        pub options_score: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgTFQuickplay_ScoreServersResponse.ServerInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ServerInfo {
        fn default() -> &'a ServerInfo {
            <ServerInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl ServerInfo {
        pub fn new() -> ServerInfo {
            ::std::default::Default::default()
        }

        // optional uint32 server_address = 1;

        pub fn server_address(&self) -> u32 {
            self.server_address.unwrap_or(0)
        }

        pub fn clear_server_address(&mut self) {
            self.server_address = ::std::option::Option::None;
        }

        pub fn has_server_address(&self) -> bool {
            self.server_address.is_some()
        }

        // Param is passed by value, moved
        pub fn set_server_address(&mut self, v: u32) {
            self.server_address = ::std::option::Option::Some(v);
        }

        // optional uint32 server_port = 2;

        pub fn server_port(&self) -> u32 {
            self.server_port.unwrap_or(0)
        }

        pub fn clear_server_port(&mut self) {
            self.server_port = ::std::option::Option::None;
        }

        pub fn has_server_port(&self) -> bool {
            self.server_port.is_some()
        }

        // Param is passed by value, moved
        pub fn set_server_port(&mut self, v: u32) {
            self.server_port = ::std::option::Option::Some(v);
        }

        // optional float total_score = 3;

        pub fn total_score(&self) -> f32 {
            self.total_score.unwrap_or(0.)
        }

        pub fn clear_total_score(&mut self) {
            self.total_score = ::std::option::Option::None;
        }

        pub fn has_total_score(&self) -> bool {
            self.total_score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_score(&mut self, v: f32) {
            self.total_score = ::std::option::Option::Some(v);
        }

        // optional uint64 steam_id = 4;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional uint32 options_score = 5;

        pub fn options_score(&self) -> u32 {
            self.options_score.unwrap_or(0)
        }

        pub fn clear_options_score(&mut self) {
            self.options_score = ::std::option::Option::None;
        }

        pub fn has_options_score(&self) -> bool {
            self.options_score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_options_score(&mut self, v: u32) {
            self.options_score = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "server_address",
                |m: &ServerInfo| { &m.server_address },
                |m: &mut ServerInfo| { &mut m.server_address },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "server_port",
                |m: &ServerInfo| { &m.server_port },
                |m: &mut ServerInfo| { &mut m.server_port },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "total_score",
                |m: &ServerInfo| { &m.total_score },
                |m: &mut ServerInfo| { &mut m.total_score },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "steam_id",
                |m: &ServerInfo| { &m.steam_id },
                |m: &mut ServerInfo| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "options_score",
                |m: &ServerInfo| { &m.options_score },
                |m: &mut ServerInfo| { &mut m.options_score },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServerInfo>(
                "CMsgTFQuickplay_ScoreServersResponse.ServerInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ServerInfo {
        const NAME: &'static str = "ServerInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.server_address = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.server_port = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    29 => {
                        self.total_score = ::std::option::Option::Some(is.read_float()?);
                    },
                    32 => {
                        self.steam_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    40 => {
                        self.options_score = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.server_address {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.server_port {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.total_score {
                my_size += 1 + 4;
            }
            if let Some(v) = self.steam_id {
                my_size += ::protobuf::rt::uint64_size(4, v);
            }
            if let Some(v) = self.options_score {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.server_address {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.server_port {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.total_score {
                os.write_float(3, v)?;
            }
            if let Some(v) = self.steam_id {
                os.write_uint64(4, v)?;
            }
            if let Some(v) = self.options_score {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ServerInfo {
            ServerInfo::new()
        }

        fn clear(&mut self) {
            self.server_address = ::std::option::Option::None;
            self.server_port = ::std::option::Option::None;
            self.total_score = ::std::option::Option::None;
            self.steam_id = ::std::option::Option::None;
            self.options_score = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ServerInfo {
            static instance: ServerInfo = ServerInfo {
                server_address: ::std::option::Option::None,
                server_port: ::std::option::Option::None,
                total_score: ::std::option::Option::None,
                steam_id: ::std::option::Option::None,
                options_score: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ServerInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgTFQuickplay_ScoreServersResponse.ServerInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ServerInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ServerInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgTFQuickplay_PlayerJoining)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFQuickplay_PlayerJoining {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFQuickplay_PlayerJoining.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFQuickplay_PlayerJoining.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFQuickplay_PlayerJoining {
    fn default() -> &'a CMsgTFQuickplay_PlayerJoining {
        <CMsgTFQuickplay_PlayerJoining as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFQuickplay_PlayerJoining {
    pub fn new() -> CMsgTFQuickplay_PlayerJoining {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgTFQuickplay_PlayerJoining| { &m.account_id },
            |m: &mut CMsgTFQuickplay_PlayerJoining| { &mut m.account_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTFQuickplay_PlayerJoining>(
            "CMsgTFQuickplay_PlayerJoining",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTFQuickplay_PlayerJoining {
    const NAME: &'static str = "CMsgTFQuickplay_PlayerJoining";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFQuickplay_PlayerJoining {
        CMsgTFQuickplay_PlayerJoining::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFQuickplay_PlayerJoining {
        static instance: CMsgTFQuickplay_PlayerJoining = CMsgTFQuickplay_PlayerJoining {
            account_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTFQuickplay_PlayerJoining {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTFQuickplay_PlayerJoining").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTFQuickplay_PlayerJoining {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFQuickplay_PlayerJoining {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGC_GameServer_LevelInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_GameServer_LevelInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_GameServer_LevelInfo.level_loaded)
    pub level_loaded: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGC_GameServer_LevelInfo.level_name)
    pub level_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_GameServer_LevelInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_LevelInfo {
    fn default() -> &'a CMsgGC_GameServer_LevelInfo {
        <CMsgGC_GameServer_LevelInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_LevelInfo {
    pub fn new() -> CMsgGC_GameServer_LevelInfo {
        ::std::default::Default::default()
    }

    // optional bool level_loaded = 1;

    pub fn level_loaded(&self) -> bool {
        self.level_loaded.unwrap_or(false)
    }

    pub fn clear_level_loaded(&mut self) {
        self.level_loaded = ::std::option::Option::None;
    }

    pub fn has_level_loaded(&self) -> bool {
        self.level_loaded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level_loaded(&mut self, v: bool) {
        self.level_loaded = ::std::option::Option::Some(v);
    }

    // optional string level_name = 2;

    pub fn level_name(&self) -> &str {
        match self.level_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_level_name(&mut self) {
        self.level_name = ::std::option::Option::None;
    }

    pub fn has_level_name(&self) -> bool {
        self.level_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level_name(&mut self, v: ::std::string::String) {
        self.level_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_level_name(&mut self) -> &mut ::std::string::String {
        if self.level_name.is_none() {
            self.level_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.level_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_level_name(&mut self) -> ::std::string::String {
        self.level_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "level_loaded",
            |m: &CMsgGC_GameServer_LevelInfo| { &m.level_loaded },
            |m: &mut CMsgGC_GameServer_LevelInfo| { &mut m.level_loaded },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "level_name",
            |m: &CMsgGC_GameServer_LevelInfo| { &m.level_name },
            |m: &mut CMsgGC_GameServer_LevelInfo| { &mut m.level_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_GameServer_LevelInfo>(
            "CMsgGC_GameServer_LevelInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_GameServer_LevelInfo {
    const NAME: &'static str = "CMsgGC_GameServer_LevelInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.level_loaded = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    self.level_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.level_loaded {
            my_size += 1 + 1;
        }
        if let Some(v) = self.level_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.level_loaded {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.level_name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_GameServer_LevelInfo {
        CMsgGC_GameServer_LevelInfo::new()
    }

    fn clear(&mut self) {
        self.level_loaded = ::std::option::Option::None;
        self.level_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_GameServer_LevelInfo {
        static instance: CMsgGC_GameServer_LevelInfo = CMsgGC_GameServer_LevelInfo {
            level_loaded: ::std::option::Option::None,
            level_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_GameServer_LevelInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_GameServer_LevelInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_GameServer_LevelInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GameServer_LevelInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGC_GameServer_AuthChallenge)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_GameServer_AuthChallenge {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_GameServer_AuthChallenge.challenge_string)
    pub challenge_string: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_GameServer_AuthChallenge.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_AuthChallenge {
    fn default() -> &'a CMsgGC_GameServer_AuthChallenge {
        <CMsgGC_GameServer_AuthChallenge as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_AuthChallenge {
    pub fn new() -> CMsgGC_GameServer_AuthChallenge {
        ::std::default::Default::default()
    }

    // optional string challenge_string = 1;

    pub fn challenge_string(&self) -> &str {
        match self.challenge_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_challenge_string(&mut self) {
        self.challenge_string = ::std::option::Option::None;
    }

    pub fn has_challenge_string(&self) -> bool {
        self.challenge_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_string(&mut self, v: ::std::string::String) {
        self.challenge_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_challenge_string(&mut self) -> &mut ::std::string::String {
        if self.challenge_string.is_none() {
            self.challenge_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.challenge_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_challenge_string(&mut self) -> ::std::string::String {
        self.challenge_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge_string",
            |m: &CMsgGC_GameServer_AuthChallenge| { &m.challenge_string },
            |m: &mut CMsgGC_GameServer_AuthChallenge| { &mut m.challenge_string },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_GameServer_AuthChallenge>(
            "CMsgGC_GameServer_AuthChallenge",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_GameServer_AuthChallenge {
    const NAME: &'static str = "CMsgGC_GameServer_AuthChallenge";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.challenge_string = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.challenge_string.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.challenge_string.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_GameServer_AuthChallenge {
        CMsgGC_GameServer_AuthChallenge::new()
    }

    fn clear(&mut self) {
        self.challenge_string = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_GameServer_AuthChallenge {
        static instance: CMsgGC_GameServer_AuthChallenge = CMsgGC_GameServer_AuthChallenge {
            challenge_string: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_GameServer_AuthChallenge {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_GameServer_AuthChallenge").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_GameServer_AuthChallenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GameServer_AuthChallenge {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGC_GameServer_AuthResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_GameServer_AuthResult {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_GameServer_AuthResult.authenticated)
    pub authenticated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGC_GameServer_AuthResult.game_server_standing)
    pub game_server_standing: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGC_GameServer_AuthResult.game_server_standing_trend)
    pub game_server_standing_trend: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGC_GameServer_AuthResult.is_valve_server)
    pub is_valve_server: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGC_GameServer_AuthResult.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_GameServer_AuthResult.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_AuthResult {
    fn default() -> &'a CMsgGC_GameServer_AuthResult {
        <CMsgGC_GameServer_AuthResult as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_AuthResult {
    pub fn new() -> CMsgGC_GameServer_AuthResult {
        ::std::default::Default::default()
    }

    // optional bool authenticated = 1;

    pub fn authenticated(&self) -> bool {
        self.authenticated.unwrap_or(false)
    }

    pub fn clear_authenticated(&mut self) {
        self.authenticated = ::std::option::Option::None;
    }

    pub fn has_authenticated(&self) -> bool {
        self.authenticated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authenticated(&mut self, v: bool) {
        self.authenticated = ::std::option::Option::Some(v);
    }

    // optional int32 game_server_standing = 2;

    pub fn game_server_standing(&self) -> i32 {
        self.game_server_standing.unwrap_or(0)
    }

    pub fn clear_game_server_standing(&mut self) {
        self.game_server_standing = ::std::option::Option::None;
    }

    pub fn has_game_server_standing(&self) -> bool {
        self.game_server_standing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_standing(&mut self, v: i32) {
        self.game_server_standing = ::std::option::Option::Some(v);
    }

    // optional int32 game_server_standing_trend = 3;

    pub fn game_server_standing_trend(&self) -> i32 {
        self.game_server_standing_trend.unwrap_or(0)
    }

    pub fn clear_game_server_standing_trend(&mut self) {
        self.game_server_standing_trend = ::std::option::Option::None;
    }

    pub fn has_game_server_standing_trend(&self) -> bool {
        self.game_server_standing_trend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_standing_trend(&mut self, v: i32) {
        self.game_server_standing_trend = ::std::option::Option::Some(v);
    }

    // optional bool is_valve_server = 4;

    pub fn is_valve_server(&self) -> bool {
        self.is_valve_server.unwrap_or(false)
    }

    pub fn clear_is_valve_server(&mut self) {
        self.is_valve_server = ::std::option::Option::None;
    }

    pub fn has_is_valve_server(&self) -> bool {
        self.is_valve_server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_valve_server(&mut self, v: bool) {
        self.is_valve_server = ::std::option::Option::Some(v);
    }

    // optional string message = 5;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "authenticated",
            |m: &CMsgGC_GameServer_AuthResult| { &m.authenticated },
            |m: &mut CMsgGC_GameServer_AuthResult| { &mut m.authenticated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_server_standing",
            |m: &CMsgGC_GameServer_AuthResult| { &m.game_server_standing },
            |m: &mut CMsgGC_GameServer_AuthResult| { &mut m.game_server_standing },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_server_standing_trend",
            |m: &CMsgGC_GameServer_AuthResult| { &m.game_server_standing_trend },
            |m: &mut CMsgGC_GameServer_AuthResult| { &mut m.game_server_standing_trend },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_valve_server",
            |m: &CMsgGC_GameServer_AuthResult| { &m.is_valve_server },
            |m: &mut CMsgGC_GameServer_AuthResult| { &mut m.is_valve_server },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &CMsgGC_GameServer_AuthResult| { &m.message },
            |m: &mut CMsgGC_GameServer_AuthResult| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_GameServer_AuthResult>(
            "CMsgGC_GameServer_AuthResult",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_GameServer_AuthResult {
    const NAME: &'static str = "CMsgGC_GameServer_AuthResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.authenticated = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.game_server_standing = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.game_server_standing_trend = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.is_valve_server = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.authenticated {
            my_size += 1 + 1;
        }
        if let Some(v) = self.game_server_standing {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.game_server_standing_trend {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.is_valve_server {
            my_size += 1 + 1;
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.authenticated {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.game_server_standing {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.game_server_standing_trend {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.is_valve_server {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_GameServer_AuthResult {
        CMsgGC_GameServer_AuthResult::new()
    }

    fn clear(&mut self) {
        self.authenticated = ::std::option::Option::None;
        self.game_server_standing = ::std::option::Option::None;
        self.game_server_standing_trend = ::std::option::Option::None;
        self.is_valve_server = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_GameServer_AuthResult {
        static instance: CMsgGC_GameServer_AuthResult = CMsgGC_GameServer_AuthResult {
            authenticated: ::std::option::Option::None,
            game_server_standing: ::std::option::Option::None,
            game_server_standing_trend: ::std::option::Option::None,
            is_valve_server: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_GameServer_AuthResult {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_GameServer_AuthResult").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_GameServer_AuthResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GameServer_AuthResult {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGC_GameServer_AuthChallengeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_GameServer_AuthChallengeResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_GameServer_AuthChallengeResponse.game_server_account_id)
    pub game_server_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGC_GameServer_AuthChallengeResponse.hashed_challenge_string)
    pub hashed_challenge_string: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_GameServer_AuthChallengeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_AuthChallengeResponse {
    fn default() -> &'a CMsgGC_GameServer_AuthChallengeResponse {
        <CMsgGC_GameServer_AuthChallengeResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_AuthChallengeResponse {
    pub fn new() -> CMsgGC_GameServer_AuthChallengeResponse {
        ::std::default::Default::default()
    }

    // optional uint32 game_server_account_id = 1;

    pub fn game_server_account_id(&self) -> u32 {
        self.game_server_account_id.unwrap_or(0)
    }

    pub fn clear_game_server_account_id(&mut self) {
        self.game_server_account_id = ::std::option::Option::None;
    }

    pub fn has_game_server_account_id(&self) -> bool {
        self.game_server_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_account_id(&mut self, v: u32) {
        self.game_server_account_id = ::std::option::Option::Some(v);
    }

    // optional bytes hashed_challenge_string = 2;

    pub fn hashed_challenge_string(&self) -> &[u8] {
        match self.hashed_challenge_string.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_hashed_challenge_string(&mut self) {
        self.hashed_challenge_string = ::std::option::Option::None;
    }

    pub fn has_hashed_challenge_string(&self) -> bool {
        self.hashed_challenge_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hashed_challenge_string(&mut self, v: ::std::vec::Vec<u8>) {
        self.hashed_challenge_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hashed_challenge_string(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.hashed_challenge_string.is_none() {
            self.hashed_challenge_string = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.hashed_challenge_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_hashed_challenge_string(&mut self) -> ::std::vec::Vec<u8> {
        self.hashed_challenge_string.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_server_account_id",
            |m: &CMsgGC_GameServer_AuthChallengeResponse| { &m.game_server_account_id },
            |m: &mut CMsgGC_GameServer_AuthChallengeResponse| { &mut m.game_server_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hashed_challenge_string",
            |m: &CMsgGC_GameServer_AuthChallengeResponse| { &m.hashed_challenge_string },
            |m: &mut CMsgGC_GameServer_AuthChallengeResponse| { &mut m.hashed_challenge_string },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_GameServer_AuthChallengeResponse>(
            "CMsgGC_GameServer_AuthChallengeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_GameServer_AuthChallengeResponse {
    const NAME: &'static str = "CMsgGC_GameServer_AuthChallengeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.game_server_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.hashed_challenge_string = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_server_account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.hashed_challenge_string.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.game_server_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.hashed_challenge_string.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_GameServer_AuthChallengeResponse {
        CMsgGC_GameServer_AuthChallengeResponse::new()
    }

    fn clear(&mut self) {
        self.game_server_account_id = ::std::option::Option::None;
        self.hashed_challenge_string = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_GameServer_AuthChallengeResponse {
        static instance: CMsgGC_GameServer_AuthChallengeResponse = CMsgGC_GameServer_AuthChallengeResponse {
            game_server_account_id: ::std::option::Option::None,
            hashed_challenge_string: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_GameServer_AuthChallengeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_GameServer_AuthChallengeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_GameServer_AuthChallengeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GameServer_AuthChallengeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGC_GameServer_CreateIdentity)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_GameServer_CreateIdentity {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_GameServer_CreateIdentity.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_GameServer_CreateIdentity.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_CreateIdentity {
    fn default() -> &'a CMsgGC_GameServer_CreateIdentity {
        <CMsgGC_GameServer_CreateIdentity as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_CreateIdentity {
    pub fn new() -> CMsgGC_GameServer_CreateIdentity {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGC_GameServer_CreateIdentity| { &m.account_id },
            |m: &mut CMsgGC_GameServer_CreateIdentity| { &mut m.account_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_GameServer_CreateIdentity>(
            "CMsgGC_GameServer_CreateIdentity",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_GameServer_CreateIdentity {
    const NAME: &'static str = "CMsgGC_GameServer_CreateIdentity";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_GameServer_CreateIdentity {
        CMsgGC_GameServer_CreateIdentity::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_GameServer_CreateIdentity {
        static instance: CMsgGC_GameServer_CreateIdentity = CMsgGC_GameServer_CreateIdentity {
            account_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_GameServer_CreateIdentity {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_GameServer_CreateIdentity").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_GameServer_CreateIdentity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GameServer_CreateIdentity {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGC_GameServer_CreateIdentityResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_GameServer_CreateIdentityResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_GameServer_CreateIdentityResponse.account_created)
    pub account_created: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGC_GameServer_CreateIdentityResponse.game_server_account_id)
    pub game_server_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGC_GameServer_CreateIdentityResponse.game_server_identity_token)
    pub game_server_identity_token: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGC_GameServer_CreateIdentityResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_gc_game_server_create_identity_response::EStatus>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_GameServer_CreateIdentityResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_CreateIdentityResponse {
    fn default() -> &'a CMsgGC_GameServer_CreateIdentityResponse {
        <CMsgGC_GameServer_CreateIdentityResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_CreateIdentityResponse {
    pub fn new() -> CMsgGC_GameServer_CreateIdentityResponse {
        ::std::default::Default::default()
    }

    // optional bool account_created = 1;

    pub fn account_created(&self) -> bool {
        self.account_created.unwrap_or(false)
    }

    pub fn clear_account_created(&mut self) {
        self.account_created = ::std::option::Option::None;
    }

    pub fn has_account_created(&self) -> bool {
        self.account_created.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_created(&mut self, v: bool) {
        self.account_created = ::std::option::Option::Some(v);
    }

    // optional uint32 game_server_account_id = 2;

    pub fn game_server_account_id(&self) -> u32 {
        self.game_server_account_id.unwrap_or(0)
    }

    pub fn clear_game_server_account_id(&mut self) {
        self.game_server_account_id = ::std::option::Option::None;
    }

    pub fn has_game_server_account_id(&self) -> bool {
        self.game_server_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_account_id(&mut self, v: u32) {
        self.game_server_account_id = ::std::option::Option::Some(v);
    }

    // optional string game_server_identity_token = 3;

    pub fn game_server_identity_token(&self) -> &str {
        match self.game_server_identity_token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_server_identity_token(&mut self) {
        self.game_server_identity_token = ::std::option::Option::None;
    }

    pub fn has_game_server_identity_token(&self) -> bool {
        self.game_server_identity_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_identity_token(&mut self, v: ::std::string::String) {
        self.game_server_identity_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_server_identity_token(&mut self) -> &mut ::std::string::String {
        if self.game_server_identity_token.is_none() {
            self.game_server_identity_token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_server_identity_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_server_identity_token(&mut self) -> ::std::string::String {
        self.game_server_identity_token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .CMsgGC_GameServer_CreateIdentityResponse.EStatus status = 4;

    pub fn status(&self) -> cmsg_gc_game_server_create_identity_response::EStatus {
        match self.status {
            Some(e) => e.enum_value_or(cmsg_gc_game_server_create_identity_response::EStatus::kStatus_GenericFailure),
            None => cmsg_gc_game_server_create_identity_response::EStatus::kStatus_GenericFailure,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: cmsg_gc_game_server_create_identity_response::EStatus) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_created",
            |m: &CMsgGC_GameServer_CreateIdentityResponse| { &m.account_created },
            |m: &mut CMsgGC_GameServer_CreateIdentityResponse| { &mut m.account_created },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_server_account_id",
            |m: &CMsgGC_GameServer_CreateIdentityResponse| { &m.game_server_account_id },
            |m: &mut CMsgGC_GameServer_CreateIdentityResponse| { &mut m.game_server_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_server_identity_token",
            |m: &CMsgGC_GameServer_CreateIdentityResponse| { &m.game_server_identity_token },
            |m: &mut CMsgGC_GameServer_CreateIdentityResponse| { &mut m.game_server_identity_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &CMsgGC_GameServer_CreateIdentityResponse| { &m.status },
            |m: &mut CMsgGC_GameServer_CreateIdentityResponse| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_GameServer_CreateIdentityResponse>(
            "CMsgGC_GameServer_CreateIdentityResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_GameServer_CreateIdentityResponse {
    const NAME: &'static str = "CMsgGC_GameServer_CreateIdentityResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_created = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.game_server_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.game_server_identity_token = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_created {
            my_size += 1 + 1;
        }
        if let Some(v) = self.game_server_account_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.game_server_identity_token.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_created {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.game_server_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.game_server_identity_token.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.status {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_GameServer_CreateIdentityResponse {
        CMsgGC_GameServer_CreateIdentityResponse::new()
    }

    fn clear(&mut self) {
        self.account_created = ::std::option::Option::None;
        self.game_server_account_id = ::std::option::Option::None;
        self.game_server_identity_token = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_GameServer_CreateIdentityResponse {
        static instance: CMsgGC_GameServer_CreateIdentityResponse = CMsgGC_GameServer_CreateIdentityResponse {
            account_created: ::std::option::Option::None,
            game_server_account_id: ::std::option::Option::None,
            game_server_identity_token: ::std::option::Option::None,
            status: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_GameServer_CreateIdentityResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_GameServer_CreateIdentityResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_GameServer_CreateIdentityResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GameServer_CreateIdentityResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGC_GameServer_CreateIdentityResponse`
pub mod cmsg_gc_game_server_create_identity_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGC_GameServer_CreateIdentityResponse.EStatus)
    pub enum EStatus {
        // @@protoc_insertion_point(enum_value:CMsgGC_GameServer_CreateIdentityResponse.EStatus.kStatus_GenericFailure)
        kStatus_GenericFailure = 0,
        // @@protoc_insertion_point(enum_value:CMsgGC_GameServer_CreateIdentityResponse.EStatus.kStatus_TooMany)
        kStatus_TooMany = -1,
        // @@protoc_insertion_point(enum_value:CMsgGC_GameServer_CreateIdentityResponse.EStatus.kStatus_NoPrivs)
        kStatus_NoPrivs = -2,
        // @@protoc_insertion_point(enum_value:CMsgGC_GameServer_CreateIdentityResponse.EStatus.kStatus_Created)
        kStatus_Created = 1,
    }

    impl ::protobuf::Enum for EStatus {
        const NAME: &'static str = "EStatus";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EStatus> {
            match value {
                0 => ::std::option::Option::Some(EStatus::kStatus_GenericFailure),
                -1 => ::std::option::Option::Some(EStatus::kStatus_TooMany),
                -2 => ::std::option::Option::Some(EStatus::kStatus_NoPrivs),
                1 => ::std::option::Option::Some(EStatus::kStatus_Created),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EStatus> {
            match str {
                "kStatus_GenericFailure" => ::std::option::Option::Some(EStatus::kStatus_GenericFailure),
                "kStatus_TooMany" => ::std::option::Option::Some(EStatus::kStatus_TooMany),
                "kStatus_NoPrivs" => ::std::option::Option::Some(EStatus::kStatus_NoPrivs),
                "kStatus_Created" => ::std::option::Option::Some(EStatus::kStatus_Created),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EStatus] = &[
            EStatus::kStatus_GenericFailure,
            EStatus::kStatus_TooMany,
            EStatus::kStatus_NoPrivs,
            EStatus::kStatus_Created,
        ];
    }

    impl ::protobuf::EnumFull for EStatus {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgGC_GameServer_CreateIdentityResponse.EStatus").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                EStatus::kStatus_GenericFailure => 0,
                EStatus::kStatus_TooMany => 1,
                EStatus::kStatus_NoPrivs => 2,
                EStatus::kStatus_Created => 3,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EStatus {
        fn default() -> Self {
            EStatus::kStatus_GenericFailure
        }
    }

    impl EStatus {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EStatus>("CMsgGC_GameServer_CreateIdentityResponse.EStatus")
        }
    }
}

// @@protoc_insertion_point(message:CMsgGC_GameServer_List)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_GameServer_List {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_GameServer_List.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_GameServer_List.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_List {
    fn default() -> &'a CMsgGC_GameServer_List {
        <CMsgGC_GameServer_List as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_List {
    pub fn new() -> CMsgGC_GameServer_List {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGC_GameServer_List| { &m.account_id },
            |m: &mut CMsgGC_GameServer_List| { &mut m.account_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_GameServer_List>(
            "CMsgGC_GameServer_List",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_GameServer_List {
    const NAME: &'static str = "CMsgGC_GameServer_List";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_GameServer_List {
        CMsgGC_GameServer_List::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_GameServer_List {
        static instance: CMsgGC_GameServer_List = CMsgGC_GameServer_List {
            account_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_GameServer_List {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_GameServer_List").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_GameServer_List {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GameServer_List {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGC_GameServer_ListResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_GameServer_ListResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_GameServer_ListResponse.owned_game_servers)
    pub owned_game_servers: ::std::vec::Vec<cmsg_gc_game_server_list_response::GameServerIdentity>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_GameServer_ListResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_ListResponse {
    fn default() -> &'a CMsgGC_GameServer_ListResponse {
        <CMsgGC_GameServer_ListResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_ListResponse {
    pub fn new() -> CMsgGC_GameServer_ListResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "owned_game_servers",
            |m: &CMsgGC_GameServer_ListResponse| { &m.owned_game_servers },
            |m: &mut CMsgGC_GameServer_ListResponse| { &mut m.owned_game_servers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_GameServer_ListResponse>(
            "CMsgGC_GameServer_ListResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_GameServer_ListResponse {
    const NAME: &'static str = "CMsgGC_GameServer_ListResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.owned_game_servers.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.owned_game_servers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.owned_game_servers {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_GameServer_ListResponse {
        CMsgGC_GameServer_ListResponse::new()
    }

    fn clear(&mut self) {
        self.owned_game_servers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_GameServer_ListResponse {
        static instance: CMsgGC_GameServer_ListResponse = CMsgGC_GameServer_ListResponse {
            owned_game_servers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_GameServer_ListResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_GameServer_ListResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_GameServer_ListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GameServer_ListResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGC_GameServer_ListResponse`
pub mod cmsg_gc_game_server_list_response {
    // @@protoc_insertion_point(message:CMsgGC_GameServer_ListResponse.GameServerIdentity)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct GameServerIdentity {
        // message fields
        // @@protoc_insertion_point(field:CMsgGC_GameServer_ListResponse.GameServerIdentity.game_server_account_id)
        pub game_server_account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_GameServer_ListResponse.GameServerIdentity.game_server_identity_token)
        pub game_server_identity_token: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGC_GameServer_ListResponse.GameServerIdentity.game_server_standing)
        pub game_server_standing: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgGC_GameServer_ListResponse.GameServerIdentity.game_server_standing_trend)
        pub game_server_standing_trend: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGC_GameServer_ListResponse.GameServerIdentity.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GameServerIdentity {
        fn default() -> &'a GameServerIdentity {
            <GameServerIdentity as ::protobuf::Message>::default_instance()
        }
    }

    impl GameServerIdentity {
        pub fn new() -> GameServerIdentity {
            ::std::default::Default::default()
        }

        // optional uint32 game_server_account_id = 1;

        pub fn game_server_account_id(&self) -> u32 {
            self.game_server_account_id.unwrap_or(0)
        }

        pub fn clear_game_server_account_id(&mut self) {
            self.game_server_account_id = ::std::option::Option::None;
        }

        pub fn has_game_server_account_id(&self) -> bool {
            self.game_server_account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_server_account_id(&mut self, v: u32) {
            self.game_server_account_id = ::std::option::Option::Some(v);
        }

        // optional string game_server_identity_token = 2;

        pub fn game_server_identity_token(&self) -> &str {
            match self.game_server_identity_token.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_game_server_identity_token(&mut self) {
            self.game_server_identity_token = ::std::option::Option::None;
        }

        pub fn has_game_server_identity_token(&self) -> bool {
            self.game_server_identity_token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_server_identity_token(&mut self, v: ::std::string::String) {
            self.game_server_identity_token = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_game_server_identity_token(&mut self) -> &mut ::std::string::String {
            if self.game_server_identity_token.is_none() {
                self.game_server_identity_token = ::std::option::Option::Some(::std::string::String::new());
            }
            self.game_server_identity_token.as_mut().unwrap()
        }

        // Take field
        pub fn take_game_server_identity_token(&mut self) -> ::std::string::String {
            self.game_server_identity_token.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 game_server_standing = 3;

        pub fn game_server_standing(&self) -> i32 {
            self.game_server_standing.unwrap_or(0)
        }

        pub fn clear_game_server_standing(&mut self) {
            self.game_server_standing = ::std::option::Option::None;
        }

        pub fn has_game_server_standing(&self) -> bool {
            self.game_server_standing.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_server_standing(&mut self, v: i32) {
            self.game_server_standing = ::std::option::Option::Some(v);
        }

        // optional int32 game_server_standing_trend = 4;

        pub fn game_server_standing_trend(&self) -> i32 {
            self.game_server_standing_trend.unwrap_or(0)
        }

        pub fn clear_game_server_standing_trend(&mut self) {
            self.game_server_standing_trend = ::std::option::Option::None;
        }

        pub fn has_game_server_standing_trend(&self) -> bool {
            self.game_server_standing_trend.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_server_standing_trend(&mut self, v: i32) {
            self.game_server_standing_trend = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_server_account_id",
                |m: &GameServerIdentity| { &m.game_server_account_id },
                |m: &mut GameServerIdentity| { &mut m.game_server_account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_server_identity_token",
                |m: &GameServerIdentity| { &m.game_server_identity_token },
                |m: &mut GameServerIdentity| { &mut m.game_server_identity_token },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_server_standing",
                |m: &GameServerIdentity| { &m.game_server_standing },
                |m: &mut GameServerIdentity| { &mut m.game_server_standing },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_server_standing_trend",
                |m: &GameServerIdentity| { &m.game_server_standing_trend },
                |m: &mut GameServerIdentity| { &mut m.game_server_standing_trend },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GameServerIdentity>(
                "CMsgGC_GameServer_ListResponse.GameServerIdentity",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for GameServerIdentity {
        const NAME: &'static str = "GameServerIdentity";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.game_server_account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.game_server_identity_token = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.game_server_standing = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.game_server_standing_trend = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.game_server_account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.game_server_identity_token.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.game_server_standing {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.game_server_standing_trend {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.game_server_account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.game_server_identity_token.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.game_server_standing {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.game_server_standing_trend {
                os.write_int32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GameServerIdentity {
            GameServerIdentity::new()
        }

        fn clear(&mut self) {
            self.game_server_account_id = ::std::option::Option::None;
            self.game_server_identity_token = ::std::option::Option::None;
            self.game_server_standing = ::std::option::Option::None;
            self.game_server_standing_trend = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GameServerIdentity {
            static instance: GameServerIdentity = GameServerIdentity {
                game_server_account_id: ::std::option::Option::None,
                game_server_identity_token: ::std::option::Option::None,
                game_server_standing: ::std::option::Option::None,
                game_server_standing_trend: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for GameServerIdentity {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGC_GameServer_ListResponse.GameServerIdentity").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for GameServerIdentity {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for GameServerIdentity {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgGC_GameServer_ResetIdentity)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_GameServer_ResetIdentity {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_GameServer_ResetIdentity.game_server_account_id)
    pub game_server_account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_GameServer_ResetIdentity.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_ResetIdentity {
    fn default() -> &'a CMsgGC_GameServer_ResetIdentity {
        <CMsgGC_GameServer_ResetIdentity as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_ResetIdentity {
    pub fn new() -> CMsgGC_GameServer_ResetIdentity {
        ::std::default::Default::default()
    }

    // optional uint32 game_server_account_id = 1;

    pub fn game_server_account_id(&self) -> u32 {
        self.game_server_account_id.unwrap_or(0)
    }

    pub fn clear_game_server_account_id(&mut self) {
        self.game_server_account_id = ::std::option::Option::None;
    }

    pub fn has_game_server_account_id(&self) -> bool {
        self.game_server_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_account_id(&mut self, v: u32) {
        self.game_server_account_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_server_account_id",
            |m: &CMsgGC_GameServer_ResetIdentity| { &m.game_server_account_id },
            |m: &mut CMsgGC_GameServer_ResetIdentity| { &mut m.game_server_account_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_GameServer_ResetIdentity>(
            "CMsgGC_GameServer_ResetIdentity",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_GameServer_ResetIdentity {
    const NAME: &'static str = "CMsgGC_GameServer_ResetIdentity";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.game_server_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_server_account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.game_server_account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_GameServer_ResetIdentity {
        CMsgGC_GameServer_ResetIdentity::new()
    }

    fn clear(&mut self) {
        self.game_server_account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_GameServer_ResetIdentity {
        static instance: CMsgGC_GameServer_ResetIdentity = CMsgGC_GameServer_ResetIdentity {
            game_server_account_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_GameServer_ResetIdentity {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_GameServer_ResetIdentity").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_GameServer_ResetIdentity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GameServer_ResetIdentity {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGC_GameServer_ResetIdentityResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_GameServer_ResetIdentityResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_GameServer_ResetIdentityResponse.game_server_identity_token_reset)
    pub game_server_identity_token_reset: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGC_GameServer_ResetIdentityResponse.game_server_account_id)
    pub game_server_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGC_GameServer_ResetIdentityResponse.game_server_identity_token)
    pub game_server_identity_token: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_GameServer_ResetIdentityResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_ResetIdentityResponse {
    fn default() -> &'a CMsgGC_GameServer_ResetIdentityResponse {
        <CMsgGC_GameServer_ResetIdentityResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_ResetIdentityResponse {
    pub fn new() -> CMsgGC_GameServer_ResetIdentityResponse {
        ::std::default::Default::default()
    }

    // optional bool game_server_identity_token_reset = 1;

    pub fn game_server_identity_token_reset(&self) -> bool {
        self.game_server_identity_token_reset.unwrap_or(false)
    }

    pub fn clear_game_server_identity_token_reset(&mut self) {
        self.game_server_identity_token_reset = ::std::option::Option::None;
    }

    pub fn has_game_server_identity_token_reset(&self) -> bool {
        self.game_server_identity_token_reset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_identity_token_reset(&mut self, v: bool) {
        self.game_server_identity_token_reset = ::std::option::Option::Some(v);
    }

    // optional uint32 game_server_account_id = 2;

    pub fn game_server_account_id(&self) -> u32 {
        self.game_server_account_id.unwrap_or(0)
    }

    pub fn clear_game_server_account_id(&mut self) {
        self.game_server_account_id = ::std::option::Option::None;
    }

    pub fn has_game_server_account_id(&self) -> bool {
        self.game_server_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_account_id(&mut self, v: u32) {
        self.game_server_account_id = ::std::option::Option::Some(v);
    }

    // optional string game_server_identity_token = 3;

    pub fn game_server_identity_token(&self) -> &str {
        match self.game_server_identity_token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_server_identity_token(&mut self) {
        self.game_server_identity_token = ::std::option::Option::None;
    }

    pub fn has_game_server_identity_token(&self) -> bool {
        self.game_server_identity_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_identity_token(&mut self, v: ::std::string::String) {
        self.game_server_identity_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_server_identity_token(&mut self) -> &mut ::std::string::String {
        if self.game_server_identity_token.is_none() {
            self.game_server_identity_token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_server_identity_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_server_identity_token(&mut self) -> ::std::string::String {
        self.game_server_identity_token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_server_identity_token_reset",
            |m: &CMsgGC_GameServer_ResetIdentityResponse| { &m.game_server_identity_token_reset },
            |m: &mut CMsgGC_GameServer_ResetIdentityResponse| { &mut m.game_server_identity_token_reset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_server_account_id",
            |m: &CMsgGC_GameServer_ResetIdentityResponse| { &m.game_server_account_id },
            |m: &mut CMsgGC_GameServer_ResetIdentityResponse| { &mut m.game_server_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_server_identity_token",
            |m: &CMsgGC_GameServer_ResetIdentityResponse| { &m.game_server_identity_token },
            |m: &mut CMsgGC_GameServer_ResetIdentityResponse| { &mut m.game_server_identity_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_GameServer_ResetIdentityResponse>(
            "CMsgGC_GameServer_ResetIdentityResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_GameServer_ResetIdentityResponse {
    const NAME: &'static str = "CMsgGC_GameServer_ResetIdentityResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.game_server_identity_token_reset = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.game_server_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.game_server_identity_token = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_server_identity_token_reset {
            my_size += 1 + 1;
        }
        if let Some(v) = self.game_server_account_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.game_server_identity_token.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.game_server_identity_token_reset {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.game_server_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.game_server_identity_token.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_GameServer_ResetIdentityResponse {
        CMsgGC_GameServer_ResetIdentityResponse::new()
    }

    fn clear(&mut self) {
        self.game_server_identity_token_reset = ::std::option::Option::None;
        self.game_server_account_id = ::std::option::Option::None;
        self.game_server_identity_token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_GameServer_ResetIdentityResponse {
        static instance: CMsgGC_GameServer_ResetIdentityResponse = CMsgGC_GameServer_ResetIdentityResponse {
            game_server_identity_token_reset: ::std::option::Option::None,
            game_server_account_id: ::std::option::Option::None,
            game_server_identity_token: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_GameServer_ResetIdentityResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_GameServer_ResetIdentityResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_GameServer_ResetIdentityResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GameServer_ResetIdentityResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGC_GameServer_AckPolicy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_GameServer_AckPolicy {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_GameServer_AckPolicy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_AckPolicy {
    fn default() -> &'a CMsgGC_GameServer_AckPolicy {
        <CMsgGC_GameServer_AckPolicy as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_AckPolicy {
    pub fn new() -> CMsgGC_GameServer_AckPolicy {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_GameServer_AckPolicy>(
            "CMsgGC_GameServer_AckPolicy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_GameServer_AckPolicy {
    const NAME: &'static str = "CMsgGC_GameServer_AckPolicy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_GameServer_AckPolicy {
        CMsgGC_GameServer_AckPolicy::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_GameServer_AckPolicy {
        static instance: CMsgGC_GameServer_AckPolicy = CMsgGC_GameServer_AckPolicy {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_GameServer_AckPolicy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_GameServer_AckPolicy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_GameServer_AckPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GameServer_AckPolicy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGC_GameServer_AckPolicyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_GameServer_AckPolicyResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_GameServer_AckPolicyResponse.result)
    pub result: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGC_GameServer_AckPolicyResponse.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_GameServer_AckPolicyResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_AckPolicyResponse {
    fn default() -> &'a CMsgGC_GameServer_AckPolicyResponse {
        <CMsgGC_GameServer_AckPolicyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_AckPolicyResponse {
    pub fn new() -> CMsgGC_GameServer_AckPolicyResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional string message = 2;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgGC_GameServer_AckPolicyResponse| { &m.result },
            |m: &mut CMsgGC_GameServer_AckPolicyResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &CMsgGC_GameServer_AckPolicyResponse| { &m.message },
            |m: &mut CMsgGC_GameServer_AckPolicyResponse| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_GameServer_AckPolicyResponse>(
            "CMsgGC_GameServer_AckPolicyResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_GameServer_AckPolicyResponse {
    const NAME: &'static str = "CMsgGC_GameServer_AckPolicyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_GameServer_AckPolicyResponse {
        CMsgGC_GameServer_AckPolicyResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_GameServer_AckPolicyResponse {
        static instance: CMsgGC_GameServer_AckPolicyResponse = CMsgGC_GameServer_AckPolicyResponse {
            result: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_GameServer_AckPolicyResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_GameServer_AckPolicyResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_GameServer_AckPolicyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GameServer_AckPolicyResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGC_Client_UseServerModificationItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_Client_UseServerModificationItem {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_Client_UseServerModificationItem.item_id)
    pub item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_Client_UseServerModificationItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_Client_UseServerModificationItem {
    fn default() -> &'a CMsgGC_Client_UseServerModificationItem {
        <CMsgGC_Client_UseServerModificationItem as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_Client_UseServerModificationItem {
    pub fn new() -> CMsgGC_Client_UseServerModificationItem {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgGC_Client_UseServerModificationItem| { &m.item_id },
            |m: &mut CMsgGC_Client_UseServerModificationItem| { &mut m.item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_Client_UseServerModificationItem>(
            "CMsgGC_Client_UseServerModificationItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_Client_UseServerModificationItem {
    const NAME: &'static str = "CMsgGC_Client_UseServerModificationItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_Client_UseServerModificationItem {
        CMsgGC_Client_UseServerModificationItem::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_Client_UseServerModificationItem {
        static instance: CMsgGC_Client_UseServerModificationItem = CMsgGC_Client_UseServerModificationItem {
            item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_Client_UseServerModificationItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_Client_UseServerModificationItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_Client_UseServerModificationItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_Client_UseServerModificationItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGC_Client_UseServerModificationItem_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_Client_UseServerModificationItem_Response {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_Client_UseServerModificationItem_Response.response_code)
    pub response_code: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_gc_client_use_server_modification_item_response::EServerModificationItemResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_Client_UseServerModificationItem_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_Client_UseServerModificationItem_Response {
    fn default() -> &'a CMsgGC_Client_UseServerModificationItem_Response {
        <CMsgGC_Client_UseServerModificationItem_Response as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_Client_UseServerModificationItem_Response {
    pub fn new() -> CMsgGC_Client_UseServerModificationItem_Response {
        ::std::default::Default::default()
    }

    // optional .CMsgGC_Client_UseServerModificationItem_Response.EServerModificationItemResponse response_code = 1;

    pub fn response_code(&self) -> cmsg_gc_client_use_server_modification_item_response::EServerModificationItemResponse {
        match self.response_code {
            Some(e) => e.enum_value_or(cmsg_gc_client_use_server_modification_item_response::EServerModificationItemResponse::kServerModificationItemResponse_AlreadyInUse),
            None => cmsg_gc_client_use_server_modification_item_response::EServerModificationItemResponse::kServerModificationItemResponse_AlreadyInUse,
        }
    }

    pub fn clear_response_code(&mut self) {
        self.response_code = ::std::option::Option::None;
    }

    pub fn has_response_code(&self) -> bool {
        self.response_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response_code(&mut self, v: cmsg_gc_client_use_server_modification_item_response::EServerModificationItemResponse) {
        self.response_code = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response_code",
            |m: &CMsgGC_Client_UseServerModificationItem_Response| { &m.response_code },
            |m: &mut CMsgGC_Client_UseServerModificationItem_Response| { &mut m.response_code },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_Client_UseServerModificationItem_Response>(
            "CMsgGC_Client_UseServerModificationItem_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_Client_UseServerModificationItem_Response {
    const NAME: &'static str = "CMsgGC_Client_UseServerModificationItem_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response_code = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response_code {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.response_code {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_Client_UseServerModificationItem_Response {
        CMsgGC_Client_UseServerModificationItem_Response::new()
    }

    fn clear(&mut self) {
        self.response_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_Client_UseServerModificationItem_Response {
        static instance: CMsgGC_Client_UseServerModificationItem_Response = CMsgGC_Client_UseServerModificationItem_Response {
            response_code: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_Client_UseServerModificationItem_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_Client_UseServerModificationItem_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_Client_UseServerModificationItem_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_Client_UseServerModificationItem_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGC_Client_UseServerModificationItem_Response`
pub mod cmsg_gc_client_use_server_modification_item_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGC_Client_UseServerModificationItem_Response.EServerModificationItemResponse)
    pub enum EServerModificationItemResponse {
        // @@protoc_insertion_point(enum_value:CMsgGC_Client_UseServerModificationItem_Response.EServerModificationItemResponse.kServerModificationItemResponse_AlreadyInUse)
        kServerModificationItemResponse_AlreadyInUse = 1,
        // @@protoc_insertion_point(enum_value:CMsgGC_Client_UseServerModificationItem_Response.EServerModificationItemResponse.kServerModificationItemResponse_NotOnAuthenticatedServer)
        kServerModificationItemResponse_NotOnAuthenticatedServer = 2,
        // @@protoc_insertion_point(enum_value:CMsgGC_Client_UseServerModificationItem_Response.EServerModificationItemResponse.kServerModificationItemResponse_ServerReject)
        kServerModificationItemResponse_ServerReject = 3,
        // @@protoc_insertion_point(enum_value:CMsgGC_Client_UseServerModificationItem_Response.EServerModificationItemResponse.kServerModificationItemResponse_InternalError)
        kServerModificationItemResponse_InternalError = 4,
        // @@protoc_insertion_point(enum_value:CMsgGC_Client_UseServerModificationItem_Response.EServerModificationItemResponse.kServerModificationItemResponse_EventAlreadyActive)
        kServerModificationItemResponse_EventAlreadyActive = 5,
    }

    impl ::protobuf::Enum for EServerModificationItemResponse {
        const NAME: &'static str = "EServerModificationItemResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EServerModificationItemResponse> {
            match value {
                1 => ::std::option::Option::Some(EServerModificationItemResponse::kServerModificationItemResponse_AlreadyInUse),
                2 => ::std::option::Option::Some(EServerModificationItemResponse::kServerModificationItemResponse_NotOnAuthenticatedServer),
                3 => ::std::option::Option::Some(EServerModificationItemResponse::kServerModificationItemResponse_ServerReject),
                4 => ::std::option::Option::Some(EServerModificationItemResponse::kServerModificationItemResponse_InternalError),
                5 => ::std::option::Option::Some(EServerModificationItemResponse::kServerModificationItemResponse_EventAlreadyActive),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EServerModificationItemResponse> {
            match str {
                "kServerModificationItemResponse_AlreadyInUse" => ::std::option::Option::Some(EServerModificationItemResponse::kServerModificationItemResponse_AlreadyInUse),
                "kServerModificationItemResponse_NotOnAuthenticatedServer" => ::std::option::Option::Some(EServerModificationItemResponse::kServerModificationItemResponse_NotOnAuthenticatedServer),
                "kServerModificationItemResponse_ServerReject" => ::std::option::Option::Some(EServerModificationItemResponse::kServerModificationItemResponse_ServerReject),
                "kServerModificationItemResponse_InternalError" => ::std::option::Option::Some(EServerModificationItemResponse::kServerModificationItemResponse_InternalError),
                "kServerModificationItemResponse_EventAlreadyActive" => ::std::option::Option::Some(EServerModificationItemResponse::kServerModificationItemResponse_EventAlreadyActive),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EServerModificationItemResponse] = &[
            EServerModificationItemResponse::kServerModificationItemResponse_AlreadyInUse,
            EServerModificationItemResponse::kServerModificationItemResponse_NotOnAuthenticatedServer,
            EServerModificationItemResponse::kServerModificationItemResponse_ServerReject,
            EServerModificationItemResponse::kServerModificationItemResponse_InternalError,
            EServerModificationItemResponse::kServerModificationItemResponse_EventAlreadyActive,
        ];
    }

    impl ::protobuf::EnumFull for EServerModificationItemResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgGC_Client_UseServerModificationItem_Response.EServerModificationItemResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                EServerModificationItemResponse::kServerModificationItemResponse_AlreadyInUse => 0,
                EServerModificationItemResponse::kServerModificationItemResponse_NotOnAuthenticatedServer => 1,
                EServerModificationItemResponse::kServerModificationItemResponse_ServerReject => 2,
                EServerModificationItemResponse::kServerModificationItemResponse_InternalError => 3,
                EServerModificationItemResponse::kServerModificationItemResponse_EventAlreadyActive => 4,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for EServerModificationItemResponse {
        fn default() -> Self {
            EServerModificationItemResponse::kServerModificationItemResponse_AlreadyInUse
        }
    }

    impl EServerModificationItemResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EServerModificationItemResponse>("CMsgGC_Client_UseServerModificationItem_Response.EServerModificationItemResponse")
        }
    }
}

// @@protoc_insertion_point(message:CMsgGC_GameServer_UseServerModificationItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_GameServer_UseServerModificationItem {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_GameServer_UseServerModificationItem.modification_type)
    pub modification_type: ::std::option::Option<::protobuf::EnumOrUnknown<EServerModificationItemType>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_GameServer_UseServerModificationItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_UseServerModificationItem {
    fn default() -> &'a CMsgGC_GameServer_UseServerModificationItem {
        <CMsgGC_GameServer_UseServerModificationItem as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_UseServerModificationItem {
    pub fn new() -> CMsgGC_GameServer_UseServerModificationItem {
        ::std::default::Default::default()
    }

    // optional .EServerModificationItemType modification_type = 1;

    pub fn modification_type(&self) -> EServerModificationItemType {
        match self.modification_type {
            Some(e) => e.enum_value_or(EServerModificationItemType::kGameServerModificationItem_Halloween),
            None => EServerModificationItemType::kGameServerModificationItem_Halloween,
        }
    }

    pub fn clear_modification_type(&mut self) {
        self.modification_type = ::std::option::Option::None;
    }

    pub fn has_modification_type(&self) -> bool {
        self.modification_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modification_type(&mut self, v: EServerModificationItemType) {
        self.modification_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "modification_type",
            |m: &CMsgGC_GameServer_UseServerModificationItem| { &m.modification_type },
            |m: &mut CMsgGC_GameServer_UseServerModificationItem| { &mut m.modification_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_GameServer_UseServerModificationItem>(
            "CMsgGC_GameServer_UseServerModificationItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_GameServer_UseServerModificationItem {
    const NAME: &'static str = "CMsgGC_GameServer_UseServerModificationItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.modification_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.modification_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.modification_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_GameServer_UseServerModificationItem {
        CMsgGC_GameServer_UseServerModificationItem::new()
    }

    fn clear(&mut self) {
        self.modification_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_GameServer_UseServerModificationItem {
        static instance: CMsgGC_GameServer_UseServerModificationItem = CMsgGC_GameServer_UseServerModificationItem {
            modification_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_GameServer_UseServerModificationItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_GameServer_UseServerModificationItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_GameServer_UseServerModificationItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GameServer_UseServerModificationItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGC_GameServer_UseServerModificationItem_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_GameServer_UseServerModificationItem_Response {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_GameServer_UseServerModificationItem_Response.modification_type)
    pub modification_type: ::std::option::Option<::protobuf::EnumOrUnknown<EServerModificationItemType>>,
    // @@protoc_insertion_point(field:CMsgGC_GameServer_UseServerModificationItem_Response.server_response_code)
    pub server_response_code: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_gc_game_server_use_server_modification_item_response::EServerModificationItemServerResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_GameServer_UseServerModificationItem_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_UseServerModificationItem_Response {
    fn default() -> &'a CMsgGC_GameServer_UseServerModificationItem_Response {
        <CMsgGC_GameServer_UseServerModificationItem_Response as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_UseServerModificationItem_Response {
    pub fn new() -> CMsgGC_GameServer_UseServerModificationItem_Response {
        ::std::default::Default::default()
    }

    // optional .EServerModificationItemType modification_type = 1;

    pub fn modification_type(&self) -> EServerModificationItemType {
        match self.modification_type {
            Some(e) => e.enum_value_or(EServerModificationItemType::kGameServerModificationItem_Halloween),
            None => EServerModificationItemType::kGameServerModificationItem_Halloween,
        }
    }

    pub fn clear_modification_type(&mut self) {
        self.modification_type = ::std::option::Option::None;
    }

    pub fn has_modification_type(&self) -> bool {
        self.modification_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modification_type(&mut self, v: EServerModificationItemType) {
        self.modification_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .CMsgGC_GameServer_UseServerModificationItem_Response.EServerModificationItemServerResponse server_response_code = 2;

    pub fn server_response_code(&self) -> cmsg_gc_game_server_use_server_modification_item_response::EServerModificationItemServerResponse {
        match self.server_response_code {
            Some(e) => e.enum_value_or(cmsg_gc_game_server_use_server_modification_item_response::EServerModificationItemServerResponse::kServerModificationItemServerResponse_Accepted),
            None => cmsg_gc_game_server_use_server_modification_item_response::EServerModificationItemServerResponse::kServerModificationItemServerResponse_Accepted,
        }
    }

    pub fn clear_server_response_code(&mut self) {
        self.server_response_code = ::std::option::Option::None;
    }

    pub fn has_server_response_code(&self) -> bool {
        self.server_response_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_response_code(&mut self, v: cmsg_gc_game_server_use_server_modification_item_response::EServerModificationItemServerResponse) {
        self.server_response_code = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "modification_type",
            |m: &CMsgGC_GameServer_UseServerModificationItem_Response| { &m.modification_type },
            |m: &mut CMsgGC_GameServer_UseServerModificationItem_Response| { &mut m.modification_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_response_code",
            |m: &CMsgGC_GameServer_UseServerModificationItem_Response| { &m.server_response_code },
            |m: &mut CMsgGC_GameServer_UseServerModificationItem_Response| { &mut m.server_response_code },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_GameServer_UseServerModificationItem_Response>(
            "CMsgGC_GameServer_UseServerModificationItem_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_GameServer_UseServerModificationItem_Response {
    const NAME: &'static str = "CMsgGC_GameServer_UseServerModificationItem_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.modification_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.server_response_code = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.modification_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.server_response_code {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.modification_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.server_response_code {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_GameServer_UseServerModificationItem_Response {
        CMsgGC_GameServer_UseServerModificationItem_Response::new()
    }

    fn clear(&mut self) {
        self.modification_type = ::std::option::Option::None;
        self.server_response_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_GameServer_UseServerModificationItem_Response {
        static instance: CMsgGC_GameServer_UseServerModificationItem_Response = CMsgGC_GameServer_UseServerModificationItem_Response {
            modification_type: ::std::option::Option::None,
            server_response_code: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_GameServer_UseServerModificationItem_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_GameServer_UseServerModificationItem_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_GameServer_UseServerModificationItem_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GameServer_UseServerModificationItem_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGC_GameServer_UseServerModificationItem_Response`
pub mod cmsg_gc_game_server_use_server_modification_item_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGC_GameServer_UseServerModificationItem_Response.EServerModificationItemServerResponse)
    pub enum EServerModificationItemServerResponse {
        // @@protoc_insertion_point(enum_value:CMsgGC_GameServer_UseServerModificationItem_Response.EServerModificationItemServerResponse.kServerModificationItemServerResponse_Accepted)
        kServerModificationItemServerResponse_Accepted = 1,
        // @@protoc_insertion_point(enum_value:CMsgGC_GameServer_UseServerModificationItem_Response.EServerModificationItemServerResponse.kServerModificationItemServerResponse_NoVoteCalled)
        kServerModificationItemServerResponse_NoVoteCalled = 2,
        // @@protoc_insertion_point(enum_value:CMsgGC_GameServer_UseServerModificationItem_Response.EServerModificationItemServerResponse.kServerModificationItemServerResponse_VoteFailed)
        kServerModificationItemServerResponse_VoteFailed = 3,
    }

    impl ::protobuf::Enum for EServerModificationItemServerResponse {
        const NAME: &'static str = "EServerModificationItemServerResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EServerModificationItemServerResponse> {
            match value {
                1 => ::std::option::Option::Some(EServerModificationItemServerResponse::kServerModificationItemServerResponse_Accepted),
                2 => ::std::option::Option::Some(EServerModificationItemServerResponse::kServerModificationItemServerResponse_NoVoteCalled),
                3 => ::std::option::Option::Some(EServerModificationItemServerResponse::kServerModificationItemServerResponse_VoteFailed),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EServerModificationItemServerResponse> {
            match str {
                "kServerModificationItemServerResponse_Accepted" => ::std::option::Option::Some(EServerModificationItemServerResponse::kServerModificationItemServerResponse_Accepted),
                "kServerModificationItemServerResponse_NoVoteCalled" => ::std::option::Option::Some(EServerModificationItemServerResponse::kServerModificationItemServerResponse_NoVoteCalled),
                "kServerModificationItemServerResponse_VoteFailed" => ::std::option::Option::Some(EServerModificationItemServerResponse::kServerModificationItemServerResponse_VoteFailed),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EServerModificationItemServerResponse] = &[
            EServerModificationItemServerResponse::kServerModificationItemServerResponse_Accepted,
            EServerModificationItemServerResponse::kServerModificationItemServerResponse_NoVoteCalled,
            EServerModificationItemServerResponse::kServerModificationItemServerResponse_VoteFailed,
        ];
    }

    impl ::protobuf::EnumFull for EServerModificationItemServerResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgGC_GameServer_UseServerModificationItem_Response.EServerModificationItemServerResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                EServerModificationItemServerResponse::kServerModificationItemServerResponse_Accepted => 0,
                EServerModificationItemServerResponse::kServerModificationItemServerResponse_NoVoteCalled => 1,
                EServerModificationItemServerResponse::kServerModificationItemServerResponse_VoteFailed => 2,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for EServerModificationItemServerResponse {
        fn default() -> Self {
            EServerModificationItemServerResponse::kServerModificationItemServerResponse_Accepted
        }
    }

    impl EServerModificationItemServerResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EServerModificationItemServerResponse>("CMsgGC_GameServer_UseServerModificationItem_Response.EServerModificationItemServerResponse")
        }
    }
}

// @@protoc_insertion_point(message:CMsgGC_GameServer_ServerModificationItemExpired)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_GameServer_ServerModificationItemExpired {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_GameServer_ServerModificationItemExpired.modification_type)
    pub modification_type: ::std::option::Option<::protobuf::EnumOrUnknown<EServerModificationItemType>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_GameServer_ServerModificationItemExpired.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_ServerModificationItemExpired {
    fn default() -> &'a CMsgGC_GameServer_ServerModificationItemExpired {
        <CMsgGC_GameServer_ServerModificationItemExpired as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_ServerModificationItemExpired {
    pub fn new() -> CMsgGC_GameServer_ServerModificationItemExpired {
        ::std::default::Default::default()
    }

    // optional .EServerModificationItemType modification_type = 1;

    pub fn modification_type(&self) -> EServerModificationItemType {
        match self.modification_type {
            Some(e) => e.enum_value_or(EServerModificationItemType::kGameServerModificationItem_Halloween),
            None => EServerModificationItemType::kGameServerModificationItem_Halloween,
        }
    }

    pub fn clear_modification_type(&mut self) {
        self.modification_type = ::std::option::Option::None;
    }

    pub fn has_modification_type(&self) -> bool {
        self.modification_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modification_type(&mut self, v: EServerModificationItemType) {
        self.modification_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "modification_type",
            |m: &CMsgGC_GameServer_ServerModificationItemExpired| { &m.modification_type },
            |m: &mut CMsgGC_GameServer_ServerModificationItemExpired| { &mut m.modification_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_GameServer_ServerModificationItemExpired>(
            "CMsgGC_GameServer_ServerModificationItemExpired",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_GameServer_ServerModificationItemExpired {
    const NAME: &'static str = "CMsgGC_GameServer_ServerModificationItemExpired";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.modification_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.modification_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.modification_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_GameServer_ServerModificationItemExpired {
        CMsgGC_GameServer_ServerModificationItemExpired::new()
    }

    fn clear(&mut self) {
        self.modification_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_GameServer_ServerModificationItemExpired {
        static instance: CMsgGC_GameServer_ServerModificationItemExpired = CMsgGC_GameServer_ServerModificationItemExpired {
            modification_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_GameServer_ServerModificationItemExpired {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_GameServer_ServerModificationItemExpired").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_GameServer_ServerModificationItemExpired {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GameServer_ServerModificationItemExpired {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGC_GameServer_ServerModificationItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_GameServer_ServerModificationItem {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_GameServer_ServerModificationItem.modification_type)
    pub modification_type: ::std::option::Option<::protobuf::EnumOrUnknown<EServerModificationItemType>>,
    // @@protoc_insertion_point(field:CMsgGC_GameServer_ServerModificationItem.active)
    pub active: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_GameServer_ServerModificationItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_ServerModificationItem {
    fn default() -> &'a CMsgGC_GameServer_ServerModificationItem {
        <CMsgGC_GameServer_ServerModificationItem as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_ServerModificationItem {
    pub fn new() -> CMsgGC_GameServer_ServerModificationItem {
        ::std::default::Default::default()
    }

    // optional .EServerModificationItemType modification_type = 1;

    pub fn modification_type(&self) -> EServerModificationItemType {
        match self.modification_type {
            Some(e) => e.enum_value_or(EServerModificationItemType::kGameServerModificationItem_Halloween),
            None => EServerModificationItemType::kGameServerModificationItem_Halloween,
        }
    }

    pub fn clear_modification_type(&mut self) {
        self.modification_type = ::std::option::Option::None;
    }

    pub fn has_modification_type(&self) -> bool {
        self.modification_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modification_type(&mut self, v: EServerModificationItemType) {
        self.modification_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool active = 2;

    pub fn active(&self) -> bool {
        self.active.unwrap_or(false)
    }

    pub fn clear_active(&mut self) {
        self.active = ::std::option::Option::None;
    }

    pub fn has_active(&self) -> bool {
        self.active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active(&mut self, v: bool) {
        self.active = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "modification_type",
            |m: &CMsgGC_GameServer_ServerModificationItem| { &m.modification_type },
            |m: &mut CMsgGC_GameServer_ServerModificationItem| { &mut m.modification_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "active",
            |m: &CMsgGC_GameServer_ServerModificationItem| { &m.active },
            |m: &mut CMsgGC_GameServer_ServerModificationItem| { &mut m.active },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_GameServer_ServerModificationItem>(
            "CMsgGC_GameServer_ServerModificationItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_GameServer_ServerModificationItem {
    const NAME: &'static str = "CMsgGC_GameServer_ServerModificationItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.modification_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.active = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.modification_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.active {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.modification_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.active {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_GameServer_ServerModificationItem {
        CMsgGC_GameServer_ServerModificationItem::new()
    }

    fn clear(&mut self) {
        self.modification_type = ::std::option::Option::None;
        self.active = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_GameServer_ServerModificationItem {
        static instance: CMsgGC_GameServer_ServerModificationItem = CMsgGC_GameServer_ServerModificationItem {
            modification_type: ::std::option::Option::None,
            active: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_GameServer_ServerModificationItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_GameServer_ServerModificationItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_GameServer_ServerModificationItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GameServer_ServerModificationItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGC_Halloween_ReservedItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_Halloween_ReservedItem {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_Halloween_ReservedItem.x)
    pub x: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CMsgGC_Halloween_ReservedItem.y)
    pub y: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CMsgGC_Halloween_ReservedItem.z)
    pub z: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CMsgGC_Halloween_ReservedItem.spawn_meta_info)
    pub spawn_meta_info: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_Halloween_ReservedItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_Halloween_ReservedItem {
    fn default() -> &'a CMsgGC_Halloween_ReservedItem {
        <CMsgGC_Halloween_ReservedItem as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_Halloween_ReservedItem {
    pub fn new() -> CMsgGC_Halloween_ReservedItem {
        ::std::default::Default::default()
    }

    // optional uint32 spawn_meta_info = 7;

    pub fn spawn_meta_info(&self) -> u32 {
        self.spawn_meta_info.unwrap_or(0)
    }

    pub fn clear_spawn_meta_info(&mut self) {
        self.spawn_meta_info = ::std::option::Option::None;
    }

    pub fn has_spawn_meta_info(&self) -> bool {
        self.spawn_meta_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spawn_meta_info(&mut self, v: u32) {
        self.spawn_meta_info = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "x",
            |m: &CMsgGC_Halloween_ReservedItem| { &m.x },
            |m: &mut CMsgGC_Halloween_ReservedItem| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "y",
            |m: &CMsgGC_Halloween_ReservedItem| { &m.y },
            |m: &mut CMsgGC_Halloween_ReservedItem| { &mut m.y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "z",
            |m: &CMsgGC_Halloween_ReservedItem| { &m.z },
            |m: &mut CMsgGC_Halloween_ReservedItem| { &mut m.z },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "spawn_meta_info",
            |m: &CMsgGC_Halloween_ReservedItem| { &m.spawn_meta_info },
            |m: &mut CMsgGC_Halloween_ReservedItem| { &mut m.spawn_meta_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_Halloween_ReservedItem>(
            "CMsgGC_Halloween_ReservedItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_Halloween_ReservedItem {
    const NAME: &'static str = "CMsgGC_Halloween_ReservedItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_float_into(&mut self.x)?;
                },
                13 => {
                    self.x.push(is.read_float()?);
                },
                18 => {
                    is.read_repeated_packed_float_into(&mut self.y)?;
                },
                21 => {
                    self.y.push(is.read_float()?);
                },
                26 => {
                    is.read_repeated_packed_float_into(&mut self.z)?;
                },
                29 => {
                    self.z.push(is.read_float()?);
                },
                56 => {
                    self.spawn_meta_info = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 5 * self.x.len() as u64;
        my_size += 5 * self.y.len() as u64;
        my_size += 5 * self.z.len() as u64;
        if let Some(v) = self.spawn_meta_info {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.x {
            os.write_float(1, *v)?;
        };
        for v in &self.y {
            os.write_float(2, *v)?;
        };
        for v in &self.z {
            os.write_float(3, *v)?;
        };
        if let Some(v) = self.spawn_meta_info {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_Halloween_ReservedItem {
        CMsgGC_Halloween_ReservedItem::new()
    }

    fn clear(&mut self) {
        self.x.clear();
        self.y.clear();
        self.z.clear();
        self.spawn_meta_info = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_Halloween_ReservedItem {
        static instance: CMsgGC_Halloween_ReservedItem = CMsgGC_Halloween_ReservedItem {
            x: ::std::vec::Vec::new(),
            y: ::std::vec::Vec::new(),
            z: ::std::vec::Vec::new(),
            spawn_meta_info: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_Halloween_ReservedItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_Halloween_ReservedItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_Halloween_ReservedItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_Halloween_ReservedItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGC_Halloween_GrantItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_Halloween_GrantItem {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_Halloween_GrantItem.recipient_account_id)
    pub recipient_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGC_Halloween_GrantItem.level_id)
    pub level_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGC_Halloween_GrantItem.flagged)
    pub flagged: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_Halloween_GrantItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_Halloween_GrantItem {
    fn default() -> &'a CMsgGC_Halloween_GrantItem {
        <CMsgGC_Halloween_GrantItem as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_Halloween_GrantItem {
    pub fn new() -> CMsgGC_Halloween_GrantItem {
        ::std::default::Default::default()
    }

    // optional uint32 recipient_account_id = 1;

    pub fn recipient_account_id(&self) -> u32 {
        self.recipient_account_id.unwrap_or(0)
    }

    pub fn clear_recipient_account_id(&mut self) {
        self.recipient_account_id = ::std::option::Option::None;
    }

    pub fn has_recipient_account_id(&self) -> bool {
        self.recipient_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipient_account_id(&mut self, v: u32) {
        self.recipient_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 level_id = 2;

    pub fn level_id(&self) -> u32 {
        self.level_id.unwrap_or(0)
    }

    pub fn clear_level_id(&mut self) {
        self.level_id = ::std::option::Option::None;
    }

    pub fn has_level_id(&self) -> bool {
        self.level_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level_id(&mut self, v: u32) {
        self.level_id = ::std::option::Option::Some(v);
    }

    // optional bool flagged = 3;

    pub fn flagged(&self) -> bool {
        self.flagged.unwrap_or(false)
    }

    pub fn clear_flagged(&mut self) {
        self.flagged = ::std::option::Option::None;
    }

    pub fn has_flagged(&self) -> bool {
        self.flagged.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flagged(&mut self, v: bool) {
        self.flagged = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recipient_account_id",
            |m: &CMsgGC_Halloween_GrantItem| { &m.recipient_account_id },
            |m: &mut CMsgGC_Halloween_GrantItem| { &mut m.recipient_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "level_id",
            |m: &CMsgGC_Halloween_GrantItem| { &m.level_id },
            |m: &mut CMsgGC_Halloween_GrantItem| { &mut m.level_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flagged",
            |m: &CMsgGC_Halloween_GrantItem| { &m.flagged },
            |m: &mut CMsgGC_Halloween_GrantItem| { &mut m.flagged },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_Halloween_GrantItem>(
            "CMsgGC_Halloween_GrantItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_Halloween_GrantItem {
    const NAME: &'static str = "CMsgGC_Halloween_GrantItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.recipient_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.level_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.flagged = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.recipient_account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.level_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.flagged {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.recipient_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.level_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.flagged {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_Halloween_GrantItem {
        CMsgGC_Halloween_GrantItem::new()
    }

    fn clear(&mut self) {
        self.recipient_account_id = ::std::option::Option::None;
        self.level_id = ::std::option::Option::None;
        self.flagged = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_Halloween_GrantItem {
        static instance: CMsgGC_Halloween_GrantItem = CMsgGC_Halloween_GrantItem {
            recipient_account_id: ::std::option::Option::None,
            level_id: ::std::option::Option::None,
            flagged: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_Halloween_GrantItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_Halloween_GrantItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_Halloween_GrantItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_Halloween_GrantItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGC_Halloween_GrantItemResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_Halloween_GrantItemResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_Halloween_GrantItemResponse.recipient_account_id)
    pub recipient_account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_Halloween_GrantItemResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_Halloween_GrantItemResponse {
    fn default() -> &'a CMsgGC_Halloween_GrantItemResponse {
        <CMsgGC_Halloween_GrantItemResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_Halloween_GrantItemResponse {
    pub fn new() -> CMsgGC_Halloween_GrantItemResponse {
        ::std::default::Default::default()
    }

    // optional uint32 recipient_account_id = 1;

    pub fn recipient_account_id(&self) -> u32 {
        self.recipient_account_id.unwrap_or(0)
    }

    pub fn clear_recipient_account_id(&mut self) {
        self.recipient_account_id = ::std::option::Option::None;
    }

    pub fn has_recipient_account_id(&self) -> bool {
        self.recipient_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipient_account_id(&mut self, v: u32) {
        self.recipient_account_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recipient_account_id",
            |m: &CMsgGC_Halloween_GrantItemResponse| { &m.recipient_account_id },
            |m: &mut CMsgGC_Halloween_GrantItemResponse| { &mut m.recipient_account_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_Halloween_GrantItemResponse>(
            "CMsgGC_Halloween_GrantItemResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_Halloween_GrantItemResponse {
    const NAME: &'static str = "CMsgGC_Halloween_GrantItemResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.recipient_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.recipient_account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.recipient_account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_Halloween_GrantItemResponse {
        CMsgGC_Halloween_GrantItemResponse::new()
    }

    fn clear(&mut self) {
        self.recipient_account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_Halloween_GrantItemResponse {
        static instance: CMsgGC_Halloween_GrantItemResponse = CMsgGC_Halloween_GrantItemResponse {
            recipient_account_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_Halloween_GrantItemResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_Halloween_GrantItemResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_Halloween_GrantItemResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_Halloween_GrantItemResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGC_Halloween_ItemClaimed)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_Halloween_ItemClaimed {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_Halloween_ItemClaimed.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_Halloween_ItemClaimed {
    fn default() -> &'a CMsgGC_Halloween_ItemClaimed {
        <CMsgGC_Halloween_ItemClaimed as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_Halloween_ItemClaimed {
    pub fn new() -> CMsgGC_Halloween_ItemClaimed {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_Halloween_ItemClaimed>(
            "CMsgGC_Halloween_ItemClaimed",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_Halloween_ItemClaimed {
    const NAME: &'static str = "CMsgGC_Halloween_ItemClaimed";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_Halloween_ItemClaimed {
        CMsgGC_Halloween_ItemClaimed::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_Halloween_ItemClaimed {
        static instance: CMsgGC_Halloween_ItemClaimed = CMsgGC_Halloween_ItemClaimed {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_Halloween_ItemClaimed {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_Halloween_ItemClaimed").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_Halloween_ItemClaimed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_Halloween_ItemClaimed {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGC_PickupItemEligibility_Query)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_PickupItemEligibility_Query {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_PickupItemEligibility_Query.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGC_PickupItemEligibility_Query.seconds_ago)
    pub seconds_ago: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_PickupItemEligibility_Query.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_PickupItemEligibility_Query {
    fn default() -> &'a CMsgGC_PickupItemEligibility_Query {
        <CMsgGC_PickupItemEligibility_Query as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_PickupItemEligibility_Query {
    pub fn new() -> CMsgGC_PickupItemEligibility_Query {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_ago = 2;

    pub fn seconds_ago(&self) -> u32 {
        self.seconds_ago.unwrap_or(0)
    }

    pub fn clear_seconds_ago(&mut self) {
        self.seconds_ago = ::std::option::Option::None;
    }

    pub fn has_seconds_ago(&self) -> bool {
        self.seconds_ago.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_ago(&mut self, v: u32) {
        self.seconds_ago = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGC_PickupItemEligibility_Query| { &m.account_id },
            |m: &mut CMsgGC_PickupItemEligibility_Query| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds_ago",
            |m: &CMsgGC_PickupItemEligibility_Query| { &m.seconds_ago },
            |m: &mut CMsgGC_PickupItemEligibility_Query| { &mut m.seconds_ago },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_PickupItemEligibility_Query>(
            "CMsgGC_PickupItemEligibility_Query",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_PickupItemEligibility_Query {
    const NAME: &'static str = "CMsgGC_PickupItemEligibility_Query";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.seconds_ago = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.seconds_ago {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.seconds_ago {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_PickupItemEligibility_Query {
        CMsgGC_PickupItemEligibility_Query::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.seconds_ago = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_PickupItemEligibility_Query {
        static instance: CMsgGC_PickupItemEligibility_Query = CMsgGC_PickupItemEligibility_Query {
            account_id: ::std::option::Option::None,
            seconds_ago: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_PickupItemEligibility_Query {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_PickupItemEligibility_Query").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_PickupItemEligibility_Query {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_PickupItemEligibility_Query {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGC_PickupItemEligibility_QueryResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_PickupItemEligibility_QueryResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_PickupItemEligibility_QueryResponse.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGC_PickupItemEligibility_QueryResponse.was_eligible)
    pub was_eligible: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGC_PickupItemEligibility_QueryResponse.level_id)
    pub level_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_PickupItemEligibility_QueryResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_PickupItemEligibility_QueryResponse {
    fn default() -> &'a CMsgGC_PickupItemEligibility_QueryResponse {
        <CMsgGC_PickupItemEligibility_QueryResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_PickupItemEligibility_QueryResponse {
    pub fn new() -> CMsgGC_PickupItemEligibility_QueryResponse {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional bool was_eligible = 2;

    pub fn was_eligible(&self) -> bool {
        self.was_eligible.unwrap_or(false)
    }

    pub fn clear_was_eligible(&mut self) {
        self.was_eligible = ::std::option::Option::None;
    }

    pub fn has_was_eligible(&self) -> bool {
        self.was_eligible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_was_eligible(&mut self, v: bool) {
        self.was_eligible = ::std::option::Option::Some(v);
    }

    // optional uint32 level_id = 3;

    pub fn level_id(&self) -> u32 {
        self.level_id.unwrap_or(0)
    }

    pub fn clear_level_id(&mut self) {
        self.level_id = ::std::option::Option::None;
    }

    pub fn has_level_id(&self) -> bool {
        self.level_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level_id(&mut self, v: u32) {
        self.level_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGC_PickupItemEligibility_QueryResponse| { &m.account_id },
            |m: &mut CMsgGC_PickupItemEligibility_QueryResponse| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "was_eligible",
            |m: &CMsgGC_PickupItemEligibility_QueryResponse| { &m.was_eligible },
            |m: &mut CMsgGC_PickupItemEligibility_QueryResponse| { &mut m.was_eligible },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "level_id",
            |m: &CMsgGC_PickupItemEligibility_QueryResponse| { &m.level_id },
            |m: &mut CMsgGC_PickupItemEligibility_QueryResponse| { &mut m.level_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_PickupItemEligibility_QueryResponse>(
            "CMsgGC_PickupItemEligibility_QueryResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_PickupItemEligibility_QueryResponse {
    const NAME: &'static str = "CMsgGC_PickupItemEligibility_QueryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.was_eligible = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.level_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.was_eligible {
            my_size += 1 + 1;
        }
        if let Some(v) = self.level_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.was_eligible {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.level_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_PickupItemEligibility_QueryResponse {
        CMsgGC_PickupItemEligibility_QueryResponse::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.was_eligible = ::std::option::Option::None;
        self.level_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_PickupItemEligibility_QueryResponse {
        static instance: CMsgGC_PickupItemEligibility_QueryResponse = CMsgGC_PickupItemEligibility_QueryResponse {
            account_id: ::std::option::Option::None,
            was_eligible: ::std::option::Option::None,
            level_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_PickupItemEligibility_QueryResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_PickupItemEligibility_QueryResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_PickupItemEligibility_QueryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_PickupItemEligibility_QueryResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSOTFPartyMember)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOTFPartyMember {
    // message fields
    // @@protoc_insertion_point(field:CSOTFPartyMember.owns_ticket)
    pub owns_ticket: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOTFPartyMember.completed_missions)
    pub completed_missions: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFPartyMember.badge_level)
    pub badge_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFPartyMember.competitive_access)
    pub competitive_access: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOTFPartyMember.experience)
    pub experience: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFPartyMember.player_criteria)
    pub player_criteria: ::protobuf::MessageField<CTFPerPlayerMatchCriteriaProto>,
    // @@protoc_insertion_point(field:CSOTFPartyMember.activity)
    pub activity: ::protobuf::MessageField<csotfparty_member::Activity>,
    // @@protoc_insertion_point(field:CSOTFPartyMember.casual_banned)
    pub casual_banned: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOTFPartyMember.ranked_banned)
    pub ranked_banned: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOTFPartyMember.casual_low_priority)
    pub casual_low_priority: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOTFPartyMember.ranked_low_priority)
    pub ranked_low_priority: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOTFPartyMember.lobby_standby)
    pub lobby_standby: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOTFPartyMember.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOTFPartyMember {
    fn default() -> &'a CSOTFPartyMember {
        <CSOTFPartyMember as ::protobuf::Message>::default_instance()
    }
}

impl CSOTFPartyMember {
    pub fn new() -> CSOTFPartyMember {
        ::std::default::Default::default()
    }

    // optional bool owns_ticket = 2;

    pub fn owns_ticket(&self) -> bool {
        self.owns_ticket.unwrap_or(false)
    }

    pub fn clear_owns_ticket(&mut self) {
        self.owns_ticket = ::std::option::Option::None;
    }

    pub fn has_owns_ticket(&self) -> bool {
        self.owns_ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owns_ticket(&mut self, v: bool) {
        self.owns_ticket = ::std::option::Option::Some(v);
    }

    // optional uint32 completed_missions = 3;

    pub fn completed_missions(&self) -> u32 {
        self.completed_missions.unwrap_or(0)
    }

    pub fn clear_completed_missions(&mut self) {
        self.completed_missions = ::std::option::Option::None;
    }

    pub fn has_completed_missions(&self) -> bool {
        self.completed_missions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_completed_missions(&mut self, v: u32) {
        self.completed_missions = ::std::option::Option::Some(v);
    }

    // optional uint32 badge_level = 4;

    pub fn badge_level(&self) -> u32 {
        self.badge_level.unwrap_or(0)
    }

    pub fn clear_badge_level(&mut self) {
        self.badge_level = ::std::option::Option::None;
    }

    pub fn has_badge_level(&self) -> bool {
        self.badge_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_badge_level(&mut self, v: u32) {
        self.badge_level = ::std::option::Option::Some(v);
    }

    // optional bool competitive_access = 9;

    pub fn competitive_access(&self) -> bool {
        self.competitive_access.unwrap_or(false)
    }

    pub fn clear_competitive_access(&mut self) {
        self.competitive_access = ::std::option::Option::None;
    }

    pub fn has_competitive_access(&self) -> bool {
        self.competitive_access.is_some()
    }

    // Param is passed by value, moved
    pub fn set_competitive_access(&mut self, v: bool) {
        self.competitive_access = ::std::option::Option::Some(v);
    }

    // optional uint32 experience = 14;

    pub fn experience(&self) -> u32 {
        self.experience.unwrap_or(0)
    }

    pub fn clear_experience(&mut self) {
        self.experience = ::std::option::Option::None;
    }

    pub fn has_experience(&self) -> bool {
        self.experience.is_some()
    }

    // Param is passed by value, moved
    pub fn set_experience(&mut self, v: u32) {
        self.experience = ::std::option::Option::Some(v);
    }

    // optional bool casual_banned = 18;

    pub fn casual_banned(&self) -> bool {
        self.casual_banned.unwrap_or(false)
    }

    pub fn clear_casual_banned(&mut self) {
        self.casual_banned = ::std::option::Option::None;
    }

    pub fn has_casual_banned(&self) -> bool {
        self.casual_banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_casual_banned(&mut self, v: bool) {
        self.casual_banned = ::std::option::Option::Some(v);
    }

    // optional bool ranked_banned = 19;

    pub fn ranked_banned(&self) -> bool {
        self.ranked_banned.unwrap_or(false)
    }

    pub fn clear_ranked_banned(&mut self) {
        self.ranked_banned = ::std::option::Option::None;
    }

    pub fn has_ranked_banned(&self) -> bool {
        self.ranked_banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ranked_banned(&mut self, v: bool) {
        self.ranked_banned = ::std::option::Option::Some(v);
    }

    // optional bool casual_low_priority = 20;

    pub fn casual_low_priority(&self) -> bool {
        self.casual_low_priority.unwrap_or(false)
    }

    pub fn clear_casual_low_priority(&mut self) {
        self.casual_low_priority = ::std::option::Option::None;
    }

    pub fn has_casual_low_priority(&self) -> bool {
        self.casual_low_priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_casual_low_priority(&mut self, v: bool) {
        self.casual_low_priority = ::std::option::Option::Some(v);
    }

    // optional bool ranked_low_priority = 21;

    pub fn ranked_low_priority(&self) -> bool {
        self.ranked_low_priority.unwrap_or(false)
    }

    pub fn clear_ranked_low_priority(&mut self) {
        self.ranked_low_priority = ::std::option::Option::None;
    }

    pub fn has_ranked_low_priority(&self) -> bool {
        self.ranked_low_priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ranked_low_priority(&mut self, v: bool) {
        self.ranked_low_priority = ::std::option::Option::Some(v);
    }

    // optional bool lobby_standby = 22;

    pub fn lobby_standby(&self) -> bool {
        self.lobby_standby.unwrap_or(false)
    }

    pub fn clear_lobby_standby(&mut self) {
        self.lobby_standby = ::std::option::Option::None;
    }

    pub fn has_lobby_standby(&self) -> bool {
        self.lobby_standby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_standby(&mut self, v: bool) {
        self.lobby_standby = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "owns_ticket",
            |m: &CSOTFPartyMember| { &m.owns_ticket },
            |m: &mut CSOTFPartyMember| { &mut m.owns_ticket },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "completed_missions",
            |m: &CSOTFPartyMember| { &m.completed_missions },
            |m: &mut CSOTFPartyMember| { &mut m.completed_missions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "badge_level",
            |m: &CSOTFPartyMember| { &m.badge_level },
            |m: &mut CSOTFPartyMember| { &mut m.badge_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "competitive_access",
            |m: &CSOTFPartyMember| { &m.competitive_access },
            |m: &mut CSOTFPartyMember| { &mut m.competitive_access },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "experience",
            |m: &CSOTFPartyMember| { &m.experience },
            |m: &mut CSOTFPartyMember| { &mut m.experience },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CTFPerPlayerMatchCriteriaProto>(
            "player_criteria",
            |m: &CSOTFPartyMember| { &m.player_criteria },
            |m: &mut CSOTFPartyMember| { &mut m.player_criteria },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, csotfparty_member::Activity>(
            "activity",
            |m: &CSOTFPartyMember| { &m.activity },
            |m: &mut CSOTFPartyMember| { &mut m.activity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "casual_banned",
            |m: &CSOTFPartyMember| { &m.casual_banned },
            |m: &mut CSOTFPartyMember| { &mut m.casual_banned },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ranked_banned",
            |m: &CSOTFPartyMember| { &m.ranked_banned },
            |m: &mut CSOTFPartyMember| { &mut m.ranked_banned },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "casual_low_priority",
            |m: &CSOTFPartyMember| { &m.casual_low_priority },
            |m: &mut CSOTFPartyMember| { &mut m.casual_low_priority },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ranked_low_priority",
            |m: &CSOTFPartyMember| { &m.ranked_low_priority },
            |m: &mut CSOTFPartyMember| { &mut m.ranked_low_priority },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_standby",
            |m: &CSOTFPartyMember| { &m.lobby_standby },
            |m: &mut CSOTFPartyMember| { &mut m.lobby_standby },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOTFPartyMember>(
            "CSOTFPartyMember",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOTFPartyMember {
    const NAME: &'static str = "CSOTFPartyMember";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.owns_ticket = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.completed_missions = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.badge_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.competitive_access = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.experience = ::std::option::Option::Some(is.read_uint32()?);
                },
                130 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.player_criteria)?;
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.activity)?;
                },
                144 => {
                    self.casual_banned = ::std::option::Option::Some(is.read_bool()?);
                },
                152 => {
                    self.ranked_banned = ::std::option::Option::Some(is.read_bool()?);
                },
                160 => {
                    self.casual_low_priority = ::std::option::Option::Some(is.read_bool()?);
                },
                168 => {
                    self.ranked_low_priority = ::std::option::Option::Some(is.read_bool()?);
                },
                176 => {
                    self.lobby_standby = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.owns_ticket {
            my_size += 1 + 1;
        }
        if let Some(v) = self.completed_missions {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.badge_level {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.competitive_access {
            my_size += 1 + 1;
        }
        if let Some(v) = self.experience {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.player_criteria.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.activity.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.casual_banned {
            my_size += 2 + 1;
        }
        if let Some(v) = self.ranked_banned {
            my_size += 2 + 1;
        }
        if let Some(v) = self.casual_low_priority {
            my_size += 2 + 1;
        }
        if let Some(v) = self.ranked_low_priority {
            my_size += 2 + 1;
        }
        if let Some(v) = self.lobby_standby {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.owns_ticket {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.completed_missions {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.badge_level {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.competitive_access {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.experience {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.player_criteria.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.activity.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.casual_banned {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.ranked_banned {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.casual_low_priority {
            os.write_bool(20, v)?;
        }
        if let Some(v) = self.ranked_low_priority {
            os.write_bool(21, v)?;
        }
        if let Some(v) = self.lobby_standby {
            os.write_bool(22, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOTFPartyMember {
        CSOTFPartyMember::new()
    }

    fn clear(&mut self) {
        self.owns_ticket = ::std::option::Option::None;
        self.completed_missions = ::std::option::Option::None;
        self.badge_level = ::std::option::Option::None;
        self.competitive_access = ::std::option::Option::None;
        self.experience = ::std::option::Option::None;
        self.player_criteria.clear();
        self.activity.clear();
        self.casual_banned = ::std::option::Option::None;
        self.ranked_banned = ::std::option::Option::None;
        self.casual_low_priority = ::std::option::Option::None;
        self.ranked_low_priority = ::std::option::Option::None;
        self.lobby_standby = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOTFPartyMember {
        static instance: CSOTFPartyMember = CSOTFPartyMember {
            owns_ticket: ::std::option::Option::None,
            completed_missions: ::std::option::Option::None,
            badge_level: ::std::option::Option::None,
            competitive_access: ::std::option::Option::None,
            experience: ::std::option::Option::None,
            player_criteria: ::protobuf::MessageField::none(),
            activity: ::protobuf::MessageField::none(),
            casual_banned: ::std::option::Option::None,
            ranked_banned: ::std::option::Option::None,
            casual_low_priority: ::std::option::Option::None,
            ranked_low_priority: ::std::option::Option::None,
            lobby_standby: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOTFPartyMember {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOTFPartyMember").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOTFPartyMember {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOTFPartyMember {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CSOTFPartyMember`
pub mod csotfparty_member {
    // @@protoc_insertion_point(message:CSOTFPartyMember.Activity)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Activity {
        // message fields
        // @@protoc_insertion_point(field:CSOTFPartyMember.Activity.lobby_id)
        pub lobby_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CSOTFPartyMember.Activity.lobby_match_group)
        pub lobby_match_group: ::std::option::Option<::protobuf::EnumOrUnknown<super::ETFMatchGroup>>,
        // @@protoc_insertion_point(field:CSOTFPartyMember.Activity.multiqueue_blocked)
        pub multiqueue_blocked: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CSOTFPartyMember.Activity.online)
        pub online: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CSOTFPartyMember.Activity.client_version)
        pub client_version: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CSOTFPartyMember.Activity.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Activity {
        fn default() -> &'a Activity {
            <Activity as ::protobuf::Message>::default_instance()
        }
    }

    impl Activity {
        pub fn new() -> Activity {
            ::std::default::Default::default()
        }

        // optional fixed64 lobby_id = 1;

        pub fn lobby_id(&self) -> u64 {
            self.lobby_id.unwrap_or(0)
        }

        pub fn clear_lobby_id(&mut self) {
            self.lobby_id = ::std::option::Option::None;
        }

        pub fn has_lobby_id(&self) -> bool {
            self.lobby_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lobby_id(&mut self, v: u64) {
            self.lobby_id = ::std::option::Option::Some(v);
        }

        // optional .ETFMatchGroup lobby_match_group = 2;

        pub fn lobby_match_group(&self) -> super::ETFMatchGroup {
            match self.lobby_match_group {
                Some(e) => e.enum_value_or(super::ETFMatchGroup::k_eTFMatchGroup_Invalid),
                None => super::ETFMatchGroup::k_eTFMatchGroup_Invalid,
            }
        }

        pub fn clear_lobby_match_group(&mut self) {
            self.lobby_match_group = ::std::option::Option::None;
        }

        pub fn has_lobby_match_group(&self) -> bool {
            self.lobby_match_group.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lobby_match_group(&mut self, v: super::ETFMatchGroup) {
            self.lobby_match_group = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional bool multiqueue_blocked = 3;

        pub fn multiqueue_blocked(&self) -> bool {
            self.multiqueue_blocked.unwrap_or(false)
        }

        pub fn clear_multiqueue_blocked(&mut self) {
            self.multiqueue_blocked = ::std::option::Option::None;
        }

        pub fn has_multiqueue_blocked(&self) -> bool {
            self.multiqueue_blocked.is_some()
        }

        // Param is passed by value, moved
        pub fn set_multiqueue_blocked(&mut self, v: bool) {
            self.multiqueue_blocked = ::std::option::Option::Some(v);
        }

        // optional bool online = 4;

        pub fn online(&self) -> bool {
            self.online.unwrap_or(false)
        }

        pub fn clear_online(&mut self) {
            self.online = ::std::option::Option::None;
        }

        pub fn has_online(&self) -> bool {
            self.online.is_some()
        }

        // Param is passed by value, moved
        pub fn set_online(&mut self, v: bool) {
            self.online = ::std::option::Option::Some(v);
        }

        // optional uint32 client_version = 5;

        pub fn client_version(&self) -> u32 {
            self.client_version.unwrap_or(0)
        }

        pub fn clear_client_version(&mut self) {
            self.client_version = ::std::option::Option::None;
        }

        pub fn has_client_version(&self) -> bool {
            self.client_version.is_some()
        }

        // Param is passed by value, moved
        pub fn set_client_version(&mut self, v: u32) {
            self.client_version = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "lobby_id",
                |m: &Activity| { &m.lobby_id },
                |m: &mut Activity| { &mut m.lobby_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "lobby_match_group",
                |m: &Activity| { &m.lobby_match_group },
                |m: &mut Activity| { &mut m.lobby_match_group },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "multiqueue_blocked",
                |m: &Activity| { &m.multiqueue_blocked },
                |m: &mut Activity| { &mut m.multiqueue_blocked },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "online",
                |m: &Activity| { &m.online },
                |m: &mut Activity| { &mut m.online },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "client_version",
                |m: &Activity| { &m.client_version },
                |m: &mut Activity| { &mut m.client_version },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Activity>(
                "CSOTFPartyMember.Activity",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Activity {
        const NAME: &'static str = "Activity";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.lobby_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.lobby_match_group = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    24 => {
                        self.multiqueue_blocked = ::std::option::Option::Some(is.read_bool()?);
                    },
                    32 => {
                        self.online = ::std::option::Option::Some(is.read_bool()?);
                    },
                    40 => {
                        self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.lobby_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.lobby_match_group {
                my_size += ::protobuf::rt::int32_size(2, v.value());
            }
            if let Some(v) = self.multiqueue_blocked {
                my_size += 1 + 1;
            }
            if let Some(v) = self.online {
                my_size += 1 + 1;
            }
            if let Some(v) = self.client_version {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.lobby_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.lobby_match_group {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.multiqueue_blocked {
                os.write_bool(3, v)?;
            }
            if let Some(v) = self.online {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.client_version {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Activity {
            Activity::new()
        }

        fn clear(&mut self) {
            self.lobby_id = ::std::option::Option::None;
            self.lobby_match_group = ::std::option::Option::None;
            self.multiqueue_blocked = ::std::option::Option::None;
            self.online = ::std::option::Option::None;
            self.client_version = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Activity {
            static instance: Activity = Activity {
                lobby_id: ::std::option::Option::None,
                lobby_match_group: ::std::option::Option::None,
                multiqueue_blocked: ::std::option::Option::None,
                online: ::std::option::Option::None,
                client_version: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Activity {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CSOTFPartyMember.Activity").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Activity {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Activity {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:TFPendingPartyMember)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TFPendingPartyMember {
    // message fields
    // @@protoc_insertion_point(field:TFPendingPartyMember.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:TFPendingPartyMember.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<tfpending_party_member::EType>>,
    // @@protoc_insertion_point(field:TFPendingPartyMember.inviter)
    pub inviter: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:TFPendingPartyMember.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TFPendingPartyMember {
    fn default() -> &'a TFPendingPartyMember {
        <TFPendingPartyMember as ::protobuf::Message>::default_instance()
    }
}

impl TFPendingPartyMember {
    pub fn new() -> TFPendingPartyMember {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional .TFPendingPartyMember.EType type = 2;

    pub fn type_(&self) -> tfpending_party_member::EType {
        match self.type_ {
            Some(e) => e.enum_value_or(tfpending_party_member::EType::Invited),
            None => tfpending_party_member::EType::Invited,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: tfpending_party_member::EType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional fixed64 inviter = 3;

    pub fn inviter(&self) -> u64 {
        self.inviter.unwrap_or(0)
    }

    pub fn clear_inviter(&mut self) {
        self.inviter = ::std::option::Option::None;
    }

    pub fn has_inviter(&self) -> bool {
        self.inviter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inviter(&mut self, v: u64) {
        self.inviter = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &TFPendingPartyMember| { &m.steamid },
            |m: &mut TFPendingPartyMember| { &mut m.steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &TFPendingPartyMember| { &m.type_ },
            |m: &mut TFPendingPartyMember| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "inviter",
            |m: &TFPendingPartyMember| { &m.inviter },
            |m: &mut TFPendingPartyMember| { &mut m.inviter },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TFPendingPartyMember>(
            "TFPendingPartyMember",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TFPendingPartyMember {
    const NAME: &'static str = "TFPendingPartyMember";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                25 => {
                    self.inviter = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.inviter {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.inviter {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TFPendingPartyMember {
        TFPendingPartyMember::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.inviter = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TFPendingPartyMember {
        static instance: TFPendingPartyMember = TFPendingPartyMember {
            steamid: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            inviter: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TFPendingPartyMember {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TFPendingPartyMember").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TFPendingPartyMember {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TFPendingPartyMember {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TFPendingPartyMember`
pub mod tfpending_party_member {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:TFPendingPartyMember.EType)
    pub enum EType {
        // @@protoc_insertion_point(enum_value:TFPendingPartyMember.EType.Invited)
        Invited = 0,
        // @@protoc_insertion_point(enum_value:TFPendingPartyMember.EType.RequestedToJoin)
        RequestedToJoin = 1,
    }

    impl ::protobuf::Enum for EType {
        const NAME: &'static str = "EType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EType> {
            match value {
                0 => ::std::option::Option::Some(EType::Invited),
                1 => ::std::option::Option::Some(EType::RequestedToJoin),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EType> {
            match str {
                "Invited" => ::std::option::Option::Some(EType::Invited),
                "RequestedToJoin" => ::std::option::Option::Some(EType::RequestedToJoin),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EType] = &[
            EType::Invited,
            EType::RequestedToJoin,
        ];
    }

    impl ::protobuf::EnumFull for EType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("TFPendingPartyMember.EType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EType {
        fn default() -> Self {
            EType::Invited
        }
    }

    impl EType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EType>("TFPendingPartyMember.EType")
        }
    }
}

// @@protoc_insertion_point(message:TFSyncedMMUIState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TFSyncedMMUIState {
    // message fields
    // @@protoc_insertion_point(field:TFSyncedMMUIState.menu_step)
    pub menu_step: ::std::option::Option<::protobuf::EnumOrUnknown<ETFSyncedMMMenuStep>>,
    // @@protoc_insertion_point(field:TFSyncedMMUIState.match_group)
    pub match_group: ::std::option::Option<::protobuf::EnumOrUnknown<ETFMatchGroup>>,
    // special fields
    // @@protoc_insertion_point(special_field:TFSyncedMMUIState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TFSyncedMMUIState {
    fn default() -> &'a TFSyncedMMUIState {
        <TFSyncedMMUIState as ::protobuf::Message>::default_instance()
    }
}

impl TFSyncedMMUIState {
    pub fn new() -> TFSyncedMMUIState {
        ::std::default::Default::default()
    }

    // optional .ETFSyncedMMMenuStep menu_step = 1;

    pub fn menu_step(&self) -> ETFSyncedMMMenuStep {
        match self.menu_step {
            Some(e) => e.enum_value_or(ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_None),
            None => ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_None,
        }
    }

    pub fn clear_menu_step(&mut self) {
        self.menu_step = ::std::option::Option::None;
    }

    pub fn has_menu_step(&self) -> bool {
        self.menu_step.is_some()
    }

    // Param is passed by value, moved
    pub fn set_menu_step(&mut self, v: ETFSyncedMMMenuStep) {
        self.menu_step = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .ETFMatchGroup match_group = 2;

    pub fn match_group(&self) -> ETFMatchGroup {
        match self.match_group {
            Some(e) => e.enum_value_or(ETFMatchGroup::k_eTFMatchGroup_Invalid),
            None => ETFMatchGroup::k_eTFMatchGroup_Invalid,
        }
    }

    pub fn clear_match_group(&mut self) {
        self.match_group = ::std::option::Option::None;
    }

    pub fn has_match_group(&self) -> bool {
        self.match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_group(&mut self, v: ETFMatchGroup) {
        self.match_group = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "menu_step",
            |m: &TFSyncedMMUIState| { &m.menu_step },
            |m: &mut TFSyncedMMUIState| { &mut m.menu_step },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_group",
            |m: &TFSyncedMMUIState| { &m.match_group },
            |m: &mut TFSyncedMMUIState| { &mut m.match_group },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TFSyncedMMUIState>(
            "TFSyncedMMUIState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TFSyncedMMUIState {
    const NAME: &'static str = "TFSyncedMMUIState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.menu_step = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.match_group = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.menu_step {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.match_group {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.menu_step {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.match_group {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TFSyncedMMUIState {
        TFSyncedMMUIState::new()
    }

    fn clear(&mut self) {
        self.menu_step = ::std::option::Option::None;
        self.match_group = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TFSyncedMMUIState {
        static instance: TFSyncedMMUIState = TFSyncedMMUIState {
            menu_step: ::std::option::Option::None,
            match_group: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TFSyncedMMUIState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TFSyncedMMUIState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TFSyncedMMUIState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TFSyncedMMUIState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CTFGroupMatchCriteriaProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CTFGroupMatchCriteriaProto {
    // message fields
    // @@protoc_insertion_point(field:CTFGroupMatchCriteriaProto.late_join_ok)
    pub late_join_ok: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CTFGroupMatchCriteriaProto.custom_ping_tolerance)
    pub custom_ping_tolerance: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CTFGroupMatchCriteriaProto.mvm_mannup_tour)
    pub mvm_mannup_tour: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CTFGroupMatchCriteriaProto.mvm_mannup_missions)
    pub mvm_mannup_missions: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CTFGroupMatchCriteriaProto.mvm_bootcamp_missions)
    pub mvm_bootcamp_missions: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CTFGroupMatchCriteriaProto.casual_criteria)
    pub casual_criteria: ::protobuf::MessageField<CTFCasualMatchCriteria>,
    // special fields
    // @@protoc_insertion_point(special_field:CTFGroupMatchCriteriaProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CTFGroupMatchCriteriaProto {
    fn default() -> &'a CTFGroupMatchCriteriaProto {
        <CTFGroupMatchCriteriaProto as ::protobuf::Message>::default_instance()
    }
}

impl CTFGroupMatchCriteriaProto {
    pub fn new() -> CTFGroupMatchCriteriaProto {
        ::std::default::Default::default()
    }

    // optional bool late_join_ok = 5;

    pub fn late_join_ok(&self) -> bool {
        self.late_join_ok.unwrap_or(false)
    }

    pub fn clear_late_join_ok(&mut self) {
        self.late_join_ok = ::std::option::Option::None;
    }

    pub fn has_late_join_ok(&self) -> bool {
        self.late_join_ok.is_some()
    }

    // Param is passed by value, moved
    pub fn set_late_join_ok(&mut self, v: bool) {
        self.late_join_ok = ::std::option::Option::Some(v);
    }

    // optional uint32 custom_ping_tolerance = 13;

    pub fn custom_ping_tolerance(&self) -> u32 {
        self.custom_ping_tolerance.unwrap_or(0u32)
    }

    pub fn clear_custom_ping_tolerance(&mut self) {
        self.custom_ping_tolerance = ::std::option::Option::None;
    }

    pub fn has_custom_ping_tolerance(&self) -> bool {
        self.custom_ping_tolerance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_ping_tolerance(&mut self, v: u32) {
        self.custom_ping_tolerance = ::std::option::Option::Some(v);
    }

    // optional string mvm_mannup_tour = 10;

    pub fn mvm_mannup_tour(&self) -> &str {
        match self.mvm_mannup_tour.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mvm_mannup_tour(&mut self) {
        self.mvm_mannup_tour = ::std::option::Option::None;
    }

    pub fn has_mvm_mannup_tour(&self) -> bool {
        self.mvm_mannup_tour.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mvm_mannup_tour(&mut self, v: ::std::string::String) {
        self.mvm_mannup_tour = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mvm_mannup_tour(&mut self) -> &mut ::std::string::String {
        if self.mvm_mannup_tour.is_none() {
            self.mvm_mannup_tour = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mvm_mannup_tour.as_mut().unwrap()
    }

    // Take field
    pub fn take_mvm_mannup_tour(&mut self) -> ::std::string::String {
        self.mvm_mannup_tour.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "late_join_ok",
            |m: &CTFGroupMatchCriteriaProto| { &m.late_join_ok },
            |m: &mut CTFGroupMatchCriteriaProto| { &mut m.late_join_ok },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_ping_tolerance",
            |m: &CTFGroupMatchCriteriaProto| { &m.custom_ping_tolerance },
            |m: &mut CTFGroupMatchCriteriaProto| { &mut m.custom_ping_tolerance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mvm_mannup_tour",
            |m: &CTFGroupMatchCriteriaProto| { &m.mvm_mannup_tour },
            |m: &mut CTFGroupMatchCriteriaProto| { &mut m.mvm_mannup_tour },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "mvm_mannup_missions",
            |m: &CTFGroupMatchCriteriaProto| { &m.mvm_mannup_missions },
            |m: &mut CTFGroupMatchCriteriaProto| { &mut m.mvm_mannup_missions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "mvm_bootcamp_missions",
            |m: &CTFGroupMatchCriteriaProto| { &m.mvm_bootcamp_missions },
            |m: &mut CTFGroupMatchCriteriaProto| { &mut m.mvm_bootcamp_missions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CTFCasualMatchCriteria>(
            "casual_criteria",
            |m: &CTFGroupMatchCriteriaProto| { &m.casual_criteria },
            |m: &mut CTFGroupMatchCriteriaProto| { &mut m.casual_criteria },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CTFGroupMatchCriteriaProto>(
            "CTFGroupMatchCriteriaProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CTFGroupMatchCriteriaProto {
    const NAME: &'static str = "CTFGroupMatchCriteriaProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                40 => {
                    self.late_join_ok = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.custom_ping_tolerance = ::std::option::Option::Some(is.read_uint32()?);
                },
                82 => {
                    self.mvm_mannup_tour = ::std::option::Option::Some(is.read_string()?);
                },
                122 => {
                    self.mvm_mannup_missions.push(is.read_string()?);
                },
                130 => {
                    self.mvm_bootcamp_missions.push(is.read_string()?);
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.casual_criteria)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.late_join_ok {
            my_size += 1 + 1;
        }
        if let Some(v) = self.custom_ping_tolerance {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.mvm_mannup_tour.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        for value in &self.mvm_mannup_missions {
            my_size += ::protobuf::rt::string_size(15, &value);
        };
        for value in &self.mvm_bootcamp_missions {
            my_size += ::protobuf::rt::string_size(16, &value);
        };
        if let Some(v) = self.casual_criteria.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.late_join_ok {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.custom_ping_tolerance {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.mvm_mannup_tour.as_ref() {
            os.write_string(10, v)?;
        }
        for v in &self.mvm_mannup_missions {
            os.write_string(15, &v)?;
        };
        for v in &self.mvm_bootcamp_missions {
            os.write_string(16, &v)?;
        };
        if let Some(v) = self.casual_criteria.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CTFGroupMatchCriteriaProto {
        CTFGroupMatchCriteriaProto::new()
    }

    fn clear(&mut self) {
        self.late_join_ok = ::std::option::Option::None;
        self.custom_ping_tolerance = ::std::option::Option::None;
        self.mvm_mannup_tour = ::std::option::Option::None;
        self.mvm_mannup_missions.clear();
        self.mvm_bootcamp_missions.clear();
        self.casual_criteria.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CTFGroupMatchCriteriaProto {
        static instance: CTFGroupMatchCriteriaProto = CTFGroupMatchCriteriaProto {
            late_join_ok: ::std::option::Option::None,
            custom_ping_tolerance: ::std::option::Option::None,
            mvm_mannup_tour: ::std::option::Option::None,
            mvm_mannup_missions: ::std::vec::Vec::new(),
            mvm_bootcamp_missions: ::std::vec::Vec::new(),
            casual_criteria: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CTFGroupMatchCriteriaProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CTFGroupMatchCriteriaProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CTFGroupMatchCriteriaProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CTFGroupMatchCriteriaProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CTFCasualMatchCriteria)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CTFCasualMatchCriteria {
    // message fields
    // @@protoc_insertion_point(field:CTFCasualMatchCriteria.selected_maps_bits)
    pub selected_maps_bits: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CTFCasualMatchCriteria.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CTFCasualMatchCriteria {
    fn default() -> &'a CTFCasualMatchCriteria {
        <CTFCasualMatchCriteria as ::protobuf::Message>::default_instance()
    }
}

impl CTFCasualMatchCriteria {
    pub fn new() -> CTFCasualMatchCriteria {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "selected_maps_bits",
            |m: &CTFCasualMatchCriteria| { &m.selected_maps_bits },
            |m: &mut CTFCasualMatchCriteria| { &mut m.selected_maps_bits },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CTFCasualMatchCriteria>(
            "CTFCasualMatchCriteria",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CTFCasualMatchCriteria {
    const NAME: &'static str = "CTFCasualMatchCriteria";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                26 => {
                    is.read_repeated_packed_fixed32_into(&mut self.selected_maps_bits)?;
                },
                29 => {
                    self.selected_maps_bits.push(is.read_fixed32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 5 * self.selected_maps_bits.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.selected_maps_bits {
            os.write_fixed32(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CTFCasualMatchCriteria {
        CTFCasualMatchCriteria::new()
    }

    fn clear(&mut self) {
        self.selected_maps_bits.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CTFCasualMatchCriteria {
        static instance: CTFCasualMatchCriteria = CTFCasualMatchCriteria {
            selected_maps_bits: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CTFCasualMatchCriteria {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CTFCasualMatchCriteria").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CTFCasualMatchCriteria {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CTFCasualMatchCriteria {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CTFPerPlayerMatchCriteriaProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CTFPerPlayerMatchCriteriaProto {
    // message fields
    // @@protoc_insertion_point(field:CTFPerPlayerMatchCriteriaProto.mvm_squad_surplus)
    pub mvm_squad_surplus: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CTFPerPlayerMatchCriteriaProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CTFPerPlayerMatchCriteriaProto {
    fn default() -> &'a CTFPerPlayerMatchCriteriaProto {
        <CTFPerPlayerMatchCriteriaProto as ::protobuf::Message>::default_instance()
    }
}

impl CTFPerPlayerMatchCriteriaProto {
    pub fn new() -> CTFPerPlayerMatchCriteriaProto {
        ::std::default::Default::default()
    }

    // optional bool mvm_squad_surplus = 1;

    pub fn mvm_squad_surplus(&self) -> bool {
        self.mvm_squad_surplus.unwrap_or(false)
    }

    pub fn clear_mvm_squad_surplus(&mut self) {
        self.mvm_squad_surplus = ::std::option::Option::None;
    }

    pub fn has_mvm_squad_surplus(&self) -> bool {
        self.mvm_squad_surplus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mvm_squad_surplus(&mut self, v: bool) {
        self.mvm_squad_surplus = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mvm_squad_surplus",
            |m: &CTFPerPlayerMatchCriteriaProto| { &m.mvm_squad_surplus },
            |m: &mut CTFPerPlayerMatchCriteriaProto| { &mut m.mvm_squad_surplus },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CTFPerPlayerMatchCriteriaProto>(
            "CTFPerPlayerMatchCriteriaProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CTFPerPlayerMatchCriteriaProto {
    const NAME: &'static str = "CTFPerPlayerMatchCriteriaProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mvm_squad_surplus = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mvm_squad_surplus {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.mvm_squad_surplus {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CTFPerPlayerMatchCriteriaProto {
        CTFPerPlayerMatchCriteriaProto::new()
    }

    fn clear(&mut self) {
        self.mvm_squad_surplus = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CTFPerPlayerMatchCriteriaProto {
        static instance: CTFPerPlayerMatchCriteriaProto = CTFPerPlayerMatchCriteriaProto {
            mvm_squad_surplus: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CTFPerPlayerMatchCriteriaProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CTFPerPlayerMatchCriteriaProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CTFPerPlayerMatchCriteriaProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CTFPerPlayerMatchCriteriaProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CTFPartyOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CTFPartyOptions {
    // message fields
    // @@protoc_insertion_point(field:CTFPartyOptions.overwrite_existing)
    pub overwrite_existing: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CTFPartyOptions.group_criteria)
    pub group_criteria: ::protobuf::MessageField<CTFGroupMatchCriteriaProto>,
    // @@protoc_insertion_point(field:CTFPartyOptions.player_criteria)
    pub player_criteria: ::protobuf::MessageField<CTFPerPlayerMatchCriteriaProto>,
    // @@protoc_insertion_point(field:CTFPartyOptions.player_uistate)
    pub player_uistate: ::protobuf::MessageField<TFSyncedMMUIState>,
    // special fields
    // @@protoc_insertion_point(special_field:CTFPartyOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CTFPartyOptions {
    fn default() -> &'a CTFPartyOptions {
        <CTFPartyOptions as ::protobuf::Message>::default_instance()
    }
}

impl CTFPartyOptions {
    pub fn new() -> CTFPartyOptions {
        ::std::default::Default::default()
    }

    // optional bool overwrite_existing = 1;

    pub fn overwrite_existing(&self) -> bool {
        self.overwrite_existing.unwrap_or(false)
    }

    pub fn clear_overwrite_existing(&mut self) {
        self.overwrite_existing = ::std::option::Option::None;
    }

    pub fn has_overwrite_existing(&self) -> bool {
        self.overwrite_existing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overwrite_existing(&mut self, v: bool) {
        self.overwrite_existing = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "overwrite_existing",
            |m: &CTFPartyOptions| { &m.overwrite_existing },
            |m: &mut CTFPartyOptions| { &mut m.overwrite_existing },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CTFGroupMatchCriteriaProto>(
            "group_criteria",
            |m: &CTFPartyOptions| { &m.group_criteria },
            |m: &mut CTFPartyOptions| { &mut m.group_criteria },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CTFPerPlayerMatchCriteriaProto>(
            "player_criteria",
            |m: &CTFPartyOptions| { &m.player_criteria },
            |m: &mut CTFPartyOptions| { &mut m.player_criteria },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TFSyncedMMUIState>(
            "player_uistate",
            |m: &CTFPartyOptions| { &m.player_uistate },
            |m: &mut CTFPartyOptions| { &mut m.player_uistate },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CTFPartyOptions>(
            "CTFPartyOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CTFPartyOptions {
    const NAME: &'static str = "CTFPartyOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.overwrite_existing = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.group_criteria)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.player_criteria)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.player_uistate)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.overwrite_existing {
            my_size += 1 + 1;
        }
        if let Some(v) = self.group_criteria.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.player_criteria.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.player_uistate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.overwrite_existing {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.group_criteria.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.player_criteria.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.player_uistate.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CTFPartyOptions {
        CTFPartyOptions::new()
    }

    fn clear(&mut self) {
        self.overwrite_existing = ::std::option::Option::None;
        self.group_criteria.clear();
        self.player_criteria.clear();
        self.player_uistate.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CTFPartyOptions {
        static instance: CTFPartyOptions = CTFPartyOptions {
            overwrite_existing: ::std::option::Option::None,
            group_criteria: ::protobuf::MessageField::none(),
            player_criteria: ::protobuf::MessageField::none(),
            player_uistate: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CTFPartyOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CTFPartyOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CTFPartyOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CTFPartyOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPartySetOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartySetOptions {
    // message fields
    // @@protoc_insertion_point(field:CMsgPartySetOptions.party_id)
    pub party_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPartySetOptions.options)
    pub options: ::protobuf::MessageField<CTFPartyOptions>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartySetOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartySetOptions {
    fn default() -> &'a CMsgPartySetOptions {
        <CMsgPartySetOptions as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartySetOptions {
    pub fn new() -> CMsgPartySetOptions {
        ::std::default::Default::default()
    }

    // optional fixed64 party_id = 1;

    pub fn party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }

    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "party_id",
            |m: &CMsgPartySetOptions| { &m.party_id },
            |m: &mut CMsgPartySetOptions| { &mut m.party_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CTFPartyOptions>(
            "options",
            |m: &CMsgPartySetOptions| { &m.options },
            |m: &mut CMsgPartySetOptions| { &mut m.options },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPartySetOptions>(
            "CMsgPartySetOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPartySetOptions {
    const NAME: &'static str = "CMsgPartySetOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.party_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.party_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartySetOptions {
        CMsgPartySetOptions::new()
    }

    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartySetOptions {
        static instance: CMsgPartySetOptions = CMsgPartySetOptions {
            party_id: ::std::option::Option::None,
            options: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPartySetOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPartySetOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPartySetOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartySetOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPartySetOptionsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartySetOptionsResponse {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartySetOptionsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartySetOptionsResponse {
    fn default() -> &'a CMsgPartySetOptionsResponse {
        <CMsgPartySetOptionsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartySetOptionsResponse {
    pub fn new() -> CMsgPartySetOptionsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPartySetOptionsResponse>(
            "CMsgPartySetOptionsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPartySetOptionsResponse {
    const NAME: &'static str = "CMsgPartySetOptionsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartySetOptionsResponse {
        CMsgPartySetOptionsResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartySetOptionsResponse {
        static instance: CMsgPartySetOptionsResponse = CMsgPartySetOptionsResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPartySetOptionsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPartySetOptionsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPartySetOptionsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartySetOptionsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPartyQueueForMatch)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartyQueueForMatch {
    // message fields
    // @@protoc_insertion_point(field:CMsgPartyQueueForMatch.party_id)
    pub party_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPartyQueueForMatch.final_options)
    pub final_options: ::protobuf::MessageField<CTFPartyOptions>,
    // @@protoc_insertion_point(field:CMsgPartyQueueForMatch.match_group)
    pub match_group: ::std::option::Option<::protobuf::EnumOrUnknown<ETFMatchGroup>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartyQueueForMatch.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyQueueForMatch {
    fn default() -> &'a CMsgPartyQueueForMatch {
        <CMsgPartyQueueForMatch as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyQueueForMatch {
    pub fn new() -> CMsgPartyQueueForMatch {
        ::std::default::Default::default()
    }

    // optional fixed64 party_id = 1;

    pub fn party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }

    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional .ETFMatchGroup match_group = 3;

    pub fn match_group(&self) -> ETFMatchGroup {
        match self.match_group {
            Some(e) => e.enum_value_or(ETFMatchGroup::k_eTFMatchGroup_Invalid),
            None => ETFMatchGroup::k_eTFMatchGroup_Invalid,
        }
    }

    pub fn clear_match_group(&mut self) {
        self.match_group = ::std::option::Option::None;
    }

    pub fn has_match_group(&self) -> bool {
        self.match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_group(&mut self, v: ETFMatchGroup) {
        self.match_group = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "party_id",
            |m: &CMsgPartyQueueForMatch| { &m.party_id },
            |m: &mut CMsgPartyQueueForMatch| { &mut m.party_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CTFPartyOptions>(
            "final_options",
            |m: &CMsgPartyQueueForMatch| { &m.final_options },
            |m: &mut CMsgPartyQueueForMatch| { &mut m.final_options },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_group",
            |m: &CMsgPartyQueueForMatch| { &m.match_group },
            |m: &mut CMsgPartyQueueForMatch| { &mut m.match_group },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPartyQueueForMatch>(
            "CMsgPartyQueueForMatch",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPartyQueueForMatch {
    const NAME: &'static str = "CMsgPartyQueueForMatch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.party_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.final_options)?;
                },
                24 => {
                    self.match_group = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.final_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.match_group {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.party_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.final_options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.match_group {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyQueueForMatch {
        CMsgPartyQueueForMatch::new()
    }

    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.final_options.clear();
        self.match_group = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyQueueForMatch {
        static instance: CMsgPartyQueueForMatch = CMsgPartyQueueForMatch {
            party_id: ::std::option::Option::None,
            final_options: ::protobuf::MessageField::none(),
            match_group: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPartyQueueForMatch {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPartyQueueForMatch").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPartyQueueForMatch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartyQueueForMatch {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPartyQueueForMatchResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartyQueueForMatchResponse {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartyQueueForMatchResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyQueueForMatchResponse {
    fn default() -> &'a CMsgPartyQueueForMatchResponse {
        <CMsgPartyQueueForMatchResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyQueueForMatchResponse {
    pub fn new() -> CMsgPartyQueueForMatchResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPartyQueueForMatchResponse>(
            "CMsgPartyQueueForMatchResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPartyQueueForMatchResponse {
    const NAME: &'static str = "CMsgPartyQueueForMatchResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyQueueForMatchResponse {
        CMsgPartyQueueForMatchResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyQueueForMatchResponse {
        static instance: CMsgPartyQueueForMatchResponse = CMsgPartyQueueForMatchResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPartyQueueForMatchResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPartyQueueForMatchResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPartyQueueForMatchResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartyQueueForMatchResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPartyQueueForStandby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartyQueueForStandby {
    // message fields
    // @@protoc_insertion_point(field:CMsgPartyQueueForStandby.party_id)
    pub party_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPartyQueueForStandby.party_lobby_id)
    pub party_lobby_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartyQueueForStandby.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyQueueForStandby {
    fn default() -> &'a CMsgPartyQueueForStandby {
        <CMsgPartyQueueForStandby as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyQueueForStandby {
    pub fn new() -> CMsgPartyQueueForStandby {
        ::std::default::Default::default()
    }

    // optional fixed64 party_id = 1;

    pub fn party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }

    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 party_lobby_id = 2;

    pub fn party_lobby_id(&self) -> u64 {
        self.party_lobby_id.unwrap_or(0)
    }

    pub fn clear_party_lobby_id(&mut self) {
        self.party_lobby_id = ::std::option::Option::None;
    }

    pub fn has_party_lobby_id(&self) -> bool {
        self.party_lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_lobby_id(&mut self, v: u64) {
        self.party_lobby_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "party_id",
            |m: &CMsgPartyQueueForStandby| { &m.party_id },
            |m: &mut CMsgPartyQueueForStandby| { &mut m.party_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "party_lobby_id",
            |m: &CMsgPartyQueueForStandby| { &m.party_lobby_id },
            |m: &mut CMsgPartyQueueForStandby| { &mut m.party_lobby_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPartyQueueForStandby>(
            "CMsgPartyQueueForStandby",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPartyQueueForStandby {
    const NAME: &'static str = "CMsgPartyQueueForStandby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.party_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.party_lobby_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.party_lobby_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.party_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.party_lobby_id {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyQueueForStandby {
        CMsgPartyQueueForStandby::new()
    }

    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.party_lobby_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyQueueForStandby {
        static instance: CMsgPartyQueueForStandby = CMsgPartyQueueForStandby {
            party_id: ::std::option::Option::None,
            party_lobby_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPartyQueueForStandby {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPartyQueueForStandby").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPartyQueueForStandby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartyQueueForStandby {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPartyQueueForStandbyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartyQueueForStandbyResponse {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartyQueueForStandbyResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyQueueForStandbyResponse {
    fn default() -> &'a CMsgPartyQueueForStandbyResponse {
        <CMsgPartyQueueForStandbyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyQueueForStandbyResponse {
    pub fn new() -> CMsgPartyQueueForStandbyResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPartyQueueForStandbyResponse>(
            "CMsgPartyQueueForStandbyResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPartyQueueForStandbyResponse {
    const NAME: &'static str = "CMsgPartyQueueForStandbyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyQueueForStandbyResponse {
        CMsgPartyQueueForStandbyResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyQueueForStandbyResponse {
        static instance: CMsgPartyQueueForStandbyResponse = CMsgPartyQueueForStandbyResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPartyQueueForStandbyResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPartyQueueForStandbyResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPartyQueueForStandbyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartyQueueForStandbyResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPartyRemoveFromQueue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartyRemoveFromQueue {
    // message fields
    // @@protoc_insertion_point(field:CMsgPartyRemoveFromQueue.party_id)
    pub party_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPartyRemoveFromQueue.match_group)
    pub match_group: ::std::option::Option<::protobuf::EnumOrUnknown<ETFMatchGroup>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartyRemoveFromQueue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyRemoveFromQueue {
    fn default() -> &'a CMsgPartyRemoveFromQueue {
        <CMsgPartyRemoveFromQueue as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyRemoveFromQueue {
    pub fn new() -> CMsgPartyRemoveFromQueue {
        ::std::default::Default::default()
    }

    // optional fixed64 party_id = 1;

    pub fn party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }

    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional .ETFMatchGroup match_group = 2;

    pub fn match_group(&self) -> ETFMatchGroup {
        match self.match_group {
            Some(e) => e.enum_value_or(ETFMatchGroup::k_eTFMatchGroup_Invalid),
            None => ETFMatchGroup::k_eTFMatchGroup_Invalid,
        }
    }

    pub fn clear_match_group(&mut self) {
        self.match_group = ::std::option::Option::None;
    }

    pub fn has_match_group(&self) -> bool {
        self.match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_group(&mut self, v: ETFMatchGroup) {
        self.match_group = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "party_id",
            |m: &CMsgPartyRemoveFromQueue| { &m.party_id },
            |m: &mut CMsgPartyRemoveFromQueue| { &mut m.party_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_group",
            |m: &CMsgPartyRemoveFromQueue| { &m.match_group },
            |m: &mut CMsgPartyRemoveFromQueue| { &mut m.match_group },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPartyRemoveFromQueue>(
            "CMsgPartyRemoveFromQueue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPartyRemoveFromQueue {
    const NAME: &'static str = "CMsgPartyRemoveFromQueue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.party_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.match_group = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.match_group {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.party_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.match_group {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyRemoveFromQueue {
        CMsgPartyRemoveFromQueue::new()
    }

    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.match_group = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyRemoveFromQueue {
        static instance: CMsgPartyRemoveFromQueue = CMsgPartyRemoveFromQueue {
            party_id: ::std::option::Option::None,
            match_group: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPartyRemoveFromQueue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPartyRemoveFromQueue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPartyRemoveFromQueue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartyRemoveFromQueue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPartyRemoveFromQueueResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartyRemoveFromQueueResponse {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartyRemoveFromQueueResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyRemoveFromQueueResponse {
    fn default() -> &'a CMsgPartyRemoveFromQueueResponse {
        <CMsgPartyRemoveFromQueueResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyRemoveFromQueueResponse {
    pub fn new() -> CMsgPartyRemoveFromQueueResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPartyRemoveFromQueueResponse>(
            "CMsgPartyRemoveFromQueueResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPartyRemoveFromQueueResponse {
    const NAME: &'static str = "CMsgPartyRemoveFromQueueResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyRemoveFromQueueResponse {
        CMsgPartyRemoveFromQueueResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyRemoveFromQueueResponse {
        static instance: CMsgPartyRemoveFromQueueResponse = CMsgPartyRemoveFromQueueResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPartyRemoveFromQueueResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPartyRemoveFromQueueResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPartyRemoveFromQueueResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartyRemoveFromQueueResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPartyRemoveFromStandbyQueue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartyRemoveFromStandbyQueue {
    // message fields
    // @@protoc_insertion_point(field:CMsgPartyRemoveFromStandbyQueue.party_id)
    pub party_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartyRemoveFromStandbyQueue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyRemoveFromStandbyQueue {
    fn default() -> &'a CMsgPartyRemoveFromStandbyQueue {
        <CMsgPartyRemoveFromStandbyQueue as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyRemoveFromStandbyQueue {
    pub fn new() -> CMsgPartyRemoveFromStandbyQueue {
        ::std::default::Default::default()
    }

    // optional fixed64 party_id = 1;

    pub fn party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }

    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "party_id",
            |m: &CMsgPartyRemoveFromStandbyQueue| { &m.party_id },
            |m: &mut CMsgPartyRemoveFromStandbyQueue| { &mut m.party_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPartyRemoveFromStandbyQueue>(
            "CMsgPartyRemoveFromStandbyQueue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPartyRemoveFromStandbyQueue {
    const NAME: &'static str = "CMsgPartyRemoveFromStandbyQueue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.party_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.party_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyRemoveFromStandbyQueue {
        CMsgPartyRemoveFromStandbyQueue::new()
    }

    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyRemoveFromStandbyQueue {
        static instance: CMsgPartyRemoveFromStandbyQueue = CMsgPartyRemoveFromStandbyQueue {
            party_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPartyRemoveFromStandbyQueue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPartyRemoveFromStandbyQueue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPartyRemoveFromStandbyQueue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartyRemoveFromStandbyQueue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPartyRemoveFromStandbyQueueResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartyRemoveFromStandbyQueueResponse {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartyRemoveFromStandbyQueueResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyRemoveFromStandbyQueueResponse {
    fn default() -> &'a CMsgPartyRemoveFromStandbyQueueResponse {
        <CMsgPartyRemoveFromStandbyQueueResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyRemoveFromStandbyQueueResponse {
    pub fn new() -> CMsgPartyRemoveFromStandbyQueueResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPartyRemoveFromStandbyQueueResponse>(
            "CMsgPartyRemoveFromStandbyQueueResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPartyRemoveFromStandbyQueueResponse {
    const NAME: &'static str = "CMsgPartyRemoveFromStandbyQueueResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyRemoveFromStandbyQueueResponse {
        CMsgPartyRemoveFromStandbyQueueResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyRemoveFromStandbyQueueResponse {
        static instance: CMsgPartyRemoveFromStandbyQueueResponse = CMsgPartyRemoveFromStandbyQueueResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPartyRemoveFromStandbyQueueResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPartyRemoveFromStandbyQueueResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPartyRemoveFromStandbyQueueResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartyRemoveFromStandbyQueueResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPartyInvitePlayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartyInvitePlayer {
    // message fields
    // @@protoc_insertion_point(field:CMsgPartyInvitePlayer.party_id)
    pub party_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPartyInvitePlayer.player_id)
    pub player_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPartyInvitePlayer.expecting_request_to_join)
    pub expecting_request_to_join: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartyInvitePlayer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyInvitePlayer {
    fn default() -> &'a CMsgPartyInvitePlayer {
        <CMsgPartyInvitePlayer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyInvitePlayer {
    pub fn new() -> CMsgPartyInvitePlayer {
        ::std::default::Default::default()
    }

    // optional fixed64 party_id = 1;

    pub fn party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }

    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 player_id = 2;

    pub fn player_id(&self) -> u64 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u64) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional bool expecting_request_to_join = 3;

    pub fn expecting_request_to_join(&self) -> bool {
        self.expecting_request_to_join.unwrap_or(false)
    }

    pub fn clear_expecting_request_to_join(&mut self) {
        self.expecting_request_to_join = ::std::option::Option::None;
    }

    pub fn has_expecting_request_to_join(&self) -> bool {
        self.expecting_request_to_join.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expecting_request_to_join(&mut self, v: bool) {
        self.expecting_request_to_join = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "party_id",
            |m: &CMsgPartyInvitePlayer| { &m.party_id },
            |m: &mut CMsgPartyInvitePlayer| { &mut m.party_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CMsgPartyInvitePlayer| { &m.player_id },
            |m: &mut CMsgPartyInvitePlayer| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expecting_request_to_join",
            |m: &CMsgPartyInvitePlayer| { &m.expecting_request_to_join },
            |m: &mut CMsgPartyInvitePlayer| { &mut m.expecting_request_to_join },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPartyInvitePlayer>(
            "CMsgPartyInvitePlayer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPartyInvitePlayer {
    const NAME: &'static str = "CMsgPartyInvitePlayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.party_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.player_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.expecting_request_to_join = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.player_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.expecting_request_to_join {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.party_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.player_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.expecting_request_to_join {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyInvitePlayer {
        CMsgPartyInvitePlayer::new()
    }

    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.player_id = ::std::option::Option::None;
        self.expecting_request_to_join = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyInvitePlayer {
        static instance: CMsgPartyInvitePlayer = CMsgPartyInvitePlayer {
            party_id: ::std::option::Option::None,
            player_id: ::std::option::Option::None,
            expecting_request_to_join: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPartyInvitePlayer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPartyInvitePlayer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPartyInvitePlayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartyInvitePlayer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPartyRequestJoinPlayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartyRequestJoinPlayer {
    // message fields
    // @@protoc_insertion_point(field:CMsgPartyRequestJoinPlayer.current_party_id)
    pub current_party_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPartyRequestJoinPlayer.join_player_id)
    pub join_player_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPartyRequestJoinPlayer.join_party_id)
    pub join_party_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPartyRequestJoinPlayer.expecting_invite)
    pub expecting_invite: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartyRequestJoinPlayer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyRequestJoinPlayer {
    fn default() -> &'a CMsgPartyRequestJoinPlayer {
        <CMsgPartyRequestJoinPlayer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyRequestJoinPlayer {
    pub fn new() -> CMsgPartyRequestJoinPlayer {
        ::std::default::Default::default()
    }

    // optional fixed64 current_party_id = 1;

    pub fn current_party_id(&self) -> u64 {
        self.current_party_id.unwrap_or(0)
    }

    pub fn clear_current_party_id(&mut self) {
        self.current_party_id = ::std::option::Option::None;
    }

    pub fn has_current_party_id(&self) -> bool {
        self.current_party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_party_id(&mut self, v: u64) {
        self.current_party_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 join_player_id = 2;

    pub fn join_player_id(&self) -> u64 {
        self.join_player_id.unwrap_or(0)
    }

    pub fn clear_join_player_id(&mut self) {
        self.join_player_id = ::std::option::Option::None;
    }

    pub fn has_join_player_id(&self) -> bool {
        self.join_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_join_player_id(&mut self, v: u64) {
        self.join_player_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 join_party_id = 3;

    pub fn join_party_id(&self) -> u64 {
        self.join_party_id.unwrap_or(0)
    }

    pub fn clear_join_party_id(&mut self) {
        self.join_party_id = ::std::option::Option::None;
    }

    pub fn has_join_party_id(&self) -> bool {
        self.join_party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_join_party_id(&mut self, v: u64) {
        self.join_party_id = ::std::option::Option::Some(v);
    }

    // optional bool expecting_invite = 4;

    pub fn expecting_invite(&self) -> bool {
        self.expecting_invite.unwrap_or(false)
    }

    pub fn clear_expecting_invite(&mut self) {
        self.expecting_invite = ::std::option::Option::None;
    }

    pub fn has_expecting_invite(&self) -> bool {
        self.expecting_invite.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expecting_invite(&mut self, v: bool) {
        self.expecting_invite = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "current_party_id",
            |m: &CMsgPartyRequestJoinPlayer| { &m.current_party_id },
            |m: &mut CMsgPartyRequestJoinPlayer| { &mut m.current_party_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "join_player_id",
            |m: &CMsgPartyRequestJoinPlayer| { &m.join_player_id },
            |m: &mut CMsgPartyRequestJoinPlayer| { &mut m.join_player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "join_party_id",
            |m: &CMsgPartyRequestJoinPlayer| { &m.join_party_id },
            |m: &mut CMsgPartyRequestJoinPlayer| { &mut m.join_party_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expecting_invite",
            |m: &CMsgPartyRequestJoinPlayer| { &m.expecting_invite },
            |m: &mut CMsgPartyRequestJoinPlayer| { &mut m.expecting_invite },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPartyRequestJoinPlayer>(
            "CMsgPartyRequestJoinPlayer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPartyRequestJoinPlayer {
    const NAME: &'static str = "CMsgPartyRequestJoinPlayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.current_party_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.join_player_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.join_party_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                32 => {
                    self.expecting_invite = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.current_party_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.join_player_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.join_party_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.expecting_invite {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.current_party_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.join_player_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.join_party_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.expecting_invite {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyRequestJoinPlayer {
        CMsgPartyRequestJoinPlayer::new()
    }

    fn clear(&mut self) {
        self.current_party_id = ::std::option::Option::None;
        self.join_player_id = ::std::option::Option::None;
        self.join_party_id = ::std::option::Option::None;
        self.expecting_invite = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyRequestJoinPlayer {
        static instance: CMsgPartyRequestJoinPlayer = CMsgPartyRequestJoinPlayer {
            current_party_id: ::std::option::Option::None,
            join_player_id: ::std::option::Option::None,
            join_party_id: ::std::option::Option::None,
            expecting_invite: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPartyRequestJoinPlayer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPartyRequestJoinPlayer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPartyRequestJoinPlayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartyRequestJoinPlayer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPartyClearPendingPlayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartyClearPendingPlayer {
    // message fields
    // @@protoc_insertion_point(field:CMsgPartyClearPendingPlayer.party_id)
    pub party_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPartyClearPendingPlayer.pending_player_id)
    pub pending_player_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartyClearPendingPlayer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyClearPendingPlayer {
    fn default() -> &'a CMsgPartyClearPendingPlayer {
        <CMsgPartyClearPendingPlayer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyClearPendingPlayer {
    pub fn new() -> CMsgPartyClearPendingPlayer {
        ::std::default::Default::default()
    }

    // optional fixed64 party_id = 1;

    pub fn party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }

    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 pending_player_id = 2;

    pub fn pending_player_id(&self) -> u64 {
        self.pending_player_id.unwrap_or(0)
    }

    pub fn clear_pending_player_id(&mut self) {
        self.pending_player_id = ::std::option::Option::None;
    }

    pub fn has_pending_player_id(&self) -> bool {
        self.pending_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pending_player_id(&mut self, v: u64) {
        self.pending_player_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "party_id",
            |m: &CMsgPartyClearPendingPlayer| { &m.party_id },
            |m: &mut CMsgPartyClearPendingPlayer| { &mut m.party_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pending_player_id",
            |m: &CMsgPartyClearPendingPlayer| { &m.pending_player_id },
            |m: &mut CMsgPartyClearPendingPlayer| { &mut m.pending_player_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPartyClearPendingPlayer>(
            "CMsgPartyClearPendingPlayer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPartyClearPendingPlayer {
    const NAME: &'static str = "CMsgPartyClearPendingPlayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.party_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.pending_player_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.pending_player_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.party_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.pending_player_id {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyClearPendingPlayer {
        CMsgPartyClearPendingPlayer::new()
    }

    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.pending_player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyClearPendingPlayer {
        static instance: CMsgPartyClearPendingPlayer = CMsgPartyClearPendingPlayer {
            party_id: ::std::option::Option::None,
            pending_player_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPartyClearPendingPlayer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPartyClearPendingPlayer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPartyClearPendingPlayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartyClearPendingPlayer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPartyClearPendingPlayerResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartyClearPendingPlayerResponse {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartyClearPendingPlayerResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyClearPendingPlayerResponse {
    fn default() -> &'a CMsgPartyClearPendingPlayerResponse {
        <CMsgPartyClearPendingPlayerResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyClearPendingPlayerResponse {
    pub fn new() -> CMsgPartyClearPendingPlayerResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPartyClearPendingPlayerResponse>(
            "CMsgPartyClearPendingPlayerResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPartyClearPendingPlayerResponse {
    const NAME: &'static str = "CMsgPartyClearPendingPlayerResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyClearPendingPlayerResponse {
        CMsgPartyClearPendingPlayerResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyClearPendingPlayerResponse {
        static instance: CMsgPartyClearPendingPlayerResponse = CMsgPartyClearPendingPlayerResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPartyClearPendingPlayerResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPartyClearPendingPlayerResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPartyClearPendingPlayerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartyClearPendingPlayerResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPartyClearOtherPartyRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartyClearOtherPartyRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgPartyClearOtherPartyRequest.other_party_id)
    pub other_party_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartyClearOtherPartyRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyClearOtherPartyRequest {
    fn default() -> &'a CMsgPartyClearOtherPartyRequest {
        <CMsgPartyClearOtherPartyRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyClearOtherPartyRequest {
    pub fn new() -> CMsgPartyClearOtherPartyRequest {
        ::std::default::Default::default()
    }

    // optional fixed64 other_party_id = 1;

    pub fn other_party_id(&self) -> u64 {
        self.other_party_id.unwrap_or(0)
    }

    pub fn clear_other_party_id(&mut self) {
        self.other_party_id = ::std::option::Option::None;
    }

    pub fn has_other_party_id(&self) -> bool {
        self.other_party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_party_id(&mut self, v: u64) {
        self.other_party_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "other_party_id",
            |m: &CMsgPartyClearOtherPartyRequest| { &m.other_party_id },
            |m: &mut CMsgPartyClearOtherPartyRequest| { &mut m.other_party_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPartyClearOtherPartyRequest>(
            "CMsgPartyClearOtherPartyRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPartyClearOtherPartyRequest {
    const NAME: &'static str = "CMsgPartyClearOtherPartyRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.other_party_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.other_party_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.other_party_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyClearOtherPartyRequest {
        CMsgPartyClearOtherPartyRequest::new()
    }

    fn clear(&mut self) {
        self.other_party_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyClearOtherPartyRequest {
        static instance: CMsgPartyClearOtherPartyRequest = CMsgPartyClearOtherPartyRequest {
            other_party_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPartyClearOtherPartyRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPartyClearOtherPartyRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPartyClearOtherPartyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartyClearOtherPartyRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPartyClearOtherPartyRequestResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartyClearOtherPartyRequestResponse {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartyClearOtherPartyRequestResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyClearOtherPartyRequestResponse {
    fn default() -> &'a CMsgPartyClearOtherPartyRequestResponse {
        <CMsgPartyClearOtherPartyRequestResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyClearOtherPartyRequestResponse {
    pub fn new() -> CMsgPartyClearOtherPartyRequestResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPartyClearOtherPartyRequestResponse>(
            "CMsgPartyClearOtherPartyRequestResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPartyClearOtherPartyRequestResponse {
    const NAME: &'static str = "CMsgPartyClearOtherPartyRequestResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyClearOtherPartyRequestResponse {
        CMsgPartyClearOtherPartyRequestResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyClearOtherPartyRequestResponse {
        static instance: CMsgPartyClearOtherPartyRequestResponse = CMsgPartyClearOtherPartyRequestResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPartyClearOtherPartyRequestResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPartyClearOtherPartyRequestResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPartyClearOtherPartyRequestResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartyClearOtherPartyRequestResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPartyPromoteToLeader)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartyPromoteToLeader {
    // message fields
    // @@protoc_insertion_point(field:CMsgPartyPromoteToLeader.party_id)
    pub party_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPartyPromoteToLeader.new_leader_id)
    pub new_leader_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartyPromoteToLeader.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyPromoteToLeader {
    fn default() -> &'a CMsgPartyPromoteToLeader {
        <CMsgPartyPromoteToLeader as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyPromoteToLeader {
    pub fn new() -> CMsgPartyPromoteToLeader {
        ::std::default::Default::default()
    }

    // optional fixed64 party_id = 1;

    pub fn party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }

    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 new_leader_id = 2;

    pub fn new_leader_id(&self) -> u64 {
        self.new_leader_id.unwrap_or(0)
    }

    pub fn clear_new_leader_id(&mut self) {
        self.new_leader_id = ::std::option::Option::None;
    }

    pub fn has_new_leader_id(&self) -> bool {
        self.new_leader_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_leader_id(&mut self, v: u64) {
        self.new_leader_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "party_id",
            |m: &CMsgPartyPromoteToLeader| { &m.party_id },
            |m: &mut CMsgPartyPromoteToLeader| { &mut m.party_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "new_leader_id",
            |m: &CMsgPartyPromoteToLeader| { &m.new_leader_id },
            |m: &mut CMsgPartyPromoteToLeader| { &mut m.new_leader_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPartyPromoteToLeader>(
            "CMsgPartyPromoteToLeader",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPartyPromoteToLeader {
    const NAME: &'static str = "CMsgPartyPromoteToLeader";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.party_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.new_leader_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.new_leader_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.party_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.new_leader_id {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyPromoteToLeader {
        CMsgPartyPromoteToLeader::new()
    }

    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.new_leader_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyPromoteToLeader {
        static instance: CMsgPartyPromoteToLeader = CMsgPartyPromoteToLeader {
            party_id: ::std::option::Option::None,
            new_leader_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPartyPromoteToLeader {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPartyPromoteToLeader").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPartyPromoteToLeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartyPromoteToLeader {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPartyKickMember)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartyKickMember {
    // message fields
    // @@protoc_insertion_point(field:CMsgPartyKickMember.party_id)
    pub party_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPartyKickMember.target_id)
    pub target_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartyKickMember.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyKickMember {
    fn default() -> &'a CMsgPartyKickMember {
        <CMsgPartyKickMember as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyKickMember {
    pub fn new() -> CMsgPartyKickMember {
        ::std::default::Default::default()
    }

    // optional fixed64 party_id = 1;

    pub fn party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }

    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 target_id = 2;

    pub fn target_id(&self) -> u64 {
        self.target_id.unwrap_or(0)
    }

    pub fn clear_target_id(&mut self) {
        self.target_id = ::std::option::Option::None;
    }

    pub fn has_target_id(&self) -> bool {
        self.target_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_id(&mut self, v: u64) {
        self.target_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "party_id",
            |m: &CMsgPartyKickMember| { &m.party_id },
            |m: &mut CMsgPartyKickMember| { &mut m.party_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_id",
            |m: &CMsgPartyKickMember| { &m.target_id },
            |m: &mut CMsgPartyKickMember| { &mut m.target_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPartyKickMember>(
            "CMsgPartyKickMember",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPartyKickMember {
    const NAME: &'static str = "CMsgPartyKickMember";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.party_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.target_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.target_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.party_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.target_id {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyKickMember {
        CMsgPartyKickMember::new()
    }

    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.target_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyKickMember {
        static instance: CMsgPartyKickMember = CMsgPartyKickMember {
            party_id: ::std::option::Option::None,
            target_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPartyKickMember {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPartyKickMember").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPartyKickMember {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartyKickMember {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPartySendChat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartySendChat {
    // message fields
    // @@protoc_insertion_point(field:CMsgPartySendChat.party_id)
    pub party_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPartySendChat.msg)
    pub msg: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartySendChat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartySendChat {
    fn default() -> &'a CMsgPartySendChat {
        <CMsgPartySendChat as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartySendChat {
    pub fn new() -> CMsgPartySendChat {
        ::std::default::Default::default()
    }

    // optional fixed64 party_id = 1;

    pub fn party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }

    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional string msg = 2;

    pub fn msg(&self) -> &str {
        match self.msg.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_msg(&mut self) {
        self.msg = ::std::option::Option::None;
    }

    pub fn has_msg(&self) -> bool {
        self.msg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg(&mut self, v: ::std::string::String) {
        self.msg = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg(&mut self) -> &mut ::std::string::String {
        if self.msg.is_none() {
            self.msg = ::std::option::Option::Some(::std::string::String::new());
        }
        self.msg.as_mut().unwrap()
    }

    // Take field
    pub fn take_msg(&mut self) -> ::std::string::String {
        self.msg.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "party_id",
            |m: &CMsgPartySendChat| { &m.party_id },
            |m: &mut CMsgPartySendChat| { &mut m.party_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msg",
            |m: &CMsgPartySendChat| { &m.msg },
            |m: &mut CMsgPartySendChat| { &mut m.msg },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPartySendChat>(
            "CMsgPartySendChat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPartySendChat {
    const NAME: &'static str = "CMsgPartySendChat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.party_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.msg = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.msg.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.party_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.msg.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartySendChat {
        CMsgPartySendChat::new()
    }

    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.msg = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartySendChat {
        static instance: CMsgPartySendChat = CMsgPartySendChat {
            party_id: ::std::option::Option::None,
            msg: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPartySendChat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPartySendChat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPartySendChat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartySendChat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPartyChatMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartyChatMsg {
    // message fields
    // @@protoc_insertion_point(field:CMsgPartyChatMsg.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<ETFPartyChatType>>,
    // @@protoc_insertion_point(field:CMsgPartyChatMsg.actor_id)
    pub actor_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPartyChatMsg.msg)
    pub msg: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartyChatMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyChatMsg {
    fn default() -> &'a CMsgPartyChatMsg {
        <CMsgPartyChatMsg as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyChatMsg {
    pub fn new() -> CMsgPartyChatMsg {
        ::std::default::Default::default()
    }

    // optional .ETFPartyChatType type = 1;

    pub fn type_(&self) -> ETFPartyChatType {
        match self.type_ {
            Some(e) => e.enum_value_or(ETFPartyChatType::k_eTFPartyChatType_Invalid),
            None => ETFPartyChatType::k_eTFPartyChatType_Invalid,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ETFPartyChatType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional fixed64 actor_id = 2;

    pub fn actor_id(&self) -> u64 {
        self.actor_id.unwrap_or(0)
    }

    pub fn clear_actor_id(&mut self) {
        self.actor_id = ::std::option::Option::None;
    }

    pub fn has_actor_id(&self) -> bool {
        self.actor_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actor_id(&mut self, v: u64) {
        self.actor_id = ::std::option::Option::Some(v);
    }

    // optional string msg = 3;

    pub fn msg(&self) -> &str {
        match self.msg.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_msg(&mut self) {
        self.msg = ::std::option::Option::None;
    }

    pub fn has_msg(&self) -> bool {
        self.msg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg(&mut self, v: ::std::string::String) {
        self.msg = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg(&mut self) -> &mut ::std::string::String {
        if self.msg.is_none() {
            self.msg = ::std::option::Option::Some(::std::string::String::new());
        }
        self.msg.as_mut().unwrap()
    }

    // Take field
    pub fn take_msg(&mut self) -> ::std::string::String {
        self.msg.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CMsgPartyChatMsg| { &m.type_ },
            |m: &mut CMsgPartyChatMsg| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "actor_id",
            |m: &CMsgPartyChatMsg| { &m.actor_id },
            |m: &mut CMsgPartyChatMsg| { &mut m.actor_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msg",
            |m: &CMsgPartyChatMsg| { &m.msg },
            |m: &mut CMsgPartyChatMsg| { &mut m.msg },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPartyChatMsg>(
            "CMsgPartyChatMsg",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPartyChatMsg {
    const NAME: &'static str = "CMsgPartyChatMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                17 => {
                    self.actor_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.msg = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.actor_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.msg.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.actor_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.msg.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyChatMsg {
        CMsgPartyChatMsg::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.actor_id = ::std::option::Option::None;
        self.msg = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyChatMsg {
        static instance: CMsgPartyChatMsg = CMsgPartyChatMsg {
            type_: ::std::option::Option::None,
            actor_id: ::std::option::Option::None,
            msg: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPartyChatMsg {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPartyChatMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPartyChatMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartyChatMsg {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSOTFParty)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOTFParty {
    // message fields
    // @@protoc_insertion_point(field:CSOTFParty.party_id)
    pub party_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSOTFParty.leader_id)
    pub leader_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSOTFParty.member_ids)
    pub member_ids: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CSOTFParty.members)
    pub members: ::std::vec::Vec<CSOTFPartyMember>,
    // @@protoc_insertion_point(field:CSOTFParty.associated_lobby_id)
    pub associated_lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSOTFParty.associated_lobby_match_group)
    pub associated_lobby_match_group: ::std::option::Option<::protobuf::EnumOrUnknown<ETFMatchGroup>>,
    // @@protoc_insertion_point(field:CSOTFParty.matchmaking_queues)
    pub matchmaking_queues: ::std::vec::Vec<csotfparty::QueueEntry>,
    // @@protoc_insertion_point(field:CSOTFParty.group_criteria)
    pub group_criteria: ::protobuf::MessageField<CTFGroupMatchCriteriaProto>,
    // @@protoc_insertion_point(field:CSOTFParty.casual_banned_time)
    pub casual_banned_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFParty.casual_low_priority_time)
    pub casual_low_priority_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFParty.ranked_banned_time)
    pub ranked_banned_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFParty.ranked_low_priority_time)
    pub ranked_low_priority_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFParty.leader_ui_state)
    pub leader_ui_state: ::protobuf::MessageField<TFSyncedMMUIState>,
    // @@protoc_insertion_point(field:CSOTFParty.pending_members)
    pub pending_members: ::std::vec::Vec<TFPendingPartyMember>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOTFParty.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOTFParty {
    fn default() -> &'a CSOTFParty {
        <CSOTFParty as ::protobuf::Message>::default_instance()
    }
}

impl CSOTFParty {
    pub fn new() -> CSOTFParty {
        ::std::default::Default::default()
    }

    // optional uint64 party_id = 1;

    pub fn party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }

    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 leader_id = 2;

    pub fn leader_id(&self) -> u64 {
        self.leader_id.unwrap_or(0)
    }

    pub fn clear_leader_id(&mut self) {
        self.leader_id = ::std::option::Option::None;
    }

    pub fn has_leader_id(&self) -> bool {
        self.leader_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leader_id(&mut self, v: u64) {
        self.leader_id = ::std::option::Option::Some(v);
    }

    // optional uint64 associated_lobby_id = 35;

    pub fn associated_lobby_id(&self) -> u64 {
        self.associated_lobby_id.unwrap_or(0)
    }

    pub fn clear_associated_lobby_id(&mut self) {
        self.associated_lobby_id = ::std::option::Option::None;
    }

    pub fn has_associated_lobby_id(&self) -> bool {
        self.associated_lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_associated_lobby_id(&mut self, v: u64) {
        self.associated_lobby_id = ::std::option::Option::Some(v);
    }

    // optional .ETFMatchGroup associated_lobby_match_group = 40;

    pub fn associated_lobby_match_group(&self) -> ETFMatchGroup {
        match self.associated_lobby_match_group {
            Some(e) => e.enum_value_or(ETFMatchGroup::k_eTFMatchGroup_Invalid),
            None => ETFMatchGroup::k_eTFMatchGroup_Invalid,
        }
    }

    pub fn clear_associated_lobby_match_group(&mut self) {
        self.associated_lobby_match_group = ::std::option::Option::None;
    }

    pub fn has_associated_lobby_match_group(&self) -> bool {
        self.associated_lobby_match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_associated_lobby_match_group(&mut self, v: ETFMatchGroup) {
        self.associated_lobby_match_group = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 casual_banned_time = 18;

    pub fn casual_banned_time(&self) -> u32 {
        self.casual_banned_time.unwrap_or(0)
    }

    pub fn clear_casual_banned_time(&mut self) {
        self.casual_banned_time = ::std::option::Option::None;
    }

    pub fn has_casual_banned_time(&self) -> bool {
        self.casual_banned_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_casual_banned_time(&mut self, v: u32) {
        self.casual_banned_time = ::std::option::Option::Some(v);
    }

    // optional uint32 casual_low_priority_time = 20;

    pub fn casual_low_priority_time(&self) -> u32 {
        self.casual_low_priority_time.unwrap_or(0)
    }

    pub fn clear_casual_low_priority_time(&mut self) {
        self.casual_low_priority_time = ::std::option::Option::None;
    }

    pub fn has_casual_low_priority_time(&self) -> bool {
        self.casual_low_priority_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_casual_low_priority_time(&mut self, v: u32) {
        self.casual_low_priority_time = ::std::option::Option::Some(v);
    }

    // optional uint32 ranked_banned_time = 41;

    pub fn ranked_banned_time(&self) -> u32 {
        self.ranked_banned_time.unwrap_or(0)
    }

    pub fn clear_ranked_banned_time(&mut self) {
        self.ranked_banned_time = ::std::option::Option::None;
    }

    pub fn has_ranked_banned_time(&self) -> bool {
        self.ranked_banned_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ranked_banned_time(&mut self, v: u32) {
        self.ranked_banned_time = ::std::option::Option::Some(v);
    }

    // optional uint32 ranked_low_priority_time = 42;

    pub fn ranked_low_priority_time(&self) -> u32 {
        self.ranked_low_priority_time.unwrap_or(0)
    }

    pub fn clear_ranked_low_priority_time(&mut self) {
        self.ranked_low_priority_time = ::std::option::Option::None;
    }

    pub fn has_ranked_low_priority_time(&self) -> bool {
        self.ranked_low_priority_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ranked_low_priority_time(&mut self, v: u32) {
        self.ranked_low_priority_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "party_id",
            |m: &CSOTFParty| { &m.party_id },
            |m: &mut CSOTFParty| { &mut m.party_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leader_id",
            |m: &CSOTFParty| { &m.leader_id },
            |m: &mut CSOTFParty| { &mut m.leader_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "member_ids",
            |m: &CSOTFParty| { &m.member_ids },
            |m: &mut CSOTFParty| { &mut m.member_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "members",
            |m: &CSOTFParty| { &m.members },
            |m: &mut CSOTFParty| { &mut m.members },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "associated_lobby_id",
            |m: &CSOTFParty| { &m.associated_lobby_id },
            |m: &mut CSOTFParty| { &mut m.associated_lobby_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "associated_lobby_match_group",
            |m: &CSOTFParty| { &m.associated_lobby_match_group },
            |m: &mut CSOTFParty| { &mut m.associated_lobby_match_group },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "matchmaking_queues",
            |m: &CSOTFParty| { &m.matchmaking_queues },
            |m: &mut CSOTFParty| { &mut m.matchmaking_queues },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CTFGroupMatchCriteriaProto>(
            "group_criteria",
            |m: &CSOTFParty| { &m.group_criteria },
            |m: &mut CSOTFParty| { &mut m.group_criteria },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "casual_banned_time",
            |m: &CSOTFParty| { &m.casual_banned_time },
            |m: &mut CSOTFParty| { &mut m.casual_banned_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "casual_low_priority_time",
            |m: &CSOTFParty| { &m.casual_low_priority_time },
            |m: &mut CSOTFParty| { &mut m.casual_low_priority_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ranked_banned_time",
            |m: &CSOTFParty| { &m.ranked_banned_time },
            |m: &mut CSOTFParty| { &mut m.ranked_banned_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ranked_low_priority_time",
            |m: &CSOTFParty| { &m.ranked_low_priority_time },
            |m: &mut CSOTFParty| { &mut m.ranked_low_priority_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TFSyncedMMUIState>(
            "leader_ui_state",
            |m: &CSOTFParty| { &m.leader_ui_state },
            |m: &mut CSOTFParty| { &mut m.leader_ui_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pending_members",
            |m: &CSOTFParty| { &m.pending_members },
            |m: &mut CSOTFParty| { &mut m.pending_members },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOTFParty>(
            "CSOTFParty",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOTFParty {
    const NAME: &'static str = "CSOTFParty";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.party_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.leader_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    is.read_repeated_packed_fixed64_into(&mut self.member_ids)?;
                },
                25 => {
                    self.member_ids.push(is.read_fixed64()?);
                },
                106 => {
                    self.members.push(is.read_message()?);
                },
                280 => {
                    self.associated_lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                320 => {
                    self.associated_lobby_match_group = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                346 => {
                    self.matchmaking_queues.push(is.read_message()?);
                },
                298 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.group_criteria)?;
                },
                144 => {
                    self.casual_banned_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.casual_low_priority_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                328 => {
                    self.ranked_banned_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                336 => {
                    self.ranked_low_priority_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                354 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.leader_ui_state)?;
                },
                314 => {
                    self.pending_members.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.leader_id {
            my_size += 1 + 8;
        }
        my_size += 9 * self.member_ids.len() as u64;
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.associated_lobby_id {
            my_size += ::protobuf::rt::uint64_size(35, v);
        }
        if let Some(v) = self.associated_lobby_match_group {
            my_size += ::protobuf::rt::int32_size(40, v.value());
        }
        for value in &self.matchmaking_queues {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.group_criteria.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.casual_banned_time {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.casual_low_priority_time {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.ranked_banned_time {
            my_size += ::protobuf::rt::uint32_size(41, v);
        }
        if let Some(v) = self.ranked_low_priority_time {
            my_size += ::protobuf::rt::uint32_size(42, v);
        }
        if let Some(v) = self.leader_ui_state.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.pending_members {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.party_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.leader_id {
            os.write_fixed64(2, v)?;
        }
        for v in &self.member_ids {
            os.write_fixed64(3, *v)?;
        };
        for v in &self.members {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        if let Some(v) = self.associated_lobby_id {
            os.write_uint64(35, v)?;
        }
        if let Some(v) = self.associated_lobby_match_group {
            os.write_enum(40, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.matchmaking_queues {
            ::protobuf::rt::write_message_field_with_cached_size(43, v, os)?;
        };
        if let Some(v) = self.group_criteria.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(37, v, os)?;
        }
        if let Some(v) = self.casual_banned_time {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.casual_low_priority_time {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.ranked_banned_time {
            os.write_uint32(41, v)?;
        }
        if let Some(v) = self.ranked_low_priority_time {
            os.write_uint32(42, v)?;
        }
        if let Some(v) = self.leader_ui_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(44, v, os)?;
        }
        for v in &self.pending_members {
            ::protobuf::rt::write_message_field_with_cached_size(39, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOTFParty {
        CSOTFParty::new()
    }

    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.leader_id = ::std::option::Option::None;
        self.member_ids.clear();
        self.members.clear();
        self.associated_lobby_id = ::std::option::Option::None;
        self.associated_lobby_match_group = ::std::option::Option::None;
        self.matchmaking_queues.clear();
        self.group_criteria.clear();
        self.casual_banned_time = ::std::option::Option::None;
        self.casual_low_priority_time = ::std::option::Option::None;
        self.ranked_banned_time = ::std::option::Option::None;
        self.ranked_low_priority_time = ::std::option::Option::None;
        self.leader_ui_state.clear();
        self.pending_members.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOTFParty {
        static instance: CSOTFParty = CSOTFParty {
            party_id: ::std::option::Option::None,
            leader_id: ::std::option::Option::None,
            member_ids: ::std::vec::Vec::new(),
            members: ::std::vec::Vec::new(),
            associated_lobby_id: ::std::option::Option::None,
            associated_lobby_match_group: ::std::option::Option::None,
            matchmaking_queues: ::std::vec::Vec::new(),
            group_criteria: ::protobuf::MessageField::none(),
            casual_banned_time: ::std::option::Option::None,
            casual_low_priority_time: ::std::option::Option::None,
            ranked_banned_time: ::std::option::Option::None,
            ranked_low_priority_time: ::std::option::Option::None,
            leader_ui_state: ::protobuf::MessageField::none(),
            pending_members: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOTFParty {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOTFParty").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOTFParty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOTFParty {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CSOTFParty`
pub mod csotfparty {
    // @@protoc_insertion_point(message:CSOTFParty.QueueEntry)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct QueueEntry {
        // message fields
        // @@protoc_insertion_point(field:CSOTFParty.QueueEntry.match_group)
        pub match_group: ::std::option::Option<::protobuf::EnumOrUnknown<super::ETFMatchGroup>>,
        // @@protoc_insertion_point(field:CSOTFParty.QueueEntry.queued_time)
        pub queued_time: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CSOTFParty.QueueEntry.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a QueueEntry {
        fn default() -> &'a QueueEntry {
            <QueueEntry as ::protobuf::Message>::default_instance()
        }
    }

    impl QueueEntry {
        pub fn new() -> QueueEntry {
            ::std::default::Default::default()
        }

        // optional .ETFMatchGroup match_group = 1;

        pub fn match_group(&self) -> super::ETFMatchGroup {
            match self.match_group {
                Some(e) => e.enum_value_or(super::ETFMatchGroup::k_eTFMatchGroup_Invalid),
                None => super::ETFMatchGroup::k_eTFMatchGroup_Invalid,
            }
        }

        pub fn clear_match_group(&mut self) {
            self.match_group = ::std::option::Option::None;
        }

        pub fn has_match_group(&self) -> bool {
            self.match_group.is_some()
        }

        // Param is passed by value, moved
        pub fn set_match_group(&mut self, v: super::ETFMatchGroup) {
            self.match_group = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional fixed32 queued_time = 2;

        pub fn queued_time(&self) -> u32 {
            self.queued_time.unwrap_or(0)
        }

        pub fn clear_queued_time(&mut self) {
            self.queued_time = ::std::option::Option::None;
        }

        pub fn has_queued_time(&self) -> bool {
            self.queued_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_queued_time(&mut self, v: u32) {
            self.queued_time = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "match_group",
                |m: &QueueEntry| { &m.match_group },
                |m: &mut QueueEntry| { &mut m.match_group },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "queued_time",
                |m: &QueueEntry| { &m.queued_time },
                |m: &mut QueueEntry| { &mut m.queued_time },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueueEntry>(
                "CSOTFParty.QueueEntry",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for QueueEntry {
        const NAME: &'static str = "QueueEntry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.match_group = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    21 => {
                        self.queued_time = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.match_group {
                my_size += ::protobuf::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.queued_time {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.match_group {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.queued_time {
                os.write_fixed32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> QueueEntry {
            QueueEntry::new()
        }

        fn clear(&mut self) {
            self.match_group = ::std::option::Option::None;
            self.queued_time = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static QueueEntry {
            static instance: QueueEntry = QueueEntry {
                match_group: ::std::option::Option::None,
                queued_time: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for QueueEntry {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CSOTFParty.QueueEntry").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for QueueEntry {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for QueueEntry {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CSOTFPartyInvite)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOTFPartyInvite {
    // message fields
    // @@protoc_insertion_point(field:CSOTFPartyInvite.group_id)
    pub group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSOTFPartyInvite.inviter)
    pub inviter: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSOTFPartyInvite.members)
    pub members: ::std::vec::Vec<csotfparty_invite::PartyMember>,
    // @@protoc_insertion_point(field:CSOTFPartyInvite.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<csotfparty_invite::Type>>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOTFPartyInvite.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOTFPartyInvite {
    fn default() -> &'a CSOTFPartyInvite {
        <CSOTFPartyInvite as ::protobuf::Message>::default_instance()
    }
}

impl CSOTFPartyInvite {
    pub fn new() -> CSOTFPartyInvite {
        ::std::default::Default::default()
    }

    // optional uint64 group_id = 1;

    pub fn group_id(&self) -> u64 {
        self.group_id.unwrap_or(0)
    }

    pub fn clear_group_id(&mut self) {
        self.group_id = ::std::option::Option::None;
    }

    pub fn has_group_id(&self) -> bool {
        self.group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_id(&mut self, v: u64) {
        self.group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 inviter = 2;

    pub fn inviter(&self) -> u64 {
        self.inviter.unwrap_or(0)
    }

    pub fn clear_inviter(&mut self) {
        self.inviter = ::std::option::Option::None;
    }

    pub fn has_inviter(&self) -> bool {
        self.inviter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inviter(&mut self, v: u64) {
        self.inviter = ::std::option::Option::Some(v);
    }

    // optional .CSOTFPartyInvite.Type type = 5;

    pub fn type_(&self) -> csotfparty_invite::Type {
        match self.type_ {
            Some(e) => e.enum_value_or(csotfparty_invite::Type::PENDING_INVITE),
            None => csotfparty_invite::Type::PENDING_INVITE,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: csotfparty_invite::Type) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "group_id",
            |m: &CSOTFPartyInvite| { &m.group_id },
            |m: &mut CSOTFPartyInvite| { &mut m.group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "inviter",
            |m: &CSOTFPartyInvite| { &m.inviter },
            |m: &mut CSOTFPartyInvite| { &mut m.inviter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "members",
            |m: &CSOTFPartyInvite| { &m.members },
            |m: &mut CSOTFPartyInvite| { &mut m.members },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CSOTFPartyInvite| { &m.type_ },
            |m: &mut CSOTFPartyInvite| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOTFPartyInvite>(
            "CSOTFPartyInvite",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOTFPartyInvite {
    const NAME: &'static str = "CSOTFPartyInvite";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.inviter = ::std::option::Option::Some(is.read_fixed64()?);
                },
                34 => {
                    self.members.push(is.read_message()?);
                },
                40 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.inviter {
            my_size += 1 + 8;
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.inviter {
            os.write_fixed64(2, v)?;
        }
        for v in &self.members {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.type_ {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOTFPartyInvite {
        CSOTFPartyInvite::new()
    }

    fn clear(&mut self) {
        self.group_id = ::std::option::Option::None;
        self.inviter = ::std::option::Option::None;
        self.members.clear();
        self.type_ = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOTFPartyInvite {
        static instance: CSOTFPartyInvite = CSOTFPartyInvite {
            group_id: ::std::option::Option::None,
            inviter: ::std::option::Option::None,
            members: ::std::vec::Vec::new(),
            type_: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOTFPartyInvite {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOTFPartyInvite").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOTFPartyInvite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOTFPartyInvite {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CSOTFPartyInvite`
pub mod csotfparty_invite {
    // @@protoc_insertion_point(message:CSOTFPartyInvite.PartyMember)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PartyMember {
        // message fields
        // @@protoc_insertion_point(field:CSOTFPartyInvite.PartyMember.steamid)
        pub steamid: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CSOTFPartyInvite.PartyMember.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PartyMember {
        fn default() -> &'a PartyMember {
            <PartyMember as ::protobuf::Message>::default_instance()
        }
    }

    impl PartyMember {
        pub fn new() -> PartyMember {
            ::std::default::Default::default()
        }

        // optional fixed64 steamid = 2;

        pub fn steamid(&self) -> u64 {
            self.steamid.unwrap_or(0)
        }

        pub fn clear_steamid(&mut self) {
            self.steamid = ::std::option::Option::None;
        }

        pub fn has_steamid(&self) -> bool {
            self.steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid(&mut self, v: u64) {
            self.steamid = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "steamid",
                |m: &PartyMember| { &m.steamid },
                |m: &mut PartyMember| { &mut m.steamid },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PartyMember>(
                "CSOTFPartyInvite.PartyMember",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PartyMember {
        const NAME: &'static str = "PartyMember";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    17 => {
                        self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steamid {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steamid {
                os.write_fixed64(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PartyMember {
            PartyMember::new()
        }

        fn clear(&mut self) {
            self.steamid = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PartyMember {
            static instance: PartyMember = PartyMember {
                steamid: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PartyMember {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CSOTFPartyInvite.PartyMember").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PartyMember {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PartyMember {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CSOTFPartyInvite.Type)
    pub enum Type {
        // @@protoc_insertion_point(enum_value:CSOTFPartyInvite.Type.PENDING_INVITE)
        PENDING_INVITE = 1,
        // @@protoc_insertion_point(enum_value:CSOTFPartyInvite.Type.PENDING_JOIN_REQUEST)
        PENDING_JOIN_REQUEST = 2,
    }

    impl ::protobuf::Enum for Type {
        const NAME: &'static str = "Type";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Type> {
            match value {
                1 => ::std::option::Option::Some(Type::PENDING_INVITE),
                2 => ::std::option::Option::Some(Type::PENDING_JOIN_REQUEST),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Type> {
            match str {
                "PENDING_INVITE" => ::std::option::Option::Some(Type::PENDING_INVITE),
                "PENDING_JOIN_REQUEST" => ::std::option::Option::Some(Type::PENDING_JOIN_REQUEST),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Type] = &[
            Type::PENDING_INVITE,
            Type::PENDING_JOIN_REQUEST,
        ];
    }

    impl ::protobuf::EnumFull for Type {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CSOTFPartyInvite.Type").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Type::PENDING_INVITE => 0,
                Type::PENDING_JOIN_REQUEST => 1,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Type {
        fn default() -> Self {
            Type::PENDING_INVITE
        }
    }

    impl Type {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Type>("CSOTFPartyInvite.Type")
        }
    }
}

// @@protoc_insertion_point(message:CTFLobbyPlayerProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CTFLobbyPlayerProto {
    // message fields
    // @@protoc_insertion_point(field:CTFLobbyPlayerProto.id)
    pub id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CTFLobbyPlayerProto.team)
    pub team: ::std::option::Option<::protobuf::EnumOrUnknown<TF_GC_TEAM>>,
    // @@protoc_insertion_point(field:CTFLobbyPlayerProto.connect_state)
    pub connect_state: ::std::option::Option<::protobuf::EnumOrUnknown<ctflobby_player_proto::ConnectState>>,
    // @@protoc_insertion_point(field:CTFLobbyPlayerProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CTFLobbyPlayerProto.original_party_id)
    pub original_party_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CTFLobbyPlayerProto.squad_surplus)
    pub squad_surplus: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CTFLobbyPlayerProto.badge_level)
    pub badge_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CTFLobbyPlayerProto.last_connect_time)
    pub last_connect_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CTFLobbyPlayerProto.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<ctflobby_player_proto::Type>>,
    // @@protoc_insertion_point(field:CTFLobbyPlayerProto.normalized_rating)
    pub normalized_rating: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CTFLobbyPlayerProto.normalized_uncertainty)
    pub normalized_uncertainty: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CTFLobbyPlayerProto.rank)
    pub rank: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CTFLobbyPlayerProto.chat_suspension)
    pub chat_suspension: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CTFLobbyPlayerProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CTFLobbyPlayerProto {
    fn default() -> &'a CTFLobbyPlayerProto {
        <CTFLobbyPlayerProto as ::protobuf::Message>::default_instance()
    }
}

impl CTFLobbyPlayerProto {
    pub fn new() -> CTFLobbyPlayerProto {
        ::std::default::Default::default()
    }

    // optional fixed64 id = 1;

    pub fn id(&self) -> u64 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional .TF_GC_TEAM team = 3;

    pub fn team(&self) -> TF_GC_TEAM {
        match self.team {
            Some(e) => e.enum_value_or(TF_GC_TEAM::TF_GC_TEAM_DEFENDERS),
            None => TF_GC_TEAM::TF_GC_TEAM_DEFENDERS,
        }
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: TF_GC_TEAM) {
        self.team = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .CTFLobbyPlayerProto.ConnectState connect_state = 13;

    pub fn connect_state(&self) -> ctflobby_player_proto::ConnectState {
        match self.connect_state {
            Some(e) => e.enum_value_or(ctflobby_player_proto::ConnectState::INVALID),
            None => ctflobby_player_proto::ConnectState::INVALID,
        }
    }

    pub fn clear_connect_state(&mut self) {
        self.connect_state = ::std::option::Option::None;
    }

    pub fn has_connect_state(&self) -> bool {
        self.connect_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connect_state(&mut self, v: ctflobby_player_proto::ConnectState) {
        self.connect_state = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string name = 6;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 original_party_id = 12;

    pub fn original_party_id(&self) -> u64 {
        self.original_party_id.unwrap_or(0)
    }

    pub fn clear_original_party_id(&mut self) {
        self.original_party_id = ::std::option::Option::None;
    }

    pub fn has_original_party_id(&self) -> bool {
        self.original_party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_party_id(&mut self, v: u64) {
        self.original_party_id = ::std::option::Option::Some(v);
    }

    // optional bool squad_surplus = 14;

    pub fn squad_surplus(&self) -> bool {
        self.squad_surplus.unwrap_or(false)
    }

    pub fn clear_squad_surplus(&mut self) {
        self.squad_surplus = ::std::option::Option::None;
    }

    pub fn has_squad_surplus(&self) -> bool {
        self.squad_surplus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_squad_surplus(&mut self, v: bool) {
        self.squad_surplus = ::std::option::Option::Some(v);
    }

    // optional uint32 badge_level = 15;

    pub fn badge_level(&self) -> u32 {
        self.badge_level.unwrap_or(0)
    }

    pub fn clear_badge_level(&mut self) {
        self.badge_level = ::std::option::Option::None;
    }

    pub fn has_badge_level(&self) -> bool {
        self.badge_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_badge_level(&mut self, v: u32) {
        self.badge_level = ::std::option::Option::Some(v);
    }

    // optional uint32 last_connect_time = 17;

    pub fn last_connect_time(&self) -> u32 {
        self.last_connect_time.unwrap_or(0)
    }

    pub fn clear_last_connect_time(&mut self) {
        self.last_connect_time = ::std::option::Option::None;
    }

    pub fn has_last_connect_time(&self) -> bool {
        self.last_connect_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_connect_time(&mut self, v: u32) {
        self.last_connect_time = ::std::option::Option::Some(v);
    }

    // optional .CTFLobbyPlayerProto.Type type = 19;

    pub fn type_(&self) -> ctflobby_player_proto::Type {
        match self.type_ {
            Some(e) => e.enum_value_or(ctflobby_player_proto::Type::INVALID_PLAYER),
            None => ctflobby_player_proto::Type::INVALID_PLAYER,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ctflobby_player_proto::Type) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional double normalized_rating = 20;

    pub fn normalized_rating(&self) -> f64 {
        self.normalized_rating.unwrap_or(0.)
    }

    pub fn clear_normalized_rating(&mut self) {
        self.normalized_rating = ::std::option::Option::None;
    }

    pub fn has_normalized_rating(&self) -> bool {
        self.normalized_rating.is_some()
    }

    // Param is passed by value, moved
    pub fn set_normalized_rating(&mut self, v: f64) {
        self.normalized_rating = ::std::option::Option::Some(v);
    }

    // optional double normalized_uncertainty = 22;

    pub fn normalized_uncertainty(&self) -> f64 {
        self.normalized_uncertainty.unwrap_or(0.)
    }

    pub fn clear_normalized_uncertainty(&mut self) {
        self.normalized_uncertainty = ::std::option::Option::None;
    }

    pub fn has_normalized_uncertainty(&self) -> bool {
        self.normalized_uncertainty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_normalized_uncertainty(&mut self, v: f64) {
        self.normalized_uncertainty = ::std::option::Option::Some(v);
    }

    // optional uint32 rank = 21;

    pub fn rank(&self) -> u32 {
        self.rank.unwrap_or(0)
    }

    pub fn clear_rank(&mut self) {
        self.rank = ::std::option::Option::None;
    }

    pub fn has_rank(&self) -> bool {
        self.rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank(&mut self, v: u32) {
        self.rank = ::std::option::Option::Some(v);
    }

    // optional bool chat_suspension = 23;

    pub fn chat_suspension(&self) -> bool {
        self.chat_suspension.unwrap_or(false)
    }

    pub fn clear_chat_suspension(&mut self) {
        self.chat_suspension = ::std::option::Option::None;
    }

    pub fn has_chat_suspension(&self) -> bool {
        self.chat_suspension.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_suspension(&mut self, v: bool) {
        self.chat_suspension = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &CTFLobbyPlayerProto| { &m.id },
            |m: &mut CTFLobbyPlayerProto| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team",
            |m: &CTFLobbyPlayerProto| { &m.team },
            |m: &mut CTFLobbyPlayerProto| { &mut m.team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "connect_state",
            |m: &CTFLobbyPlayerProto| { &m.connect_state },
            |m: &mut CTFLobbyPlayerProto| { &mut m.connect_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CTFLobbyPlayerProto| { &m.name },
            |m: &mut CTFLobbyPlayerProto| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "original_party_id",
            |m: &CTFLobbyPlayerProto| { &m.original_party_id },
            |m: &mut CTFLobbyPlayerProto| { &mut m.original_party_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "squad_surplus",
            |m: &CTFLobbyPlayerProto| { &m.squad_surplus },
            |m: &mut CTFLobbyPlayerProto| { &mut m.squad_surplus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "badge_level",
            |m: &CTFLobbyPlayerProto| { &m.badge_level },
            |m: &mut CTFLobbyPlayerProto| { &mut m.badge_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_connect_time",
            |m: &CTFLobbyPlayerProto| { &m.last_connect_time },
            |m: &mut CTFLobbyPlayerProto| { &mut m.last_connect_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CTFLobbyPlayerProto| { &m.type_ },
            |m: &mut CTFLobbyPlayerProto| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "normalized_rating",
            |m: &CTFLobbyPlayerProto| { &m.normalized_rating },
            |m: &mut CTFLobbyPlayerProto| { &mut m.normalized_rating },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "normalized_uncertainty",
            |m: &CTFLobbyPlayerProto| { &m.normalized_uncertainty },
            |m: &mut CTFLobbyPlayerProto| { &mut m.normalized_uncertainty },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rank",
            |m: &CTFLobbyPlayerProto| { &m.rank },
            |m: &mut CTFLobbyPlayerProto| { &mut m.rank },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_suspension",
            |m: &CTFLobbyPlayerProto| { &m.chat_suspension },
            |m: &mut CTFLobbyPlayerProto| { &mut m.chat_suspension },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CTFLobbyPlayerProto>(
            "CTFLobbyPlayerProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CTFLobbyPlayerProto {
    const NAME: &'static str = "CTFLobbyPlayerProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.team = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                104 => {
                    self.connect_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                50 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                96 => {
                    self.original_party_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                112 => {
                    self.squad_surplus = ::std::option::Option::Some(is.read_bool()?);
                },
                120 => {
                    self.badge_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.last_connect_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                161 => {
                    self.normalized_rating = ::std::option::Option::Some(is.read_double()?);
                },
                177 => {
                    self.normalized_uncertainty = ::std::option::Option::Some(is.read_double()?);
                },
                168 => {
                    self.rank = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.chat_suspension = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.connect_state {
            my_size += ::protobuf::rt::int32_size(13, v.value());
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.original_party_id {
            my_size += ::protobuf::rt::uint64_size(12, v);
        }
        if let Some(v) = self.squad_surplus {
            my_size += 1 + 1;
        }
        if let Some(v) = self.badge_level {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.last_connect_time {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(19, v.value());
        }
        if let Some(v) = self.normalized_rating {
            my_size += 2 + 8;
        }
        if let Some(v) = self.normalized_uncertainty {
            my_size += 2 + 8;
        }
        if let Some(v) = self.rank {
            my_size += ::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.chat_suspension {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.team {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.connect_state {
            os.write_enum(13, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.original_party_id {
            os.write_uint64(12, v)?;
        }
        if let Some(v) = self.squad_surplus {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.badge_level {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.last_connect_time {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(19, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.normalized_rating {
            os.write_double(20, v)?;
        }
        if let Some(v) = self.normalized_uncertainty {
            os.write_double(22, v)?;
        }
        if let Some(v) = self.rank {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.chat_suspension {
            os.write_bool(23, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CTFLobbyPlayerProto {
        CTFLobbyPlayerProto::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.team = ::std::option::Option::None;
        self.connect_state = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.original_party_id = ::std::option::Option::None;
        self.squad_surplus = ::std::option::Option::None;
        self.badge_level = ::std::option::Option::None;
        self.last_connect_time = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.normalized_rating = ::std::option::Option::None;
        self.normalized_uncertainty = ::std::option::Option::None;
        self.rank = ::std::option::Option::None;
        self.chat_suspension = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CTFLobbyPlayerProto {
        static instance: CTFLobbyPlayerProto = CTFLobbyPlayerProto {
            id: ::std::option::Option::None,
            team: ::std::option::Option::None,
            connect_state: ::std::option::Option::None,
            name: ::std::option::Option::None,
            original_party_id: ::std::option::Option::None,
            squad_surplus: ::std::option::Option::None,
            badge_level: ::std::option::Option::None,
            last_connect_time: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            normalized_rating: ::std::option::Option::None,
            normalized_uncertainty: ::std::option::Option::None,
            rank: ::std::option::Option::None,
            chat_suspension: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CTFLobbyPlayerProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CTFLobbyPlayerProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CTFLobbyPlayerProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CTFLobbyPlayerProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CTFLobbyPlayerProto`
pub mod ctflobby_player_proto {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CTFLobbyPlayerProto.ConnectState)
    pub enum ConnectState {
        // @@protoc_insertion_point(enum_value:CTFLobbyPlayerProto.ConnectState.INVALID)
        INVALID = 0,
        // @@protoc_insertion_point(enum_value:CTFLobbyPlayerProto.ConnectState.RESERVATION_PENDING)
        RESERVATION_PENDING = 1,
        // @@protoc_insertion_point(enum_value:CTFLobbyPlayerProto.ConnectState.RESERVED)
        RESERVED = 2,
        // @@protoc_insertion_point(enum_value:CTFLobbyPlayerProto.ConnectState.CONNECTED)
        CONNECTED = 3,
        // @@protoc_insertion_point(enum_value:CTFLobbyPlayerProto.ConnectState.DISCONNECTED)
        DISCONNECTED = 5,
    }

    impl ::protobuf::Enum for ConnectState {
        const NAME: &'static str = "ConnectState";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ConnectState> {
            match value {
                0 => ::std::option::Option::Some(ConnectState::INVALID),
                1 => ::std::option::Option::Some(ConnectState::RESERVATION_PENDING),
                2 => ::std::option::Option::Some(ConnectState::RESERVED),
                3 => ::std::option::Option::Some(ConnectState::CONNECTED),
                5 => ::std::option::Option::Some(ConnectState::DISCONNECTED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ConnectState> {
            match str {
                "INVALID" => ::std::option::Option::Some(ConnectState::INVALID),
                "RESERVATION_PENDING" => ::std::option::Option::Some(ConnectState::RESERVATION_PENDING),
                "RESERVED" => ::std::option::Option::Some(ConnectState::RESERVED),
                "CONNECTED" => ::std::option::Option::Some(ConnectState::CONNECTED),
                "DISCONNECTED" => ::std::option::Option::Some(ConnectState::DISCONNECTED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ConnectState] = &[
            ConnectState::INVALID,
            ConnectState::RESERVATION_PENDING,
            ConnectState::RESERVED,
            ConnectState::CONNECTED,
            ConnectState::DISCONNECTED,
        ];
    }

    impl ::protobuf::EnumFull for ConnectState {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CTFLobbyPlayerProto.ConnectState").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                ConnectState::INVALID => 0,
                ConnectState::RESERVATION_PENDING => 1,
                ConnectState::RESERVED => 2,
                ConnectState::CONNECTED => 3,
                ConnectState::DISCONNECTED => 4,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ConnectState {
        fn default() -> Self {
            ConnectState::INVALID
        }
    }

    impl ConnectState {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ConnectState>("CTFLobbyPlayerProto.ConnectState")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CTFLobbyPlayerProto.Type)
    pub enum Type {
        // @@protoc_insertion_point(enum_value:CTFLobbyPlayerProto.Type.INVALID_PLAYER)
        INVALID_PLAYER = 0,
        // @@protoc_insertion_point(enum_value:CTFLobbyPlayerProto.Type.MATCH_PLAYER)
        MATCH_PLAYER = 1,
        // @@protoc_insertion_point(enum_value:CTFLobbyPlayerProto.Type.STANDBY_PLAYER)
        STANDBY_PLAYER = 2,
        // @@protoc_insertion_point(enum_value:CTFLobbyPlayerProto.Type.OBSERVING_PLAYER)
        OBSERVING_PLAYER = 3,
    }

    impl ::protobuf::Enum for Type {
        const NAME: &'static str = "Type";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Type> {
            match value {
                0 => ::std::option::Option::Some(Type::INVALID_PLAYER),
                1 => ::std::option::Option::Some(Type::MATCH_PLAYER),
                2 => ::std::option::Option::Some(Type::STANDBY_PLAYER),
                3 => ::std::option::Option::Some(Type::OBSERVING_PLAYER),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Type> {
            match str {
                "INVALID_PLAYER" => ::std::option::Option::Some(Type::INVALID_PLAYER),
                "MATCH_PLAYER" => ::std::option::Option::Some(Type::MATCH_PLAYER),
                "STANDBY_PLAYER" => ::std::option::Option::Some(Type::STANDBY_PLAYER),
                "OBSERVING_PLAYER" => ::std::option::Option::Some(Type::OBSERVING_PLAYER),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Type] = &[
            Type::INVALID_PLAYER,
            Type::MATCH_PLAYER,
            Type::STANDBY_PLAYER,
            Type::OBSERVING_PLAYER,
        ];
    }

    impl ::protobuf::EnumFull for Type {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CTFLobbyPlayerProto.Type").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Type {
        fn default() -> Self {
            Type::INVALID_PLAYER
        }
    }

    impl Type {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Type>("CTFLobbyPlayerProto.Type")
        }
    }
}

// @@protoc_insertion_point(message:CTFLobbyInviteProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CTFLobbyInviteProto {
    // message fields
    // @@protoc_insertion_point(field:CTFLobbyInviteProto.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CTFLobbyInviteProto.match_group)
    pub match_group: ::std::option::Option<::protobuf::EnumOrUnknown<ETFMatchGroup>>,
    // special fields
    // @@protoc_insertion_point(special_field:CTFLobbyInviteProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CTFLobbyInviteProto {
    fn default() -> &'a CTFLobbyInviteProto {
        <CTFLobbyInviteProto as ::protobuf::Message>::default_instance()
    }
}

impl CTFLobbyInviteProto {
    pub fn new() -> CTFLobbyInviteProto {
        ::std::default::Default::default()
    }

    // optional fixed64 lobby_id = 1;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional .ETFMatchGroup match_group = 2;

    pub fn match_group(&self) -> ETFMatchGroup {
        match self.match_group {
            Some(e) => e.enum_value_or(ETFMatchGroup::k_eTFMatchGroup_Invalid),
            None => ETFMatchGroup::k_eTFMatchGroup_Invalid,
        }
    }

    pub fn clear_match_group(&mut self) {
        self.match_group = ::std::option::Option::None;
    }

    pub fn has_match_group(&self) -> bool {
        self.match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_group(&mut self, v: ETFMatchGroup) {
        self.match_group = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_id",
            |m: &CTFLobbyInviteProto| { &m.lobby_id },
            |m: &mut CTFLobbyInviteProto| { &mut m.lobby_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_group",
            |m: &CTFLobbyInviteProto| { &m.match_group },
            |m: &mut CTFLobbyInviteProto| { &mut m.match_group },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CTFLobbyInviteProto>(
            "CTFLobbyInviteProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CTFLobbyInviteProto {
    const NAME: &'static str = "CTFLobbyInviteProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.match_group = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.match_group {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.lobby_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.match_group {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CTFLobbyInviteProto {
        CTFLobbyInviteProto::new()
    }

    fn clear(&mut self) {
        self.lobby_id = ::std::option::Option::None;
        self.match_group = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CTFLobbyInviteProto {
        static instance: CTFLobbyInviteProto = CTFLobbyInviteProto {
            lobby_id: ::std::option::Option::None,
            match_group: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CTFLobbyInviteProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CTFLobbyInviteProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CTFLobbyInviteProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CTFLobbyInviteProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSOTFGameServerLobby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOTFGameServerLobby {
    // message fields
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.members)
    pub members: ::std::vec::Vec<CTFLobbyPlayerProto>,
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.server_id)
    pub server_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.state)
    pub state: ::std::option::Option<::protobuf::EnumOrUnknown<csotfgame_server_lobby::State>>,
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.connect)
    pub connect: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.game_state)
    pub game_state: ::std::option::Option<::protobuf::EnumOrUnknown<TF_GC_GameState>>,
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.initial_average_mm_rating)
    pub initial_average_mm_rating: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.mannup_tour_name)
    pub mannup_tour_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.map_name)
    pub map_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.mission_name)
    pub mission_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.match_group)
    pub match_group: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.formed_time)
    pub formed_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.late_join_eligible)
    pub late_join_eligible: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.fixed_match_size)
    pub fixed_match_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.is_war_match)
    pub is_war_match: ::std::option::Option<::protobuf::EnumOrUnknown<csotfgame_server_lobby::WarMatch>>,
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.next_maps_for_vote)
    pub next_maps_for_vote: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.lobby_mm_version)
    pub lobby_mm_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.pending_members)
    pub pending_members: ::std::vec::Vec<CTFLobbyPlayerProto>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOTFGameServerLobby.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOTFGameServerLobby {
    fn default() -> &'a CSOTFGameServerLobby {
        <CSOTFGameServerLobby as ::protobuf::Message>::default_instance()
    }
}

impl CSOTFGameServerLobby {
    pub fn new() -> CSOTFGameServerLobby {
        ::std::default::Default::default()
    }

    // optional uint64 lobby_id = 1;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 server_id = 6;

    pub fn server_id(&self) -> u64 {
        self.server_id.unwrap_or(0u64)
    }

    pub fn clear_server_id(&mut self) {
        self.server_id = ::std::option::Option::None;
    }

    pub fn has_server_id(&self) -> bool {
        self.server_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_id(&mut self, v: u64) {
        self.server_id = ::std::option::Option::Some(v);
    }

    // optional .CSOTFGameServerLobby.State state = 4;

    pub fn state(&self) -> csotfgame_server_lobby::State {
        match self.state {
            Some(e) => e.enum_value_or(csotfgame_server_lobby::State::UNKNOWN),
            None => csotfgame_server_lobby::State::UNKNOWN,
        }
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: csotfgame_server_lobby::State) {
        self.state = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string connect = 5;

    pub fn connect(&self) -> &str {
        match self.connect.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_connect(&mut self) {
        self.connect = ::std::option::Option::None;
    }

    pub fn has_connect(&self) -> bool {
        self.connect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connect(&mut self, v: ::std::string::String) {
        self.connect = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connect(&mut self) -> &mut ::std::string::String {
        if self.connect.is_none() {
            self.connect = ::std::option::Option::Some(::std::string::String::new());
        }
        self.connect.as_mut().unwrap()
    }

    // Take field
    pub fn take_connect(&mut self) -> ::std::string::String {
        self.connect.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .TF_GC_GameState game_state = 22;

    pub fn game_state(&self) -> TF_GC_GameState {
        match self.game_state {
            Some(e) => e.enum_value_or(TF_GC_GameState::TF_GC_GAMESTATE_STATE_INIT),
            None => TF_GC_GameState::TF_GC_GAMESTATE_STATE_INIT,
        }
    }

    pub fn clear_game_state(&mut self) {
        self.game_state = ::std::option::Option::None;
    }

    pub fn has_game_state(&self) -> bool {
        self.game_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_state(&mut self, v: TF_GC_GameState) {
        self.game_state = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional double initial_average_mm_rating = 32;

    pub fn initial_average_mm_rating(&self) -> f64 {
        self.initial_average_mm_rating.unwrap_or(0.)
    }

    pub fn clear_initial_average_mm_rating(&mut self) {
        self.initial_average_mm_rating = ::std::option::Option::None;
    }

    pub fn has_initial_average_mm_rating(&self) -> bool {
        self.initial_average_mm_rating.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_average_mm_rating(&mut self, v: f64) {
        self.initial_average_mm_rating = ::std::option::Option::Some(v);
    }

    // optional string mannup_tour_name = 42;

    pub fn mannup_tour_name(&self) -> &str {
        match self.mannup_tour_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mannup_tour_name(&mut self) {
        self.mannup_tour_name = ::std::option::Option::None;
    }

    pub fn has_mannup_tour_name(&self) -> bool {
        self.mannup_tour_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mannup_tour_name(&mut self, v: ::std::string::String) {
        self.mannup_tour_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mannup_tour_name(&mut self) -> &mut ::std::string::String {
        if self.mannup_tour_name.is_none() {
            self.mannup_tour_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mannup_tour_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_mannup_tour_name(&mut self) -> ::std::string::String {
        self.mannup_tour_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string map_name = 38;

    pub fn map_name(&self) -> &str {
        match self.map_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_map_name(&mut self) {
        self.map_name = ::std::option::Option::None;
    }

    pub fn has_map_name(&self) -> bool {
        self.map_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_name(&mut self, v: ::std::string::String) {
        self.map_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_name(&mut self) -> &mut ::std::string::String {
        if self.map_name.is_none() {
            self.map_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.map_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_map_name(&mut self) -> ::std::string::String {
        self.map_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mission_name = 39;

    pub fn mission_name(&self) -> &str {
        match self.mission_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mission_name(&mut self) {
        self.mission_name = ::std::option::Option::None;
    }

    pub fn has_mission_name(&self) -> bool {
        self.mission_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mission_name(&mut self, v: ::std::string::String) {
        self.mission_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mission_name(&mut self) -> &mut ::std::string::String {
        if self.mission_name.is_none() {
            self.mission_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mission_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_mission_name(&mut self) -> ::std::string::String {
        self.mission_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 match_group = 41;

    pub fn match_group(&self) -> u32 {
        self.match_group.unwrap_or(0)
    }

    pub fn clear_match_group(&mut self) {
        self.match_group = ::std::option::Option::None;
    }

    pub fn has_match_group(&self) -> bool {
        self.match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_group(&mut self, v: u32) {
        self.match_group = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 30;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0u64)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 formed_time = 36;

    pub fn formed_time(&self) -> u32 {
        self.formed_time.unwrap_or(0)
    }

    pub fn clear_formed_time(&mut self) {
        self.formed_time = ::std::option::Option::None;
    }

    pub fn has_formed_time(&self) -> bool {
        self.formed_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_formed_time(&mut self, v: u32) {
        self.formed_time = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 43;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional bool late_join_eligible = 44;

    pub fn late_join_eligible(&self) -> bool {
        self.late_join_eligible.unwrap_or(false)
    }

    pub fn clear_late_join_eligible(&mut self) {
        self.late_join_eligible = ::std::option::Option::None;
    }

    pub fn has_late_join_eligible(&self) -> bool {
        self.late_join_eligible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_late_join_eligible(&mut self, v: bool) {
        self.late_join_eligible = ::std::option::Option::Some(v);
    }

    // optional uint32 fixed_match_size = 45;

    pub fn fixed_match_size(&self) -> u32 {
        self.fixed_match_size.unwrap_or(0)
    }

    pub fn clear_fixed_match_size(&mut self) {
        self.fixed_match_size = ::std::option::Option::None;
    }

    pub fn has_fixed_match_size(&self) -> bool {
        self.fixed_match_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fixed_match_size(&mut self, v: u32) {
        self.fixed_match_size = ::std::option::Option::Some(v);
    }

    // optional .CSOTFGameServerLobby.WarMatch is_war_match = 46;

    pub fn is_war_match(&self) -> csotfgame_server_lobby::WarMatch {
        match self.is_war_match {
            Some(e) => e.enum_value_or(csotfgame_server_lobby::WarMatch::NOPE),
            None => csotfgame_server_lobby::WarMatch::NOPE,
        }
    }

    pub fn clear_is_war_match(&mut self) {
        self.is_war_match = ::std::option::Option::None;
    }

    pub fn has_is_war_match(&self) -> bool {
        self.is_war_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_war_match(&mut self, v: csotfgame_server_lobby::WarMatch) {
        self.is_war_match = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 lobby_mm_version = 48;

    pub fn lobby_mm_version(&self) -> u32 {
        self.lobby_mm_version.unwrap_or(0)
    }

    pub fn clear_lobby_mm_version(&mut self) {
        self.lobby_mm_version = ::std::option::Option::None;
    }

    pub fn has_lobby_mm_version(&self) -> bool {
        self.lobby_mm_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_mm_version(&mut self, v: u32) {
        self.lobby_mm_version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(20);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_id",
            |m: &CSOTFGameServerLobby| { &m.lobby_id },
            |m: &mut CSOTFGameServerLobby| { &mut m.lobby_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "members",
            |m: &CSOTFGameServerLobby| { &m.members },
            |m: &mut CSOTFGameServerLobby| { &mut m.members },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_id",
            |m: &CSOTFGameServerLobby| { &m.server_id },
            |m: &mut CSOTFGameServerLobby| { &mut m.server_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "state",
            |m: &CSOTFGameServerLobby| { &m.state },
            |m: &mut CSOTFGameServerLobby| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "connect",
            |m: &CSOTFGameServerLobby| { &m.connect },
            |m: &mut CSOTFGameServerLobby| { &mut m.connect },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_state",
            |m: &CSOTFGameServerLobby| { &m.game_state },
            |m: &mut CSOTFGameServerLobby| { &mut m.game_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "initial_average_mm_rating",
            |m: &CSOTFGameServerLobby| { &m.initial_average_mm_rating },
            |m: &mut CSOTFGameServerLobby| { &mut m.initial_average_mm_rating },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mannup_tour_name",
            |m: &CSOTFGameServerLobby| { &m.mannup_tour_name },
            |m: &mut CSOTFGameServerLobby| { &mut m.mannup_tour_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map_name",
            |m: &CSOTFGameServerLobby| { &m.map_name },
            |m: &mut CSOTFGameServerLobby| { &mut m.map_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mission_name",
            |m: &CSOTFGameServerLobby| { &m.mission_name },
            |m: &mut CSOTFGameServerLobby| { &mut m.mission_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_group",
            |m: &CSOTFGameServerLobby| { &m.match_group },
            |m: &mut CSOTFGameServerLobby| { &mut m.match_group },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CSOTFGameServerLobby| { &m.match_id },
            |m: &mut CSOTFGameServerLobby| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "formed_time",
            |m: &CSOTFGameServerLobby| { &m.formed_time },
            |m: &mut CSOTFGameServerLobby| { &mut m.formed_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CSOTFGameServerLobby| { &m.flags },
            |m: &mut CSOTFGameServerLobby| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "late_join_eligible",
            |m: &CSOTFGameServerLobby| { &m.late_join_eligible },
            |m: &mut CSOTFGameServerLobby| { &mut m.late_join_eligible },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fixed_match_size",
            |m: &CSOTFGameServerLobby| { &m.fixed_match_size },
            |m: &mut CSOTFGameServerLobby| { &mut m.fixed_match_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_war_match",
            |m: &CSOTFGameServerLobby| { &m.is_war_match },
            |m: &mut CSOTFGameServerLobby| { &mut m.is_war_match },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "next_maps_for_vote",
            |m: &CSOTFGameServerLobby| { &m.next_maps_for_vote },
            |m: &mut CSOTFGameServerLobby| { &mut m.next_maps_for_vote },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_mm_version",
            |m: &CSOTFGameServerLobby| { &m.lobby_mm_version },
            |m: &mut CSOTFGameServerLobby| { &mut m.lobby_mm_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pending_members",
            |m: &CSOTFGameServerLobby| { &m.pending_members },
            |m: &mut CSOTFGameServerLobby| { &mut m.pending_members },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOTFGameServerLobby>(
            "CSOTFGameServerLobby",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOTFGameServerLobby {
    const NAME: &'static str = "CSOTFGameServerLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.members.push(is.read_message()?);
                },
                49 => {
                    self.server_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                32 => {
                    self.state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                42 => {
                    self.connect = ::std::option::Option::Some(is.read_string()?);
                },
                176 => {
                    self.game_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                257 => {
                    self.initial_average_mm_rating = ::std::option::Option::Some(is.read_double()?);
                },
                338 => {
                    self.mannup_tour_name = ::std::option::Option::Some(is.read_string()?);
                },
                306 => {
                    self.map_name = ::std::option::Option::Some(is.read_string()?);
                },
                314 => {
                    self.mission_name = ::std::option::Option::Some(is.read_string()?);
                },
                328 => {
                    self.match_group = ::std::option::Option::Some(is.read_uint32()?);
                },
                240 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                288 => {
                    self.formed_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                344 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                352 => {
                    self.late_join_eligible = ::std::option::Option::Some(is.read_bool()?);
                },
                360 => {
                    self.fixed_match_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                368 => {
                    self.is_war_match = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                378 => {
                    is.read_repeated_packed_uint32_into(&mut self.next_maps_for_vote)?;
                },
                376 => {
                    self.next_maps_for_vote.push(is.read_uint32()?);
                },
                384 => {
                    self.lobby_mm_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                394 => {
                    self.pending_members.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.server_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.connect.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.game_state {
            my_size += ::protobuf::rt::int32_size(22, v.value());
        }
        if let Some(v) = self.initial_average_mm_rating {
            my_size += 2 + 8;
        }
        if let Some(v) = self.mannup_tour_name.as_ref() {
            my_size += ::protobuf::rt::string_size(42, &v);
        }
        if let Some(v) = self.map_name.as_ref() {
            my_size += ::protobuf::rt::string_size(38, &v);
        }
        if let Some(v) = self.mission_name.as_ref() {
            my_size += ::protobuf::rt::string_size(39, &v);
        }
        if let Some(v) = self.match_group {
            my_size += ::protobuf::rt::uint32_size(41, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(30, v);
        }
        if let Some(v) = self.formed_time {
            my_size += ::protobuf::rt::uint32_size(36, v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(43, v);
        }
        if let Some(v) = self.late_join_eligible {
            my_size += 2 + 1;
        }
        if let Some(v) = self.fixed_match_size {
            my_size += ::protobuf::rt::uint32_size(45, v);
        }
        if let Some(v) = self.is_war_match {
            my_size += ::protobuf::rt::int32_size(46, v.value());
        }
        for value in &self.next_maps_for_vote {
            my_size += ::protobuf::rt::uint32_size(47, *value);
        };
        if let Some(v) = self.lobby_mm_version {
            my_size += ::protobuf::rt::uint32_size(48, v);
        }
        for value in &self.pending_members {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.lobby_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.members {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.server_id {
            os.write_fixed64(6, v)?;
        }
        if let Some(v) = self.state {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.connect.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.game_state {
            os.write_enum(22, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.initial_average_mm_rating {
            os.write_double(32, v)?;
        }
        if let Some(v) = self.mannup_tour_name.as_ref() {
            os.write_string(42, v)?;
        }
        if let Some(v) = self.map_name.as_ref() {
            os.write_string(38, v)?;
        }
        if let Some(v) = self.mission_name.as_ref() {
            os.write_string(39, v)?;
        }
        if let Some(v) = self.match_group {
            os.write_uint32(41, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(30, v)?;
        }
        if let Some(v) = self.formed_time {
            os.write_uint32(36, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(43, v)?;
        }
        if let Some(v) = self.late_join_eligible {
            os.write_bool(44, v)?;
        }
        if let Some(v) = self.fixed_match_size {
            os.write_uint32(45, v)?;
        }
        if let Some(v) = self.is_war_match {
            os.write_enum(46, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.next_maps_for_vote {
            os.write_uint32(47, *v)?;
        };
        if let Some(v) = self.lobby_mm_version {
            os.write_uint32(48, v)?;
        }
        for v in &self.pending_members {
            ::protobuf::rt::write_message_field_with_cached_size(49, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOTFGameServerLobby {
        CSOTFGameServerLobby::new()
    }

    fn clear(&mut self) {
        self.lobby_id = ::std::option::Option::None;
        self.members.clear();
        self.server_id = ::std::option::Option::None;
        self.state = ::std::option::Option::None;
        self.connect = ::std::option::Option::None;
        self.game_state = ::std::option::Option::None;
        self.initial_average_mm_rating = ::std::option::Option::None;
        self.mannup_tour_name = ::std::option::Option::None;
        self.map_name = ::std::option::Option::None;
        self.mission_name = ::std::option::Option::None;
        self.match_group = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.formed_time = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.late_join_eligible = ::std::option::Option::None;
        self.fixed_match_size = ::std::option::Option::None;
        self.is_war_match = ::std::option::Option::None;
        self.next_maps_for_vote.clear();
        self.lobby_mm_version = ::std::option::Option::None;
        self.pending_members.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOTFGameServerLobby {
        static instance: CSOTFGameServerLobby = CSOTFGameServerLobby {
            lobby_id: ::std::option::Option::None,
            members: ::std::vec::Vec::new(),
            server_id: ::std::option::Option::None,
            state: ::std::option::Option::None,
            connect: ::std::option::Option::None,
            game_state: ::std::option::Option::None,
            initial_average_mm_rating: ::std::option::Option::None,
            mannup_tour_name: ::std::option::Option::None,
            map_name: ::std::option::Option::None,
            mission_name: ::std::option::Option::None,
            match_group: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            formed_time: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            late_join_eligible: ::std::option::Option::None,
            fixed_match_size: ::std::option::Option::None,
            is_war_match: ::std::option::Option::None,
            next_maps_for_vote: ::std::vec::Vec::new(),
            lobby_mm_version: ::std::option::Option::None,
            pending_members: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOTFGameServerLobby {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOTFGameServerLobby").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOTFGameServerLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOTFGameServerLobby {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CSOTFGameServerLobby`
pub mod csotfgame_server_lobby {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CSOTFGameServerLobby.State)
    pub enum State {
        // @@protoc_insertion_point(enum_value:CSOTFGameServerLobby.State.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:CSOTFGameServerLobby.State.SERVERSETUP)
        SERVERSETUP = 1,
        // @@protoc_insertion_point(enum_value:CSOTFGameServerLobby.State.RUN)
        RUN = 2,
    }

    impl ::protobuf::Enum for State {
        const NAME: &'static str = "State";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<State> {
            match value {
                0 => ::std::option::Option::Some(State::UNKNOWN),
                1 => ::std::option::Option::Some(State::SERVERSETUP),
                2 => ::std::option::Option::Some(State::RUN),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<State> {
            match str {
                "UNKNOWN" => ::std::option::Option::Some(State::UNKNOWN),
                "SERVERSETUP" => ::std::option::Option::Some(State::SERVERSETUP),
                "RUN" => ::std::option::Option::Some(State::RUN),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [State] = &[
            State::UNKNOWN,
            State::SERVERSETUP,
            State::RUN,
        ];
    }

    impl ::protobuf::EnumFull for State {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CSOTFGameServerLobby.State").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for State {
        fn default() -> Self {
            State::UNKNOWN
        }
    }

    impl State {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<State>("CSOTFGameServerLobby.State")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CSOTFGameServerLobby.WarMatch)
    pub enum WarMatch {
        // @@protoc_insertion_point(enum_value:CSOTFGameServerLobby.WarMatch.NOPE)
        NOPE = 0,
        // @@protoc_insertion_point(enum_value:CSOTFGameServerLobby.WarMatch.INVADERS_ARE_PYRO)
        INVADERS_ARE_PYRO = 1,
        // @@protoc_insertion_point(enum_value:CSOTFGameServerLobby.WarMatch.INVADERS_ARE_HEAVY)
        INVADERS_ARE_HEAVY = 2,
    }

    impl ::protobuf::Enum for WarMatch {
        const NAME: &'static str = "WarMatch";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<WarMatch> {
            match value {
                0 => ::std::option::Option::Some(WarMatch::NOPE),
                1 => ::std::option::Option::Some(WarMatch::INVADERS_ARE_PYRO),
                2 => ::std::option::Option::Some(WarMatch::INVADERS_ARE_HEAVY),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<WarMatch> {
            match str {
                "NOPE" => ::std::option::Option::Some(WarMatch::NOPE),
                "INVADERS_ARE_PYRO" => ::std::option::Option::Some(WarMatch::INVADERS_ARE_PYRO),
                "INVADERS_ARE_HEAVY" => ::std::option::Option::Some(WarMatch::INVADERS_ARE_HEAVY),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [WarMatch] = &[
            WarMatch::NOPE,
            WarMatch::INVADERS_ARE_PYRO,
            WarMatch::INVADERS_ARE_HEAVY,
        ];
    }

    impl ::protobuf::EnumFull for WarMatch {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CSOTFGameServerLobby.WarMatch").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for WarMatch {
        fn default() -> Self {
            WarMatch::NOPE
        }
    }

    impl WarMatch {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<WarMatch>("CSOTFGameServerLobby.WarMatch")
        }
    }
}

// @@protoc_insertion_point(message:CMsgExitMatchmaking)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgExitMatchmaking {
    // message fields
    // @@protoc_insertion_point(field:CMsgExitMatchmaking.explicit_abandon)
    pub explicit_abandon: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgExitMatchmaking.party_id)
    pub party_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgExitMatchmaking.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgExitMatchmaking.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgExitMatchmaking {
    fn default() -> &'a CMsgExitMatchmaking {
        <CMsgExitMatchmaking as ::protobuf::Message>::default_instance()
    }
}

impl CMsgExitMatchmaking {
    pub fn new() -> CMsgExitMatchmaking {
        ::std::default::Default::default()
    }

    // optional bool explicit_abandon = 1;

    pub fn explicit_abandon(&self) -> bool {
        self.explicit_abandon.unwrap_or(false)
    }

    pub fn clear_explicit_abandon(&mut self) {
        self.explicit_abandon = ::std::option::Option::None;
    }

    pub fn has_explicit_abandon(&self) -> bool {
        self.explicit_abandon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_explicit_abandon(&mut self, v: bool) {
        self.explicit_abandon = ::std::option::Option::Some(v);
    }

    // optional uint64 party_id = 2;

    pub fn party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }

    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional uint64 lobby_id = 3;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "explicit_abandon",
            |m: &CMsgExitMatchmaking| { &m.explicit_abandon },
            |m: &mut CMsgExitMatchmaking| { &mut m.explicit_abandon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "party_id",
            |m: &CMsgExitMatchmaking| { &m.party_id },
            |m: &mut CMsgExitMatchmaking| { &mut m.party_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_id",
            |m: &CMsgExitMatchmaking| { &m.lobby_id },
            |m: &mut CMsgExitMatchmaking| { &mut m.lobby_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgExitMatchmaking>(
            "CMsgExitMatchmaking",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgExitMatchmaking {
    const NAME: &'static str = "CMsgExitMatchmaking";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.explicit_abandon = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.party_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.explicit_abandon {
            my_size += 1 + 1;
        }
        if let Some(v) = self.party_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.lobby_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.explicit_abandon {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.party_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.lobby_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgExitMatchmaking {
        CMsgExitMatchmaking::new()
    }

    fn clear(&mut self) {
        self.explicit_abandon = ::std::option::Option::None;
        self.party_id = ::std::option::Option::None;
        self.lobby_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgExitMatchmaking {
        static instance: CMsgExitMatchmaking = CMsgExitMatchmaking {
            explicit_abandon: ::std::option::Option::None,
            party_id: ::std::option::Option::None,
            lobby_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgExitMatchmaking {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgExitMatchmaking").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgExitMatchmaking {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgExitMatchmaking {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgAcceptLobbyInvite)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAcceptLobbyInvite {
    // message fields
    // @@protoc_insertion_point(field:CMsgAcceptLobbyInvite.invited_lobby_id)
    pub invited_lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgAcceptLobbyInvite.abandoning_match_id)
    pub abandoning_match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgAcceptLobbyInvite.abandoning_invite_lobby_ids)
    pub abandoning_invite_lobby_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAcceptLobbyInvite.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAcceptLobbyInvite {
    fn default() -> &'a CMsgAcceptLobbyInvite {
        <CMsgAcceptLobbyInvite as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAcceptLobbyInvite {
    pub fn new() -> CMsgAcceptLobbyInvite {
        ::std::default::Default::default()
    }

    // optional uint64 invited_lobby_id = 1;

    pub fn invited_lobby_id(&self) -> u64 {
        self.invited_lobby_id.unwrap_or(0)
    }

    pub fn clear_invited_lobby_id(&mut self) {
        self.invited_lobby_id = ::std::option::Option::None;
    }

    pub fn has_invited_lobby_id(&self) -> bool {
        self.invited_lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invited_lobby_id(&mut self, v: u64) {
        self.invited_lobby_id = ::std::option::Option::Some(v);
    }

    // optional uint64 abandoning_match_id = 2;

    pub fn abandoning_match_id(&self) -> u64 {
        self.abandoning_match_id.unwrap_or(0)
    }

    pub fn clear_abandoning_match_id(&mut self) {
        self.abandoning_match_id = ::std::option::Option::None;
    }

    pub fn has_abandoning_match_id(&self) -> bool {
        self.abandoning_match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_abandoning_match_id(&mut self, v: u64) {
        self.abandoning_match_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "invited_lobby_id",
            |m: &CMsgAcceptLobbyInvite| { &m.invited_lobby_id },
            |m: &mut CMsgAcceptLobbyInvite| { &mut m.invited_lobby_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "abandoning_match_id",
            |m: &CMsgAcceptLobbyInvite| { &m.abandoning_match_id },
            |m: &mut CMsgAcceptLobbyInvite| { &mut m.abandoning_match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "abandoning_invite_lobby_ids",
            |m: &CMsgAcceptLobbyInvite| { &m.abandoning_invite_lobby_ids },
            |m: &mut CMsgAcceptLobbyInvite| { &mut m.abandoning_invite_lobby_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAcceptLobbyInvite>(
            "CMsgAcceptLobbyInvite",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgAcceptLobbyInvite {
    const NAME: &'static str = "CMsgAcceptLobbyInvite";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.invited_lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.abandoning_match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    is.read_repeated_packed_uint64_into(&mut self.abandoning_invite_lobby_ids)?;
                },
                24 => {
                    self.abandoning_invite_lobby_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.invited_lobby_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.abandoning_match_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        for value in &self.abandoning_invite_lobby_ids {
            my_size += ::protobuf::rt::uint64_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.invited_lobby_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.abandoning_match_id {
            os.write_uint64(2, v)?;
        }
        for v in &self.abandoning_invite_lobby_ids {
            os.write_uint64(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAcceptLobbyInvite {
        CMsgAcceptLobbyInvite::new()
    }

    fn clear(&mut self) {
        self.invited_lobby_id = ::std::option::Option::None;
        self.abandoning_match_id = ::std::option::Option::None;
        self.abandoning_invite_lobby_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAcceptLobbyInvite {
        static instance: CMsgAcceptLobbyInvite = CMsgAcceptLobbyInvite {
            invited_lobby_id: ::std::option::Option::None,
            abandoning_match_id: ::std::option::Option::None,
            abandoning_invite_lobby_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgAcceptLobbyInvite {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAcceptLobbyInvite").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAcceptLobbyInvite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAcceptLobbyInvite {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgAcceptLobbyInviteReply)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAcceptLobbyInviteReply {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAcceptLobbyInviteReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAcceptLobbyInviteReply {
    fn default() -> &'a CMsgAcceptLobbyInviteReply {
        <CMsgAcceptLobbyInviteReply as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAcceptLobbyInviteReply {
    pub fn new() -> CMsgAcceptLobbyInviteReply {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAcceptLobbyInviteReply>(
            "CMsgAcceptLobbyInviteReply",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgAcceptLobbyInviteReply {
    const NAME: &'static str = "CMsgAcceptLobbyInviteReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAcceptLobbyInviteReply {
        CMsgAcceptLobbyInviteReply::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAcceptLobbyInviteReply {
        static instance: CMsgAcceptLobbyInviteReply = CMsgAcceptLobbyInviteReply {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgAcceptLobbyInviteReply {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAcceptLobbyInviteReply").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAcceptLobbyInviteReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAcceptLobbyInviteReply {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgMatchmakingSearchCountRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMatchmakingSearchCountRequest {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMatchmakingSearchCountRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMatchmakingSearchCountRequest {
    fn default() -> &'a CMsgMatchmakingSearchCountRequest {
        <CMsgMatchmakingSearchCountRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMatchmakingSearchCountRequest {
    pub fn new() -> CMsgMatchmakingSearchCountRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgMatchmakingSearchCountRequest>(
            "CMsgMatchmakingSearchCountRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgMatchmakingSearchCountRequest {
    const NAME: &'static str = "CMsgMatchmakingSearchCountRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMatchmakingSearchCountRequest {
        CMsgMatchmakingSearchCountRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMatchmakingSearchCountRequest {
        static instance: CMsgMatchmakingSearchCountRequest = CMsgMatchmakingSearchCountRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgMatchmakingSearchCountRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgMatchmakingSearchCountRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgMatchmakingSearchCountRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMatchmakingSearchCountRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgMatchmakingSearchCountResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMatchmakingSearchCountResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgMatchmakingSearchCountResponse.searching_players_by_group)
    pub searching_players_by_group: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMatchmakingSearchCountResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMatchmakingSearchCountResponse {
    fn default() -> &'a CMsgMatchmakingSearchCountResponse {
        <CMsgMatchmakingSearchCountResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMatchmakingSearchCountResponse {
    pub fn new() -> CMsgMatchmakingSearchCountResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "searching_players_by_group",
            |m: &CMsgMatchmakingSearchCountResponse| { &m.searching_players_by_group },
            |m: &mut CMsgMatchmakingSearchCountResponse| { &mut m.searching_players_by_group },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgMatchmakingSearchCountResponse>(
            "CMsgMatchmakingSearchCountResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgMatchmakingSearchCountResponse {
    const NAME: &'static str = "CMsgMatchmakingSearchCountResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.searching_players_by_group)?;
                },
                8 => {
                    self.searching_players_by_group.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.searching_players_by_group {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.searching_players_by_group {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMatchmakingSearchCountResponse {
        CMsgMatchmakingSearchCountResponse::new()
    }

    fn clear(&mut self) {
        self.searching_players_by_group.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMatchmakingSearchCountResponse {
        static instance: CMsgMatchmakingSearchCountResponse = CMsgMatchmakingSearchCountResponse {
            searching_players_by_group: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgMatchmakingSearchCountResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgMatchmakingSearchCountResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgMatchmakingSearchCountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMatchmakingSearchCountResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgKickedFromMatchmakingQueue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgKickedFromMatchmakingQueue {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgKickedFromMatchmakingQueue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgKickedFromMatchmakingQueue {
    fn default() -> &'a CMsgKickedFromMatchmakingQueue {
        <CMsgKickedFromMatchmakingQueue as ::protobuf::Message>::default_instance()
    }
}

impl CMsgKickedFromMatchmakingQueue {
    pub fn new() -> CMsgKickedFromMatchmakingQueue {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgKickedFromMatchmakingQueue>(
            "CMsgKickedFromMatchmakingQueue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgKickedFromMatchmakingQueue {
    const NAME: &'static str = "CMsgKickedFromMatchmakingQueue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgKickedFromMatchmakingQueue {
        CMsgKickedFromMatchmakingQueue::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgKickedFromMatchmakingQueue {
        static instance: CMsgKickedFromMatchmakingQueue = CMsgKickedFromMatchmakingQueue {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgKickedFromMatchmakingQueue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgKickedFromMatchmakingQueue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgKickedFromMatchmakingQueue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgKickedFromMatchmakingQueue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGameServerMatchmakingStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameServerMatchmakingStatus {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.server_version)
    pub server_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.matchmaking_state)
    pub matchmaking_state: ::std::option::Option<::protobuf::EnumOrUnknown<ServerMatchmakingState>>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.map)
    pub map: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.tags)
    pub tags: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.bot_count)
    pub bot_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.num_spectators)
    pub num_spectators: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.max_players)
    pub max_players: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.slots_free)
    pub slots_free: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.server_region)
    pub server_region: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.server_loadavg)
    pub server_loadavg: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.server_trusted)
    pub server_trusted: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.server_dedicated)
    pub server_dedicated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.strict)
    pub strict: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.fake_ip)
    pub fake_ip: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.players)
    pub players: ::std::vec::Vec<cmsg_game_server_matchmaking_status::Player>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.game_state)
    pub game_state: ::std::option::Option<::protobuf::EnumOrUnknown<TF_GC_GameState>>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.event)
    pub event: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_game_server_matchmaking_status::Event>>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.mvm_wave)
    pub mvm_wave: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.mvm_credits_acquired)
    pub mvm_credits_acquired: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.mvm_credits_dropped)
    pub mvm_credits_dropped: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.match_group)
    pub match_group: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.lobby_mm_version)
    pub lobby_mm_version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameServerMatchmakingStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerMatchmakingStatus {
    fn default() -> &'a CMsgGameServerMatchmakingStatus {
        <CMsgGameServerMatchmakingStatus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerMatchmakingStatus {
    pub fn new() -> CMsgGameServerMatchmakingStatus {
        ::std::default::Default::default()
    }

    // optional uint32 server_version = 16;

    pub fn server_version(&self) -> u32 {
        self.server_version.unwrap_or(1225u32)
    }

    pub fn clear_server_version(&mut self) {
        self.server_version = ::std::option::Option::None;
    }

    pub fn has_server_version(&self) -> bool {
        self.server_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_version(&mut self, v: u32) {
        self.server_version = ::std::option::Option::Some(v);
    }

    // optional .ServerMatchmakingState matchmaking_state = 1;

    pub fn matchmaking_state(&self) -> ServerMatchmakingState {
        match self.matchmaking_state {
            Some(e) => e.enum_value_or(ServerMatchmakingState::ServerMatchmakingState_INVALID),
            None => ServerMatchmakingState::ServerMatchmakingState_INVALID,
        }
    }

    pub fn clear_matchmaking_state(&mut self) {
        self.matchmaking_state = ::std::option::Option::None;
    }

    pub fn has_matchmaking_state(&self) -> bool {
        self.matchmaking_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchmaking_state(&mut self, v: ServerMatchmakingState) {
        self.matchmaking_state = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string map = 3;

    pub fn map(&self) -> &str {
        match self.map.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_map(&mut self) {
        self.map = ::std::option::Option::None;
    }

    pub fn has_map(&self) -> bool {
        self.map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map(&mut self, v: ::std::string::String) {
        self.map = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map(&mut self) -> &mut ::std::string::String {
        if self.map.is_none() {
            self.map = ::std::option::Option::Some(::std::string::String::new());
        }
        self.map.as_mut().unwrap()
    }

    // Take field
    pub fn take_map(&mut self) -> ::std::string::String {
        self.map.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string tags = 4;

    pub fn tags(&self) -> &str {
        match self.tags.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_tags(&mut self) {
        self.tags = ::std::option::Option::None;
    }

    pub fn has_tags(&self) -> bool {
        self.tags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::std::string::String) {
        self.tags = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tags(&mut self) -> &mut ::std::string::String {
        if self.tags.is_none() {
            self.tags = ::std::option::Option::Some(::std::string::String::new());
        }
        self.tags.as_mut().unwrap()
    }

    // Take field
    pub fn take_tags(&mut self) -> ::std::string::String {
        self.tags.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 bot_count = 5;

    pub fn bot_count(&self) -> u32 {
        self.bot_count.unwrap_or(0)
    }

    pub fn clear_bot_count(&mut self) {
        self.bot_count = ::std::option::Option::None;
    }

    pub fn has_bot_count(&self) -> bool {
        self.bot_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bot_count(&mut self, v: u32) {
        self.bot_count = ::std::option::Option::Some(v);
    }

    // optional uint32 num_spectators = 6;

    pub fn num_spectators(&self) -> u32 {
        self.num_spectators.unwrap_or(0)
    }

    pub fn clear_num_spectators(&mut self) {
        self.num_spectators = ::std::option::Option::None;
    }

    pub fn has_num_spectators(&self) -> bool {
        self.num_spectators.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_spectators(&mut self, v: u32) {
        self.num_spectators = ::std::option::Option::Some(v);
    }

    // optional uint32 max_players = 7;

    pub fn max_players(&self) -> u32 {
        self.max_players.unwrap_or(0)
    }

    pub fn clear_max_players(&mut self) {
        self.max_players = ::std::option::Option::None;
    }

    pub fn has_max_players(&self) -> bool {
        self.max_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_players(&mut self, v: u32) {
        self.max_players = ::std::option::Option::Some(v);
    }

    // optional uint32 slots_free = 8;

    pub fn slots_free(&self) -> u32 {
        self.slots_free.unwrap_or(0)
    }

    pub fn clear_slots_free(&mut self) {
        self.slots_free = ::std::option::Option::None;
    }

    pub fn has_slots_free(&self) -> bool {
        self.slots_free.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slots_free(&mut self, v: u32) {
        self.slots_free = ::std::option::Option::Some(v);
    }

    // optional uint32 server_region = 9;

    pub fn server_region(&self) -> u32 {
        self.server_region.unwrap_or(0)
    }

    pub fn clear_server_region(&mut self) {
        self.server_region = ::std::option::Option::None;
    }

    pub fn has_server_region(&self) -> bool {
        self.server_region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_region(&mut self, v: u32) {
        self.server_region = ::std::option::Option::Some(v);
    }

    // optional float server_loadavg = 10;

    pub fn server_loadavg(&self) -> f32 {
        self.server_loadavg.unwrap_or(0.)
    }

    pub fn clear_server_loadavg(&mut self) {
        self.server_loadavg = ::std::option::Option::None;
    }

    pub fn has_server_loadavg(&self) -> bool {
        self.server_loadavg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_loadavg(&mut self, v: f32) {
        self.server_loadavg = ::std::option::Option::Some(v);
    }

    // optional bool server_trusted = 11;

    pub fn server_trusted(&self) -> bool {
        self.server_trusted.unwrap_or(false)
    }

    pub fn clear_server_trusted(&mut self) {
        self.server_trusted = ::std::option::Option::None;
    }

    pub fn has_server_trusted(&self) -> bool {
        self.server_trusted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_trusted(&mut self, v: bool) {
        self.server_trusted = ::std::option::Option::Some(v);
    }

    // optional bool server_dedicated = 12;

    pub fn server_dedicated(&self) -> bool {
        self.server_dedicated.unwrap_or(false)
    }

    pub fn clear_server_dedicated(&mut self) {
        self.server_dedicated = ::std::option::Option::None;
    }

    pub fn has_server_dedicated(&self) -> bool {
        self.server_dedicated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_dedicated(&mut self, v: bool) {
        self.server_dedicated = ::std::option::Option::Some(v);
    }

    // optional uint32 strict = 17;

    pub fn strict(&self) -> u32 {
        self.strict.unwrap_or(0)
    }

    pub fn clear_strict(&mut self) {
        self.strict = ::std::option::Option::None;
    }

    pub fn has_strict(&self) -> bool {
        self.strict.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strict(&mut self, v: u32) {
        self.strict = ::std::option::Option::Some(v);
    }

    // optional string fake_ip = 25;

    pub fn fake_ip(&self) -> &str {
        match self.fake_ip.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fake_ip(&mut self) {
        self.fake_ip = ::std::option::Option::None;
    }

    pub fn has_fake_ip(&self) -> bool {
        self.fake_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fake_ip(&mut self, v: ::std::string::String) {
        self.fake_ip = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fake_ip(&mut self) -> &mut ::std::string::String {
        if self.fake_ip.is_none() {
            self.fake_ip = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fake_ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_fake_ip(&mut self) -> ::std::string::String {
        self.fake_ip.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .TF_GC_GameState game_state = 14;

    pub fn game_state(&self) -> TF_GC_GameState {
        match self.game_state {
            Some(e) => e.enum_value_or(TF_GC_GameState::TF_GC_GAMESTATE_STATE_INIT),
            None => TF_GC_GameState::TF_GC_GAMESTATE_STATE_INIT,
        }
    }

    pub fn clear_game_state(&mut self) {
        self.game_state = ::std::option::Option::None;
    }

    pub fn has_game_state(&self) -> bool {
        self.game_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_state(&mut self, v: TF_GC_GameState) {
        self.game_state = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .CMsgGameServerMatchmakingStatus.Event event = 15;

    pub fn event(&self) -> cmsg_game_server_matchmaking_status::Event {
        match self.event {
            Some(e) => e.enum_value_or(cmsg_game_server_matchmaking_status::Event::None),
            None => cmsg_game_server_matchmaking_status::Event::None,
        }
    }

    pub fn clear_event(&mut self) {
        self.event = ::std::option::Option::None;
    }

    pub fn has_event(&self) -> bool {
        self.event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event(&mut self, v: cmsg_game_server_matchmaking_status::Event) {
        self.event = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 mvm_wave = 18;

    pub fn mvm_wave(&self) -> u32 {
        self.mvm_wave.unwrap_or(0)
    }

    pub fn clear_mvm_wave(&mut self) {
        self.mvm_wave = ::std::option::Option::None;
    }

    pub fn has_mvm_wave(&self) -> bool {
        self.mvm_wave.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mvm_wave(&mut self, v: u32) {
        self.mvm_wave = ::std::option::Option::Some(v);
    }

    // optional uint32 mvm_credits_acquired = 19;

    pub fn mvm_credits_acquired(&self) -> u32 {
        self.mvm_credits_acquired.unwrap_or(0)
    }

    pub fn clear_mvm_credits_acquired(&mut self) {
        self.mvm_credits_acquired = ::std::option::Option::None;
    }

    pub fn has_mvm_credits_acquired(&self) -> bool {
        self.mvm_credits_acquired.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mvm_credits_acquired(&mut self, v: u32) {
        self.mvm_credits_acquired = ::std::option::Option::Some(v);
    }

    // optional uint32 mvm_credits_dropped = 20;

    pub fn mvm_credits_dropped(&self) -> u32 {
        self.mvm_credits_dropped.unwrap_or(0)
    }

    pub fn clear_mvm_credits_dropped(&mut self) {
        self.mvm_credits_dropped = ::std::option::Option::None;
    }

    pub fn has_mvm_credits_dropped(&self) -> bool {
        self.mvm_credits_dropped.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mvm_credits_dropped(&mut self, v: u32) {
        self.mvm_credits_dropped = ::std::option::Option::Some(v);
    }

    // optional sint32 match_group = 23;

    pub fn match_group(&self) -> i32 {
        self.match_group.unwrap_or(-1i32)
    }

    pub fn clear_match_group(&mut self) {
        self.match_group = ::std::option::Option::None;
    }

    pub fn has_match_group(&self) -> bool {
        self.match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_group(&mut self, v: i32) {
        self.match_group = ::std::option::Option::Some(v);
    }

    // optional uint32 lobby_mm_version = 24;

    pub fn lobby_mm_version(&self) -> u32 {
        self.lobby_mm_version.unwrap_or(0)
    }

    pub fn clear_lobby_mm_version(&mut self) {
        self.lobby_mm_version = ::std::option::Option::None;
    }

    pub fn has_lobby_mm_version(&self) -> bool {
        self.lobby_mm_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_mm_version(&mut self, v: u32) {
        self.lobby_mm_version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(22);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_version",
            |m: &CMsgGameServerMatchmakingStatus| { &m.server_version },
            |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.server_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchmaking_state",
            |m: &CMsgGameServerMatchmakingStatus| { &m.matchmaking_state },
            |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.matchmaking_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map",
            |m: &CMsgGameServerMatchmakingStatus| { &m.map },
            |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.map },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tags",
            |m: &CMsgGameServerMatchmakingStatus| { &m.tags },
            |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.tags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bot_count",
            |m: &CMsgGameServerMatchmakingStatus| { &m.bot_count },
            |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.bot_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_spectators",
            |m: &CMsgGameServerMatchmakingStatus| { &m.num_spectators },
            |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.num_spectators },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_players",
            |m: &CMsgGameServerMatchmakingStatus| { &m.max_players },
            |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.max_players },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slots_free",
            |m: &CMsgGameServerMatchmakingStatus| { &m.slots_free },
            |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.slots_free },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_region",
            |m: &CMsgGameServerMatchmakingStatus| { &m.server_region },
            |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.server_region },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_loadavg",
            |m: &CMsgGameServerMatchmakingStatus| { &m.server_loadavg },
            |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.server_loadavg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_trusted",
            |m: &CMsgGameServerMatchmakingStatus| { &m.server_trusted },
            |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.server_trusted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_dedicated",
            |m: &CMsgGameServerMatchmakingStatus| { &m.server_dedicated },
            |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.server_dedicated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "strict",
            |m: &CMsgGameServerMatchmakingStatus| { &m.strict },
            |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.strict },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fake_ip",
            |m: &CMsgGameServerMatchmakingStatus| { &m.fake_ip },
            |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.fake_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "players",
            |m: &CMsgGameServerMatchmakingStatus| { &m.players },
            |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.players },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_state",
            |m: &CMsgGameServerMatchmakingStatus| { &m.game_state },
            |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.game_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event",
            |m: &CMsgGameServerMatchmakingStatus| { &m.event },
            |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.event },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mvm_wave",
            |m: &CMsgGameServerMatchmakingStatus| { &m.mvm_wave },
            |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.mvm_wave },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mvm_credits_acquired",
            |m: &CMsgGameServerMatchmakingStatus| { &m.mvm_credits_acquired },
            |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.mvm_credits_acquired },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mvm_credits_dropped",
            |m: &CMsgGameServerMatchmakingStatus| { &m.mvm_credits_dropped },
            |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.mvm_credits_dropped },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_group",
            |m: &CMsgGameServerMatchmakingStatus| { &m.match_group },
            |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.match_group },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_mm_version",
            |m: &CMsgGameServerMatchmakingStatus| { &m.lobby_mm_version },
            |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.lobby_mm_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGameServerMatchmakingStatus>(
            "CMsgGameServerMatchmakingStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGameServerMatchmakingStatus {
    const NAME: &'static str = "CMsgGameServerMatchmakingStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                128 => {
                    self.server_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                8 => {
                    self.matchmaking_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    self.map = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.tags = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.bot_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.num_spectators = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.max_players = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.slots_free = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.server_region = ::std::option::Option::Some(is.read_uint32()?);
                },
                85 => {
                    self.server_loadavg = ::std::option::Option::Some(is.read_float()?);
                },
                88 => {
                    self.server_trusted = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.server_dedicated = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self.strict = ::std::option::Option::Some(is.read_uint32()?);
                },
                202 => {
                    self.fake_ip = ::std::option::Option::Some(is.read_string()?);
                },
                106 => {
                    self.players.push(is.read_message()?);
                },
                112 => {
                    self.game_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                120 => {
                    self.event = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                144 => {
                    self.mvm_wave = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.mvm_credits_acquired = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.mvm_credits_dropped = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.match_group = ::std::option::Option::Some(is.read_sint32()?);
                },
                192 => {
                    self.lobby_mm_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.server_version {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.matchmaking_state {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.map.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.tags.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.bot_count {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.num_spectators {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.max_players {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.slots_free {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.server_region {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.server_loadavg {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_trusted {
            my_size += 1 + 1;
        }
        if let Some(v) = self.server_dedicated {
            my_size += 1 + 1;
        }
        if let Some(v) = self.strict {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.fake_ip.as_ref() {
            my_size += ::protobuf::rt::string_size(25, &v);
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.game_state {
            my_size += ::protobuf::rt::int32_size(14, v.value());
        }
        if let Some(v) = self.event {
            my_size += ::protobuf::rt::int32_size(15, v.value());
        }
        if let Some(v) = self.mvm_wave {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.mvm_credits_acquired {
            my_size += ::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.mvm_credits_dropped {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.match_group {
            my_size += ::protobuf::rt::sint32_size(23, v);
        }
        if let Some(v) = self.lobby_mm_version {
            my_size += ::protobuf::rt::uint32_size(24, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.server_version {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.matchmaking_state {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.map.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.tags.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.bot_count {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.num_spectators {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.max_players {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.slots_free {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.server_region {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.server_loadavg {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.server_trusted {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.server_dedicated {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.strict {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.fake_ip.as_ref() {
            os.write_string(25, v)?;
        }
        for v in &self.players {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        if let Some(v) = self.game_state {
            os.write_enum(14, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.event {
            os.write_enum(15, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.mvm_wave {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.mvm_credits_acquired {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.mvm_credits_dropped {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.match_group {
            os.write_sint32(23, v)?;
        }
        if let Some(v) = self.lobby_mm_version {
            os.write_uint32(24, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameServerMatchmakingStatus {
        CMsgGameServerMatchmakingStatus::new()
    }

    fn clear(&mut self) {
        self.server_version = ::std::option::Option::None;
        self.matchmaking_state = ::std::option::Option::None;
        self.map = ::std::option::Option::None;
        self.tags = ::std::option::Option::None;
        self.bot_count = ::std::option::Option::None;
        self.num_spectators = ::std::option::Option::None;
        self.max_players = ::std::option::Option::None;
        self.slots_free = ::std::option::Option::None;
        self.server_region = ::std::option::Option::None;
        self.server_loadavg = ::std::option::Option::None;
        self.server_trusted = ::std::option::Option::None;
        self.server_dedicated = ::std::option::Option::None;
        self.strict = ::std::option::Option::None;
        self.fake_ip = ::std::option::Option::None;
        self.players.clear();
        self.game_state = ::std::option::Option::None;
        self.event = ::std::option::Option::None;
        self.mvm_wave = ::std::option::Option::None;
        self.mvm_credits_acquired = ::std::option::Option::None;
        self.mvm_credits_dropped = ::std::option::Option::None;
        self.match_group = ::std::option::Option::None;
        self.lobby_mm_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameServerMatchmakingStatus {
        static instance: CMsgGameServerMatchmakingStatus = CMsgGameServerMatchmakingStatus {
            server_version: ::std::option::Option::None,
            matchmaking_state: ::std::option::Option::None,
            map: ::std::option::Option::None,
            tags: ::std::option::Option::None,
            bot_count: ::std::option::Option::None,
            num_spectators: ::std::option::Option::None,
            max_players: ::std::option::Option::None,
            slots_free: ::std::option::Option::None,
            server_region: ::std::option::Option::None,
            server_loadavg: ::std::option::Option::None,
            server_trusted: ::std::option::Option::None,
            server_dedicated: ::std::option::Option::None,
            strict: ::std::option::Option::None,
            fake_ip: ::std::option::Option::None,
            players: ::std::vec::Vec::new(),
            game_state: ::std::option::Option::None,
            event: ::std::option::Option::None,
            mvm_wave: ::std::option::Option::None,
            mvm_credits_acquired: ::std::option::Option::None,
            mvm_credits_dropped: ::std::option::Option::None,
            match_group: ::std::option::Option::None,
            lobby_mm_version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGameServerMatchmakingStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGameServerMatchmakingStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGameServerMatchmakingStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerMatchmakingStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGameServerMatchmakingStatus`
pub mod cmsg_game_server_matchmaking_status {
    // @@protoc_insertion_point(message:CMsgGameServerMatchmakingStatus.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.Player.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.Player.connect_state)
        pub connect_state: ::std::option::Option<::protobuf::EnumOrUnknown<PlayerConnectState>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGameServerMatchmakingStatus.Player.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id = 1;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional .CMsgGameServerMatchmakingStatus.PlayerConnectState connect_state = 2;

        pub fn connect_state(&self) -> PlayerConnectState {
            match self.connect_state {
                Some(e) => e.enum_value_or(PlayerConnectState::INVALID),
                None => PlayerConnectState::INVALID,
            }
        }

        pub fn clear_connect_state(&mut self) {
            self.connect_state = ::std::option::Option::None;
        }

        pub fn has_connect_state(&self) -> bool {
            self.connect_state.is_some()
        }

        // Param is passed by value, moved
        pub fn set_connect_state(&mut self, v: PlayerConnectState) {
            self.connect_state = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "steam_id",
                |m: &Player| { &m.steam_id },
                |m: &mut Player| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "connect_state",
                |m: &Player| { &m.connect_state },
                |m: &mut Player| { &mut m.connect_state },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Player>(
                "CMsgGameServerMatchmakingStatus.Player",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.connect_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.connect_state {
                my_size += ::protobuf::rt::int32_size(2, v.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steam_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.connect_state {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.connect_state = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                steam_id: ::std::option::Option::None,
                connect_state: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Player {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGameServerMatchmakingStatus.Player").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Player {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Player {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGameServerMatchmakingStatus.PlayerConnectState)
    pub enum PlayerConnectState {
        // @@protoc_insertion_point(enum_value:CMsgGameServerMatchmakingStatus.PlayerConnectState.INVALID)
        INVALID = 0,
        // @@protoc_insertion_point(enum_value:CMsgGameServerMatchmakingStatus.PlayerConnectState.CONNECTED)
        CONNECTED = 1,
        // @@protoc_insertion_point(enum_value:CMsgGameServerMatchmakingStatus.PlayerConnectState.RESERVED)
        RESERVED = 2,
    }

    impl ::protobuf::Enum for PlayerConnectState {
        const NAME: &'static str = "PlayerConnectState";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<PlayerConnectState> {
            match value {
                0 => ::std::option::Option::Some(PlayerConnectState::INVALID),
                1 => ::std::option::Option::Some(PlayerConnectState::CONNECTED),
                2 => ::std::option::Option::Some(PlayerConnectState::RESERVED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<PlayerConnectState> {
            match str {
                "INVALID" => ::std::option::Option::Some(PlayerConnectState::INVALID),
                "CONNECTED" => ::std::option::Option::Some(PlayerConnectState::CONNECTED),
                "RESERVED" => ::std::option::Option::Some(PlayerConnectState::RESERVED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [PlayerConnectState] = &[
            PlayerConnectState::INVALID,
            PlayerConnectState::CONNECTED,
            PlayerConnectState::RESERVED,
        ];
    }

    impl ::protobuf::EnumFull for PlayerConnectState {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgGameServerMatchmakingStatus.PlayerConnectState").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for PlayerConnectState {
        fn default() -> Self {
            PlayerConnectState::INVALID
        }
    }

    impl PlayerConnectState {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PlayerConnectState>("CMsgGameServerMatchmakingStatus.PlayerConnectState")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGameServerMatchmakingStatus.Event)
    pub enum Event {
        // @@protoc_insertion_point(enum_value:CMsgGameServerMatchmakingStatus.Event.None)
        None = 0,
        // @@protoc_insertion_point(enum_value:CMsgGameServerMatchmakingStatus.Event.MvMVictory)
        MvMVictory = 1,
        // @@protoc_insertion_point(enum_value:CMsgGameServerMatchmakingStatus.Event.MvMDefeat)
        MvMDefeat = 2,
        // @@protoc_insertion_point(enum_value:CMsgGameServerMatchmakingStatus.Event.AcknowledgePlayers)
        AcknowledgePlayers = 3,
    }

    impl ::protobuf::Enum for Event {
        const NAME: &'static str = "Event";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Event> {
            match value {
                0 => ::std::option::Option::Some(Event::None),
                1 => ::std::option::Option::Some(Event::MvMVictory),
                2 => ::std::option::Option::Some(Event::MvMDefeat),
                3 => ::std::option::Option::Some(Event::AcknowledgePlayers),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Event> {
            match str {
                "None" => ::std::option::Option::Some(Event::None),
                "MvMVictory" => ::std::option::Option::Some(Event::MvMVictory),
                "MvMDefeat" => ::std::option::Option::Some(Event::MvMDefeat),
                "AcknowledgePlayers" => ::std::option::Option::Some(Event::AcknowledgePlayers),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Event] = &[
            Event::None,
            Event::MvMVictory,
            Event::MvMDefeat,
            Event::AcknowledgePlayers,
        ];
    }

    impl ::protobuf::EnumFull for Event {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgGameServerMatchmakingStatus.Event").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Event {
        fn default() -> Self {
            Event::None
        }
    }

    impl Event {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Event>("CMsgGameServerMatchmakingStatus.Event")
        }
    }
}

// @@protoc_insertion_point(message:CMsgMatchmakingProgress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMatchmakingProgress {
    // message fields
    // @@protoc_insertion_point(field:CMsgMatchmakingProgress.avg_wait_time_new)
    pub avg_wait_time_new: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMatchmakingProgress.avg_wait_time_join_late)
    pub avg_wait_time_join_late: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMatchmakingProgress.your_wait_time)
    pub your_wait_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMatchmakingProgress.matching_worldwide_searching_players)
    pub matching_worldwide_searching_players: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMatchmakingProgress.matching_near_you_searching_players)
    pub matching_near_you_searching_players: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMatchmakingProgress.total_worldwide_searching_players)
    pub total_worldwide_searching_players: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMatchmakingProgress.total_near_you_searching_players)
    pub total_near_you_searching_players: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMatchmakingProgress.matching_worldwide_active_players)
    pub matching_worldwide_active_players: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMatchmakingProgress.matching_near_you_active_players)
    pub matching_near_you_active_players: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMatchmakingProgress.total_worldwide_active_players)
    pub total_worldwide_active_players: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMatchmakingProgress.total_near_you_active_players)
    pub total_near_you_active_players: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMatchmakingProgress.matching_worldwide_empty_gameservers)
    pub matching_worldwide_empty_gameservers: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMatchmakingProgress.matching_near_you_empty_gameservers)
    pub matching_near_you_empty_gameservers: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMatchmakingProgress.total_worldwide_empty_gameservers)
    pub total_worldwide_empty_gameservers: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMatchmakingProgress.total_near_you_empty_gameservers)
    pub total_near_you_empty_gameservers: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMatchmakingProgress.urgency_pct)
    pub urgency_pct: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMatchmakingProgress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMatchmakingProgress {
    fn default() -> &'a CMsgMatchmakingProgress {
        <CMsgMatchmakingProgress as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMatchmakingProgress {
    pub fn new() -> CMsgMatchmakingProgress {
        ::std::default::Default::default()
    }

    // optional uint32 avg_wait_time_new = 4;

    pub fn avg_wait_time_new(&self) -> u32 {
        self.avg_wait_time_new.unwrap_or(0)
    }

    pub fn clear_avg_wait_time_new(&mut self) {
        self.avg_wait_time_new = ::std::option::Option::None;
    }

    pub fn has_avg_wait_time_new(&self) -> bool {
        self.avg_wait_time_new.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_wait_time_new(&mut self, v: u32) {
        self.avg_wait_time_new = ::std::option::Option::Some(v);
    }

    // optional uint32 avg_wait_time_join_late = 5;

    pub fn avg_wait_time_join_late(&self) -> u32 {
        self.avg_wait_time_join_late.unwrap_or(0)
    }

    pub fn clear_avg_wait_time_join_late(&mut self) {
        self.avg_wait_time_join_late = ::std::option::Option::None;
    }

    pub fn has_avg_wait_time_join_late(&self) -> bool {
        self.avg_wait_time_join_late.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_wait_time_join_late(&mut self, v: u32) {
        self.avg_wait_time_join_late = ::std::option::Option::Some(v);
    }

    // optional uint32 your_wait_time = 6;

    pub fn your_wait_time(&self) -> u32 {
        self.your_wait_time.unwrap_or(0)
    }

    pub fn clear_your_wait_time(&mut self) {
        self.your_wait_time = ::std::option::Option::None;
    }

    pub fn has_your_wait_time(&self) -> bool {
        self.your_wait_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_your_wait_time(&mut self, v: u32) {
        self.your_wait_time = ::std::option::Option::Some(v);
    }

    // optional uint32 matching_worldwide_searching_players = 8;

    pub fn matching_worldwide_searching_players(&self) -> u32 {
        self.matching_worldwide_searching_players.unwrap_or(0)
    }

    pub fn clear_matching_worldwide_searching_players(&mut self) {
        self.matching_worldwide_searching_players = ::std::option::Option::None;
    }

    pub fn has_matching_worldwide_searching_players(&self) -> bool {
        self.matching_worldwide_searching_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matching_worldwide_searching_players(&mut self, v: u32) {
        self.matching_worldwide_searching_players = ::std::option::Option::Some(v);
    }

    // optional uint32 matching_near_you_searching_players = 9;

    pub fn matching_near_you_searching_players(&self) -> u32 {
        self.matching_near_you_searching_players.unwrap_or(0)
    }

    pub fn clear_matching_near_you_searching_players(&mut self) {
        self.matching_near_you_searching_players = ::std::option::Option::None;
    }

    pub fn has_matching_near_you_searching_players(&self) -> bool {
        self.matching_near_you_searching_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matching_near_you_searching_players(&mut self, v: u32) {
        self.matching_near_you_searching_players = ::std::option::Option::Some(v);
    }

    // optional uint32 total_worldwide_searching_players = 13;

    pub fn total_worldwide_searching_players(&self) -> u32 {
        self.total_worldwide_searching_players.unwrap_or(0)
    }

    pub fn clear_total_worldwide_searching_players(&mut self) {
        self.total_worldwide_searching_players = ::std::option::Option::None;
    }

    pub fn has_total_worldwide_searching_players(&self) -> bool {
        self.total_worldwide_searching_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_worldwide_searching_players(&mut self, v: u32) {
        self.total_worldwide_searching_players = ::std::option::Option::Some(v);
    }

    // optional uint32 total_near_you_searching_players = 14;

    pub fn total_near_you_searching_players(&self) -> u32 {
        self.total_near_you_searching_players.unwrap_or(0)
    }

    pub fn clear_total_near_you_searching_players(&mut self) {
        self.total_near_you_searching_players = ::std::option::Option::None;
    }

    pub fn has_total_near_you_searching_players(&self) -> bool {
        self.total_near_you_searching_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_near_you_searching_players(&mut self, v: u32) {
        self.total_near_you_searching_players = ::std::option::Option::Some(v);
    }

    // optional uint32 matching_worldwide_active_players = 15;

    pub fn matching_worldwide_active_players(&self) -> u32 {
        self.matching_worldwide_active_players.unwrap_or(0)
    }

    pub fn clear_matching_worldwide_active_players(&mut self) {
        self.matching_worldwide_active_players = ::std::option::Option::None;
    }

    pub fn has_matching_worldwide_active_players(&self) -> bool {
        self.matching_worldwide_active_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matching_worldwide_active_players(&mut self, v: u32) {
        self.matching_worldwide_active_players = ::std::option::Option::Some(v);
    }

    // optional uint32 matching_near_you_active_players = 16;

    pub fn matching_near_you_active_players(&self) -> u32 {
        self.matching_near_you_active_players.unwrap_or(0)
    }

    pub fn clear_matching_near_you_active_players(&mut self) {
        self.matching_near_you_active_players = ::std::option::Option::None;
    }

    pub fn has_matching_near_you_active_players(&self) -> bool {
        self.matching_near_you_active_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matching_near_you_active_players(&mut self, v: u32) {
        self.matching_near_you_active_players = ::std::option::Option::Some(v);
    }

    // optional uint32 total_worldwide_active_players = 17;

    pub fn total_worldwide_active_players(&self) -> u32 {
        self.total_worldwide_active_players.unwrap_or(0)
    }

    pub fn clear_total_worldwide_active_players(&mut self) {
        self.total_worldwide_active_players = ::std::option::Option::None;
    }

    pub fn has_total_worldwide_active_players(&self) -> bool {
        self.total_worldwide_active_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_worldwide_active_players(&mut self, v: u32) {
        self.total_worldwide_active_players = ::std::option::Option::Some(v);
    }

    // optional uint32 total_near_you_active_players = 18;

    pub fn total_near_you_active_players(&self) -> u32 {
        self.total_near_you_active_players.unwrap_or(0)
    }

    pub fn clear_total_near_you_active_players(&mut self) {
        self.total_near_you_active_players = ::std::option::Option::None;
    }

    pub fn has_total_near_you_active_players(&self) -> bool {
        self.total_near_you_active_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_near_you_active_players(&mut self, v: u32) {
        self.total_near_you_active_players = ::std::option::Option::Some(v);
    }

    // optional uint32 matching_worldwide_empty_gameservers = 19;

    pub fn matching_worldwide_empty_gameservers(&self) -> u32 {
        self.matching_worldwide_empty_gameservers.unwrap_or(0)
    }

    pub fn clear_matching_worldwide_empty_gameservers(&mut self) {
        self.matching_worldwide_empty_gameservers = ::std::option::Option::None;
    }

    pub fn has_matching_worldwide_empty_gameservers(&self) -> bool {
        self.matching_worldwide_empty_gameservers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matching_worldwide_empty_gameservers(&mut self, v: u32) {
        self.matching_worldwide_empty_gameservers = ::std::option::Option::Some(v);
    }

    // optional uint32 matching_near_you_empty_gameservers = 20;

    pub fn matching_near_you_empty_gameservers(&self) -> u32 {
        self.matching_near_you_empty_gameservers.unwrap_or(0)
    }

    pub fn clear_matching_near_you_empty_gameservers(&mut self) {
        self.matching_near_you_empty_gameservers = ::std::option::Option::None;
    }

    pub fn has_matching_near_you_empty_gameservers(&self) -> bool {
        self.matching_near_you_empty_gameservers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matching_near_you_empty_gameservers(&mut self, v: u32) {
        self.matching_near_you_empty_gameservers = ::std::option::Option::Some(v);
    }

    // optional uint32 total_worldwide_empty_gameservers = 21;

    pub fn total_worldwide_empty_gameservers(&self) -> u32 {
        self.total_worldwide_empty_gameservers.unwrap_or(0)
    }

    pub fn clear_total_worldwide_empty_gameservers(&mut self) {
        self.total_worldwide_empty_gameservers = ::std::option::Option::None;
    }

    pub fn has_total_worldwide_empty_gameservers(&self) -> bool {
        self.total_worldwide_empty_gameservers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_worldwide_empty_gameservers(&mut self, v: u32) {
        self.total_worldwide_empty_gameservers = ::std::option::Option::Some(v);
    }

    // optional uint32 total_near_you_empty_gameservers = 22;

    pub fn total_near_you_empty_gameservers(&self) -> u32 {
        self.total_near_you_empty_gameservers.unwrap_or(0)
    }

    pub fn clear_total_near_you_empty_gameservers(&mut self) {
        self.total_near_you_empty_gameservers = ::std::option::Option::None;
    }

    pub fn has_total_near_you_empty_gameservers(&self) -> bool {
        self.total_near_you_empty_gameservers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_near_you_empty_gameservers(&mut self, v: u32) {
        self.total_near_you_empty_gameservers = ::std::option::Option::Some(v);
    }

    // optional uint32 urgency_pct = 1;

    pub fn urgency_pct(&self) -> u32 {
        self.urgency_pct.unwrap_or(0)
    }

    pub fn clear_urgency_pct(&mut self) {
        self.urgency_pct = ::std::option::Option::None;
    }

    pub fn has_urgency_pct(&self) -> bool {
        self.urgency_pct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_urgency_pct(&mut self, v: u32) {
        self.urgency_pct = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(16);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "avg_wait_time_new",
            |m: &CMsgMatchmakingProgress| { &m.avg_wait_time_new },
            |m: &mut CMsgMatchmakingProgress| { &mut m.avg_wait_time_new },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "avg_wait_time_join_late",
            |m: &CMsgMatchmakingProgress| { &m.avg_wait_time_join_late },
            |m: &mut CMsgMatchmakingProgress| { &mut m.avg_wait_time_join_late },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "your_wait_time",
            |m: &CMsgMatchmakingProgress| { &m.your_wait_time },
            |m: &mut CMsgMatchmakingProgress| { &mut m.your_wait_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matching_worldwide_searching_players",
            |m: &CMsgMatchmakingProgress| { &m.matching_worldwide_searching_players },
            |m: &mut CMsgMatchmakingProgress| { &mut m.matching_worldwide_searching_players },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matching_near_you_searching_players",
            |m: &CMsgMatchmakingProgress| { &m.matching_near_you_searching_players },
            |m: &mut CMsgMatchmakingProgress| { &mut m.matching_near_you_searching_players },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_worldwide_searching_players",
            |m: &CMsgMatchmakingProgress| { &m.total_worldwide_searching_players },
            |m: &mut CMsgMatchmakingProgress| { &mut m.total_worldwide_searching_players },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_near_you_searching_players",
            |m: &CMsgMatchmakingProgress| { &m.total_near_you_searching_players },
            |m: &mut CMsgMatchmakingProgress| { &mut m.total_near_you_searching_players },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matching_worldwide_active_players",
            |m: &CMsgMatchmakingProgress| { &m.matching_worldwide_active_players },
            |m: &mut CMsgMatchmakingProgress| { &mut m.matching_worldwide_active_players },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matching_near_you_active_players",
            |m: &CMsgMatchmakingProgress| { &m.matching_near_you_active_players },
            |m: &mut CMsgMatchmakingProgress| { &mut m.matching_near_you_active_players },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_worldwide_active_players",
            |m: &CMsgMatchmakingProgress| { &m.total_worldwide_active_players },
            |m: &mut CMsgMatchmakingProgress| { &mut m.total_worldwide_active_players },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_near_you_active_players",
            |m: &CMsgMatchmakingProgress| { &m.total_near_you_active_players },
            |m: &mut CMsgMatchmakingProgress| { &mut m.total_near_you_active_players },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matching_worldwide_empty_gameservers",
            |m: &CMsgMatchmakingProgress| { &m.matching_worldwide_empty_gameservers },
            |m: &mut CMsgMatchmakingProgress| { &mut m.matching_worldwide_empty_gameservers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matching_near_you_empty_gameservers",
            |m: &CMsgMatchmakingProgress| { &m.matching_near_you_empty_gameservers },
            |m: &mut CMsgMatchmakingProgress| { &mut m.matching_near_you_empty_gameservers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_worldwide_empty_gameservers",
            |m: &CMsgMatchmakingProgress| { &m.total_worldwide_empty_gameservers },
            |m: &mut CMsgMatchmakingProgress| { &mut m.total_worldwide_empty_gameservers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_near_you_empty_gameservers",
            |m: &CMsgMatchmakingProgress| { &m.total_near_you_empty_gameservers },
            |m: &mut CMsgMatchmakingProgress| { &mut m.total_near_you_empty_gameservers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "urgency_pct",
            |m: &CMsgMatchmakingProgress| { &m.urgency_pct },
            |m: &mut CMsgMatchmakingProgress| { &mut m.urgency_pct },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgMatchmakingProgress>(
            "CMsgMatchmakingProgress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgMatchmakingProgress {
    const NAME: &'static str = "CMsgMatchmakingProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                32 => {
                    self.avg_wait_time_new = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.avg_wait_time_join_late = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.your_wait_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.matching_worldwide_searching_players = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.matching_near_you_searching_players = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.total_worldwide_searching_players = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.total_near_you_searching_players = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.matching_worldwide_active_players = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.matching_near_you_active_players = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.total_worldwide_active_players = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.total_near_you_active_players = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.matching_worldwide_empty_gameservers = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.matching_near_you_empty_gameservers = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.total_worldwide_empty_gameservers = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.total_near_you_empty_gameservers = ::std::option::Option::Some(is.read_uint32()?);
                },
                8 => {
                    self.urgency_pct = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.avg_wait_time_new {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.avg_wait_time_join_late {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.your_wait_time {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.matching_worldwide_searching_players {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.matching_near_you_searching_players {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.total_worldwide_searching_players {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.total_near_you_searching_players {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.matching_worldwide_active_players {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.matching_near_you_active_players {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.total_worldwide_active_players {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.total_near_you_active_players {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.matching_worldwide_empty_gameservers {
            my_size += ::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.matching_near_you_empty_gameservers {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.total_worldwide_empty_gameservers {
            my_size += ::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.total_near_you_empty_gameservers {
            my_size += ::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.urgency_pct {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.avg_wait_time_new {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.avg_wait_time_join_late {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.your_wait_time {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.matching_worldwide_searching_players {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.matching_near_you_searching_players {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.total_worldwide_searching_players {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.total_near_you_searching_players {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.matching_worldwide_active_players {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.matching_near_you_active_players {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.total_worldwide_active_players {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.total_near_you_active_players {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.matching_worldwide_empty_gameservers {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.matching_near_you_empty_gameservers {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.total_worldwide_empty_gameservers {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.total_near_you_empty_gameservers {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.urgency_pct {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMatchmakingProgress {
        CMsgMatchmakingProgress::new()
    }

    fn clear(&mut self) {
        self.avg_wait_time_new = ::std::option::Option::None;
        self.avg_wait_time_join_late = ::std::option::Option::None;
        self.your_wait_time = ::std::option::Option::None;
        self.matching_worldwide_searching_players = ::std::option::Option::None;
        self.matching_near_you_searching_players = ::std::option::Option::None;
        self.total_worldwide_searching_players = ::std::option::Option::None;
        self.total_near_you_searching_players = ::std::option::Option::None;
        self.matching_worldwide_active_players = ::std::option::Option::None;
        self.matching_near_you_active_players = ::std::option::Option::None;
        self.total_worldwide_active_players = ::std::option::Option::None;
        self.total_near_you_active_players = ::std::option::Option::None;
        self.matching_worldwide_empty_gameservers = ::std::option::Option::None;
        self.matching_near_you_empty_gameservers = ::std::option::Option::None;
        self.total_worldwide_empty_gameservers = ::std::option::Option::None;
        self.total_near_you_empty_gameservers = ::std::option::Option::None;
        self.urgency_pct = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMatchmakingProgress {
        static instance: CMsgMatchmakingProgress = CMsgMatchmakingProgress {
            avg_wait_time_new: ::std::option::Option::None,
            avg_wait_time_join_late: ::std::option::Option::None,
            your_wait_time: ::std::option::Option::None,
            matching_worldwide_searching_players: ::std::option::Option::None,
            matching_near_you_searching_players: ::std::option::Option::None,
            total_worldwide_searching_players: ::std::option::Option::None,
            total_near_you_searching_players: ::std::option::Option::None,
            matching_worldwide_active_players: ::std::option::Option::None,
            matching_near_you_active_players: ::std::option::Option::None,
            total_worldwide_active_players: ::std::option::Option::None,
            total_near_you_active_players: ::std::option::Option::None,
            matching_worldwide_empty_gameservers: ::std::option::Option::None,
            matching_near_you_empty_gameservers: ::std::option::Option::None,
            total_worldwide_empty_gameservers: ::std::option::Option::None,
            total_near_you_empty_gameservers: ::std::option::Option::None,
            urgency_pct: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgMatchmakingProgress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgMatchmakingProgress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgMatchmakingProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMatchmakingProgress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgMvMVictoryInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMvMVictoryInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgMvMVictoryInfo.players)
    pub players: ::std::vec::Vec<cmsg_mv_mvictory_info::Player>,
    // @@protoc_insertion_point(field:CMsgMvMVictoryInfo.tour_name)
    pub tour_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgMvMVictoryInfo.mission_name)
    pub mission_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMvMVictoryInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMvMVictoryInfo {
    fn default() -> &'a CMsgMvMVictoryInfo {
        <CMsgMvMVictoryInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMvMVictoryInfo {
    pub fn new() -> CMsgMvMVictoryInfo {
        ::std::default::Default::default()
    }

    // optional string tour_name = 2;

    pub fn tour_name(&self) -> &str {
        match self.tour_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_tour_name(&mut self) {
        self.tour_name = ::std::option::Option::None;
    }

    pub fn has_tour_name(&self) -> bool {
        self.tour_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tour_name(&mut self, v: ::std::string::String) {
        self.tour_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tour_name(&mut self) -> &mut ::std::string::String {
        if self.tour_name.is_none() {
            self.tour_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.tour_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_tour_name(&mut self) -> ::std::string::String {
        self.tour_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mission_name = 3;

    pub fn mission_name(&self) -> &str {
        match self.mission_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mission_name(&mut self) {
        self.mission_name = ::std::option::Option::None;
    }

    pub fn has_mission_name(&self) -> bool {
        self.mission_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mission_name(&mut self, v: ::std::string::String) {
        self.mission_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mission_name(&mut self) -> &mut ::std::string::String {
        if self.mission_name.is_none() {
            self.mission_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mission_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_mission_name(&mut self) -> ::std::string::String {
        self.mission_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "players",
            |m: &CMsgMvMVictoryInfo| { &m.players },
            |m: &mut CMsgMvMVictoryInfo| { &mut m.players },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tour_name",
            |m: &CMsgMvMVictoryInfo| { &m.tour_name },
            |m: &mut CMsgMvMVictoryInfo| { &mut m.tour_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mission_name",
            |m: &CMsgMvMVictoryInfo| { &m.mission_name },
            |m: &mut CMsgMvMVictoryInfo| { &mut m.mission_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgMvMVictoryInfo>(
            "CMsgMvMVictoryInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgMvMVictoryInfo {
    const NAME: &'static str = "CMsgMvMVictoryInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.players.push(is.read_message()?);
                },
                18 => {
                    self.tour_name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.mission_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.tour_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.mission_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.players {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.tour_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.mission_name.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMvMVictoryInfo {
        CMsgMvMVictoryInfo::new()
    }

    fn clear(&mut self) {
        self.players.clear();
        self.tour_name = ::std::option::Option::None;
        self.mission_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMvMVictoryInfo {
        static instance: CMsgMvMVictoryInfo = CMsgMvMVictoryInfo {
            players: ::std::vec::Vec::new(),
            tour_name: ::std::option::Option::None,
            mission_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgMvMVictoryInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgMvMVictoryInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgMvMVictoryInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMvMVictoryInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgMvMVictoryInfo`
pub mod cmsg_mv_mvictory_info {
    // @@protoc_insertion_point(message:CMsgMvMVictoryInfo.Item)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Item {
        // message fields
        // @@protoc_insertion_point(field:CMsgMvMVictoryInfo.Item.grant_reason)
        pub grant_reason: ::std::option::Option<::protobuf::EnumOrUnknown<GrantReason>>,
        // @@protoc_insertion_point(field:CMsgMvMVictoryInfo.Item.item_data)
        pub item_data: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:CMsgMvMVictoryInfo.Item.squad_surplus_claimer_steam_id)
        pub squad_surplus_claimer_steam_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgMvMVictoryInfo.Item.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Item {
        fn default() -> &'a Item {
            <Item as ::protobuf::Message>::default_instance()
        }
    }

    impl Item {
        pub fn new() -> Item {
            ::std::default::Default::default()
        }

        // optional .CMsgMvMVictoryInfo.GrantReason grant_reason = 1;

        pub fn grant_reason(&self) -> GrantReason {
            match self.grant_reason {
                Some(e) => e.enum_value_or(GrantReason::INVALID),
                None => GrantReason::INVALID,
            }
        }

        pub fn clear_grant_reason(&mut self) {
            self.grant_reason = ::std::option::Option::None;
        }

        pub fn has_grant_reason(&self) -> bool {
            self.grant_reason.is_some()
        }

        // Param is passed by value, moved
        pub fn set_grant_reason(&mut self, v: GrantReason) {
            self.grant_reason = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional bytes item_data = 2;

        pub fn item_data(&self) -> &[u8] {
            match self.item_data.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_item_data(&mut self) {
            self.item_data = ::std::option::Option::None;
        }

        pub fn has_item_data(&self) -> bool {
            self.item_data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_data(&mut self, v: ::std::vec::Vec<u8>) {
            self.item_data = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_item_data(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.item_data.is_none() {
                self.item_data = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.item_data.as_mut().unwrap()
        }

        // Take field
        pub fn take_item_data(&mut self) -> ::std::vec::Vec<u8> {
            self.item_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional fixed64 squad_surplus_claimer_steam_id = 3;

        pub fn squad_surplus_claimer_steam_id(&self) -> u64 {
            self.squad_surplus_claimer_steam_id.unwrap_or(0)
        }

        pub fn clear_squad_surplus_claimer_steam_id(&mut self) {
            self.squad_surplus_claimer_steam_id = ::std::option::Option::None;
        }

        pub fn has_squad_surplus_claimer_steam_id(&self) -> bool {
            self.squad_surplus_claimer_steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_squad_surplus_claimer_steam_id(&mut self, v: u64) {
            self.squad_surplus_claimer_steam_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "grant_reason",
                |m: &Item| { &m.grant_reason },
                |m: &mut Item| { &mut m.grant_reason },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_data",
                |m: &Item| { &m.item_data },
                |m: &mut Item| { &mut m.item_data },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "squad_surplus_claimer_steam_id",
                |m: &Item| { &m.squad_surplus_claimer_steam_id },
                |m: &mut Item| { &mut m.squad_surplus_claimer_steam_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Item>(
                "CMsgMvMVictoryInfo.Item",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Item {
        const NAME: &'static str = "Item";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.grant_reason = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    18 => {
                        self.item_data = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    25 => {
                        self.squad_surplus_claimer_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.grant_reason {
                my_size += ::protobuf::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.item_data.as_ref() {
                my_size += ::protobuf::rt::bytes_size(2, &v);
            }
            if let Some(v) = self.squad_surplus_claimer_steam_id {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.grant_reason {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.item_data.as_ref() {
                os.write_bytes(2, v)?;
            }
            if let Some(v) = self.squad_surplus_claimer_steam_id {
                os.write_fixed64(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Item {
            Item::new()
        }

        fn clear(&mut self) {
            self.grant_reason = ::std::option::Option::None;
            self.item_data = ::std::option::Option::None;
            self.squad_surplus_claimer_steam_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Item {
            static instance: Item = Item {
                grant_reason: ::std::option::Option::None,
                item_data: ::std::option::Option::None,
                squad_surplus_claimer_steam_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Item {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgMvMVictoryInfo.Item").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Item {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Item {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgMvMVictoryInfo.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CMsgMvMVictoryInfo.Player.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgMvMVictoryInfo.Player.badge_granted)
        pub badge_granted: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgMvMVictoryInfo.Player.badge_progress_updated)
        pub badge_progress_updated: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgMvMVictoryInfo.Player.badge_leveled)
        pub badge_leveled: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgMvMVictoryInfo.Player.badge_level)
        pub badge_level: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgMvMVictoryInfo.Player.badge_progress_bits)
        pub badge_progress_bits: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgMvMVictoryInfo.Player.items)
        pub items: ::std::vec::Vec<Item>,
        // @@protoc_insertion_point(field:CMsgMvMVictoryInfo.Player.voucher_missing)
        pub voucher_missing: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgMvMVictoryInfo.Player.badge_points)
        pub badge_points: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgMvMVictoryInfo.Player.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id = 1;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional bool badge_granted = 3;

        pub fn badge_granted(&self) -> bool {
            self.badge_granted.unwrap_or(false)
        }

        pub fn clear_badge_granted(&mut self) {
            self.badge_granted = ::std::option::Option::None;
        }

        pub fn has_badge_granted(&self) -> bool {
            self.badge_granted.is_some()
        }

        // Param is passed by value, moved
        pub fn set_badge_granted(&mut self, v: bool) {
            self.badge_granted = ::std::option::Option::Some(v);
        }

        // optional bool badge_progress_updated = 4;

        pub fn badge_progress_updated(&self) -> bool {
            self.badge_progress_updated.unwrap_or(false)
        }

        pub fn clear_badge_progress_updated(&mut self) {
            self.badge_progress_updated = ::std::option::Option::None;
        }

        pub fn has_badge_progress_updated(&self) -> bool {
            self.badge_progress_updated.is_some()
        }

        // Param is passed by value, moved
        pub fn set_badge_progress_updated(&mut self, v: bool) {
            self.badge_progress_updated = ::std::option::Option::Some(v);
        }

        // optional bool badge_leveled = 5;

        pub fn badge_leveled(&self) -> bool {
            self.badge_leveled.unwrap_or(false)
        }

        pub fn clear_badge_leveled(&mut self) {
            self.badge_leveled = ::std::option::Option::None;
        }

        pub fn has_badge_leveled(&self) -> bool {
            self.badge_leveled.is_some()
        }

        // Param is passed by value, moved
        pub fn set_badge_leveled(&mut self, v: bool) {
            self.badge_leveled = ::std::option::Option::Some(v);
        }

        // optional uint32 badge_level = 6;

        pub fn badge_level(&self) -> u32 {
            self.badge_level.unwrap_or(0)
        }

        pub fn clear_badge_level(&mut self) {
            self.badge_level = ::std::option::Option::None;
        }

        pub fn has_badge_level(&self) -> bool {
            self.badge_level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_badge_level(&mut self, v: u32) {
            self.badge_level = ::std::option::Option::Some(v);
        }

        // optional uint32 badge_progress_bits = 7;

        pub fn badge_progress_bits(&self) -> u32 {
            self.badge_progress_bits.unwrap_or(0)
        }

        pub fn clear_badge_progress_bits(&mut self) {
            self.badge_progress_bits = ::std::option::Option::None;
        }

        pub fn has_badge_progress_bits(&self) -> bool {
            self.badge_progress_bits.is_some()
        }

        // Param is passed by value, moved
        pub fn set_badge_progress_bits(&mut self, v: u32) {
            self.badge_progress_bits = ::std::option::Option::Some(v);
        }

        // optional bool voucher_missing = 9;

        pub fn voucher_missing(&self) -> bool {
            self.voucher_missing.unwrap_or(false)
        }

        pub fn clear_voucher_missing(&mut self) {
            self.voucher_missing = ::std::option::Option::None;
        }

        pub fn has_voucher_missing(&self) -> bool {
            self.voucher_missing.is_some()
        }

        // Param is passed by value, moved
        pub fn set_voucher_missing(&mut self, v: bool) {
            self.voucher_missing = ::std::option::Option::Some(v);
        }

        // optional uint32 badge_points = 10;

        pub fn badge_points(&self) -> u32 {
            self.badge_points.unwrap_or(0)
        }

        pub fn clear_badge_points(&mut self) {
            self.badge_points = ::std::option::Option::None;
        }

        pub fn has_badge_points(&self) -> bool {
            self.badge_points.is_some()
        }

        // Param is passed by value, moved
        pub fn set_badge_points(&mut self, v: u32) {
            self.badge_points = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(9);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "steam_id",
                |m: &Player| { &m.steam_id },
                |m: &mut Player| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "badge_granted",
                |m: &Player| { &m.badge_granted },
                |m: &mut Player| { &mut m.badge_granted },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "badge_progress_updated",
                |m: &Player| { &m.badge_progress_updated },
                |m: &mut Player| { &mut m.badge_progress_updated },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "badge_leveled",
                |m: &Player| { &m.badge_leveled },
                |m: &mut Player| { &mut m.badge_leveled },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "badge_level",
                |m: &Player| { &m.badge_level },
                |m: &mut Player| { &mut m.badge_level },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "badge_progress_bits",
                |m: &Player| { &m.badge_progress_bits },
                |m: &mut Player| { &mut m.badge_progress_bits },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "items",
                |m: &Player| { &m.items },
                |m: &mut Player| { &mut m.items },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "voucher_missing",
                |m: &Player| { &m.voucher_missing },
                |m: &mut Player| { &mut m.voucher_missing },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "badge_points",
                |m: &Player| { &m.badge_points },
                |m: &mut Player| { &mut m.badge_points },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Player>(
                "CMsgMvMVictoryInfo.Player",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    24 => {
                        self.badge_granted = ::std::option::Option::Some(is.read_bool()?);
                    },
                    32 => {
                        self.badge_progress_updated = ::std::option::Option::Some(is.read_bool()?);
                    },
                    40 => {
                        self.badge_leveled = ::std::option::Option::Some(is.read_bool()?);
                    },
                    48 => {
                        self.badge_level = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.badge_progress_bits = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    66 => {
                        self.items.push(is.read_message()?);
                    },
                    72 => {
                        self.voucher_missing = ::std::option::Option::Some(is.read_bool()?);
                    },
                    80 => {
                        self.badge_points = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.badge_granted {
                my_size += 1 + 1;
            }
            if let Some(v) = self.badge_progress_updated {
                my_size += 1 + 1;
            }
            if let Some(v) = self.badge_leveled {
                my_size += 1 + 1;
            }
            if let Some(v) = self.badge_level {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.badge_progress_bits {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            for value in &self.items {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.voucher_missing {
                my_size += 1 + 1;
            }
            if let Some(v) = self.badge_points {
                my_size += ::protobuf::rt::uint32_size(10, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steam_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.badge_granted {
                os.write_bool(3, v)?;
            }
            if let Some(v) = self.badge_progress_updated {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.badge_leveled {
                os.write_bool(5, v)?;
            }
            if let Some(v) = self.badge_level {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.badge_progress_bits {
                os.write_uint32(7, v)?;
            }
            for v in &self.items {
                ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
            };
            if let Some(v) = self.voucher_missing {
                os.write_bool(9, v)?;
            }
            if let Some(v) = self.badge_points {
                os.write_uint32(10, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.badge_granted = ::std::option::Option::None;
            self.badge_progress_updated = ::std::option::Option::None;
            self.badge_leveled = ::std::option::Option::None;
            self.badge_level = ::std::option::Option::None;
            self.badge_progress_bits = ::std::option::Option::None;
            self.items.clear();
            self.voucher_missing = ::std::option::Option::None;
            self.badge_points = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                steam_id: ::std::option::Option::None,
                badge_granted: ::std::option::Option::None,
                badge_progress_updated: ::std::option::Option::None,
                badge_leveled: ::std::option::Option::None,
                badge_level: ::std::option::Option::None,
                badge_progress_bits: ::std::option::Option::None,
                items: ::std::vec::Vec::new(),
                voucher_missing: ::std::option::Option::None,
                badge_points: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Player {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgMvMVictoryInfo.Player").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Player {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Player {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgMvMVictoryInfo.GrantReason)
    pub enum GrantReason {
        // @@protoc_insertion_point(enum_value:CMsgMvMVictoryInfo.GrantReason.INVALID)
        INVALID = 0,
        // @@protoc_insertion_point(enum_value:CMsgMvMVictoryInfo.GrantReason.BADGE_LEVELED)
        BADGE_LEVELED = 1,
        // @@protoc_insertion_point(enum_value:CMsgMvMVictoryInfo.GrantReason.SQUAD_SURPLUS)
        SQUAD_SURPLUS = 2,
        // @@protoc_insertion_point(enum_value:CMsgMvMVictoryInfo.GrantReason.MANN_UP)
        MANN_UP = 3,
        // @@protoc_insertion_point(enum_value:CMsgMvMVictoryInfo.GrantReason.HELP_A_NOOB)
        HELP_A_NOOB = 4,
    }

    impl ::protobuf::Enum for GrantReason {
        const NAME: &'static str = "GrantReason";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<GrantReason> {
            match value {
                0 => ::std::option::Option::Some(GrantReason::INVALID),
                1 => ::std::option::Option::Some(GrantReason::BADGE_LEVELED),
                2 => ::std::option::Option::Some(GrantReason::SQUAD_SURPLUS),
                3 => ::std::option::Option::Some(GrantReason::MANN_UP),
                4 => ::std::option::Option::Some(GrantReason::HELP_A_NOOB),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<GrantReason> {
            match str {
                "INVALID" => ::std::option::Option::Some(GrantReason::INVALID),
                "BADGE_LEVELED" => ::std::option::Option::Some(GrantReason::BADGE_LEVELED),
                "SQUAD_SURPLUS" => ::std::option::Option::Some(GrantReason::SQUAD_SURPLUS),
                "MANN_UP" => ::std::option::Option::Some(GrantReason::MANN_UP),
                "HELP_A_NOOB" => ::std::option::Option::Some(GrantReason::HELP_A_NOOB),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [GrantReason] = &[
            GrantReason::INVALID,
            GrantReason::BADGE_LEVELED,
            GrantReason::SQUAD_SURPLUS,
            GrantReason::MANN_UP,
            GrantReason::HELP_A_NOOB,
        ];
    }

    impl ::protobuf::EnumFull for GrantReason {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgMvMVictoryInfo.GrantReason").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for GrantReason {
        fn default() -> Self {
            GrantReason::INVALID
        }
    }

    impl GrantReason {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<GrantReason>("CMsgMvMVictoryInfo.GrantReason")
        }
    }
}

// @@protoc_insertion_point(message:CGCMsgTFHelloResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCMsgTFHelloResponse {
    // message fields
    // @@protoc_insertion_point(field:CGCMsgTFHelloResponse.version_check)
    pub version_check: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCMsgTFHelloResponse.version_checksum)
    pub version_checksum: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CGCMsgTFHelloResponse.version_verbose)
    pub version_verbose: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCMsgTFHelloResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCMsgTFHelloResponse {
    fn default() -> &'a CGCMsgTFHelloResponse {
        <CGCMsgTFHelloResponse as ::protobuf::Message>::default_instance()
    }
}

impl CGCMsgTFHelloResponse {
    pub fn new() -> CGCMsgTFHelloResponse {
        ::std::default::Default::default()
    }

    // optional uint32 version_check = 1;

    pub fn version_check(&self) -> u32 {
        self.version_check.unwrap_or(0)
    }

    pub fn clear_version_check(&mut self) {
        self.version_check = ::std::option::Option::None;
    }

    pub fn has_version_check(&self) -> bool {
        self.version_check.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_check(&mut self, v: u32) {
        self.version_check = ::std::option::Option::Some(v);
    }

    // optional uint32 version_verbose = 3;

    pub fn version_verbose(&self) -> u32 {
        self.version_verbose.unwrap_or(0)
    }

    pub fn clear_version_verbose(&mut self) {
        self.version_verbose = ::std::option::Option::None;
    }

    pub fn has_version_verbose(&self) -> bool {
        self.version_verbose.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_verbose(&mut self, v: u32) {
        self.version_verbose = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version_check",
            |m: &CGCMsgTFHelloResponse| { &m.version_check },
            |m: &mut CGCMsgTFHelloResponse| { &mut m.version_check },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "version_checksum",
            |m: &CGCMsgTFHelloResponse| { &m.version_checksum },
            |m: &mut CGCMsgTFHelloResponse| { &mut m.version_checksum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version_verbose",
            |m: &CGCMsgTFHelloResponse| { &m.version_verbose },
            |m: &mut CGCMsgTFHelloResponse| { &mut m.version_verbose },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGCMsgTFHelloResponse>(
            "CGCMsgTFHelloResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGCMsgTFHelloResponse {
    const NAME: &'static str = "CGCMsgTFHelloResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version_check = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.version_checksum)?;
                },
                16 => {
                    self.version_checksum.push(is.read_uint64()?);
                },
                24 => {
                    self.version_verbose = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version_check {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.version_checksum {
            my_size += ::protobuf::rt::uint64_size(2, *value);
        };
        if let Some(v) = self.version_verbose {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version_check {
            os.write_uint32(1, v)?;
        }
        for v in &self.version_checksum {
            os.write_uint64(2, *v)?;
        };
        if let Some(v) = self.version_verbose {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCMsgTFHelloResponse {
        CGCMsgTFHelloResponse::new()
    }

    fn clear(&mut self) {
        self.version_check = ::std::option::Option::None;
        self.version_checksum.clear();
        self.version_verbose = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCMsgTFHelloResponse {
        static instance: CGCMsgTFHelloResponse = CGCMsgTFHelloResponse {
            version_check: ::std::option::Option::None,
            version_checksum: ::std::vec::Vec::new(),
            version_verbose: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGCMsgTFHelloResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGCMsgTFHelloResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGCMsgTFHelloResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCMsgTFHelloResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CGCMsgTFSync)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCMsgTFSync {
    // message fields
    // @@protoc_insertion_point(field:CGCMsgTFSync.version_checksum)
    pub version_checksum: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CGCMsgTFSync.version_check)
    pub version_check: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCMsgTFSync.version_check_ex)
    pub version_check_ex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCMsgTFSync.version_check_ex2)
    pub version_check_ex2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCMsgTFSync.version_checksum_ex)
    pub version_checksum_ex: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCMsgTFSync.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCMsgTFSync {
    fn default() -> &'a CGCMsgTFSync {
        <CGCMsgTFSync as ::protobuf::Message>::default_instance()
    }
}

impl CGCMsgTFSync {
    pub fn new() -> CGCMsgTFSync {
        ::std::default::Default::default()
    }

    // optional bytes version_checksum = 1;

    pub fn version_checksum(&self) -> &[u8] {
        match self.version_checksum.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_version_checksum(&mut self) {
        self.version_checksum = ::std::option::Option::None;
    }

    pub fn has_version_checksum(&self) -> bool {
        self.version_checksum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_checksum(&mut self, v: ::std::vec::Vec<u8>) {
        self.version_checksum = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_checksum(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.version_checksum.is_none() {
            self.version_checksum = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.version_checksum.as_mut().unwrap()
    }

    // Take field
    pub fn take_version_checksum(&mut self) -> ::std::vec::Vec<u8> {
        self.version_checksum.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 version_check = 2;

    pub fn version_check(&self) -> u32 {
        self.version_check.unwrap_or(0)
    }

    pub fn clear_version_check(&mut self) {
        self.version_check = ::std::option::Option::None;
    }

    pub fn has_version_check(&self) -> bool {
        self.version_check.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_check(&mut self, v: u32) {
        self.version_check = ::std::option::Option::Some(v);
    }

    // optional uint32 version_check_ex = 3;

    pub fn version_check_ex(&self) -> u32 {
        self.version_check_ex.unwrap_or(0)
    }

    pub fn clear_version_check_ex(&mut self) {
        self.version_check_ex = ::std::option::Option::None;
    }

    pub fn has_version_check_ex(&self) -> bool {
        self.version_check_ex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_check_ex(&mut self, v: u32) {
        self.version_check_ex = ::std::option::Option::Some(v);
    }

    // optional uint32 version_check_ex2 = 4;

    pub fn version_check_ex2(&self) -> u32 {
        self.version_check_ex2.unwrap_or(0)
    }

    pub fn clear_version_check_ex2(&mut self) {
        self.version_check_ex2 = ::std::option::Option::None;
    }

    pub fn has_version_check_ex2(&self) -> bool {
        self.version_check_ex2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_check_ex2(&mut self, v: u32) {
        self.version_check_ex2 = ::std::option::Option::Some(v);
    }

    // optional bytes version_checksum_ex = 5;

    pub fn version_checksum_ex(&self) -> &[u8] {
        match self.version_checksum_ex.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_version_checksum_ex(&mut self) {
        self.version_checksum_ex = ::std::option::Option::None;
    }

    pub fn has_version_checksum_ex(&self) -> bool {
        self.version_checksum_ex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_checksum_ex(&mut self, v: ::std::vec::Vec<u8>) {
        self.version_checksum_ex = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_checksum_ex(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.version_checksum_ex.is_none() {
            self.version_checksum_ex = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.version_checksum_ex.as_mut().unwrap()
    }

    // Take field
    pub fn take_version_checksum_ex(&mut self) -> ::std::vec::Vec<u8> {
        self.version_checksum_ex.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version_checksum",
            |m: &CGCMsgTFSync| { &m.version_checksum },
            |m: &mut CGCMsgTFSync| { &mut m.version_checksum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version_check",
            |m: &CGCMsgTFSync| { &m.version_check },
            |m: &mut CGCMsgTFSync| { &mut m.version_check },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version_check_ex",
            |m: &CGCMsgTFSync| { &m.version_check_ex },
            |m: &mut CGCMsgTFSync| { &mut m.version_check_ex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version_check_ex2",
            |m: &CGCMsgTFSync| { &m.version_check_ex2 },
            |m: &mut CGCMsgTFSync| { &mut m.version_check_ex2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version_checksum_ex",
            |m: &CGCMsgTFSync| { &m.version_checksum_ex },
            |m: &mut CGCMsgTFSync| { &mut m.version_checksum_ex },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGCMsgTFSync>(
            "CGCMsgTFSync",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGCMsgTFSync {
    const NAME: &'static str = "CGCMsgTFSync";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.version_checksum = ::std::option::Option::Some(is.read_bytes()?);
                },
                16 => {
                    self.version_check = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.version_check_ex = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.version_check_ex2 = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.version_checksum_ex = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version_checksum.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.version_check {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.version_check_ex {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.version_check_ex2 {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.version_checksum_ex.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version_checksum.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.version_check {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.version_check_ex {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.version_check_ex2 {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.version_checksum_ex.as_ref() {
            os.write_bytes(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCMsgTFSync {
        CGCMsgTFSync::new()
    }

    fn clear(&mut self) {
        self.version_checksum = ::std::option::Option::None;
        self.version_check = ::std::option::Option::None;
        self.version_check_ex = ::std::option::Option::None;
        self.version_check_ex2 = ::std::option::Option::None;
        self.version_checksum_ex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCMsgTFSync {
        static instance: CGCMsgTFSync = CGCMsgTFSync {
            version_checksum: ::std::option::Option::None,
            version_check: ::std::option::Option::None,
            version_check_ex: ::std::option::Option::None,
            version_check_ex2: ::std::option::Option::None,
            version_checksum_ex: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGCMsgTFSync {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGCMsgTFSync").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGCMsgTFSync {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCMsgTFSync {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CGCMsgTFSyncEx)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCMsgTFSyncEx {
    // message fields
    // @@protoc_insertion_point(field:CGCMsgTFSyncEx.version_checksum)
    pub version_checksum: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGCMsgTFSyncEx.version_checksum_ex)
    pub version_checksum_ex: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CGCMsgTFSyncEx.version_check)
    pub version_check: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCMsgTFSyncEx.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCMsgTFSyncEx {
    fn default() -> &'a CGCMsgTFSyncEx {
        <CGCMsgTFSyncEx as ::protobuf::Message>::default_instance()
    }
}

impl CGCMsgTFSyncEx {
    pub fn new() -> CGCMsgTFSyncEx {
        ::std::default::Default::default()
    }

    // optional string version_checksum = 1;

    pub fn version_checksum(&self) -> &str {
        match self.version_checksum.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version_checksum(&mut self) {
        self.version_checksum = ::std::option::Option::None;
    }

    pub fn has_version_checksum(&self) -> bool {
        self.version_checksum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_checksum(&mut self, v: ::std::string::String) {
        self.version_checksum = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_checksum(&mut self) -> &mut ::std::string::String {
        if self.version_checksum.is_none() {
            self.version_checksum = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version_checksum.as_mut().unwrap()
    }

    // Take field
    pub fn take_version_checksum(&mut self) -> ::std::string::String {
        self.version_checksum.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes version_checksum_ex = 2;

    pub fn version_checksum_ex(&self) -> &[u8] {
        match self.version_checksum_ex.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_version_checksum_ex(&mut self) {
        self.version_checksum_ex = ::std::option::Option::None;
    }

    pub fn has_version_checksum_ex(&self) -> bool {
        self.version_checksum_ex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_checksum_ex(&mut self, v: ::std::vec::Vec<u8>) {
        self.version_checksum_ex = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_checksum_ex(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.version_checksum_ex.is_none() {
            self.version_checksum_ex = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.version_checksum_ex.as_mut().unwrap()
    }

    // Take field
    pub fn take_version_checksum_ex(&mut self) -> ::std::vec::Vec<u8> {
        self.version_checksum_ex.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 version_check = 3;

    pub fn version_check(&self) -> u32 {
        self.version_check.unwrap_or(0)
    }

    pub fn clear_version_check(&mut self) {
        self.version_check = ::std::option::Option::None;
    }

    pub fn has_version_check(&self) -> bool {
        self.version_check.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_check(&mut self, v: u32) {
        self.version_check = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version_checksum",
            |m: &CGCMsgTFSyncEx| { &m.version_checksum },
            |m: &mut CGCMsgTFSyncEx| { &mut m.version_checksum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version_checksum_ex",
            |m: &CGCMsgTFSyncEx| { &m.version_checksum_ex },
            |m: &mut CGCMsgTFSyncEx| { &mut m.version_checksum_ex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version_check",
            |m: &CGCMsgTFSyncEx| { &m.version_check },
            |m: &mut CGCMsgTFSyncEx| { &mut m.version_check },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGCMsgTFSyncEx>(
            "CGCMsgTFSyncEx",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGCMsgTFSyncEx {
    const NAME: &'static str = "CGCMsgTFSyncEx";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.version_checksum = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.version_checksum_ex = ::std::option::Option::Some(is.read_bytes()?);
                },
                24 => {
                    self.version_check = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version_checksum.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.version_checksum_ex.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.version_check {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version_checksum.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.version_checksum_ex.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.version_check {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCMsgTFSyncEx {
        CGCMsgTFSyncEx::new()
    }

    fn clear(&mut self) {
        self.version_checksum = ::std::option::Option::None;
        self.version_checksum_ex = ::std::option::Option::None;
        self.version_check = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCMsgTFSyncEx {
        static instance: CGCMsgTFSyncEx = CGCMsgTFSyncEx {
            version_checksum: ::std::option::Option::None,
            version_checksum_ex: ::std::option::Option::None,
            version_check: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGCMsgTFSyncEx {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGCMsgTFSyncEx").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGCMsgTFSyncEx {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCMsgTFSyncEx {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgMvMVictory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMvMVictory {
    // message fields
    // @@protoc_insertion_point(field:CMsgMvMVictory.legacy_mission_index)
    pub legacy_mission_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMvMVictory.tour_name_mannup)
    pub tour_name_mannup: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgMvMVictory.mission_name)
    pub mission_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgMvMVictory.players)
    pub players: ::std::vec::Vec<cmsg_mv_mvictory::Player>,
    // @@protoc_insertion_point(field:CMsgMvMVictory.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgMvMVictory.event_time)
    pub event_time: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMvMVictory.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMvMVictory {
    fn default() -> &'a CMsgMvMVictory {
        <CMsgMvMVictory as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMvMVictory {
    pub fn new() -> CMsgMvMVictory {
        ::std::default::Default::default()
    }

    // optional uint32 legacy_mission_index = 1;

    pub fn legacy_mission_index(&self) -> u32 {
        self.legacy_mission_index.unwrap_or(0)
    }

    pub fn clear_legacy_mission_index(&mut self) {
        self.legacy_mission_index = ::std::option::Option::None;
    }

    pub fn has_legacy_mission_index(&self) -> bool {
        self.legacy_mission_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_mission_index(&mut self, v: u32) {
        self.legacy_mission_index = ::std::option::Option::Some(v);
    }

    // optional string tour_name_mannup = 5;

    pub fn tour_name_mannup(&self) -> &str {
        match self.tour_name_mannup.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_tour_name_mannup(&mut self) {
        self.tour_name_mannup = ::std::option::Option::None;
    }

    pub fn has_tour_name_mannup(&self) -> bool {
        self.tour_name_mannup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tour_name_mannup(&mut self, v: ::std::string::String) {
        self.tour_name_mannup = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tour_name_mannup(&mut self) -> &mut ::std::string::String {
        if self.tour_name_mannup.is_none() {
            self.tour_name_mannup = ::std::option::Option::Some(::std::string::String::new());
        }
        self.tour_name_mannup.as_mut().unwrap()
    }

    // Take field
    pub fn take_tour_name_mannup(&mut self) -> ::std::string::String {
        self.tour_name_mannup.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mission_name = 6;

    pub fn mission_name(&self) -> &str {
        match self.mission_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mission_name(&mut self) {
        self.mission_name = ::std::option::Option::None;
    }

    pub fn has_mission_name(&self) -> bool {
        self.mission_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mission_name(&mut self, v: ::std::string::String) {
        self.mission_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mission_name(&mut self) -> &mut ::std::string::String {
        if self.mission_name.is_none() {
            self.mission_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mission_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_mission_name(&mut self) -> ::std::string::String {
        self.mission_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 lobby_id = 3;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 event_time = 4;

    pub fn event_time(&self) -> u32 {
        self.event_time.unwrap_or(0)
    }

    pub fn clear_event_time(&mut self) {
        self.event_time = ::std::option::Option::None;
    }

    pub fn has_event_time(&self) -> bool {
        self.event_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_time(&mut self, v: u32) {
        self.event_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "legacy_mission_index",
            |m: &CMsgMvMVictory| { &m.legacy_mission_index },
            |m: &mut CMsgMvMVictory| { &mut m.legacy_mission_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tour_name_mannup",
            |m: &CMsgMvMVictory| { &m.tour_name_mannup },
            |m: &mut CMsgMvMVictory| { &mut m.tour_name_mannup },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mission_name",
            |m: &CMsgMvMVictory| { &m.mission_name },
            |m: &mut CMsgMvMVictory| { &mut m.mission_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "players",
            |m: &CMsgMvMVictory| { &m.players },
            |m: &mut CMsgMvMVictory| { &mut m.players },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_id",
            |m: &CMsgMvMVictory| { &m.lobby_id },
            |m: &mut CMsgMvMVictory| { &mut m.lobby_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_time",
            |m: &CMsgMvMVictory| { &m.event_time },
            |m: &mut CMsgMvMVictory| { &mut m.event_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgMvMVictory>(
            "CMsgMvMVictory",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgMvMVictory {
    const NAME: &'static str = "CMsgMvMVictory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.legacy_mission_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.tour_name_mannup = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.mission_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.players.push(is.read_message()?);
                },
                24 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                37 => {
                    self.event_time = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.legacy_mission_index {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.tour_name_mannup.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.mission_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.lobby_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.event_time {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.legacy_mission_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.tour_name_mannup.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.mission_name.as_ref() {
            os.write_string(6, v)?;
        }
        for v in &self.players {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.lobby_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.event_time {
            os.write_fixed32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMvMVictory {
        CMsgMvMVictory::new()
    }

    fn clear(&mut self) {
        self.legacy_mission_index = ::std::option::Option::None;
        self.tour_name_mannup = ::std::option::Option::None;
        self.mission_name = ::std::option::Option::None;
        self.players.clear();
        self.lobby_id = ::std::option::Option::None;
        self.event_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMvMVictory {
        static instance: CMsgMvMVictory = CMsgMvMVictory {
            legacy_mission_index: ::std::option::Option::None,
            tour_name_mannup: ::std::option::Option::None,
            mission_name: ::std::option::Option::None,
            players: ::std::vec::Vec::new(),
            lobby_id: ::std::option::Option::None,
            event_time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgMvMVictory {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgMvMVictory").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgMvMVictory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMvMVictory {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgMvMVictory`
pub mod cmsg_mv_mvictory {
    // @@protoc_insertion_point(message:CMsgMvMVictory.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CMsgMvMVictory.Player.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgMvMVictory.Player.squad_surplus)
        pub squad_surplus: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgMvMVictory.Player.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id = 1;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional bool squad_surplus = 2;

        pub fn squad_surplus(&self) -> bool {
            self.squad_surplus.unwrap_or(false)
        }

        pub fn clear_squad_surplus(&mut self) {
            self.squad_surplus = ::std::option::Option::None;
        }

        pub fn has_squad_surplus(&self) -> bool {
            self.squad_surplus.is_some()
        }

        // Param is passed by value, moved
        pub fn set_squad_surplus(&mut self, v: bool) {
            self.squad_surplus = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "steam_id",
                |m: &Player| { &m.steam_id },
                |m: &mut Player| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "squad_surplus",
                |m: &Player| { &m.squad_surplus },
                |m: &mut Player| { &mut m.squad_surplus },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Player>(
                "CMsgMvMVictory.Player",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.squad_surplus = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.squad_surplus {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steam_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.squad_surplus {
                os.write_bool(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.squad_surplus = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                steam_id: ::std::option::Option::None,
                squad_surplus: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Player {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgMvMVictory.Player").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Player {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Player {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgMvMMannUpVictoryReply)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMvMMannUpVictoryReply {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMvMMannUpVictoryReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMvMMannUpVictoryReply {
    fn default() -> &'a CMsgMvMMannUpVictoryReply {
        <CMsgMvMMannUpVictoryReply as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMvMMannUpVictoryReply {
    pub fn new() -> CMsgMvMMannUpVictoryReply {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgMvMMannUpVictoryReply>(
            "CMsgMvMMannUpVictoryReply",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgMvMMannUpVictoryReply {
    const NAME: &'static str = "CMsgMvMMannUpVictoryReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMvMMannUpVictoryReply {
        CMsgMvMMannUpVictoryReply::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMvMMannUpVictoryReply {
        static instance: CMsgMvMMannUpVictoryReply = CMsgMvMMannUpVictoryReply {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgMvMMannUpVictoryReply {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgMvMMannUpVictoryReply").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgMvMMannUpVictoryReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMvMMannUpVictoryReply {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGameServerKickingLobby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameServerKickingLobby {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameServerKickingLobby.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGameServerKickingLobby.match_id)
    pub match_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameServerKickingLobby.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerKickingLobby {
    fn default() -> &'a CMsgGameServerKickingLobby {
        <CMsgGameServerKickingLobby as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerKickingLobby {
    pub fn new() -> CMsgGameServerKickingLobby {
        ::std::default::Default::default()
    }

    // optional uint64 lobby_id = 3;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 4;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_id",
            |m: &CMsgGameServerKickingLobby| { &m.lobby_id },
            |m: &mut CMsgGameServerKickingLobby| { &mut m.lobby_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgGameServerKickingLobby| { &m.match_id },
            |m: &mut CMsgGameServerKickingLobby| { &mut m.match_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGameServerKickingLobby>(
            "CMsgGameServerKickingLobby",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGameServerKickingLobby {
    const NAME: &'static str = "CMsgGameServerKickingLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                24 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.lobby_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameServerKickingLobby {
        CMsgGameServerKickingLobby::new()
    }

    fn clear(&mut self) {
        self.lobby_id = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameServerKickingLobby {
        static instance: CMsgGameServerKickingLobby = CMsgGameServerKickingLobby {
            lobby_id: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGameServerKickingLobby {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGameServerKickingLobby").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGameServerKickingLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerKickingLobby {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGameServerKickingLobbyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameServerKickingLobbyResponse {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameServerKickingLobbyResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerKickingLobbyResponse {
    fn default() -> &'a CMsgGameServerKickingLobbyResponse {
        <CMsgGameServerKickingLobbyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerKickingLobbyResponse {
    pub fn new() -> CMsgGameServerKickingLobbyResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGameServerKickingLobbyResponse>(
            "CMsgGameServerKickingLobbyResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGameServerKickingLobbyResponse {
    const NAME: &'static str = "CMsgGameServerKickingLobbyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameServerKickingLobbyResponse {
        CMsgGameServerKickingLobbyResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameServerKickingLobbyResponse {
        static instance: CMsgGameServerKickingLobbyResponse = CMsgGameServerKickingLobbyResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGameServerKickingLobbyResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGameServerKickingLobbyResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGameServerKickingLobbyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerKickingLobbyResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgLeaveGameAndPrepareToJoinParty)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLeaveGameAndPrepareToJoinParty {
    // message fields
    // @@protoc_insertion_point(field:CMsgLeaveGameAndPrepareToJoinParty.party_id)
    pub party_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLeaveGameAndPrepareToJoinParty.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLeaveGameAndPrepareToJoinParty {
    fn default() -> &'a CMsgLeaveGameAndPrepareToJoinParty {
        <CMsgLeaveGameAndPrepareToJoinParty as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLeaveGameAndPrepareToJoinParty {
    pub fn new() -> CMsgLeaveGameAndPrepareToJoinParty {
        ::std::default::Default::default()
    }

    // optional fixed64 party_id = 1;

    pub fn party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }

    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "party_id",
            |m: &CMsgLeaveGameAndPrepareToJoinParty| { &m.party_id },
            |m: &mut CMsgLeaveGameAndPrepareToJoinParty| { &mut m.party_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLeaveGameAndPrepareToJoinParty>(
            "CMsgLeaveGameAndPrepareToJoinParty",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgLeaveGameAndPrepareToJoinParty {
    const NAME: &'static str = "CMsgLeaveGameAndPrepareToJoinParty";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.party_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.party_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLeaveGameAndPrepareToJoinParty {
        CMsgLeaveGameAndPrepareToJoinParty::new()
    }

    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLeaveGameAndPrepareToJoinParty {
        static instance: CMsgLeaveGameAndPrepareToJoinParty = CMsgLeaveGameAndPrepareToJoinParty {
            party_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgLeaveGameAndPrepareToJoinParty {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLeaveGameAndPrepareToJoinParty").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLeaveGameAndPrepareToJoinParty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLeaveGameAndPrepareToJoinParty {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPlayerLeftMatch)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPlayerLeftMatch {
    // message fields
    // @@protoc_insertion_point(field:CMsgPlayerLeftMatch.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPlayerLeftMatch.leave_reason)
    pub leave_reason: ::std::option::Option<::protobuf::EnumOrUnknown<TFMatchLeaveReason>>,
    // @@protoc_insertion_point(field:CMsgPlayerLeftMatch.was_abandon)
    pub was_abandon: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPlayerLeftMatch.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPlayerLeftMatch.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPlayerLeftMatch.xp_breakdown)
    pub xp_breakdown: ::std::vec::Vec<CMsgTFXPSource>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPlayerLeftMatch.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPlayerLeftMatch {
    fn default() -> &'a CMsgPlayerLeftMatch {
        <CMsgPlayerLeftMatch as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPlayerLeftMatch {
    pub fn new() -> CMsgPlayerLeftMatch {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional .TFMatchLeaveReason leave_reason = 2;

    pub fn leave_reason(&self) -> TFMatchLeaveReason {
        match self.leave_reason {
            Some(e) => e.enum_value_or(TFMatchLeaveReason::TFMatchLeaveReason_UNSPECIFIED),
            None => TFMatchLeaveReason::TFMatchLeaveReason_UNSPECIFIED,
        }
    }

    pub fn clear_leave_reason(&mut self) {
        self.leave_reason = ::std::option::Option::None;
    }

    pub fn has_leave_reason(&self) -> bool {
        self.leave_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leave_reason(&mut self, v: TFMatchLeaveReason) {
        self.leave_reason = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool was_abandon = 3;

    pub fn was_abandon(&self) -> bool {
        self.was_abandon.unwrap_or(false)
    }

    pub fn clear_was_abandon(&mut self) {
        self.was_abandon = ::std::option::Option::None;
    }

    pub fn has_was_abandon(&self) -> bool {
        self.was_abandon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_was_abandon(&mut self, v: bool) {
        self.was_abandon = ::std::option::Option::Some(v);
    }

    // optional uint64 lobby_id = 4;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 5;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id",
            |m: &CMsgPlayerLeftMatch| { &m.steam_id },
            |m: &mut CMsgPlayerLeftMatch| { &mut m.steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leave_reason",
            |m: &CMsgPlayerLeftMatch| { &m.leave_reason },
            |m: &mut CMsgPlayerLeftMatch| { &mut m.leave_reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "was_abandon",
            |m: &CMsgPlayerLeftMatch| { &m.was_abandon },
            |m: &mut CMsgPlayerLeftMatch| { &mut m.was_abandon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_id",
            |m: &CMsgPlayerLeftMatch| { &m.lobby_id },
            |m: &mut CMsgPlayerLeftMatch| { &mut m.lobby_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgPlayerLeftMatch| { &m.match_id },
            |m: &mut CMsgPlayerLeftMatch| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "xp_breakdown",
            |m: &CMsgPlayerLeftMatch| { &m.xp_breakdown },
            |m: &mut CMsgPlayerLeftMatch| { &mut m.xp_breakdown },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPlayerLeftMatch>(
            "CMsgPlayerLeftMatch",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPlayerLeftMatch {
    const NAME: &'static str = "CMsgPlayerLeftMatch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.leave_reason = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.was_abandon = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                50 => {
                    self.xp_breakdown.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.leave_reason {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.was_abandon {
            my_size += 1 + 1;
        }
        if let Some(v) = self.lobby_id {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        for value in &self.xp_breakdown {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.leave_reason {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.was_abandon {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.lobby_id {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(5, v)?;
        }
        for v in &self.xp_breakdown {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPlayerLeftMatch {
        CMsgPlayerLeftMatch::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.leave_reason = ::std::option::Option::None;
        self.was_abandon = ::std::option::Option::None;
        self.lobby_id = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.xp_breakdown.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPlayerLeftMatch {
        static instance: CMsgPlayerLeftMatch = CMsgPlayerLeftMatch {
            steam_id: ::std::option::Option::None,
            leave_reason: ::std::option::Option::None,
            was_abandon: ::std::option::Option::None,
            lobby_id: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            xp_breakdown: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPlayerLeftMatch {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPlayerLeftMatch").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPlayerLeftMatch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPlayerLeftMatch {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPlayerLeftMatchResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPlayerLeftMatchResponse {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPlayerLeftMatchResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPlayerLeftMatchResponse {
    fn default() -> &'a CMsgPlayerLeftMatchResponse {
        <CMsgPlayerLeftMatchResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPlayerLeftMatchResponse {
    pub fn new() -> CMsgPlayerLeftMatchResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPlayerLeftMatchResponse>(
            "CMsgPlayerLeftMatchResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPlayerLeftMatchResponse {
    const NAME: &'static str = "CMsgPlayerLeftMatchResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPlayerLeftMatchResponse {
        CMsgPlayerLeftMatchResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPlayerLeftMatchResponse {
        static instance: CMsgPlayerLeftMatchResponse = CMsgPlayerLeftMatchResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPlayerLeftMatchResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPlayerLeftMatchResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPlayerLeftMatchResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPlayerLeftMatchResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgProcessMatchVoteKick)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgProcessMatchVoteKick {
    // message fields
    // @@protoc_insertion_point(field:CMsgProcessMatchVoteKick.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgProcessMatchVoteKick.initiator_steam_id)
    pub initiator_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgProcessMatchVoteKick.target_steam_id)
    pub target_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgProcessMatchVoteKick.reason)
    pub reason: ::std::option::Option<::protobuf::EnumOrUnknown<TFVoteKickReason>>,
    // @@protoc_insertion_point(field:CMsgProcessMatchVoteKick.votes)
    pub votes: ::std::vec::Vec<cmsg_process_match_vote_kick::Vote>,
    // @@protoc_insertion_point(field:CMsgProcessMatchVoteKick.default_pass)
    pub default_pass: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgProcessMatchVoteKick.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgProcessMatchVoteKick {
    fn default() -> &'a CMsgProcessMatchVoteKick {
        <CMsgProcessMatchVoteKick as ::protobuf::Message>::default_instance()
    }
}

impl CMsgProcessMatchVoteKick {
    pub fn new() -> CMsgProcessMatchVoteKick {
        ::std::default::Default::default()
    }

    // optional fixed64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 initiator_steam_id = 2;

    pub fn initiator_steam_id(&self) -> u64 {
        self.initiator_steam_id.unwrap_or(0)
    }

    pub fn clear_initiator_steam_id(&mut self) {
        self.initiator_steam_id = ::std::option::Option::None;
    }

    pub fn has_initiator_steam_id(&self) -> bool {
        self.initiator_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initiator_steam_id(&mut self, v: u64) {
        self.initiator_steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 target_steam_id = 3;

    pub fn target_steam_id(&self) -> u64 {
        self.target_steam_id.unwrap_or(0)
    }

    pub fn clear_target_steam_id(&mut self) {
        self.target_steam_id = ::std::option::Option::None;
    }

    pub fn has_target_steam_id(&self) -> bool {
        self.target_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_steam_id(&mut self, v: u64) {
        self.target_steam_id = ::std::option::Option::Some(v);
    }

    // optional .TFVoteKickReason reason = 4;

    pub fn reason(&self) -> TFVoteKickReason {
        match self.reason {
            Some(e) => e.enum_value_or(TFVoteKickReason::TFVoteKickReason_Other),
            None => TFVoteKickReason::TFVoteKickReason_Other,
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: TFVoteKickReason) {
        self.reason = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool default_pass = 6;

    pub fn default_pass(&self) -> bool {
        self.default_pass.unwrap_or(false)
    }

    pub fn clear_default_pass(&mut self) {
        self.default_pass = ::std::option::Option::None;
    }

    pub fn has_default_pass(&self) -> bool {
        self.default_pass.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_pass(&mut self, v: bool) {
        self.default_pass = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgProcessMatchVoteKick| { &m.match_id },
            |m: &mut CMsgProcessMatchVoteKick| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "initiator_steam_id",
            |m: &CMsgProcessMatchVoteKick| { &m.initiator_steam_id },
            |m: &mut CMsgProcessMatchVoteKick| { &mut m.initiator_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_steam_id",
            |m: &CMsgProcessMatchVoteKick| { &m.target_steam_id },
            |m: &mut CMsgProcessMatchVoteKick| { &mut m.target_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &CMsgProcessMatchVoteKick| { &m.reason },
            |m: &mut CMsgProcessMatchVoteKick| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "votes",
            |m: &CMsgProcessMatchVoteKick| { &m.votes },
            |m: &mut CMsgProcessMatchVoteKick| { &mut m.votes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "default_pass",
            |m: &CMsgProcessMatchVoteKick| { &m.default_pass },
            |m: &mut CMsgProcessMatchVoteKick| { &mut m.default_pass },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgProcessMatchVoteKick>(
            "CMsgProcessMatchVoteKick",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgProcessMatchVoteKick {
    const NAME: &'static str = "CMsgProcessMatchVoteKick";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.match_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.initiator_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.target_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                32 => {
                    self.reason = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                42 => {
                    self.votes.push(is.read_message()?);
                },
                48 => {
                    self.default_pass = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.initiator_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.target_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        for value in &self.votes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.default_pass {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.initiator_steam_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.target_steam_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.reason {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.votes {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.default_pass {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgProcessMatchVoteKick {
        CMsgProcessMatchVoteKick::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.initiator_steam_id = ::std::option::Option::None;
        self.target_steam_id = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.votes.clear();
        self.default_pass = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgProcessMatchVoteKick {
        static instance: CMsgProcessMatchVoteKick = CMsgProcessMatchVoteKick {
            match_id: ::std::option::Option::None,
            initiator_steam_id: ::std::option::Option::None,
            target_steam_id: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            votes: ::std::vec::Vec::new(),
            default_pass: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgProcessMatchVoteKick {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgProcessMatchVoteKick").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgProcessMatchVoteKick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgProcessMatchVoteKick {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgProcessMatchVoteKick`
pub mod cmsg_process_match_vote_kick {
    // @@protoc_insertion_point(message:CMsgProcessMatchVoteKick.Vote)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Vote {
        // message fields
        // @@protoc_insertion_point(field:CMsgProcessMatchVoteKick.Vote.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgProcessMatchVoteKick.Vote.vote_yay)
        pub vote_yay: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgProcessMatchVoteKick.Vote.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Vote {
        fn default() -> &'a Vote {
            <Vote as ::protobuf::Message>::default_instance()
        }
    }

    impl Vote {
        pub fn new() -> Vote {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id = 1;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional bool vote_yay = 2;

        pub fn vote_yay(&self) -> bool {
            self.vote_yay.unwrap_or(false)
        }

        pub fn clear_vote_yay(&mut self) {
            self.vote_yay = ::std::option::Option::None;
        }

        pub fn has_vote_yay(&self) -> bool {
            self.vote_yay.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vote_yay(&mut self, v: bool) {
            self.vote_yay = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "steam_id",
                |m: &Vote| { &m.steam_id },
                |m: &mut Vote| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "vote_yay",
                |m: &Vote| { &m.vote_yay },
                |m: &mut Vote| { &mut m.vote_yay },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Vote>(
                "CMsgProcessMatchVoteKick.Vote",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Vote {
        const NAME: &'static str = "Vote";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.vote_yay = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.vote_yay {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steam_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.vote_yay {
                os.write_bool(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Vote {
            Vote::new()
        }

        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.vote_yay = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Vote {
            static instance: Vote = Vote {
                steam_id: ::std::option::Option::None,
                vote_yay: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Vote {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgProcessMatchVoteKick.Vote").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Vote {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Vote {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgProcessMatchVoteKickResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgProcessMatchVoteKickResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgProcessMatchVoteKickResponse.rip)
    pub rip: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgProcessMatchVoteKickResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgProcessMatchVoteKickResponse {
    fn default() -> &'a CMsgProcessMatchVoteKickResponse {
        <CMsgProcessMatchVoteKickResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgProcessMatchVoteKickResponse {
    pub fn new() -> CMsgProcessMatchVoteKickResponse {
        ::std::default::Default::default()
    }

    // optional bool rip = 1;

    pub fn rip(&self) -> bool {
        self.rip.unwrap_or(false)
    }

    pub fn clear_rip(&mut self) {
        self.rip = ::std::option::Option::None;
    }

    pub fn has_rip(&self) -> bool {
        self.rip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rip(&mut self, v: bool) {
        self.rip = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rip",
            |m: &CMsgProcessMatchVoteKickResponse| { &m.rip },
            |m: &mut CMsgProcessMatchVoteKickResponse| { &mut m.rip },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgProcessMatchVoteKickResponse>(
            "CMsgProcessMatchVoteKickResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgProcessMatchVoteKickResponse {
    const NAME: &'static str = "CMsgProcessMatchVoteKickResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.rip = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rip {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rip {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgProcessMatchVoteKickResponse {
        CMsgProcessMatchVoteKickResponse::new()
    }

    fn clear(&mut self) {
        self.rip = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgProcessMatchVoteKickResponse {
        static instance: CMsgProcessMatchVoteKickResponse = CMsgProcessMatchVoteKickResponse {
            rip: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgProcessMatchVoteKickResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgProcessMatchVoteKickResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgProcessMatchVoteKickResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgProcessMatchVoteKickResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPlayerVoteKickedAfterLeavingMatchResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPlayerVoteKickedAfterLeavingMatchResponse {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPlayerVoteKickedAfterLeavingMatchResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPlayerVoteKickedAfterLeavingMatchResponse {
    fn default() -> &'a CMsgPlayerVoteKickedAfterLeavingMatchResponse {
        <CMsgPlayerVoteKickedAfterLeavingMatchResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPlayerVoteKickedAfterLeavingMatchResponse {
    pub fn new() -> CMsgPlayerVoteKickedAfterLeavingMatchResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPlayerVoteKickedAfterLeavingMatchResponse>(
            "CMsgPlayerVoteKickedAfterLeavingMatchResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPlayerVoteKickedAfterLeavingMatchResponse {
    const NAME: &'static str = "CMsgPlayerVoteKickedAfterLeavingMatchResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPlayerVoteKickedAfterLeavingMatchResponse {
        CMsgPlayerVoteKickedAfterLeavingMatchResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPlayerVoteKickedAfterLeavingMatchResponse {
        static instance: CMsgPlayerVoteKickedAfterLeavingMatchResponse = CMsgPlayerVoteKickedAfterLeavingMatchResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPlayerVoteKickedAfterLeavingMatchResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPlayerVoteKickedAfterLeavingMatchResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPlayerVoteKickedAfterLeavingMatchResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPlayerVoteKickedAfterLeavingMatchResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgHalloween_ServerBossEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHalloween_ServerBossEvent {
    // message fields
    // @@protoc_insertion_point(field:CMsgHalloween_ServerBossEvent.event_counter)
    pub event_counter: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_ServerBossEvent.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_ServerBossEvent.boss_type)
    pub boss_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_ServerBossEvent.boss_level)
    pub boss_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_ServerBossEvent.event_type)
    pub event_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_ServerBossEvent.players_involved)
    pub players_involved: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_ServerBossEvent.elapsed_time)
    pub elapsed_time: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHalloween_ServerBossEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHalloween_ServerBossEvent {
    fn default() -> &'a CMsgHalloween_ServerBossEvent {
        <CMsgHalloween_ServerBossEvent as ::protobuf::Message>::default_instance()
    }
}

impl CMsgHalloween_ServerBossEvent {
    pub fn new() -> CMsgHalloween_ServerBossEvent {
        ::std::default::Default::default()
    }

    // optional uint32 event_counter = 1;

    pub fn event_counter(&self) -> u32 {
        self.event_counter.unwrap_or(0)
    }

    pub fn clear_event_counter(&mut self) {
        self.event_counter = ::std::option::Option::None;
    }

    pub fn has_event_counter(&self) -> bool {
        self.event_counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_counter(&mut self, v: u32) {
        self.event_counter = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 2;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 boss_type = 3;

    pub fn boss_type(&self) -> u32 {
        self.boss_type.unwrap_or(0)
    }

    pub fn clear_boss_type(&mut self) {
        self.boss_type = ::std::option::Option::None;
    }

    pub fn has_boss_type(&self) -> bool {
        self.boss_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_boss_type(&mut self, v: u32) {
        self.boss_type = ::std::option::Option::Some(v);
    }

    // optional uint32 boss_level = 4;

    pub fn boss_level(&self) -> u32 {
        self.boss_level.unwrap_or(0)
    }

    pub fn clear_boss_level(&mut self) {
        self.boss_level = ::std::option::Option::None;
    }

    pub fn has_boss_level(&self) -> bool {
        self.boss_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_boss_level(&mut self, v: u32) {
        self.boss_level = ::std::option::Option::Some(v);
    }

    // optional uint32 event_type = 5;

    pub fn event_type(&self) -> u32 {
        self.event_type.unwrap_or(0)
    }

    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: u32) {
        self.event_type = ::std::option::Option::Some(v);
    }

    // optional uint32 players_involved = 6;

    pub fn players_involved(&self) -> u32 {
        self.players_involved.unwrap_or(0)
    }

    pub fn clear_players_involved(&mut self) {
        self.players_involved = ::std::option::Option::None;
    }

    pub fn has_players_involved(&self) -> bool {
        self.players_involved.is_some()
    }

    // Param is passed by value, moved
    pub fn set_players_involved(&mut self, v: u32) {
        self.players_involved = ::std::option::Option::Some(v);
    }

    // optional float elapsed_time = 7;

    pub fn elapsed_time(&self) -> f32 {
        self.elapsed_time.unwrap_or(0.)
    }

    pub fn clear_elapsed_time(&mut self) {
        self.elapsed_time = ::std::option::Option::None;
    }

    pub fn has_elapsed_time(&self) -> bool {
        self.elapsed_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elapsed_time(&mut self, v: f32) {
        self.elapsed_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_counter",
            |m: &CMsgHalloween_ServerBossEvent| { &m.event_counter },
            |m: &mut CMsgHalloween_ServerBossEvent| { &mut m.event_counter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &CMsgHalloween_ServerBossEvent| { &m.timestamp },
            |m: &mut CMsgHalloween_ServerBossEvent| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "boss_type",
            |m: &CMsgHalloween_ServerBossEvent| { &m.boss_type },
            |m: &mut CMsgHalloween_ServerBossEvent| { &mut m.boss_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "boss_level",
            |m: &CMsgHalloween_ServerBossEvent| { &m.boss_level },
            |m: &mut CMsgHalloween_ServerBossEvent| { &mut m.boss_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_type",
            |m: &CMsgHalloween_ServerBossEvent| { &m.event_type },
            |m: &mut CMsgHalloween_ServerBossEvent| { &mut m.event_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "players_involved",
            |m: &CMsgHalloween_ServerBossEvent| { &m.players_involved },
            |m: &mut CMsgHalloween_ServerBossEvent| { &mut m.players_involved },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "elapsed_time",
            |m: &CMsgHalloween_ServerBossEvent| { &m.elapsed_time },
            |m: &mut CMsgHalloween_ServerBossEvent| { &mut m.elapsed_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgHalloween_ServerBossEvent>(
            "CMsgHalloween_ServerBossEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgHalloween_ServerBossEvent {
    const NAME: &'static str = "CMsgHalloween_ServerBossEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_counter = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.boss_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.boss_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.event_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.players_involved = ::std::option::Option::Some(is.read_uint32()?);
                },
                61 => {
                    self.elapsed_time = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_counter {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.boss_type {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.boss_level {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.event_type {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.players_involved {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.elapsed_time {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.event_counter {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.boss_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.boss_level {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.event_type {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.players_involved {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.elapsed_time {
            os.write_float(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHalloween_ServerBossEvent {
        CMsgHalloween_ServerBossEvent::new()
    }

    fn clear(&mut self) {
        self.event_counter = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.boss_type = ::std::option::Option::None;
        self.boss_level = ::std::option::Option::None;
        self.event_type = ::std::option::Option::None;
        self.players_involved = ::std::option::Option::None;
        self.elapsed_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHalloween_ServerBossEvent {
        static instance: CMsgHalloween_ServerBossEvent = CMsgHalloween_ServerBossEvent {
            event_counter: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            boss_type: ::std::option::Option::None,
            boss_level: ::std::option::Option::None,
            event_type: ::std::option::Option::None,
            players_involved: ::std::option::Option::None,
            elapsed_time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgHalloween_ServerBossEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgHalloween_ServerBossEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgHalloween_ServerBossEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgHalloween_ServerBossEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgHalloween_Merasmus2012)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHalloween_Merasmus2012 {
    // message fields
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.event_counter)
    pub event_counter: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.time_submitted)
    pub time_submitted: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.is_valve_server)
    pub is_valve_server: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.boss_level)
    pub boss_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.spawned_health)
    pub spawned_health: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.remaining_health)
    pub remaining_health: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.life_time)
    pub life_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.bomb_kills)
    pub bomb_kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.staff_kills)
    pub staff_kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.pvp_kills)
    pub pvp_kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.prophunt_time1)
    pub prophunt_time1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.prophunt_time2)
    pub prophunt_time2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.dmg_scout)
    pub dmg_scout: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.dmg_sniper)
    pub dmg_sniper: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.dmg_soldier)
    pub dmg_soldier: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.dmg_demo)
    pub dmg_demo: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.dmg_medic)
    pub dmg_medic: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.dmg_heavy)
    pub dmg_heavy: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.dmg_pyro)
    pub dmg_pyro: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.dmg_spy)
    pub dmg_spy: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.dmg_engineer)
    pub dmg_engineer: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.scout_count)
    pub scout_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.sniper_count)
    pub sniper_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.solider_count)
    pub solider_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.demo_count)
    pub demo_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.medic_count)
    pub medic_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.heavy_count)
    pub heavy_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.pyro_count)
    pub pyro_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.spy_count)
    pub spy_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.engineer_count)
    pub engineer_count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHalloween_Merasmus2012.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHalloween_Merasmus2012 {
    fn default() -> &'a CMsgHalloween_Merasmus2012 {
        <CMsgHalloween_Merasmus2012 as ::protobuf::Message>::default_instance()
    }
}

impl CMsgHalloween_Merasmus2012 {
    pub fn new() -> CMsgHalloween_Merasmus2012 {
        ::std::default::Default::default()
    }

    // optional uint32 event_counter = 1;

    pub fn event_counter(&self) -> u32 {
        self.event_counter.unwrap_or(0)
    }

    pub fn clear_event_counter(&mut self) {
        self.event_counter = ::std::option::Option::None;
    }

    pub fn has_event_counter(&self) -> bool {
        self.event_counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_counter(&mut self, v: u32) {
        self.event_counter = ::std::option::Option::Some(v);
    }

    // optional fixed32 time_submitted = 2;

    pub fn time_submitted(&self) -> u32 {
        self.time_submitted.unwrap_or(0)
    }

    pub fn clear_time_submitted(&mut self) {
        self.time_submitted = ::std::option::Option::None;
    }

    pub fn has_time_submitted(&self) -> bool {
        self.time_submitted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_submitted(&mut self, v: u32) {
        self.time_submitted = ::std::option::Option::Some(v);
    }

    // optional bool is_valve_server = 3;

    pub fn is_valve_server(&self) -> bool {
        self.is_valve_server.unwrap_or(false)
    }

    pub fn clear_is_valve_server(&mut self) {
        self.is_valve_server = ::std::option::Option::None;
    }

    pub fn has_is_valve_server(&self) -> bool {
        self.is_valve_server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_valve_server(&mut self, v: bool) {
        self.is_valve_server = ::std::option::Option::Some(v);
    }

    // optional uint32 boss_level = 4;

    pub fn boss_level(&self) -> u32 {
        self.boss_level.unwrap_or(0)
    }

    pub fn clear_boss_level(&mut self) {
        self.boss_level = ::std::option::Option::None;
    }

    pub fn has_boss_level(&self) -> bool {
        self.boss_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_boss_level(&mut self, v: u32) {
        self.boss_level = ::std::option::Option::Some(v);
    }

    // optional uint32 spawned_health = 5;

    pub fn spawned_health(&self) -> u32 {
        self.spawned_health.unwrap_or(0)
    }

    pub fn clear_spawned_health(&mut self) {
        self.spawned_health = ::std::option::Option::None;
    }

    pub fn has_spawned_health(&self) -> bool {
        self.spawned_health.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spawned_health(&mut self, v: u32) {
        self.spawned_health = ::std::option::Option::Some(v);
    }

    // optional uint32 remaining_health = 6;

    pub fn remaining_health(&self) -> u32 {
        self.remaining_health.unwrap_or(0)
    }

    pub fn clear_remaining_health(&mut self) {
        self.remaining_health = ::std::option::Option::None;
    }

    pub fn has_remaining_health(&self) -> bool {
        self.remaining_health.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remaining_health(&mut self, v: u32) {
        self.remaining_health = ::std::option::Option::Some(v);
    }

    // optional uint32 life_time = 7;

    pub fn life_time(&self) -> u32 {
        self.life_time.unwrap_or(0)
    }

    pub fn clear_life_time(&mut self) {
        self.life_time = ::std::option::Option::None;
    }

    pub fn has_life_time(&self) -> bool {
        self.life_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_life_time(&mut self, v: u32) {
        self.life_time = ::std::option::Option::Some(v);
    }

    // optional uint32 bomb_kills = 8;

    pub fn bomb_kills(&self) -> u32 {
        self.bomb_kills.unwrap_or(0)
    }

    pub fn clear_bomb_kills(&mut self) {
        self.bomb_kills = ::std::option::Option::None;
    }

    pub fn has_bomb_kills(&self) -> bool {
        self.bomb_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bomb_kills(&mut self, v: u32) {
        self.bomb_kills = ::std::option::Option::Some(v);
    }

    // optional uint32 staff_kills = 9;

    pub fn staff_kills(&self) -> u32 {
        self.staff_kills.unwrap_or(0)
    }

    pub fn clear_staff_kills(&mut self) {
        self.staff_kills = ::std::option::Option::None;
    }

    pub fn has_staff_kills(&self) -> bool {
        self.staff_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_staff_kills(&mut self, v: u32) {
        self.staff_kills = ::std::option::Option::Some(v);
    }

    // optional uint32 pvp_kills = 10;

    pub fn pvp_kills(&self) -> u32 {
        self.pvp_kills.unwrap_or(0)
    }

    pub fn clear_pvp_kills(&mut self) {
        self.pvp_kills = ::std::option::Option::None;
    }

    pub fn has_pvp_kills(&self) -> bool {
        self.pvp_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pvp_kills(&mut self, v: u32) {
        self.pvp_kills = ::std::option::Option::Some(v);
    }

    // optional uint32 prophunt_time1 = 11;

    pub fn prophunt_time1(&self) -> u32 {
        self.prophunt_time1.unwrap_or(0)
    }

    pub fn clear_prophunt_time1(&mut self) {
        self.prophunt_time1 = ::std::option::Option::None;
    }

    pub fn has_prophunt_time1(&self) -> bool {
        self.prophunt_time1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prophunt_time1(&mut self, v: u32) {
        self.prophunt_time1 = ::std::option::Option::Some(v);
    }

    // optional uint32 prophunt_time2 = 12;

    pub fn prophunt_time2(&self) -> u32 {
        self.prophunt_time2.unwrap_or(0)
    }

    pub fn clear_prophunt_time2(&mut self) {
        self.prophunt_time2 = ::std::option::Option::None;
    }

    pub fn has_prophunt_time2(&self) -> bool {
        self.prophunt_time2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prophunt_time2(&mut self, v: u32) {
        self.prophunt_time2 = ::std::option::Option::Some(v);
    }

    // optional uint32 dmg_scout = 13;

    pub fn dmg_scout(&self) -> u32 {
        self.dmg_scout.unwrap_or(0)
    }

    pub fn clear_dmg_scout(&mut self) {
        self.dmg_scout = ::std::option::Option::None;
    }

    pub fn has_dmg_scout(&self) -> bool {
        self.dmg_scout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dmg_scout(&mut self, v: u32) {
        self.dmg_scout = ::std::option::Option::Some(v);
    }

    // optional uint32 dmg_sniper = 14;

    pub fn dmg_sniper(&self) -> u32 {
        self.dmg_sniper.unwrap_or(0)
    }

    pub fn clear_dmg_sniper(&mut self) {
        self.dmg_sniper = ::std::option::Option::None;
    }

    pub fn has_dmg_sniper(&self) -> bool {
        self.dmg_sniper.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dmg_sniper(&mut self, v: u32) {
        self.dmg_sniper = ::std::option::Option::Some(v);
    }

    // optional uint32 dmg_soldier = 15;

    pub fn dmg_soldier(&self) -> u32 {
        self.dmg_soldier.unwrap_or(0)
    }

    pub fn clear_dmg_soldier(&mut self) {
        self.dmg_soldier = ::std::option::Option::None;
    }

    pub fn has_dmg_soldier(&self) -> bool {
        self.dmg_soldier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dmg_soldier(&mut self, v: u32) {
        self.dmg_soldier = ::std::option::Option::Some(v);
    }

    // optional uint32 dmg_demo = 16;

    pub fn dmg_demo(&self) -> u32 {
        self.dmg_demo.unwrap_or(0)
    }

    pub fn clear_dmg_demo(&mut self) {
        self.dmg_demo = ::std::option::Option::None;
    }

    pub fn has_dmg_demo(&self) -> bool {
        self.dmg_demo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dmg_demo(&mut self, v: u32) {
        self.dmg_demo = ::std::option::Option::Some(v);
    }

    // optional uint32 dmg_medic = 17;

    pub fn dmg_medic(&self) -> u32 {
        self.dmg_medic.unwrap_or(0)
    }

    pub fn clear_dmg_medic(&mut self) {
        self.dmg_medic = ::std::option::Option::None;
    }

    pub fn has_dmg_medic(&self) -> bool {
        self.dmg_medic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dmg_medic(&mut self, v: u32) {
        self.dmg_medic = ::std::option::Option::Some(v);
    }

    // optional uint32 dmg_heavy = 18;

    pub fn dmg_heavy(&self) -> u32 {
        self.dmg_heavy.unwrap_or(0)
    }

    pub fn clear_dmg_heavy(&mut self) {
        self.dmg_heavy = ::std::option::Option::None;
    }

    pub fn has_dmg_heavy(&self) -> bool {
        self.dmg_heavy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dmg_heavy(&mut self, v: u32) {
        self.dmg_heavy = ::std::option::Option::Some(v);
    }

    // optional uint32 dmg_pyro = 19;

    pub fn dmg_pyro(&self) -> u32 {
        self.dmg_pyro.unwrap_or(0)
    }

    pub fn clear_dmg_pyro(&mut self) {
        self.dmg_pyro = ::std::option::Option::None;
    }

    pub fn has_dmg_pyro(&self) -> bool {
        self.dmg_pyro.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dmg_pyro(&mut self, v: u32) {
        self.dmg_pyro = ::std::option::Option::Some(v);
    }

    // optional uint32 dmg_spy = 20;

    pub fn dmg_spy(&self) -> u32 {
        self.dmg_spy.unwrap_or(0)
    }

    pub fn clear_dmg_spy(&mut self) {
        self.dmg_spy = ::std::option::Option::None;
    }

    pub fn has_dmg_spy(&self) -> bool {
        self.dmg_spy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dmg_spy(&mut self, v: u32) {
        self.dmg_spy = ::std::option::Option::Some(v);
    }

    // optional uint32 dmg_engineer = 21;

    pub fn dmg_engineer(&self) -> u32 {
        self.dmg_engineer.unwrap_or(0)
    }

    pub fn clear_dmg_engineer(&mut self) {
        self.dmg_engineer = ::std::option::Option::None;
    }

    pub fn has_dmg_engineer(&self) -> bool {
        self.dmg_engineer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dmg_engineer(&mut self, v: u32) {
        self.dmg_engineer = ::std::option::Option::Some(v);
    }

    // optional uint32 scout_count = 22;

    pub fn scout_count(&self) -> u32 {
        self.scout_count.unwrap_or(0)
    }

    pub fn clear_scout_count(&mut self) {
        self.scout_count = ::std::option::Option::None;
    }

    pub fn has_scout_count(&self) -> bool {
        self.scout_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scout_count(&mut self, v: u32) {
        self.scout_count = ::std::option::Option::Some(v);
    }

    // optional uint32 sniper_count = 23;

    pub fn sniper_count(&self) -> u32 {
        self.sniper_count.unwrap_or(0)
    }

    pub fn clear_sniper_count(&mut self) {
        self.sniper_count = ::std::option::Option::None;
    }

    pub fn has_sniper_count(&self) -> bool {
        self.sniper_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sniper_count(&mut self, v: u32) {
        self.sniper_count = ::std::option::Option::Some(v);
    }

    // optional uint32 solider_count = 24;

    pub fn solider_count(&self) -> u32 {
        self.solider_count.unwrap_or(0)
    }

    pub fn clear_solider_count(&mut self) {
        self.solider_count = ::std::option::Option::None;
    }

    pub fn has_solider_count(&self) -> bool {
        self.solider_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_solider_count(&mut self, v: u32) {
        self.solider_count = ::std::option::Option::Some(v);
    }

    // optional uint32 demo_count = 25;

    pub fn demo_count(&self) -> u32 {
        self.demo_count.unwrap_or(0)
    }

    pub fn clear_demo_count(&mut self) {
        self.demo_count = ::std::option::Option::None;
    }

    pub fn has_demo_count(&self) -> bool {
        self.demo_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_demo_count(&mut self, v: u32) {
        self.demo_count = ::std::option::Option::Some(v);
    }

    // optional uint32 medic_count = 26;

    pub fn medic_count(&self) -> u32 {
        self.medic_count.unwrap_or(0)
    }

    pub fn clear_medic_count(&mut self) {
        self.medic_count = ::std::option::Option::None;
    }

    pub fn has_medic_count(&self) -> bool {
        self.medic_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_medic_count(&mut self, v: u32) {
        self.medic_count = ::std::option::Option::Some(v);
    }

    // optional uint32 heavy_count = 27;

    pub fn heavy_count(&self) -> u32 {
        self.heavy_count.unwrap_or(0)
    }

    pub fn clear_heavy_count(&mut self) {
        self.heavy_count = ::std::option::Option::None;
    }

    pub fn has_heavy_count(&self) -> bool {
        self.heavy_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_heavy_count(&mut self, v: u32) {
        self.heavy_count = ::std::option::Option::Some(v);
    }

    // optional uint32 pyro_count = 28;

    pub fn pyro_count(&self) -> u32 {
        self.pyro_count.unwrap_or(0)
    }

    pub fn clear_pyro_count(&mut self) {
        self.pyro_count = ::std::option::Option::None;
    }

    pub fn has_pyro_count(&self) -> bool {
        self.pyro_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pyro_count(&mut self, v: u32) {
        self.pyro_count = ::std::option::Option::Some(v);
    }

    // optional uint32 spy_count = 29;

    pub fn spy_count(&self) -> u32 {
        self.spy_count.unwrap_or(0)
    }

    pub fn clear_spy_count(&mut self) {
        self.spy_count = ::std::option::Option::None;
    }

    pub fn has_spy_count(&self) -> bool {
        self.spy_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spy_count(&mut self, v: u32) {
        self.spy_count = ::std::option::Option::Some(v);
    }

    // optional uint32 engineer_count = 30;

    pub fn engineer_count(&self) -> u32 {
        self.engineer_count.unwrap_or(0)
    }

    pub fn clear_engineer_count(&mut self) {
        self.engineer_count = ::std::option::Option::None;
    }

    pub fn has_engineer_count(&self) -> bool {
        self.engineer_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_engineer_count(&mut self, v: u32) {
        self.engineer_count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(30);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_counter",
            |m: &CMsgHalloween_Merasmus2012| { &m.event_counter },
            |m: &mut CMsgHalloween_Merasmus2012| { &mut m.event_counter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_submitted",
            |m: &CMsgHalloween_Merasmus2012| { &m.time_submitted },
            |m: &mut CMsgHalloween_Merasmus2012| { &mut m.time_submitted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_valve_server",
            |m: &CMsgHalloween_Merasmus2012| { &m.is_valve_server },
            |m: &mut CMsgHalloween_Merasmus2012| { &mut m.is_valve_server },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "boss_level",
            |m: &CMsgHalloween_Merasmus2012| { &m.boss_level },
            |m: &mut CMsgHalloween_Merasmus2012| { &mut m.boss_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "spawned_health",
            |m: &CMsgHalloween_Merasmus2012| { &m.spawned_health },
            |m: &mut CMsgHalloween_Merasmus2012| { &mut m.spawned_health },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "remaining_health",
            |m: &CMsgHalloween_Merasmus2012| { &m.remaining_health },
            |m: &mut CMsgHalloween_Merasmus2012| { &mut m.remaining_health },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "life_time",
            |m: &CMsgHalloween_Merasmus2012| { &m.life_time },
            |m: &mut CMsgHalloween_Merasmus2012| { &mut m.life_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bomb_kills",
            |m: &CMsgHalloween_Merasmus2012| { &m.bomb_kills },
            |m: &mut CMsgHalloween_Merasmus2012| { &mut m.bomb_kills },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "staff_kills",
            |m: &CMsgHalloween_Merasmus2012| { &m.staff_kills },
            |m: &mut CMsgHalloween_Merasmus2012| { &mut m.staff_kills },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pvp_kills",
            |m: &CMsgHalloween_Merasmus2012| { &m.pvp_kills },
            |m: &mut CMsgHalloween_Merasmus2012| { &mut m.pvp_kills },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "prophunt_time1",
            |m: &CMsgHalloween_Merasmus2012| { &m.prophunt_time1 },
            |m: &mut CMsgHalloween_Merasmus2012| { &mut m.prophunt_time1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "prophunt_time2",
            |m: &CMsgHalloween_Merasmus2012| { &m.prophunt_time2 },
            |m: &mut CMsgHalloween_Merasmus2012| { &mut m.prophunt_time2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dmg_scout",
            |m: &CMsgHalloween_Merasmus2012| { &m.dmg_scout },
            |m: &mut CMsgHalloween_Merasmus2012| { &mut m.dmg_scout },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dmg_sniper",
            |m: &CMsgHalloween_Merasmus2012| { &m.dmg_sniper },
            |m: &mut CMsgHalloween_Merasmus2012| { &mut m.dmg_sniper },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dmg_soldier",
            |m: &CMsgHalloween_Merasmus2012| { &m.dmg_soldier },
            |m: &mut CMsgHalloween_Merasmus2012| { &mut m.dmg_soldier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dmg_demo",
            |m: &CMsgHalloween_Merasmus2012| { &m.dmg_demo },
            |m: &mut CMsgHalloween_Merasmus2012| { &mut m.dmg_demo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dmg_medic",
            |m: &CMsgHalloween_Merasmus2012| { &m.dmg_medic },
            |m: &mut CMsgHalloween_Merasmus2012| { &mut m.dmg_medic },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dmg_heavy",
            |m: &CMsgHalloween_Merasmus2012| { &m.dmg_heavy },
            |m: &mut CMsgHalloween_Merasmus2012| { &mut m.dmg_heavy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dmg_pyro",
            |m: &CMsgHalloween_Merasmus2012| { &m.dmg_pyro },
            |m: &mut CMsgHalloween_Merasmus2012| { &mut m.dmg_pyro },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dmg_spy",
            |m: &CMsgHalloween_Merasmus2012| { &m.dmg_spy },
            |m: &mut CMsgHalloween_Merasmus2012| { &mut m.dmg_spy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dmg_engineer",
            |m: &CMsgHalloween_Merasmus2012| { &m.dmg_engineer },
            |m: &mut CMsgHalloween_Merasmus2012| { &mut m.dmg_engineer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scout_count",
            |m: &CMsgHalloween_Merasmus2012| { &m.scout_count },
            |m: &mut CMsgHalloween_Merasmus2012| { &mut m.scout_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sniper_count",
            |m: &CMsgHalloween_Merasmus2012| { &m.sniper_count },
            |m: &mut CMsgHalloween_Merasmus2012| { &mut m.sniper_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "solider_count",
            |m: &CMsgHalloween_Merasmus2012| { &m.solider_count },
            |m: &mut CMsgHalloween_Merasmus2012| { &mut m.solider_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "demo_count",
            |m: &CMsgHalloween_Merasmus2012| { &m.demo_count },
            |m: &mut CMsgHalloween_Merasmus2012| { &mut m.demo_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "medic_count",
            |m: &CMsgHalloween_Merasmus2012| { &m.medic_count },
            |m: &mut CMsgHalloween_Merasmus2012| { &mut m.medic_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "heavy_count",
            |m: &CMsgHalloween_Merasmus2012| { &m.heavy_count },
            |m: &mut CMsgHalloween_Merasmus2012| { &mut m.heavy_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pyro_count",
            |m: &CMsgHalloween_Merasmus2012| { &m.pyro_count },
            |m: &mut CMsgHalloween_Merasmus2012| { &mut m.pyro_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "spy_count",
            |m: &CMsgHalloween_Merasmus2012| { &m.spy_count },
            |m: &mut CMsgHalloween_Merasmus2012| { &mut m.spy_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "engineer_count",
            |m: &CMsgHalloween_Merasmus2012| { &m.engineer_count },
            |m: &mut CMsgHalloween_Merasmus2012| { &mut m.engineer_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgHalloween_Merasmus2012>(
            "CMsgHalloween_Merasmus2012",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgHalloween_Merasmus2012 {
    const NAME: &'static str = "CMsgHalloween_Merasmus2012";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_counter = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.time_submitted = ::std::option::Option::Some(is.read_fixed32()?);
                },
                24 => {
                    self.is_valve_server = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.boss_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.spawned_health = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.remaining_health = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.life_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.bomb_kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.staff_kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.pvp_kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.prophunt_time1 = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.prophunt_time2 = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.dmg_scout = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.dmg_sniper = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.dmg_soldier = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.dmg_demo = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.dmg_medic = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.dmg_heavy = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.dmg_pyro = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.dmg_spy = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.dmg_engineer = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.scout_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.sniper_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                192 => {
                    self.solider_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                200 => {
                    self.demo_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                208 => {
                    self.medic_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                216 => {
                    self.heavy_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                224 => {
                    self.pyro_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                232 => {
                    self.spy_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                240 => {
                    self.engineer_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_counter {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.time_submitted {
            my_size += 1 + 4;
        }
        if let Some(v) = self.is_valve_server {
            my_size += 1 + 1;
        }
        if let Some(v) = self.boss_level {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.spawned_health {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.remaining_health {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.life_time {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.bomb_kills {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.staff_kills {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.pvp_kills {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.prophunt_time1 {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.prophunt_time2 {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.dmg_scout {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.dmg_sniper {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.dmg_soldier {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.dmg_demo {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.dmg_medic {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.dmg_heavy {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.dmg_pyro {
            my_size += ::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.dmg_spy {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.dmg_engineer {
            my_size += ::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.scout_count {
            my_size += ::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.sniper_count {
            my_size += ::protobuf::rt::uint32_size(23, v);
        }
        if let Some(v) = self.solider_count {
            my_size += ::protobuf::rt::uint32_size(24, v);
        }
        if let Some(v) = self.demo_count {
            my_size += ::protobuf::rt::uint32_size(25, v);
        }
        if let Some(v) = self.medic_count {
            my_size += ::protobuf::rt::uint32_size(26, v);
        }
        if let Some(v) = self.heavy_count {
            my_size += ::protobuf::rt::uint32_size(27, v);
        }
        if let Some(v) = self.pyro_count {
            my_size += ::protobuf::rt::uint32_size(28, v);
        }
        if let Some(v) = self.spy_count {
            my_size += ::protobuf::rt::uint32_size(29, v);
        }
        if let Some(v) = self.engineer_count {
            my_size += ::protobuf::rt::uint32_size(30, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.event_counter {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.time_submitted {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.is_valve_server {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.boss_level {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.spawned_health {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.remaining_health {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.life_time {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.bomb_kills {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.staff_kills {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.pvp_kills {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.prophunt_time1 {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.prophunt_time2 {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.dmg_scout {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.dmg_sniper {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.dmg_soldier {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.dmg_demo {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.dmg_medic {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.dmg_heavy {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.dmg_pyro {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.dmg_spy {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.dmg_engineer {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.scout_count {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.sniper_count {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.solider_count {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.demo_count {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.medic_count {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.heavy_count {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.pyro_count {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.spy_count {
            os.write_uint32(29, v)?;
        }
        if let Some(v) = self.engineer_count {
            os.write_uint32(30, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHalloween_Merasmus2012 {
        CMsgHalloween_Merasmus2012::new()
    }

    fn clear(&mut self) {
        self.event_counter = ::std::option::Option::None;
        self.time_submitted = ::std::option::Option::None;
        self.is_valve_server = ::std::option::Option::None;
        self.boss_level = ::std::option::Option::None;
        self.spawned_health = ::std::option::Option::None;
        self.remaining_health = ::std::option::Option::None;
        self.life_time = ::std::option::Option::None;
        self.bomb_kills = ::std::option::Option::None;
        self.staff_kills = ::std::option::Option::None;
        self.pvp_kills = ::std::option::Option::None;
        self.prophunt_time1 = ::std::option::Option::None;
        self.prophunt_time2 = ::std::option::Option::None;
        self.dmg_scout = ::std::option::Option::None;
        self.dmg_sniper = ::std::option::Option::None;
        self.dmg_soldier = ::std::option::Option::None;
        self.dmg_demo = ::std::option::Option::None;
        self.dmg_medic = ::std::option::Option::None;
        self.dmg_heavy = ::std::option::Option::None;
        self.dmg_pyro = ::std::option::Option::None;
        self.dmg_spy = ::std::option::Option::None;
        self.dmg_engineer = ::std::option::Option::None;
        self.scout_count = ::std::option::Option::None;
        self.sniper_count = ::std::option::Option::None;
        self.solider_count = ::std::option::Option::None;
        self.demo_count = ::std::option::Option::None;
        self.medic_count = ::std::option::Option::None;
        self.heavy_count = ::std::option::Option::None;
        self.pyro_count = ::std::option::Option::None;
        self.spy_count = ::std::option::Option::None;
        self.engineer_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHalloween_Merasmus2012 {
        static instance: CMsgHalloween_Merasmus2012 = CMsgHalloween_Merasmus2012 {
            event_counter: ::std::option::Option::None,
            time_submitted: ::std::option::Option::None,
            is_valve_server: ::std::option::Option::None,
            boss_level: ::std::option::Option::None,
            spawned_health: ::std::option::Option::None,
            remaining_health: ::std::option::Option::None,
            life_time: ::std::option::Option::None,
            bomb_kills: ::std::option::Option::None,
            staff_kills: ::std::option::Option::None,
            pvp_kills: ::std::option::Option::None,
            prophunt_time1: ::std::option::Option::None,
            prophunt_time2: ::std::option::Option::None,
            dmg_scout: ::std::option::Option::None,
            dmg_sniper: ::std::option::Option::None,
            dmg_soldier: ::std::option::Option::None,
            dmg_demo: ::std::option::Option::None,
            dmg_medic: ::std::option::Option::None,
            dmg_heavy: ::std::option::Option::None,
            dmg_pyro: ::std::option::Option::None,
            dmg_spy: ::std::option::Option::None,
            dmg_engineer: ::std::option::Option::None,
            scout_count: ::std::option::Option::None,
            sniper_count: ::std::option::Option::None,
            solider_count: ::std::option::Option::None,
            demo_count: ::std::option::Option::None,
            medic_count: ::std::option::Option::None,
            heavy_count: ::std::option::Option::None,
            pyro_count: ::std::option::Option::None,
            spy_count: ::std::option::Option::None,
            engineer_count: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgHalloween_Merasmus2012 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgHalloween_Merasmus2012").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgHalloween_Merasmus2012 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgHalloween_Merasmus2012 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgUpdateHalloweenMerasmusLootLevel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgUpdateHalloweenMerasmusLootLevel {
    // message fields
    // @@protoc_insertion_point(field:CMsgUpdateHalloweenMerasmusLootLevel.players)
    pub players: ::std::vec::Vec<cmsg_update_halloween_merasmus_loot_level::Player>,
    // @@protoc_insertion_point(field:CMsgUpdateHalloweenMerasmusLootLevel.merasmus_level)
    pub merasmus_level: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgUpdateHalloweenMerasmusLootLevel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgUpdateHalloweenMerasmusLootLevel {
    fn default() -> &'a CMsgUpdateHalloweenMerasmusLootLevel {
        <CMsgUpdateHalloweenMerasmusLootLevel as ::protobuf::Message>::default_instance()
    }
}

impl CMsgUpdateHalloweenMerasmusLootLevel {
    pub fn new() -> CMsgUpdateHalloweenMerasmusLootLevel {
        ::std::default::Default::default()
    }

    // optional uint32 merasmus_level = 2;

    pub fn merasmus_level(&self) -> u32 {
        self.merasmus_level.unwrap_or(0)
    }

    pub fn clear_merasmus_level(&mut self) {
        self.merasmus_level = ::std::option::Option::None;
    }

    pub fn has_merasmus_level(&self) -> bool {
        self.merasmus_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_merasmus_level(&mut self, v: u32) {
        self.merasmus_level = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "players",
            |m: &CMsgUpdateHalloweenMerasmusLootLevel| { &m.players },
            |m: &mut CMsgUpdateHalloweenMerasmusLootLevel| { &mut m.players },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "merasmus_level",
            |m: &CMsgUpdateHalloweenMerasmusLootLevel| { &m.merasmus_level },
            |m: &mut CMsgUpdateHalloweenMerasmusLootLevel| { &mut m.merasmus_level },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgUpdateHalloweenMerasmusLootLevel>(
            "CMsgUpdateHalloweenMerasmusLootLevel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgUpdateHalloweenMerasmusLootLevel {
    const NAME: &'static str = "CMsgUpdateHalloweenMerasmusLootLevel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.players.push(is.read_message()?);
                },
                16 => {
                    self.merasmus_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.merasmus_level {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.players {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.merasmus_level {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgUpdateHalloweenMerasmusLootLevel {
        CMsgUpdateHalloweenMerasmusLootLevel::new()
    }

    fn clear(&mut self) {
        self.players.clear();
        self.merasmus_level = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgUpdateHalloweenMerasmusLootLevel {
        static instance: CMsgUpdateHalloweenMerasmusLootLevel = CMsgUpdateHalloweenMerasmusLootLevel {
            players: ::std::vec::Vec::new(),
            merasmus_level: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgUpdateHalloweenMerasmusLootLevel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgUpdateHalloweenMerasmusLootLevel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgUpdateHalloweenMerasmusLootLevel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgUpdateHalloweenMerasmusLootLevel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgUpdateHalloweenMerasmusLootLevel`
pub mod cmsg_update_halloween_merasmus_loot_level {
    // @@protoc_insertion_point(message:CMsgUpdateHalloweenMerasmusLootLevel.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CMsgUpdateHalloweenMerasmusLootLevel.Player.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgUpdateHalloweenMerasmusLootLevel.Player.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id = 1;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "steam_id",
                |m: &Player| { &m.steam_id },
                |m: &mut Player| { &mut m.steam_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Player>(
                "CMsgUpdateHalloweenMerasmusLootLevel.Player",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steam_id {
                os.write_fixed64(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                steam_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Player {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgUpdateHalloweenMerasmusLootLevel.Player").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Player {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Player {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CAttribute_String)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CAttribute_String {
    // message fields
    // @@protoc_insertion_point(field:CAttribute_String.value)
    pub value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CAttribute_String.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CAttribute_String {
    fn default() -> &'a CAttribute_String {
        <CAttribute_String as ::protobuf::Message>::default_instance()
    }
}

impl CAttribute_String {
    pub fn new() -> CAttribute_String {
        ::std::default::Default::default()
    }

    // optional string value = 1;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CAttribute_String| { &m.value },
            |m: &mut CAttribute_String| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CAttribute_String>(
            "CAttribute_String",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CAttribute_String {
    const NAME: &'static str = "CAttribute_String";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.value.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CAttribute_String {
        CAttribute_String::new()
    }

    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CAttribute_String {
        static instance: CAttribute_String = CAttribute_String {
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CAttribute_String {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CAttribute_String").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CAttribute_String {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CAttribute_String {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CAttribute_DynamicRecipeComponent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CAttribute_DynamicRecipeComponent {
    // message fields
    // @@protoc_insertion_point(field:CAttribute_DynamicRecipeComponent.def_index)
    pub def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CAttribute_DynamicRecipeComponent.item_quality)
    pub item_quality: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CAttribute_DynamicRecipeComponent.component_flags)
    pub component_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CAttribute_DynamicRecipeComponent.attributes_string)
    pub attributes_string: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CAttribute_DynamicRecipeComponent.num_required)
    pub num_required: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CAttribute_DynamicRecipeComponent.num_fulfilled)
    pub num_fulfilled: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CAttribute_DynamicRecipeComponent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CAttribute_DynamicRecipeComponent {
    fn default() -> &'a CAttribute_DynamicRecipeComponent {
        <CAttribute_DynamicRecipeComponent as ::protobuf::Message>::default_instance()
    }
}

impl CAttribute_DynamicRecipeComponent {
    pub fn new() -> CAttribute_DynamicRecipeComponent {
        ::std::default::Default::default()
    }

    // optional uint32 def_index = 1;

    pub fn def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 item_quality = 2;

    pub fn item_quality(&self) -> u32 {
        self.item_quality.unwrap_or(0)
    }

    pub fn clear_item_quality(&mut self) {
        self.item_quality = ::std::option::Option::None;
    }

    pub fn has_item_quality(&self) -> bool {
        self.item_quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_quality(&mut self, v: u32) {
        self.item_quality = ::std::option::Option::Some(v);
    }

    // optional uint32 component_flags = 3;

    pub fn component_flags(&self) -> u32 {
        self.component_flags.unwrap_or(0)
    }

    pub fn clear_component_flags(&mut self) {
        self.component_flags = ::std::option::Option::None;
    }

    pub fn has_component_flags(&self) -> bool {
        self.component_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_component_flags(&mut self, v: u32) {
        self.component_flags = ::std::option::Option::Some(v);
    }

    // optional string attributes_string = 4;

    pub fn attributes_string(&self) -> &str {
        match self.attributes_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_attributes_string(&mut self) {
        self.attributes_string = ::std::option::Option::None;
    }

    pub fn has_attributes_string(&self) -> bool {
        self.attributes_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attributes_string(&mut self, v: ::std::string::String) {
        self.attributes_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attributes_string(&mut self) -> &mut ::std::string::String {
        if self.attributes_string.is_none() {
            self.attributes_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.attributes_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_attributes_string(&mut self) -> ::std::string::String {
        self.attributes_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 num_required = 5;

    pub fn num_required(&self) -> u32 {
        self.num_required.unwrap_or(0)
    }

    pub fn clear_num_required(&mut self) {
        self.num_required = ::std::option::Option::None;
    }

    pub fn has_num_required(&self) -> bool {
        self.num_required.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_required(&mut self, v: u32) {
        self.num_required = ::std::option::Option::Some(v);
    }

    // optional uint32 num_fulfilled = 6;

    pub fn num_fulfilled(&self) -> u32 {
        self.num_fulfilled.unwrap_or(0)
    }

    pub fn clear_num_fulfilled(&mut self) {
        self.num_fulfilled = ::std::option::Option::None;
    }

    pub fn has_num_fulfilled(&self) -> bool {
        self.num_fulfilled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_fulfilled(&mut self, v: u32) {
        self.num_fulfilled = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "def_index",
            |m: &CAttribute_DynamicRecipeComponent| { &m.def_index },
            |m: &mut CAttribute_DynamicRecipeComponent| { &mut m.def_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_quality",
            |m: &CAttribute_DynamicRecipeComponent| { &m.item_quality },
            |m: &mut CAttribute_DynamicRecipeComponent| { &mut m.item_quality },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "component_flags",
            |m: &CAttribute_DynamicRecipeComponent| { &m.component_flags },
            |m: &mut CAttribute_DynamicRecipeComponent| { &mut m.component_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "attributes_string",
            |m: &CAttribute_DynamicRecipeComponent| { &m.attributes_string },
            |m: &mut CAttribute_DynamicRecipeComponent| { &mut m.attributes_string },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_required",
            |m: &CAttribute_DynamicRecipeComponent| { &m.num_required },
            |m: &mut CAttribute_DynamicRecipeComponent| { &mut m.num_required },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_fulfilled",
            |m: &CAttribute_DynamicRecipeComponent| { &m.num_fulfilled },
            |m: &mut CAttribute_DynamicRecipeComponent| { &mut m.num_fulfilled },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CAttribute_DynamicRecipeComponent>(
            "CAttribute_DynamicRecipeComponent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CAttribute_DynamicRecipeComponent {
    const NAME: &'static str = "CAttribute_DynamicRecipeComponent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.item_quality = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.component_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.attributes_string = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.num_required = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.num_fulfilled = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.item_quality {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.component_flags {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.attributes_string.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.num_required {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.num_fulfilled {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_quality {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.component_flags {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.attributes_string.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.num_required {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.num_fulfilled {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CAttribute_DynamicRecipeComponent {
        CAttribute_DynamicRecipeComponent::new()
    }

    fn clear(&mut self) {
        self.def_index = ::std::option::Option::None;
        self.item_quality = ::std::option::Option::None;
        self.component_flags = ::std::option::Option::None;
        self.attributes_string = ::std::option::Option::None;
        self.num_required = ::std::option::Option::None;
        self.num_fulfilled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CAttribute_DynamicRecipeComponent {
        static instance: CAttribute_DynamicRecipeComponent = CAttribute_DynamicRecipeComponent {
            def_index: ::std::option::Option::None,
            item_quality: ::std::option::Option::None,
            component_flags: ::std::option::Option::None,
            attributes_string: ::std::option::Option::None,
            num_required: ::std::option::Option::None,
            num_fulfilled: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CAttribute_DynamicRecipeComponent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CAttribute_DynamicRecipeComponent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CAttribute_DynamicRecipeComponent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CAttribute_DynamicRecipeComponent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT {
    // message fields
    // @@protoc_insertion_point(field:CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT.def_index)
    pub def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT.item_def)
    pub item_def: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT.item_quality)
    pub item_quality: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT.component_flags)
    pub component_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT.item_flags)
    pub item_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT.attributes_string)
    pub attributes_string: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT.num_required)
    pub num_required: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT.item_count)
    pub item_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT.num_fulfilled)
    pub num_fulfilled: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT.items_fulfilled)
    pub items_fulfilled: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT {
    fn default() -> &'a CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT {
        <CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT as ::protobuf::Message>::default_instance()
    }
}

impl CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT {
    pub fn new() -> CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT {
        ::std::default::Default::default()
    }

    // optional uint32 def_index = 1;

    pub fn def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 item_def = 2;

    pub fn item_def(&self) -> u32 {
        self.item_def.unwrap_or(0)
    }

    pub fn clear_item_def(&mut self) {
        self.item_def = ::std::option::Option::None;
    }

    pub fn has_item_def(&self) -> bool {
        self.item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def(&mut self, v: u32) {
        self.item_def = ::std::option::Option::Some(v);
    }

    // optional uint32 item_quality = 3;

    pub fn item_quality(&self) -> u32 {
        self.item_quality.unwrap_or(0)
    }

    pub fn clear_item_quality(&mut self) {
        self.item_quality = ::std::option::Option::None;
    }

    pub fn has_item_quality(&self) -> bool {
        self.item_quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_quality(&mut self, v: u32) {
        self.item_quality = ::std::option::Option::Some(v);
    }

    // optional uint32 component_flags = 4;

    pub fn component_flags(&self) -> u32 {
        self.component_flags.unwrap_or(0)
    }

    pub fn clear_component_flags(&mut self) {
        self.component_flags = ::std::option::Option::None;
    }

    pub fn has_component_flags(&self) -> bool {
        self.component_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_component_flags(&mut self, v: u32) {
        self.component_flags = ::std::option::Option::Some(v);
    }

    // optional uint32 item_flags = 5;

    pub fn item_flags(&self) -> u32 {
        self.item_flags.unwrap_or(0)
    }

    pub fn clear_item_flags(&mut self) {
        self.item_flags = ::std::option::Option::None;
    }

    pub fn has_item_flags(&self) -> bool {
        self.item_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_flags(&mut self, v: u32) {
        self.item_flags = ::std::option::Option::Some(v);
    }

    // optional string attributes_string = 6;

    pub fn attributes_string(&self) -> &str {
        match self.attributes_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_attributes_string(&mut self) {
        self.attributes_string = ::std::option::Option::None;
    }

    pub fn has_attributes_string(&self) -> bool {
        self.attributes_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attributes_string(&mut self, v: ::std::string::String) {
        self.attributes_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attributes_string(&mut self) -> &mut ::std::string::String {
        if self.attributes_string.is_none() {
            self.attributes_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.attributes_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_attributes_string(&mut self) -> ::std::string::String {
        self.attributes_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 num_required = 7;

    pub fn num_required(&self) -> u32 {
        self.num_required.unwrap_or(0)
    }

    pub fn clear_num_required(&mut self) {
        self.num_required = ::std::option::Option::None;
    }

    pub fn has_num_required(&self) -> bool {
        self.num_required.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_required(&mut self, v: u32) {
        self.num_required = ::std::option::Option::Some(v);
    }

    // optional uint32 item_count = 8;

    pub fn item_count(&self) -> u32 {
        self.item_count.unwrap_or(0)
    }

    pub fn clear_item_count(&mut self) {
        self.item_count = ::std::option::Option::None;
    }

    pub fn has_item_count(&self) -> bool {
        self.item_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_count(&mut self, v: u32) {
        self.item_count = ::std::option::Option::Some(v);
    }

    // optional uint32 num_fulfilled = 9;

    pub fn num_fulfilled(&self) -> u32 {
        self.num_fulfilled.unwrap_or(0)
    }

    pub fn clear_num_fulfilled(&mut self) {
        self.num_fulfilled = ::std::option::Option::None;
    }

    pub fn has_num_fulfilled(&self) -> bool {
        self.num_fulfilled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_fulfilled(&mut self, v: u32) {
        self.num_fulfilled = ::std::option::Option::Some(v);
    }

    // optional uint32 items_fulfilled = 10;

    pub fn items_fulfilled(&self) -> u32 {
        self.items_fulfilled.unwrap_or(0)
    }

    pub fn clear_items_fulfilled(&mut self) {
        self.items_fulfilled = ::std::option::Option::None;
    }

    pub fn has_items_fulfilled(&self) -> bool {
        self.items_fulfilled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_items_fulfilled(&mut self, v: u32) {
        self.items_fulfilled = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "def_index",
            |m: &CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &m.def_index },
            |m: &mut CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &mut m.def_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_def",
            |m: &CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &m.item_def },
            |m: &mut CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &mut m.item_def },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_quality",
            |m: &CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &m.item_quality },
            |m: &mut CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &mut m.item_quality },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "component_flags",
            |m: &CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &m.component_flags },
            |m: &mut CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &mut m.component_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_flags",
            |m: &CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &m.item_flags },
            |m: &mut CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &mut m.item_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "attributes_string",
            |m: &CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &m.attributes_string },
            |m: &mut CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &mut m.attributes_string },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_required",
            |m: &CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &m.num_required },
            |m: &mut CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &mut m.num_required },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_count",
            |m: &CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &m.item_count },
            |m: &mut CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &mut m.item_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_fulfilled",
            |m: &CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &m.num_fulfilled },
            |m: &mut CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &mut m.num_fulfilled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "items_fulfilled",
            |m: &CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &m.items_fulfilled },
            |m: &mut CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &mut m.items_fulfilled },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT>(
            "CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT {
    const NAME: &'static str = "CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.item_def = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.item_quality = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.component_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.item_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    self.attributes_string = ::std::option::Option::Some(is.read_string()?);
                },
                56 => {
                    self.num_required = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.item_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.num_fulfilled = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.items_fulfilled = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.item_def {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.item_quality {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.component_flags {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.item_flags {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.attributes_string.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.num_required {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.item_count {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.num_fulfilled {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.items_fulfilled {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_def {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.item_quality {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.component_flags {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.item_flags {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.attributes_string.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.num_required {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.item_count {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.num_fulfilled {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.items_fulfilled {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT {
        CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT::new()
    }

    fn clear(&mut self) {
        self.def_index = ::std::option::Option::None;
        self.item_def = ::std::option::Option::None;
        self.item_quality = ::std::option::Option::None;
        self.component_flags = ::std::option::Option::None;
        self.item_flags = ::std::option::Option::None;
        self.attributes_string = ::std::option::Option::None;
        self.num_required = ::std::option::Option::None;
        self.item_count = ::std::option::Option::None;
        self.num_fulfilled = ::std::option::Option::None;
        self.items_fulfilled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT {
        static instance: CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT = CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT {
            def_index: ::std::option::Option::None,
            item_def: ::std::option::Option::None,
            item_quality: ::std::option::Option::None,
            component_flags: ::std::option::Option::None,
            item_flags: ::std::option::Option::None,
            attributes_string: ::std::option::Option::None,
            num_required: ::std::option::Option::None,
            item_count: ::std::option::Option::None,
            num_fulfilled: ::std::option::Option::None,
            items_fulfilled: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CAttribute_ItemSlotCriteria)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CAttribute_ItemSlotCriteria {
    // message fields
    // @@protoc_insertion_point(field:CAttribute_ItemSlotCriteria.tags)
    pub tags: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CAttribute_ItemSlotCriteria.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CAttribute_ItemSlotCriteria {
    fn default() -> &'a CAttribute_ItemSlotCriteria {
        <CAttribute_ItemSlotCriteria as ::protobuf::Message>::default_instance()
    }
}

impl CAttribute_ItemSlotCriteria {
    pub fn new() -> CAttribute_ItemSlotCriteria {
        ::std::default::Default::default()
    }

    // optional string tags = 1;

    pub fn tags(&self) -> &str {
        match self.tags.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_tags(&mut self) {
        self.tags = ::std::option::Option::None;
    }

    pub fn has_tags(&self) -> bool {
        self.tags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::std::string::String) {
        self.tags = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tags(&mut self) -> &mut ::std::string::String {
        if self.tags.is_none() {
            self.tags = ::std::option::Option::Some(::std::string::String::new());
        }
        self.tags.as_mut().unwrap()
    }

    // Take field
    pub fn take_tags(&mut self) -> ::std::string::String {
        self.tags.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tags",
            |m: &CAttribute_ItemSlotCriteria| { &m.tags },
            |m: &mut CAttribute_ItemSlotCriteria| { &mut m.tags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CAttribute_ItemSlotCriteria>(
            "CAttribute_ItemSlotCriteria",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CAttribute_ItemSlotCriteria {
    const NAME: &'static str = "CAttribute_ItemSlotCriteria";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tags = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tags.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tags.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CAttribute_ItemSlotCriteria {
        CAttribute_ItemSlotCriteria::new()
    }

    fn clear(&mut self) {
        self.tags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CAttribute_ItemSlotCriteria {
        static instance: CAttribute_ItemSlotCriteria = CAttribute_ItemSlotCriteria {
            tags: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CAttribute_ItemSlotCriteria {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CAttribute_ItemSlotCriteria").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CAttribute_ItemSlotCriteria {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CAttribute_ItemSlotCriteria {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSetItemSlotAttribute)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetItemSlotAttribute {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetItemSlotAttribute.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSetItemSlotAttribute.slot_item_original_id)
    pub slot_item_original_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSetItemSlotAttribute.slot_index)
    pub slot_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetItemSlotAttribute.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetItemSlotAttribute {
    fn default() -> &'a CMsgSetItemSlotAttribute {
        <CMsgSetItemSlotAttribute as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetItemSlotAttribute {
    pub fn new() -> CMsgSetItemSlotAttribute {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 slot_item_original_id = 2;

    pub fn slot_item_original_id(&self) -> u64 {
        self.slot_item_original_id.unwrap_or(0)
    }

    pub fn clear_slot_item_original_id(&mut self) {
        self.slot_item_original_id = ::std::option::Option::None;
    }

    pub fn has_slot_item_original_id(&self) -> bool {
        self.slot_item_original_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_item_original_id(&mut self, v: u64) {
        self.slot_item_original_id = ::std::option::Option::Some(v);
    }

    // optional uint32 slot_index = 3;

    pub fn slot_index(&self) -> u32 {
        self.slot_index.unwrap_or(0)
    }

    pub fn clear_slot_index(&mut self) {
        self.slot_index = ::std::option::Option::None;
    }

    pub fn has_slot_index(&self) -> bool {
        self.slot_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_index(&mut self, v: u32) {
        self.slot_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgSetItemSlotAttribute| { &m.item_id },
            |m: &mut CMsgSetItemSlotAttribute| { &mut m.item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slot_item_original_id",
            |m: &CMsgSetItemSlotAttribute| { &m.slot_item_original_id },
            |m: &mut CMsgSetItemSlotAttribute| { &mut m.slot_item_original_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slot_index",
            |m: &CMsgSetItemSlotAttribute| { &m.slot_index },
            |m: &mut CMsgSetItemSlotAttribute| { &mut m.slot_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetItemSlotAttribute>(
            "CMsgSetItemSlotAttribute",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSetItemSlotAttribute {
    const NAME: &'static str = "CMsgSetItemSlotAttribute";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.slot_item_original_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.slot_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.slot_item_original_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.slot_index {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.slot_item_original_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.slot_index {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetItemSlotAttribute {
        CMsgSetItemSlotAttribute::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.slot_item_original_id = ::std::option::Option::None;
        self.slot_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetItemSlotAttribute {
        static instance: CMsgSetItemSlotAttribute = CMsgSetItemSlotAttribute {
            item_id: ::std::option::Option::None,
            slot_item_original_id: ::std::option::Option::None,
            slot_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSetItemSlotAttribute {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetItemSlotAttribute").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetItemSlotAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetItemSlotAttribute {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSOWarData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOWarData {
    // message fields
    // @@protoc_insertion_point(field:CSOWarData.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOWarData.war_id)
    pub war_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOWarData.affiliation)
    pub affiliation: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOWarData.points_scored)
    pub points_scored: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOWarData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOWarData {
    fn default() -> &'a CSOWarData {
        <CSOWarData as ::protobuf::Message>::default_instance()
    }
}

impl CSOWarData {
    pub fn new() -> CSOWarData {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 war_id = 2;

    pub fn war_id(&self) -> u32 {
        self.war_id.unwrap_or(0)
    }

    pub fn clear_war_id(&mut self) {
        self.war_id = ::std::option::Option::None;
    }

    pub fn has_war_id(&self) -> bool {
        self.war_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_war_id(&mut self, v: u32) {
        self.war_id = ::std::option::Option::Some(v);
    }

    // optional uint32 affiliation = 3;

    pub fn affiliation(&self) -> u32 {
        self.affiliation.unwrap_or(0)
    }

    pub fn clear_affiliation(&mut self) {
        self.affiliation = ::std::option::Option::None;
    }

    pub fn has_affiliation(&self) -> bool {
        self.affiliation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_affiliation(&mut self, v: u32) {
        self.affiliation = ::std::option::Option::Some(v);
    }

    // optional uint32 points_scored = 4;

    pub fn points_scored(&self) -> u32 {
        self.points_scored.unwrap_or(0)
    }

    pub fn clear_points_scored(&mut self) {
        self.points_scored = ::std::option::Option::None;
    }

    pub fn has_points_scored(&self) -> bool {
        self.points_scored.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_scored(&mut self, v: u32) {
        self.points_scored = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CSOWarData| { &m.account_id },
            |m: &mut CSOWarData| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "war_id",
            |m: &CSOWarData| { &m.war_id },
            |m: &mut CSOWarData| { &mut m.war_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "affiliation",
            |m: &CSOWarData| { &m.affiliation },
            |m: &mut CSOWarData| { &mut m.affiliation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "points_scored",
            |m: &CSOWarData| { &m.points_scored },
            |m: &mut CSOWarData| { &mut m.points_scored },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOWarData>(
            "CSOWarData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOWarData {
    const NAME: &'static str = "CSOWarData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.war_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.affiliation = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.points_scored = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.war_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.affiliation {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.points_scored {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.war_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.affiliation {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.points_scored {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOWarData {
        CSOWarData::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.war_id = ::std::option::Option::None;
        self.affiliation = ::std::option::Option::None;
        self.points_scored = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOWarData {
        static instance: CSOWarData = CSOWarData {
            account_id: ::std::option::Option::None,
            war_id: ::std::option::Option::None,
            affiliation: ::std::option::Option::None,
            points_scored: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOWarData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOWarData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOWarData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOWarData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CGCMsgGC_War_IndividualUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCMsgGC_War_IndividualUpdate {
    // message fields
    // @@protoc_insertion_point(field:CGCMsgGC_War_IndividualUpdate.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CGCMsgGC_War_IndividualUpdate.war_id)
    pub war_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCMsgGC_War_IndividualUpdate.score)
    pub score: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCMsgGC_War_IndividualUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCMsgGC_War_IndividualUpdate {
    fn default() -> &'a CGCMsgGC_War_IndividualUpdate {
        <CGCMsgGC_War_IndividualUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CGCMsgGC_War_IndividualUpdate {
    pub fn new() -> CGCMsgGC_War_IndividualUpdate {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 war_id = 2;

    pub fn war_id(&self) -> u32 {
        self.war_id.unwrap_or(0)
    }

    pub fn clear_war_id(&mut self) {
        self.war_id = ::std::option::Option::None;
    }

    pub fn has_war_id(&self) -> bool {
        self.war_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_war_id(&mut self, v: u32) {
        self.war_id = ::std::option::Option::Some(v);
    }

    // optional uint32 score = 3;

    pub fn score(&self) -> u32 {
        self.score.unwrap_or(0)
    }

    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: u32) {
        self.score = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id",
            |m: &CGCMsgGC_War_IndividualUpdate| { &m.steam_id },
            |m: &mut CGCMsgGC_War_IndividualUpdate| { &mut m.steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "war_id",
            |m: &CGCMsgGC_War_IndividualUpdate| { &m.war_id },
            |m: &mut CGCMsgGC_War_IndividualUpdate| { &mut m.war_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "score",
            |m: &CGCMsgGC_War_IndividualUpdate| { &m.score },
            |m: &mut CGCMsgGC_War_IndividualUpdate| { &mut m.score },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGCMsgGC_War_IndividualUpdate>(
            "CGCMsgGC_War_IndividualUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGCMsgGC_War_IndividualUpdate {
    const NAME: &'static str = "CGCMsgGC_War_IndividualUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.war_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.score = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.war_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.war_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.score {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCMsgGC_War_IndividualUpdate {
        CGCMsgGC_War_IndividualUpdate::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.war_id = ::std::option::Option::None;
        self.score = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCMsgGC_War_IndividualUpdate {
        static instance: CGCMsgGC_War_IndividualUpdate = CGCMsgGC_War_IndividualUpdate {
            steam_id: ::std::option::Option::None,
            war_id: ::std::option::Option::None,
            score: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGCMsgGC_War_IndividualUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGCMsgGC_War_IndividualUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGCMsgGC_War_IndividualUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCMsgGC_War_IndividualUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CGCMsgGC_War_JoinWar)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCMsgGC_War_JoinWar {
    // message fields
    // @@protoc_insertion_point(field:CGCMsgGC_War_JoinWar.affiliation)
    pub affiliation: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCMsgGC_War_JoinWar.war_id)
    pub war_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCMsgGC_War_JoinWar.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCMsgGC_War_JoinWar {
    fn default() -> &'a CGCMsgGC_War_JoinWar {
        <CGCMsgGC_War_JoinWar as ::protobuf::Message>::default_instance()
    }
}

impl CGCMsgGC_War_JoinWar {
    pub fn new() -> CGCMsgGC_War_JoinWar {
        ::std::default::Default::default()
    }

    // optional uint32 affiliation = 1;

    pub fn affiliation(&self) -> u32 {
        self.affiliation.unwrap_or(0)
    }

    pub fn clear_affiliation(&mut self) {
        self.affiliation = ::std::option::Option::None;
    }

    pub fn has_affiliation(&self) -> bool {
        self.affiliation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_affiliation(&mut self, v: u32) {
        self.affiliation = ::std::option::Option::Some(v);
    }

    // optional uint32 war_id = 2;

    pub fn war_id(&self) -> u32 {
        self.war_id.unwrap_or(0)
    }

    pub fn clear_war_id(&mut self) {
        self.war_id = ::std::option::Option::None;
    }

    pub fn has_war_id(&self) -> bool {
        self.war_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_war_id(&mut self, v: u32) {
        self.war_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "affiliation",
            |m: &CGCMsgGC_War_JoinWar| { &m.affiliation },
            |m: &mut CGCMsgGC_War_JoinWar| { &mut m.affiliation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "war_id",
            |m: &CGCMsgGC_War_JoinWar| { &m.war_id },
            |m: &mut CGCMsgGC_War_JoinWar| { &mut m.war_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGCMsgGC_War_JoinWar>(
            "CGCMsgGC_War_JoinWar",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGCMsgGC_War_JoinWar {
    const NAME: &'static str = "CGCMsgGC_War_JoinWar";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.affiliation = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.war_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.affiliation {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.war_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.affiliation {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.war_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCMsgGC_War_JoinWar {
        CGCMsgGC_War_JoinWar::new()
    }

    fn clear(&mut self) {
        self.affiliation = ::std::option::Option::None;
        self.war_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCMsgGC_War_JoinWar {
        static instance: CGCMsgGC_War_JoinWar = CGCMsgGC_War_JoinWar {
            affiliation: ::std::option::Option::None,
            war_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGCMsgGC_War_JoinWar {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGCMsgGC_War_JoinWar").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGCMsgGC_War_JoinWar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCMsgGC_War_JoinWar {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CGCMsgGC_War_RequestGlobalStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCMsgGC_War_RequestGlobalStats {
    // message fields
    // @@protoc_insertion_point(field:CGCMsgGC_War_RequestGlobalStats.war_id)
    pub war_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCMsgGC_War_RequestGlobalStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCMsgGC_War_RequestGlobalStats {
    fn default() -> &'a CGCMsgGC_War_RequestGlobalStats {
        <CGCMsgGC_War_RequestGlobalStats as ::protobuf::Message>::default_instance()
    }
}

impl CGCMsgGC_War_RequestGlobalStats {
    pub fn new() -> CGCMsgGC_War_RequestGlobalStats {
        ::std::default::Default::default()
    }

    // optional uint32 war_id = 1;

    pub fn war_id(&self) -> u32 {
        self.war_id.unwrap_or(0)
    }

    pub fn clear_war_id(&mut self) {
        self.war_id = ::std::option::Option::None;
    }

    pub fn has_war_id(&self) -> bool {
        self.war_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_war_id(&mut self, v: u32) {
        self.war_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "war_id",
            |m: &CGCMsgGC_War_RequestGlobalStats| { &m.war_id },
            |m: &mut CGCMsgGC_War_RequestGlobalStats| { &mut m.war_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGCMsgGC_War_RequestGlobalStats>(
            "CGCMsgGC_War_RequestGlobalStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGCMsgGC_War_RequestGlobalStats {
    const NAME: &'static str = "CGCMsgGC_War_RequestGlobalStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.war_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.war_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.war_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCMsgGC_War_RequestGlobalStats {
        CGCMsgGC_War_RequestGlobalStats::new()
    }

    fn clear(&mut self) {
        self.war_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCMsgGC_War_RequestGlobalStats {
        static instance: CGCMsgGC_War_RequestGlobalStats = CGCMsgGC_War_RequestGlobalStats {
            war_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGCMsgGC_War_RequestGlobalStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGCMsgGC_War_RequestGlobalStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGCMsgGC_War_RequestGlobalStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCMsgGC_War_RequestGlobalStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CGCMsgGC_War_GlobalStatsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCMsgGC_War_GlobalStatsResponse {
    // message fields
    // @@protoc_insertion_point(field:CGCMsgGC_War_GlobalStatsResponse.side_scores)
    pub side_scores: ::std::vec::Vec<cgcmsg_gc_war_global_stats_response::SideScore>,
    // @@protoc_insertion_point(field:CGCMsgGC_War_GlobalStatsResponse.war_id)
    pub war_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCMsgGC_War_GlobalStatsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCMsgGC_War_GlobalStatsResponse {
    fn default() -> &'a CGCMsgGC_War_GlobalStatsResponse {
        <CGCMsgGC_War_GlobalStatsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CGCMsgGC_War_GlobalStatsResponse {
    pub fn new() -> CGCMsgGC_War_GlobalStatsResponse {
        ::std::default::Default::default()
    }

    // optional uint32 war_id = 2;

    pub fn war_id(&self) -> u32 {
        self.war_id.unwrap_or(0)
    }

    pub fn clear_war_id(&mut self) {
        self.war_id = ::std::option::Option::None;
    }

    pub fn has_war_id(&self) -> bool {
        self.war_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_war_id(&mut self, v: u32) {
        self.war_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "side_scores",
            |m: &CGCMsgGC_War_GlobalStatsResponse| { &m.side_scores },
            |m: &mut CGCMsgGC_War_GlobalStatsResponse| { &mut m.side_scores },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "war_id",
            |m: &CGCMsgGC_War_GlobalStatsResponse| { &m.war_id },
            |m: &mut CGCMsgGC_War_GlobalStatsResponse| { &mut m.war_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGCMsgGC_War_GlobalStatsResponse>(
            "CGCMsgGC_War_GlobalStatsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGCMsgGC_War_GlobalStatsResponse {
    const NAME: &'static str = "CGCMsgGC_War_GlobalStatsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.side_scores.push(is.read_message()?);
                },
                16 => {
                    self.war_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.side_scores {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.war_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.side_scores {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.war_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCMsgGC_War_GlobalStatsResponse {
        CGCMsgGC_War_GlobalStatsResponse::new()
    }

    fn clear(&mut self) {
        self.side_scores.clear();
        self.war_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCMsgGC_War_GlobalStatsResponse {
        static instance: CGCMsgGC_War_GlobalStatsResponse = CGCMsgGC_War_GlobalStatsResponse {
            side_scores: ::std::vec::Vec::new(),
            war_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGCMsgGC_War_GlobalStatsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGCMsgGC_War_GlobalStatsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGCMsgGC_War_GlobalStatsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCMsgGC_War_GlobalStatsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CGCMsgGC_War_GlobalStatsResponse`
pub mod cgcmsg_gc_war_global_stats_response {
    // @@protoc_insertion_point(message:CGCMsgGC_War_GlobalStatsResponse.SideScore)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SideScore {
        // message fields
        // @@protoc_insertion_point(field:CGCMsgGC_War_GlobalStatsResponse.SideScore.side)
        pub side: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CGCMsgGC_War_GlobalStatsResponse.SideScore.score)
        pub score: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CGCMsgGC_War_GlobalStatsResponse.SideScore.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SideScore {
        fn default() -> &'a SideScore {
            <SideScore as ::protobuf::Message>::default_instance()
        }
    }

    impl SideScore {
        pub fn new() -> SideScore {
            ::std::default::Default::default()
        }

        // optional uint32 side = 1;

        pub fn side(&self) -> u32 {
            self.side.unwrap_or(0)
        }

        pub fn clear_side(&mut self) {
            self.side = ::std::option::Option::None;
        }

        pub fn has_side(&self) -> bool {
            self.side.is_some()
        }

        // Param is passed by value, moved
        pub fn set_side(&mut self, v: u32) {
            self.side = ::std::option::Option::Some(v);
        }

        // optional uint64 score = 2;

        pub fn score(&self) -> u64 {
            self.score.unwrap_or(0)
        }

        pub fn clear_score(&mut self) {
            self.score = ::std::option::Option::None;
        }

        pub fn has_score(&self) -> bool {
            self.score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score(&mut self, v: u64) {
            self.score = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "side",
                |m: &SideScore| { &m.side },
                |m: &mut SideScore| { &mut m.side },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "score",
                |m: &SideScore| { &m.score },
                |m: &mut SideScore| { &mut m.score },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SideScore>(
                "CGCMsgGC_War_GlobalStatsResponse.SideScore",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SideScore {
        const NAME: &'static str = "SideScore";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.side = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.score = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.side {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.score {
                my_size += ::protobuf::rt::uint64_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.side {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.score {
                os.write_uint64(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SideScore {
            SideScore::new()
        }

        fn clear(&mut self) {
            self.side = ::std::option::Option::None;
            self.score = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SideScore {
            static instance: SideScore = SideScore {
                side: ::std::option::Option::None,
                score: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SideScore {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CGCMsgGC_War_GlobalStatsResponse.SideScore").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SideScore {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SideScore {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate {
    // message fields
    // @@protoc_insertion_point(field:CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate.score)
    pub score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate.type)
    pub type_: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate.score_id)
    pub score_id: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate.score_check)
    pub score_check: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate {
    fn default() -> &'a CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate {
        <CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate {
    pub fn new() -> CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate {
        ::std::default::Default::default()
    }

    // optional uint32 score = 2;

    pub fn score(&self) -> u32 {
        self.score.unwrap_or(0)
    }

    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: u32) {
        self.score = ::std::option::Option::Some(v);
    }

    // optional uint32 type = 3;

    pub fn type_(&self) -> u32 {
        self.type_.unwrap_or(0)
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: u32) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // optional bytes score_id = 4;

    pub fn score_id(&self) -> &[u8] {
        match self.score_id.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_score_id(&mut self) {
        self.score_id = ::std::option::Option::None;
    }

    pub fn has_score_id(&self) -> bool {
        self.score_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.score_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_score_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.score_id.is_none() {
            self.score_id = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.score_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_score_id(&mut self) -> ::std::vec::Vec<u8> {
        self.score_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 score_check = 5;

    pub fn score_check(&self) -> u32 {
        self.score_check.unwrap_or(0)
    }

    pub fn clear_score_check(&mut self) {
        self.score_check = ::std::option::Option::None;
    }

    pub fn has_score_check(&self) -> bool {
        self.score_check.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score_check(&mut self, v: u32) {
        self.score_check = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "score",
            |m: &CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate| { &m.score },
            |m: &mut CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate| { &mut m.score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate| { &m.type_ },
            |m: &mut CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "score_id",
            |m: &CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate| { &m.score_id },
            |m: &mut CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate| { &mut m.score_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "score_check",
            |m: &CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate| { &m.score_check },
            |m: &mut CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate| { &mut m.score_check },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate>(
            "CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate {
    const NAME: &'static str = "CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.score = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.type_ = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.score_id = ::std::option::Option::Some(is.read_bytes()?);
                },
                40 => {
                    self.score_check = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.score_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.score_check {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.score {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.score_id.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.score_check {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate {
        CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate::new()
    }

    fn clear(&mut self) {
        self.score = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.score_id = ::std::option::Option::None;
        self.score_check = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate {
        static instance: CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate = CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate {
            score: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            score_id: ::std::option::Option::None,
            score_check: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CAttribute_WorldItemPlacement)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CAttribute_WorldItemPlacement {
    // message fields
    // @@protoc_insertion_point(field:CAttribute_WorldItemPlacement.original_item_id)
    pub original_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CAttribute_WorldItemPlacement.pos_x)
    pub pos_x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CAttribute_WorldItemPlacement.pos_y)
    pub pos_y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CAttribute_WorldItemPlacement.pos_z)
    pub pos_z: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CAttribute_WorldItemPlacement.ang_x)
    pub ang_x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CAttribute_WorldItemPlacement.ang_y)
    pub ang_y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CAttribute_WorldItemPlacement.ang_z)
    pub ang_z: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CAttribute_WorldItemPlacement.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CAttribute_WorldItemPlacement {
    fn default() -> &'a CAttribute_WorldItemPlacement {
        <CAttribute_WorldItemPlacement as ::protobuf::Message>::default_instance()
    }
}

impl CAttribute_WorldItemPlacement {
    pub fn new() -> CAttribute_WorldItemPlacement {
        ::std::default::Default::default()
    }

    // optional uint64 original_item_id = 1;

    pub fn original_item_id(&self) -> u64 {
        self.original_item_id.unwrap_or(0)
    }

    pub fn clear_original_item_id(&mut self) {
        self.original_item_id = ::std::option::Option::None;
    }

    pub fn has_original_item_id(&self) -> bool {
        self.original_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_item_id(&mut self, v: u64) {
        self.original_item_id = ::std::option::Option::Some(v);
    }

    // optional float pos_x = 2;

    pub fn pos_x(&self) -> f32 {
        self.pos_x.unwrap_or(0.)
    }

    pub fn clear_pos_x(&mut self) {
        self.pos_x = ::std::option::Option::None;
    }

    pub fn has_pos_x(&self) -> bool {
        self.pos_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_x(&mut self, v: f32) {
        self.pos_x = ::std::option::Option::Some(v);
    }

    // optional float pos_y = 3;

    pub fn pos_y(&self) -> f32 {
        self.pos_y.unwrap_or(0.)
    }

    pub fn clear_pos_y(&mut self) {
        self.pos_y = ::std::option::Option::None;
    }

    pub fn has_pos_y(&self) -> bool {
        self.pos_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_y(&mut self, v: f32) {
        self.pos_y = ::std::option::Option::Some(v);
    }

    // optional float pos_z = 4;

    pub fn pos_z(&self) -> f32 {
        self.pos_z.unwrap_or(0.)
    }

    pub fn clear_pos_z(&mut self) {
        self.pos_z = ::std::option::Option::None;
    }

    pub fn has_pos_z(&self) -> bool {
        self.pos_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_z(&mut self, v: f32) {
        self.pos_z = ::std::option::Option::Some(v);
    }

    // optional float ang_x = 5;

    pub fn ang_x(&self) -> f32 {
        self.ang_x.unwrap_or(0.)
    }

    pub fn clear_ang_x(&mut self) {
        self.ang_x = ::std::option::Option::None;
    }

    pub fn has_ang_x(&self) -> bool {
        self.ang_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ang_x(&mut self, v: f32) {
        self.ang_x = ::std::option::Option::Some(v);
    }

    // optional float ang_y = 6;

    pub fn ang_y(&self) -> f32 {
        self.ang_y.unwrap_or(0.)
    }

    pub fn clear_ang_y(&mut self) {
        self.ang_y = ::std::option::Option::None;
    }

    pub fn has_ang_y(&self) -> bool {
        self.ang_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ang_y(&mut self, v: f32) {
        self.ang_y = ::std::option::Option::Some(v);
    }

    // optional float ang_z = 7;

    pub fn ang_z(&self) -> f32 {
        self.ang_z.unwrap_or(0.)
    }

    pub fn clear_ang_z(&mut self) {
        self.ang_z = ::std::option::Option::None;
    }

    pub fn has_ang_z(&self) -> bool {
        self.ang_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ang_z(&mut self, v: f32) {
        self.ang_z = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "original_item_id",
            |m: &CAttribute_WorldItemPlacement| { &m.original_item_id },
            |m: &mut CAttribute_WorldItemPlacement| { &mut m.original_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pos_x",
            |m: &CAttribute_WorldItemPlacement| { &m.pos_x },
            |m: &mut CAttribute_WorldItemPlacement| { &mut m.pos_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pos_y",
            |m: &CAttribute_WorldItemPlacement| { &m.pos_y },
            |m: &mut CAttribute_WorldItemPlacement| { &mut m.pos_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pos_z",
            |m: &CAttribute_WorldItemPlacement| { &m.pos_z },
            |m: &mut CAttribute_WorldItemPlacement| { &mut m.pos_z },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ang_x",
            |m: &CAttribute_WorldItemPlacement| { &m.ang_x },
            |m: &mut CAttribute_WorldItemPlacement| { &mut m.ang_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ang_y",
            |m: &CAttribute_WorldItemPlacement| { &m.ang_y },
            |m: &mut CAttribute_WorldItemPlacement| { &mut m.ang_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ang_z",
            |m: &CAttribute_WorldItemPlacement| { &m.ang_z },
            |m: &mut CAttribute_WorldItemPlacement| { &mut m.ang_z },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CAttribute_WorldItemPlacement>(
            "CAttribute_WorldItemPlacement",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CAttribute_WorldItemPlacement {
    const NAME: &'static str = "CAttribute_WorldItemPlacement";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.original_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                21 => {
                    self.pos_x = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.pos_y = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.pos_z = ::std::option::Option::Some(is.read_float()?);
                },
                45 => {
                    self.ang_x = ::std::option::Option::Some(is.read_float()?);
                },
                53 => {
                    self.ang_y = ::std::option::Option::Some(is.read_float()?);
                },
                61 => {
                    self.ang_z = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.original_item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.pos_x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.pos_y {
            my_size += 1 + 4;
        }
        if let Some(v) = self.pos_z {
            my_size += 1 + 4;
        }
        if let Some(v) = self.ang_x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.ang_y {
            my_size += 1 + 4;
        }
        if let Some(v) = self.ang_z {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.original_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.pos_x {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.pos_y {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.pos_z {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.ang_x {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.ang_y {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.ang_z {
            os.write_float(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CAttribute_WorldItemPlacement {
        CAttribute_WorldItemPlacement::new()
    }

    fn clear(&mut self) {
        self.original_item_id = ::std::option::Option::None;
        self.pos_x = ::std::option::Option::None;
        self.pos_y = ::std::option::Option::None;
        self.pos_z = ::std::option::Option::None;
        self.ang_x = ::std::option::Option::None;
        self.ang_y = ::std::option::Option::None;
        self.ang_z = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CAttribute_WorldItemPlacement {
        static instance: CAttribute_WorldItemPlacement = CAttribute_WorldItemPlacement {
            original_item_id: ::std::option::Option::None,
            pos_x: ::std::option::Option::None,
            pos_y: ::std::option::Option::None,
            pos_z: ::std::option::Option::None,
            ang_x: ::std::option::Option::None,
            ang_y: ::std::option::Option::None,
            ang_z: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CAttribute_WorldItemPlacement {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CAttribute_WorldItemPlacement").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CAttribute_WorldItemPlacement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CAttribute_WorldItemPlacement {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CGCMsg_WorldItemPlacement_Update)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCMsg_WorldItemPlacement_Update {
    // message fields
    // @@protoc_insertion_point(field:CGCMsg_WorldItemPlacement_Update.original_item_id)
    pub original_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CGCMsg_WorldItemPlacement_Update.pos_x)
    pub pos_x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CGCMsg_WorldItemPlacement_Update.pos_y)
    pub pos_y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CGCMsg_WorldItemPlacement_Update.pos_z)
    pub pos_z: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CGCMsg_WorldItemPlacement_Update.ang_x)
    pub ang_x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CGCMsg_WorldItemPlacement_Update.ang_y)
    pub ang_y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CGCMsg_WorldItemPlacement_Update.ang_z)
    pub ang_z: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CGCMsg_WorldItemPlacement_Update.force_remove_all)
    pub force_remove_all: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CGCMsg_WorldItemPlacement_Update.attrib_name)
    pub attrib_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCMsg_WorldItemPlacement_Update.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCMsg_WorldItemPlacement_Update {
    fn default() -> &'a CGCMsg_WorldItemPlacement_Update {
        <CGCMsg_WorldItemPlacement_Update as ::protobuf::Message>::default_instance()
    }
}

impl CGCMsg_WorldItemPlacement_Update {
    pub fn new() -> CGCMsg_WorldItemPlacement_Update {
        ::std::default::Default::default()
    }

    // optional uint64 original_item_id = 1;

    pub fn original_item_id(&self) -> u64 {
        self.original_item_id.unwrap_or(0)
    }

    pub fn clear_original_item_id(&mut self) {
        self.original_item_id = ::std::option::Option::None;
    }

    pub fn has_original_item_id(&self) -> bool {
        self.original_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_item_id(&mut self, v: u64) {
        self.original_item_id = ::std::option::Option::Some(v);
    }

    // optional float pos_x = 2;

    pub fn pos_x(&self) -> f32 {
        self.pos_x.unwrap_or(0.)
    }

    pub fn clear_pos_x(&mut self) {
        self.pos_x = ::std::option::Option::None;
    }

    pub fn has_pos_x(&self) -> bool {
        self.pos_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_x(&mut self, v: f32) {
        self.pos_x = ::std::option::Option::Some(v);
    }

    // optional float pos_y = 3;

    pub fn pos_y(&self) -> f32 {
        self.pos_y.unwrap_or(0.)
    }

    pub fn clear_pos_y(&mut self) {
        self.pos_y = ::std::option::Option::None;
    }

    pub fn has_pos_y(&self) -> bool {
        self.pos_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_y(&mut self, v: f32) {
        self.pos_y = ::std::option::Option::Some(v);
    }

    // optional float pos_z = 4;

    pub fn pos_z(&self) -> f32 {
        self.pos_z.unwrap_or(0.)
    }

    pub fn clear_pos_z(&mut self) {
        self.pos_z = ::std::option::Option::None;
    }

    pub fn has_pos_z(&self) -> bool {
        self.pos_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_z(&mut self, v: f32) {
        self.pos_z = ::std::option::Option::Some(v);
    }

    // optional float ang_x = 5;

    pub fn ang_x(&self) -> f32 {
        self.ang_x.unwrap_or(0.)
    }

    pub fn clear_ang_x(&mut self) {
        self.ang_x = ::std::option::Option::None;
    }

    pub fn has_ang_x(&self) -> bool {
        self.ang_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ang_x(&mut self, v: f32) {
        self.ang_x = ::std::option::Option::Some(v);
    }

    // optional float ang_y = 6;

    pub fn ang_y(&self) -> f32 {
        self.ang_y.unwrap_or(0.)
    }

    pub fn clear_ang_y(&mut self) {
        self.ang_y = ::std::option::Option::None;
    }

    pub fn has_ang_y(&self) -> bool {
        self.ang_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ang_y(&mut self, v: f32) {
        self.ang_y = ::std::option::Option::Some(v);
    }

    // optional float ang_z = 7;

    pub fn ang_z(&self) -> f32 {
        self.ang_z.unwrap_or(0.)
    }

    pub fn clear_ang_z(&mut self) {
        self.ang_z = ::std::option::Option::None;
    }

    pub fn has_ang_z(&self) -> bool {
        self.ang_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ang_z(&mut self, v: f32) {
        self.ang_z = ::std::option::Option::Some(v);
    }

    // optional bool force_remove_all = 8;

    pub fn force_remove_all(&self) -> bool {
        self.force_remove_all.unwrap_or(false)
    }

    pub fn clear_force_remove_all(&mut self) {
        self.force_remove_all = ::std::option::Option::None;
    }

    pub fn has_force_remove_all(&self) -> bool {
        self.force_remove_all.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_remove_all(&mut self, v: bool) {
        self.force_remove_all = ::std::option::Option::Some(v);
    }

    // optional string attrib_name = 9;

    pub fn attrib_name(&self) -> &str {
        match self.attrib_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_attrib_name(&mut self) {
        self.attrib_name = ::std::option::Option::None;
    }

    pub fn has_attrib_name(&self) -> bool {
        self.attrib_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attrib_name(&mut self, v: ::std::string::String) {
        self.attrib_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attrib_name(&mut self) -> &mut ::std::string::String {
        if self.attrib_name.is_none() {
            self.attrib_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.attrib_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_attrib_name(&mut self) -> ::std::string::String {
        self.attrib_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "original_item_id",
            |m: &CGCMsg_WorldItemPlacement_Update| { &m.original_item_id },
            |m: &mut CGCMsg_WorldItemPlacement_Update| { &mut m.original_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pos_x",
            |m: &CGCMsg_WorldItemPlacement_Update| { &m.pos_x },
            |m: &mut CGCMsg_WorldItemPlacement_Update| { &mut m.pos_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pos_y",
            |m: &CGCMsg_WorldItemPlacement_Update| { &m.pos_y },
            |m: &mut CGCMsg_WorldItemPlacement_Update| { &mut m.pos_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pos_z",
            |m: &CGCMsg_WorldItemPlacement_Update| { &m.pos_z },
            |m: &mut CGCMsg_WorldItemPlacement_Update| { &mut m.pos_z },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ang_x",
            |m: &CGCMsg_WorldItemPlacement_Update| { &m.ang_x },
            |m: &mut CGCMsg_WorldItemPlacement_Update| { &mut m.ang_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ang_y",
            |m: &CGCMsg_WorldItemPlacement_Update| { &m.ang_y },
            |m: &mut CGCMsg_WorldItemPlacement_Update| { &mut m.ang_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ang_z",
            |m: &CGCMsg_WorldItemPlacement_Update| { &m.ang_z },
            |m: &mut CGCMsg_WorldItemPlacement_Update| { &mut m.ang_z },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "force_remove_all",
            |m: &CGCMsg_WorldItemPlacement_Update| { &m.force_remove_all },
            |m: &mut CGCMsg_WorldItemPlacement_Update| { &mut m.force_remove_all },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "attrib_name",
            |m: &CGCMsg_WorldItemPlacement_Update| { &m.attrib_name },
            |m: &mut CGCMsg_WorldItemPlacement_Update| { &mut m.attrib_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGCMsg_WorldItemPlacement_Update>(
            "CGCMsg_WorldItemPlacement_Update",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGCMsg_WorldItemPlacement_Update {
    const NAME: &'static str = "CGCMsg_WorldItemPlacement_Update";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.original_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                21 => {
                    self.pos_x = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.pos_y = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.pos_z = ::std::option::Option::Some(is.read_float()?);
                },
                45 => {
                    self.ang_x = ::std::option::Option::Some(is.read_float()?);
                },
                53 => {
                    self.ang_y = ::std::option::Option::Some(is.read_float()?);
                },
                61 => {
                    self.ang_z = ::std::option::Option::Some(is.read_float()?);
                },
                64 => {
                    self.force_remove_all = ::std::option::Option::Some(is.read_bool()?);
                },
                74 => {
                    self.attrib_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.original_item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.pos_x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.pos_y {
            my_size += 1 + 4;
        }
        if let Some(v) = self.pos_z {
            my_size += 1 + 4;
        }
        if let Some(v) = self.ang_x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.ang_y {
            my_size += 1 + 4;
        }
        if let Some(v) = self.ang_z {
            my_size += 1 + 4;
        }
        if let Some(v) = self.force_remove_all {
            my_size += 1 + 1;
        }
        if let Some(v) = self.attrib_name.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.original_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.pos_x {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.pos_y {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.pos_z {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.ang_x {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.ang_y {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.ang_z {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.force_remove_all {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.attrib_name.as_ref() {
            os.write_string(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCMsg_WorldItemPlacement_Update {
        CGCMsg_WorldItemPlacement_Update::new()
    }

    fn clear(&mut self) {
        self.original_item_id = ::std::option::Option::None;
        self.pos_x = ::std::option::Option::None;
        self.pos_y = ::std::option::Option::None;
        self.pos_z = ::std::option::Option::None;
        self.ang_x = ::std::option::Option::None;
        self.ang_y = ::std::option::Option::None;
        self.ang_z = ::std::option::Option::None;
        self.force_remove_all = ::std::option::Option::None;
        self.attrib_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCMsg_WorldItemPlacement_Update {
        static instance: CGCMsg_WorldItemPlacement_Update = CGCMsg_WorldItemPlacement_Update {
            original_item_id: ::std::option::Option::None,
            pos_x: ::std::option::Option::None,
            pos_y: ::std::option::Option::None,
            pos_z: ::std::option::Option::None,
            ang_x: ::std::option::Option::None,
            ang_y: ::std::option::Option::None,
            ang_z: ::std::option::Option::None,
            force_remove_all: ::std::option::Option::None,
            attrib_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGCMsg_WorldItemPlacement_Update {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGCMsg_WorldItemPlacement_Update").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGCMsg_WorldItemPlacement_Update {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCMsg_WorldItemPlacement_Update {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgAcknowledgeXP)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAcknowledgeXP {
    // message fields
    // @@protoc_insertion_point(field:CMsgAcknowledgeXP.match_group)
    pub match_group: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgAcknowledgeXP.predicted_experience)
    pub predicted_experience: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAcknowledgeXP.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAcknowledgeXP {
    fn default() -> &'a CMsgAcknowledgeXP {
        <CMsgAcknowledgeXP as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAcknowledgeXP {
    pub fn new() -> CMsgAcknowledgeXP {
        ::std::default::Default::default()
    }

    // optional int32 match_group = 1;

    pub fn match_group(&self) -> i32 {
        self.match_group.unwrap_or(0)
    }

    pub fn clear_match_group(&mut self) {
        self.match_group = ::std::option::Option::None;
    }

    pub fn has_match_group(&self) -> bool {
        self.match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_group(&mut self, v: i32) {
        self.match_group = ::std::option::Option::Some(v);
    }

    // optional uint32 predicted_experience = 2;

    pub fn predicted_experience(&self) -> u32 {
        self.predicted_experience.unwrap_or(0)
    }

    pub fn clear_predicted_experience(&mut self) {
        self.predicted_experience = ::std::option::Option::None;
    }

    pub fn has_predicted_experience(&self) -> bool {
        self.predicted_experience.is_some()
    }

    // Param is passed by value, moved
    pub fn set_predicted_experience(&mut self, v: u32) {
        self.predicted_experience = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_group",
            |m: &CMsgAcknowledgeXP| { &m.match_group },
            |m: &mut CMsgAcknowledgeXP| { &mut m.match_group },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "predicted_experience",
            |m: &CMsgAcknowledgeXP| { &m.predicted_experience },
            |m: &mut CMsgAcknowledgeXP| { &mut m.predicted_experience },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAcknowledgeXP>(
            "CMsgAcknowledgeXP",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgAcknowledgeXP {
    const NAME: &'static str = "CMsgAcknowledgeXP";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_group = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.predicted_experience = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_group {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.predicted_experience {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.match_group {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.predicted_experience {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAcknowledgeXP {
        CMsgAcknowledgeXP::new()
    }

    fn clear(&mut self) {
        self.match_group = ::std::option::Option::None;
        self.predicted_experience = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAcknowledgeXP {
        static instance: CMsgAcknowledgeXP = CMsgAcknowledgeXP {
            match_group: ::std::option::Option::None,
            predicted_experience: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgAcknowledgeXP {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAcknowledgeXP").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAcknowledgeXP {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAcknowledgeXP {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTFXPSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFXPSource {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFXPSource.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_tfxpsource::XPSourceType>>,
    // @@protoc_insertion_point(field:CMsgTFXPSource.amount)
    pub amount: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgTFXPSource.match_group)
    pub match_group: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgTFXPSource.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTFXPSource.match_id)
    pub match_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFXPSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFXPSource {
    fn default() -> &'a CMsgTFXPSource {
        <CMsgTFXPSource as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFXPSource {
    pub fn new() -> CMsgTFXPSource {
        ::std::default::Default::default()
    }

    // optional .CMsgTFXPSource.XPSourceType type = 1;

    pub fn type_(&self) -> cmsg_tfxpsource::XPSourceType {
        match self.type_ {
            Some(e) => e.enum_value_or(cmsg_tfxpsource::XPSourceType::SOURCE_SCORE),
            None => cmsg_tfxpsource::XPSourceType::SOURCE_SCORE,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: cmsg_tfxpsource::XPSourceType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 amount = 2;

    pub fn amount(&self) -> i32 {
        self.amount.unwrap_or(0)
    }

    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i32) {
        self.amount = ::std::option::Option::Some(v);
    }

    // optional int32 match_group = 3;

    pub fn match_group(&self) -> i32 {
        self.match_group.unwrap_or(0)
    }

    pub fn clear_match_group(&mut self) {
        self.match_group = ::std::option::Option::None;
    }

    pub fn has_match_group(&self) -> bool {
        self.match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_group(&mut self, v: i32) {
        self.match_group = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id = 4;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 5;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CMsgTFXPSource| { &m.type_ },
            |m: &mut CMsgTFXPSource| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "amount",
            |m: &CMsgTFXPSource| { &m.amount },
            |m: &mut CMsgTFXPSource| { &mut m.amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_group",
            |m: &CMsgTFXPSource| { &m.match_group },
            |m: &mut CMsgTFXPSource| { &mut m.match_group },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgTFXPSource| { &m.account_id },
            |m: &mut CMsgTFXPSource| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgTFXPSource| { &m.match_id },
            |m: &mut CMsgTFXPSource| { &mut m.match_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTFXPSource>(
            "CMsgTFXPSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTFXPSource {
    const NAME: &'static str = "CMsgTFXPSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.amount = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.match_group = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.amount {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.match_group {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.amount {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.match_group {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFXPSource {
        CMsgTFXPSource::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.amount = ::std::option::Option::None;
        self.match_group = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFXPSource {
        static instance: CMsgTFXPSource = CMsgTFXPSource {
            type_: ::std::option::Option::None,
            amount: ::std::option::Option::None,
            match_group: ::std::option::Option::None,
            account_id: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTFXPSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTFXPSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTFXPSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFXPSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgTFXPSource`
pub mod cmsg_tfxpsource {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgTFXPSource.XPSourceType)
    pub enum XPSourceType {
        // @@protoc_insertion_point(enum_value:CMsgTFXPSource.XPSourceType.SOURCE_SCORE)
        SOURCE_SCORE = 0,
        // @@protoc_insertion_point(enum_value:CMsgTFXPSource.XPSourceType.SOURCE_OBJECTIVE_BONUS)
        SOURCE_OBJECTIVE_BONUS = 1,
        // @@protoc_insertion_point(enum_value:CMsgTFXPSource.XPSourceType.SOURCE_COMPLETED_MATCH)
        SOURCE_COMPLETED_MATCH = 2,
        // @@protoc_insertion_point(enum_value:CMsgTFXPSource.XPSourceType.SOURCE_COMPETITIVE_ABANDON)
        SOURCE_COMPETITIVE_ABANDON = 3,
        // @@protoc_insertion_point(enum_value:CMsgTFXPSource.XPSourceType.SOURCE_COMPETITIVE_WIN)
        SOURCE_COMPETITIVE_WIN = 4,
        // @@protoc_insertion_point(enum_value:CMsgTFXPSource.XPSourceType.SOURCE_COMPETITIVE_LOSS)
        SOURCE_COMPETITIVE_LOSS = 5,
        // @@protoc_insertion_point(enum_value:CMsgTFXPSource.XPSourceType.SOURCE_AUTOBALANCE_BONUS)
        SOURCE_AUTOBALANCE_BONUS = 6,
        // @@protoc_insertion_point(enum_value:CMsgTFXPSource.XPSourceType.SOURCE_PRESTIGE_BONUS)
        SOURCE_PRESTIGE_BONUS = 7,
    }

    impl ::protobuf::Enum for XPSourceType {
        const NAME: &'static str = "XPSourceType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<XPSourceType> {
            match value {
                0 => ::std::option::Option::Some(XPSourceType::SOURCE_SCORE),
                1 => ::std::option::Option::Some(XPSourceType::SOURCE_OBJECTIVE_BONUS),
                2 => ::std::option::Option::Some(XPSourceType::SOURCE_COMPLETED_MATCH),
                3 => ::std::option::Option::Some(XPSourceType::SOURCE_COMPETITIVE_ABANDON),
                4 => ::std::option::Option::Some(XPSourceType::SOURCE_COMPETITIVE_WIN),
                5 => ::std::option::Option::Some(XPSourceType::SOURCE_COMPETITIVE_LOSS),
                6 => ::std::option::Option::Some(XPSourceType::SOURCE_AUTOBALANCE_BONUS),
                7 => ::std::option::Option::Some(XPSourceType::SOURCE_PRESTIGE_BONUS),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<XPSourceType> {
            match str {
                "SOURCE_SCORE" => ::std::option::Option::Some(XPSourceType::SOURCE_SCORE),
                "SOURCE_OBJECTIVE_BONUS" => ::std::option::Option::Some(XPSourceType::SOURCE_OBJECTIVE_BONUS),
                "SOURCE_COMPLETED_MATCH" => ::std::option::Option::Some(XPSourceType::SOURCE_COMPLETED_MATCH),
                "SOURCE_COMPETITIVE_ABANDON" => ::std::option::Option::Some(XPSourceType::SOURCE_COMPETITIVE_ABANDON),
                "SOURCE_COMPETITIVE_WIN" => ::std::option::Option::Some(XPSourceType::SOURCE_COMPETITIVE_WIN),
                "SOURCE_COMPETITIVE_LOSS" => ::std::option::Option::Some(XPSourceType::SOURCE_COMPETITIVE_LOSS),
                "SOURCE_AUTOBALANCE_BONUS" => ::std::option::Option::Some(XPSourceType::SOURCE_AUTOBALANCE_BONUS),
                "SOURCE_PRESTIGE_BONUS" => ::std::option::Option::Some(XPSourceType::SOURCE_PRESTIGE_BONUS),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [XPSourceType] = &[
            XPSourceType::SOURCE_SCORE,
            XPSourceType::SOURCE_OBJECTIVE_BONUS,
            XPSourceType::SOURCE_COMPLETED_MATCH,
            XPSourceType::SOURCE_COMPETITIVE_ABANDON,
            XPSourceType::SOURCE_COMPETITIVE_WIN,
            XPSourceType::SOURCE_COMPETITIVE_LOSS,
            XPSourceType::SOURCE_AUTOBALANCE_BONUS,
            XPSourceType::SOURCE_PRESTIGE_BONUS,
        ];
    }

    impl ::protobuf::EnumFull for XPSourceType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgTFXPSource.XPSourceType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for XPSourceType {
        fn default() -> Self {
            XPSourceType::SOURCE_SCORE
        }
    }

    impl XPSourceType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<XPSourceType>("CMsgTFXPSource.XPSourceType")
        }
    }
}

// @@protoc_insertion_point(message:CMsgTFXPSourceBreakdown)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFXPSourceBreakdown {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFXPSourceBreakdown.sources)
    pub sources: ::std::vec::Vec<CMsgTFXPSource>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFXPSourceBreakdown.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFXPSourceBreakdown {
    fn default() -> &'a CMsgTFXPSourceBreakdown {
        <CMsgTFXPSourceBreakdown as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFXPSourceBreakdown {
    pub fn new() -> CMsgTFXPSourceBreakdown {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sources",
            |m: &CMsgTFXPSourceBreakdown| { &m.sources },
            |m: &mut CMsgTFXPSourceBreakdown| { &mut m.sources },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTFXPSourceBreakdown>(
            "CMsgTFXPSourceBreakdown",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTFXPSourceBreakdown {
    const NAME: &'static str = "CMsgTFXPSourceBreakdown";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sources.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.sources {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.sources {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFXPSourceBreakdown {
        CMsgTFXPSourceBreakdown::new()
    }

    fn clear(&mut self) {
        self.sources.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFXPSourceBreakdown {
        static instance: CMsgTFXPSourceBreakdown = CMsgTFXPSourceBreakdown {
            sources: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTFXPSourceBreakdown {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTFXPSourceBreakdown").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTFXPSourceBreakdown {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFXPSourceBreakdown {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTFClientInit)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFClientInit {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFClientInit.client_version)
    pub client_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTFClientInit.language)
    pub language: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFClientInit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFClientInit {
    fn default() -> &'a CMsgTFClientInit {
        <CMsgTFClientInit as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFClientInit {
    pub fn new() -> CMsgTFClientInit {
        ::std::default::Default::default()
    }

    // optional uint32 client_version = 1;

    pub fn client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }

    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }

    // optional int32 language = 2;

    pub fn language(&self) -> i32 {
        self.language.unwrap_or(0)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_version",
            |m: &CMsgTFClientInit| { &m.client_version },
            |m: &mut CMsgTFClientInit| { &mut m.client_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "language",
            |m: &CMsgTFClientInit| { &m.language },
            |m: &mut CMsgTFClientInit| { &mut m.language },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTFClientInit>(
            "CMsgTFClientInit",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTFClientInit {
    const NAME: &'static str = "CMsgTFClientInit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.language = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.client_version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.client_version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.language {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFClientInit {
        CMsgTFClientInit::new()
    }

    fn clear(&mut self) {
        self.client_version = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFClientInit {
        static instance: CMsgTFClientInit = CMsgTFClientInit {
            client_version: ::std::option::Option::None,
            language: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTFClientInit {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTFClientInit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTFClientInit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFClientInit {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCNotification {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCNotification.notification_id)
    pub notification_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCNotification.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCNotification.expiration_time)
    pub expiration_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCNotification.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_gcnotification::NotificationType>>,
    // @@protoc_insertion_point(field:CMsgGCNotification.notification_string)
    pub notification_string: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCNotification {
    fn default() -> &'a CMsgGCNotification {
        <CMsgGCNotification as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCNotification {
    pub fn new() -> CMsgGCNotification {
        ::std::default::Default::default()
    }

    // optional uint64 notification_id = 1;

    pub fn notification_id(&self) -> u64 {
        self.notification_id.unwrap_or(0)
    }

    pub fn clear_notification_id(&mut self) {
        self.notification_id = ::std::option::Option::None;
    }

    pub fn has_notification_id(&self) -> bool {
        self.notification_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notification_id(&mut self, v: u64) {
        self.notification_id = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id = 2;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 expiration_time = 3;

    pub fn expiration_time(&self) -> u32 {
        self.expiration_time.unwrap_or(0)
    }

    pub fn clear_expiration_time(&mut self) {
        self.expiration_time = ::std::option::Option::None;
    }

    pub fn has_expiration_time(&self) -> bool {
        self.expiration_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration_time(&mut self, v: u32) {
        self.expiration_time = ::std::option::Option::Some(v);
    }

    // optional .CMsgGCNotification.NotificationType type = 4;

    pub fn type_(&self) -> cmsg_gcnotification::NotificationType {
        match self.type_ {
            Some(e) => e.enum_value_or(cmsg_gcnotification::NotificationType::NOTIFICATION_CUSTOM_STRING),
            None => cmsg_gcnotification::NotificationType::NOTIFICATION_CUSTOM_STRING,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: cmsg_gcnotification::NotificationType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string notification_string = 5;

    pub fn notification_string(&self) -> &str {
        match self.notification_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_notification_string(&mut self) {
        self.notification_string = ::std::option::Option::None;
    }

    pub fn has_notification_string(&self) -> bool {
        self.notification_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notification_string(&mut self, v: ::std::string::String) {
        self.notification_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_notification_string(&mut self) -> &mut ::std::string::String {
        if self.notification_string.is_none() {
            self.notification_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.notification_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_notification_string(&mut self) -> ::std::string::String {
        self.notification_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "notification_id",
            |m: &CMsgGCNotification| { &m.notification_id },
            |m: &mut CMsgGCNotification| { &mut m.notification_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCNotification| { &m.account_id },
            |m: &mut CMsgGCNotification| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expiration_time",
            |m: &CMsgGCNotification| { &m.expiration_time },
            |m: &mut CMsgGCNotification| { &mut m.expiration_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CMsgGCNotification| { &m.type_ },
            |m: &mut CMsgGCNotification| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "notification_string",
            |m: &CMsgGCNotification| { &m.notification_string },
            |m: &mut CMsgGCNotification| { &mut m.notification_string },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCNotification>(
            "CMsgGCNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCNotification {
    const NAME: &'static str = "CMsgGCNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.notification_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                29 => {
                    self.expiration_time = ::std::option::Option::Some(is.read_fixed32()?);
                },
                32 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                42 => {
                    self.notification_string = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.notification_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.expiration_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.notification_string.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.notification_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.expiration_time {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.notification_string.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCNotification {
        CMsgGCNotification::new()
    }

    fn clear(&mut self) {
        self.notification_id = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.expiration_time = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.notification_string = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCNotification {
        static instance: CMsgGCNotification = CMsgGCNotification {
            notification_id: ::std::option::Option::None,
            account_id: ::std::option::Option::None,
            expiration_time: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            notification_string: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGCNotification`
pub mod cmsg_gcnotification {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGCNotification.NotificationType)
    pub enum NotificationType {
        // @@protoc_insertion_point(enum_value:CMsgGCNotification.NotificationType.NOTIFICATION_REPORTED_PLAYER_BANNED)
        NOTIFICATION_REPORTED_PLAYER_BANNED = 0,
        // @@protoc_insertion_point(enum_value:CMsgGCNotification.NotificationType.NOTIFICATION_CUSTOM_STRING)
        NOTIFICATION_CUSTOM_STRING = 1,
        // @@protoc_insertion_point(enum_value:CMsgGCNotification.NotificationType.NOTIFICATION_MM_BAN_DUE_TO_EXCESSIVE_REPORTS)
        NOTIFICATION_MM_BAN_DUE_TO_EXCESSIVE_REPORTS = 2,
        // @@protoc_insertion_point(enum_value:CMsgGCNotification.NotificationType.NOTIFICATION_REPORTED_PLAYER_WAS_BANNED)
        NOTIFICATION_REPORTED_PLAYER_WAS_BANNED = 3,
        // @@protoc_insertion_point(enum_value:CMsgGCNotification.NotificationType.NOTIFICATION_SUPPORT_MESSAGE)
        NOTIFICATION_SUPPORT_MESSAGE = 4,
        // @@protoc_insertion_point(enum_value:CMsgGCNotification.NotificationType.NOTIFICATION_NUM_TYPES)
        NOTIFICATION_NUM_TYPES = 5,
    }

    impl ::protobuf::Enum for NotificationType {
        const NAME: &'static str = "NotificationType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<NotificationType> {
            match value {
                0 => ::std::option::Option::Some(NotificationType::NOTIFICATION_REPORTED_PLAYER_BANNED),
                1 => ::std::option::Option::Some(NotificationType::NOTIFICATION_CUSTOM_STRING),
                2 => ::std::option::Option::Some(NotificationType::NOTIFICATION_MM_BAN_DUE_TO_EXCESSIVE_REPORTS),
                3 => ::std::option::Option::Some(NotificationType::NOTIFICATION_REPORTED_PLAYER_WAS_BANNED),
                4 => ::std::option::Option::Some(NotificationType::NOTIFICATION_SUPPORT_MESSAGE),
                5 => ::std::option::Option::Some(NotificationType::NOTIFICATION_NUM_TYPES),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<NotificationType> {
            match str {
                "NOTIFICATION_REPORTED_PLAYER_BANNED" => ::std::option::Option::Some(NotificationType::NOTIFICATION_REPORTED_PLAYER_BANNED),
                "NOTIFICATION_CUSTOM_STRING" => ::std::option::Option::Some(NotificationType::NOTIFICATION_CUSTOM_STRING),
                "NOTIFICATION_MM_BAN_DUE_TO_EXCESSIVE_REPORTS" => ::std::option::Option::Some(NotificationType::NOTIFICATION_MM_BAN_DUE_TO_EXCESSIVE_REPORTS),
                "NOTIFICATION_REPORTED_PLAYER_WAS_BANNED" => ::std::option::Option::Some(NotificationType::NOTIFICATION_REPORTED_PLAYER_WAS_BANNED),
                "NOTIFICATION_SUPPORT_MESSAGE" => ::std::option::Option::Some(NotificationType::NOTIFICATION_SUPPORT_MESSAGE),
                "NOTIFICATION_NUM_TYPES" => ::std::option::Option::Some(NotificationType::NOTIFICATION_NUM_TYPES),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [NotificationType] = &[
            NotificationType::NOTIFICATION_REPORTED_PLAYER_BANNED,
            NotificationType::NOTIFICATION_CUSTOM_STRING,
            NotificationType::NOTIFICATION_MM_BAN_DUE_TO_EXCESSIVE_REPORTS,
            NotificationType::NOTIFICATION_REPORTED_PLAYER_WAS_BANNED,
            NotificationType::NOTIFICATION_SUPPORT_MESSAGE,
            NotificationType::NOTIFICATION_NUM_TYPES,
        ];
    }

    impl ::protobuf::EnumFull for NotificationType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgGCNotification.NotificationType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for NotificationType {
        fn default() -> Self {
            NotificationType::NOTIFICATION_REPORTED_PLAYER_BANNED
        }
    }

    impl NotificationType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<NotificationType>("CMsgGCNotification.NotificationType")
        }
    }
}

// @@protoc_insertion_point(message:CMsgGCNotificationQueue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCNotificationQueue {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCNotificationQueue.notifications)
    pub notifications: ::std::vec::Vec<CMsgGCNotification>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCNotificationQueue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCNotificationQueue {
    fn default() -> &'a CMsgGCNotificationQueue {
        <CMsgGCNotificationQueue as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCNotificationQueue {
    pub fn new() -> CMsgGCNotificationQueue {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "notifications",
            |m: &CMsgGCNotificationQueue| { &m.notifications },
            |m: &mut CMsgGCNotificationQueue| { &mut m.notifications },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCNotificationQueue>(
            "CMsgGCNotificationQueue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCNotificationQueue {
    const NAME: &'static str = "CMsgGCNotificationQueue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.notifications.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.notifications {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.notifications {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCNotificationQueue {
        CMsgGCNotificationQueue::new()
    }

    fn clear(&mut self) {
        self.notifications.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCNotificationQueue {
        static instance: CMsgGCNotificationQueue = CMsgGCNotificationQueue {
            notifications: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCNotificationQueue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCNotificationQueue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCNotificationQueue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCNotificationQueue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgNotificationAcknowledge)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgNotificationAcknowledge {
    // message fields
    // @@protoc_insertion_point(field:CMsgNotificationAcknowledge.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNotificationAcknowledge.notification_id)
    pub notification_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgNotificationAcknowledge.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgNotificationAcknowledge {
    fn default() -> &'a CMsgNotificationAcknowledge {
        <CMsgNotificationAcknowledge as ::protobuf::Message>::default_instance()
    }
}

impl CMsgNotificationAcknowledge {
    pub fn new() -> CMsgNotificationAcknowledge {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 notification_id = 2;

    pub fn notification_id(&self) -> u64 {
        self.notification_id.unwrap_or(0)
    }

    pub fn clear_notification_id(&mut self) {
        self.notification_id = ::std::option::Option::None;
    }

    pub fn has_notification_id(&self) -> bool {
        self.notification_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notification_id(&mut self, v: u64) {
        self.notification_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgNotificationAcknowledge| { &m.account_id },
            |m: &mut CMsgNotificationAcknowledge| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "notification_id",
            |m: &CMsgNotificationAcknowledge| { &m.notification_id },
            |m: &mut CMsgNotificationAcknowledge| { &mut m.notification_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgNotificationAcknowledge>(
            "CMsgNotificationAcknowledge",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgNotificationAcknowledge {
    const NAME: &'static str = "CMsgNotificationAcknowledge";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.notification_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.notification_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.notification_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgNotificationAcknowledge {
        CMsgNotificationAcknowledge::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.notification_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgNotificationAcknowledge {
        static instance: CMsgNotificationAcknowledge = CMsgNotificationAcknowledge {
            account_id: ::std::option::Option::None,
            notification_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgNotificationAcknowledge {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgNotificationAcknowledge").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgNotificationAcknowledge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgNotificationAcknowledge {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgNotificationAcknowledgeReply)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgNotificationAcknowledgeReply {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgNotificationAcknowledgeReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgNotificationAcknowledgeReply {
    fn default() -> &'a CMsgNotificationAcknowledgeReply {
        <CMsgNotificationAcknowledgeReply as ::protobuf::Message>::default_instance()
    }
}

impl CMsgNotificationAcknowledgeReply {
    pub fn new() -> CMsgNotificationAcknowledgeReply {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgNotificationAcknowledgeReply>(
            "CMsgNotificationAcknowledgeReply",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgNotificationAcknowledgeReply {
    const NAME: &'static str = "CMsgNotificationAcknowledgeReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgNotificationAcknowledgeReply {
        CMsgNotificationAcknowledgeReply::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgNotificationAcknowledgeReply {
        static instance: CMsgNotificationAcknowledgeReply = CMsgNotificationAcknowledgeReply {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgNotificationAcknowledgeReply {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgNotificationAcknowledgeReply").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgNotificationAcknowledgeReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgNotificationAcknowledgeReply {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGC_Match_Result)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_Match_Result {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_Match_Result.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGC_Match_Result.match_group)
    pub match_group: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGC_Match_Result.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_gc_match_result::Status>>,
    // @@protoc_insertion_point(field:CMsgGC_Match_Result.duration)
    pub duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGC_Match_Result.red_score)
    pub red_score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGC_Match_Result.blue_score)
    pub blue_score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGC_Match_Result.winning_team)
    pub winning_team: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGC_Match_Result.map_index)
    pub map_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGC_Match_Result.game_type)
    pub game_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGC_Match_Result.players)
    pub players: ::std::vec::Vec<cmsg_gc_match_result::Player>,
    // @@protoc_insertion_point(field:CMsgGC_Match_Result.win_reason)
    pub win_reason: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGC_Match_Result.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGC_Match_Result.bots)
    pub bots: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_Match_Result.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_Match_Result {
    fn default() -> &'a CMsgGC_Match_Result {
        <CMsgGC_Match_Result as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_Match_Result {
    pub fn new() -> CMsgGC_Match_Result {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional int32 match_group = 2;

    pub fn match_group(&self) -> i32 {
        self.match_group.unwrap_or(0)
    }

    pub fn clear_match_group(&mut self) {
        self.match_group = ::std::option::Option::None;
    }

    pub fn has_match_group(&self) -> bool {
        self.match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_group(&mut self, v: i32) {
        self.match_group = ::std::option::Option::Some(v);
    }

    // optional .CMsgGC_Match_Result.Status status = 3;

    pub fn status(&self) -> cmsg_gc_match_result::Status {
        match self.status {
            Some(e) => e.enum_value_or(cmsg_gc_match_result::Status::MATCH_SUCCEEDED),
            None => cmsg_gc_match_result::Status::MATCH_SUCCEEDED,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: cmsg_gc_match_result::Status) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 duration = 4;

    pub fn duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional uint32 red_score = 5;

    pub fn red_score(&self) -> u32 {
        self.red_score.unwrap_or(0)
    }

    pub fn clear_red_score(&mut self) {
        self.red_score = ::std::option::Option::None;
    }

    pub fn has_red_score(&self) -> bool {
        self.red_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_red_score(&mut self, v: u32) {
        self.red_score = ::std::option::Option::Some(v);
    }

    // optional uint32 blue_score = 6;

    pub fn blue_score(&self) -> u32 {
        self.blue_score.unwrap_or(0)
    }

    pub fn clear_blue_score(&mut self) {
        self.blue_score = ::std::option::Option::None;
    }

    pub fn has_blue_score(&self) -> bool {
        self.blue_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blue_score(&mut self, v: u32) {
        self.blue_score = ::std::option::Option::Some(v);
    }

    // optional uint32 winning_team = 7;

    pub fn winning_team(&self) -> u32 {
        self.winning_team.unwrap_or(0)
    }

    pub fn clear_winning_team(&mut self) {
        self.winning_team = ::std::option::Option::None;
    }

    pub fn has_winning_team(&self) -> bool {
        self.winning_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_winning_team(&mut self, v: u32) {
        self.winning_team = ::std::option::Option::Some(v);
    }

    // optional uint32 map_index = 8;

    pub fn map_index(&self) -> u32 {
        self.map_index.unwrap_or(0)
    }

    pub fn clear_map_index(&mut self) {
        self.map_index = ::std::option::Option::None;
    }

    pub fn has_map_index(&self) -> bool {
        self.map_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_index(&mut self, v: u32) {
        self.map_index = ::std::option::Option::Some(v);
    }

    // optional uint32 game_type = 9;

    pub fn game_type(&self) -> u32 {
        self.game_type.unwrap_or(0u32)
    }

    pub fn clear_game_type(&mut self) {
        self.game_type = ::std::option::Option::None;
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: u32) {
        self.game_type = ::std::option::Option::Some(v);
    }

    // optional uint32 win_reason = 13;

    pub fn win_reason(&self) -> u32 {
        self.win_reason.unwrap_or(0)
    }

    pub fn clear_win_reason(&mut self) {
        self.win_reason = ::std::option::Option::None;
    }

    pub fn has_win_reason(&self) -> bool {
        self.win_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_win_reason(&mut self, v: u32) {
        self.win_reason = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 14;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 bots = 16;

    pub fn bots(&self) -> u32 {
        self.bots.unwrap_or(0)
    }

    pub fn clear_bots(&mut self) {
        self.bots = ::std::option::Option::None;
    }

    pub fn has_bots(&self) -> bool {
        self.bots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bots(&mut self, v: u32) {
        self.bots = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgGC_Match_Result| { &m.match_id },
            |m: &mut CMsgGC_Match_Result| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_group",
            |m: &CMsgGC_Match_Result| { &m.match_group },
            |m: &mut CMsgGC_Match_Result| { &mut m.match_group },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &CMsgGC_Match_Result| { &m.status },
            |m: &mut CMsgGC_Match_Result| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CMsgGC_Match_Result| { &m.duration },
            |m: &mut CMsgGC_Match_Result| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "red_score",
            |m: &CMsgGC_Match_Result| { &m.red_score },
            |m: &mut CMsgGC_Match_Result| { &mut m.red_score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "blue_score",
            |m: &CMsgGC_Match_Result| { &m.blue_score },
            |m: &mut CMsgGC_Match_Result| { &mut m.blue_score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "winning_team",
            |m: &CMsgGC_Match_Result| { &m.winning_team },
            |m: &mut CMsgGC_Match_Result| { &mut m.winning_team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map_index",
            |m: &CMsgGC_Match_Result| { &m.map_index },
            |m: &mut CMsgGC_Match_Result| { &mut m.map_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_type",
            |m: &CMsgGC_Match_Result| { &m.game_type },
            |m: &mut CMsgGC_Match_Result| { &mut m.game_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "players",
            |m: &CMsgGC_Match_Result| { &m.players },
            |m: &mut CMsgGC_Match_Result| { &mut m.players },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "win_reason",
            |m: &CMsgGC_Match_Result| { &m.win_reason },
            |m: &mut CMsgGC_Match_Result| { &mut m.win_reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CMsgGC_Match_Result| { &m.flags },
            |m: &mut CMsgGC_Match_Result| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bots",
            |m: &CMsgGC_Match_Result| { &m.bots },
            |m: &mut CMsgGC_Match_Result| { &mut m.bots },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_Match_Result>(
            "CMsgGC_Match_Result",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_Match_Result {
    const NAME: &'static str = "CMsgGC_Match_Result";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.match_group = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.red_score = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.blue_score = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.winning_team = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.map_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.game_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                82 => {
                    self.players.push(is.read_message()?);
                },
                104 => {
                    self.win_reason = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.bots = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.match_group {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.red_score {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.blue_score {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.winning_team {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.map_index {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.game_type {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.win_reason {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.bots {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.match_group {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.status {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.duration {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.red_score {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.blue_score {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.winning_team {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.map_index {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.game_type {
            os.write_uint32(9, v)?;
        }
        for v in &self.players {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        if let Some(v) = self.win_reason {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.bots {
            os.write_uint32(16, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_Match_Result {
        CMsgGC_Match_Result::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.match_group = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.red_score = ::std::option::Option::None;
        self.blue_score = ::std::option::Option::None;
        self.winning_team = ::std::option::Option::None;
        self.map_index = ::std::option::Option::None;
        self.game_type = ::std::option::Option::None;
        self.players.clear();
        self.win_reason = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.bots = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_Match_Result {
        static instance: CMsgGC_Match_Result = CMsgGC_Match_Result {
            match_id: ::std::option::Option::None,
            match_group: ::std::option::Option::None,
            status: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            red_score: ::std::option::Option::None,
            blue_score: ::std::option::Option::None,
            winning_team: ::std::option::Option::None,
            map_index: ::std::option::Option::None,
            game_type: ::std::option::Option::None,
            players: ::std::vec::Vec::new(),
            win_reason: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            bots: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_Match_Result {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_Match_Result").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_Match_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_Match_Result {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGC_Match_Result`
pub mod cmsg_gc_match_result {
    // @@protoc_insertion_point(message:CMsgGC_Match_Result.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.original_party_id)
        pub original_party_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.team)
        pub team: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.score)
        pub score: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.ping)
        pub ping: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.flags)
        pub flags: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.rank)
        pub rank: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.classes_played)
        pub classes_played: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.kills)
        pub kills: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.deaths)
        pub deaths: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.damage)
        pub damage: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.healing)
        pub healing: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.support)
        pub support: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.score_medal)
        pub score_medal: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.kills_medal)
        pub kills_medal: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.damage_medal)
        pub damage_medal: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.healing_medal)
        pub healing_medal: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.support_medal)
        pub support_medal: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.xp_breakdown)
        pub xp_breakdown: ::std::vec::Vec<super::CMsgTFXPSource>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.leave_time)
        pub leave_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.leave_reason)
        pub leave_reason: ::std::option::Option<::protobuf::EnumOrUnknown<super::TFMatchLeaveReason>>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.connect_time)
        pub connect_time: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGC_Match_Result.Player.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id = 1;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional uint64 original_party_id = 2;

        pub fn original_party_id(&self) -> u64 {
            self.original_party_id.unwrap_or(0)
        }

        pub fn clear_original_party_id(&mut self) {
            self.original_party_id = ::std::option::Option::None;
        }

        pub fn has_original_party_id(&self) -> bool {
            self.original_party_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_original_party_id(&mut self, v: u64) {
            self.original_party_id = ::std::option::Option::Some(v);
        }

        // optional uint32 team = 3;

        pub fn team(&self) -> u32 {
            self.team.unwrap_or(0)
        }

        pub fn clear_team(&mut self) {
            self.team = ::std::option::Option::None;
        }

        pub fn has_team(&self) -> bool {
            self.team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team(&mut self, v: u32) {
            self.team = ::std::option::Option::Some(v);
        }

        // optional uint32 score = 4;

        pub fn score(&self) -> u32 {
            self.score.unwrap_or(0)
        }

        pub fn clear_score(&mut self) {
            self.score = ::std::option::Option::None;
        }

        pub fn has_score(&self) -> bool {
            self.score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score(&mut self, v: u32) {
            self.score = ::std::option::Option::Some(v);
        }

        // optional uint32 ping = 5;

        pub fn ping(&self) -> u32 {
            self.ping.unwrap_or(0)
        }

        pub fn clear_ping(&mut self) {
            self.ping = ::std::option::Option::None;
        }

        pub fn has_ping(&self) -> bool {
            self.ping.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ping(&mut self, v: u32) {
            self.ping = ::std::option::Option::Some(v);
        }

        // optional uint32 flags = 6;

        pub fn flags(&self) -> u32 {
            self.flags.unwrap_or(0)
        }

        pub fn clear_flags(&mut self) {
            self.flags = ::std::option::Option::None;
        }

        pub fn has_flags(&self) -> bool {
            self.flags.is_some()
        }

        // Param is passed by value, moved
        pub fn set_flags(&mut self, v: u32) {
            self.flags = ::std::option::Option::Some(v);
        }

        // optional uint32 rank = 9;

        pub fn rank(&self) -> u32 {
            self.rank.unwrap_or(0)
        }

        pub fn clear_rank(&mut self) {
            self.rank = ::std::option::Option::None;
        }

        pub fn has_rank(&self) -> bool {
            self.rank.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank(&mut self, v: u32) {
            self.rank = ::std::option::Option::Some(v);
        }

        // optional uint32 classes_played = 10;

        pub fn classes_played(&self) -> u32 {
            self.classes_played.unwrap_or(0)
        }

        pub fn clear_classes_played(&mut self) {
            self.classes_played = ::std::option::Option::None;
        }

        pub fn has_classes_played(&self) -> bool {
            self.classes_played.is_some()
        }

        // Param is passed by value, moved
        pub fn set_classes_played(&mut self, v: u32) {
            self.classes_played = ::std::option::Option::Some(v);
        }

        // optional uint32 kills = 11;

        pub fn kills(&self) -> u32 {
            self.kills.unwrap_or(0)
        }

        pub fn clear_kills(&mut self) {
            self.kills = ::std::option::Option::None;
        }

        pub fn has_kills(&self) -> bool {
            self.kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_kills(&mut self, v: u32) {
            self.kills = ::std::option::Option::Some(v);
        }

        // optional uint32 deaths = 12;

        pub fn deaths(&self) -> u32 {
            self.deaths.unwrap_or(0)
        }

        pub fn clear_deaths(&mut self) {
            self.deaths = ::std::option::Option::None;
        }

        pub fn has_deaths(&self) -> bool {
            self.deaths.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deaths(&mut self, v: u32) {
            self.deaths = ::std::option::Option::Some(v);
        }

        // optional uint32 damage = 13;

        pub fn damage(&self) -> u32 {
            self.damage.unwrap_or(0)
        }

        pub fn clear_damage(&mut self) {
            self.damage = ::std::option::Option::None;
        }

        pub fn has_damage(&self) -> bool {
            self.damage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_damage(&mut self, v: u32) {
            self.damage = ::std::option::Option::Some(v);
        }

        // optional uint32 healing = 14;

        pub fn healing(&self) -> u32 {
            self.healing.unwrap_or(0)
        }

        pub fn clear_healing(&mut self) {
            self.healing = ::std::option::Option::None;
        }

        pub fn has_healing(&self) -> bool {
            self.healing.is_some()
        }

        // Param is passed by value, moved
        pub fn set_healing(&mut self, v: u32) {
            self.healing = ::std::option::Option::Some(v);
        }

        // optional uint32 support = 15;

        pub fn support(&self) -> u32 {
            self.support.unwrap_or(0)
        }

        pub fn clear_support(&mut self) {
            self.support = ::std::option::Option::None;
        }

        pub fn has_support(&self) -> bool {
            self.support.is_some()
        }

        // Param is passed by value, moved
        pub fn set_support(&mut self, v: u32) {
            self.support = ::std::option::Option::Some(v);
        }

        // optional uint32 score_medal = 16;

        pub fn score_medal(&self) -> u32 {
            self.score_medal.unwrap_or(0)
        }

        pub fn clear_score_medal(&mut self) {
            self.score_medal = ::std::option::Option::None;
        }

        pub fn has_score_medal(&self) -> bool {
            self.score_medal.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score_medal(&mut self, v: u32) {
            self.score_medal = ::std::option::Option::Some(v);
        }

        // optional uint32 kills_medal = 17;

        pub fn kills_medal(&self) -> u32 {
            self.kills_medal.unwrap_or(0)
        }

        pub fn clear_kills_medal(&mut self) {
            self.kills_medal = ::std::option::Option::None;
        }

        pub fn has_kills_medal(&self) -> bool {
            self.kills_medal.is_some()
        }

        // Param is passed by value, moved
        pub fn set_kills_medal(&mut self, v: u32) {
            self.kills_medal = ::std::option::Option::Some(v);
        }

        // optional uint32 damage_medal = 18;

        pub fn damage_medal(&self) -> u32 {
            self.damage_medal.unwrap_or(0)
        }

        pub fn clear_damage_medal(&mut self) {
            self.damage_medal = ::std::option::Option::None;
        }

        pub fn has_damage_medal(&self) -> bool {
            self.damage_medal.is_some()
        }

        // Param is passed by value, moved
        pub fn set_damage_medal(&mut self, v: u32) {
            self.damage_medal = ::std::option::Option::Some(v);
        }

        // optional uint32 healing_medal = 19;

        pub fn healing_medal(&self) -> u32 {
            self.healing_medal.unwrap_or(0)
        }

        pub fn clear_healing_medal(&mut self) {
            self.healing_medal = ::std::option::Option::None;
        }

        pub fn has_healing_medal(&self) -> bool {
            self.healing_medal.is_some()
        }

        // Param is passed by value, moved
        pub fn set_healing_medal(&mut self, v: u32) {
            self.healing_medal = ::std::option::Option::Some(v);
        }

        // optional uint32 support_medal = 20;

        pub fn support_medal(&self) -> u32 {
            self.support_medal.unwrap_or(0)
        }

        pub fn clear_support_medal(&mut self) {
            self.support_medal = ::std::option::Option::None;
        }

        pub fn has_support_medal(&self) -> bool {
            self.support_medal.is_some()
        }

        // Param is passed by value, moved
        pub fn set_support_medal(&mut self, v: u32) {
            self.support_medal = ::std::option::Option::Some(v);
        }

        // optional uint32 leave_time = 22;

        pub fn leave_time(&self) -> u32 {
            self.leave_time.unwrap_or(0)
        }

        pub fn clear_leave_time(&mut self) {
            self.leave_time = ::std::option::Option::None;
        }

        pub fn has_leave_time(&self) -> bool {
            self.leave_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_leave_time(&mut self, v: u32) {
            self.leave_time = ::std::option::Option::Some(v);
        }

        // optional .TFMatchLeaveReason leave_reason = 23;

        pub fn leave_reason(&self) -> super::TFMatchLeaveReason {
            match self.leave_reason {
                Some(e) => e.enum_value_or(super::TFMatchLeaveReason::TFMatchLeaveReason_UNSPECIFIED),
                None => super::TFMatchLeaveReason::TFMatchLeaveReason_UNSPECIFIED,
            }
        }

        pub fn clear_leave_reason(&mut self) {
            self.leave_reason = ::std::option::Option::None;
        }

        pub fn has_leave_reason(&self) -> bool {
            self.leave_reason.is_some()
        }

        // Param is passed by value, moved
        pub fn set_leave_reason(&mut self, v: super::TFMatchLeaveReason) {
            self.leave_reason = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional uint32 connect_time = 24;

        pub fn connect_time(&self) -> u32 {
            self.connect_time.unwrap_or(0)
        }

        pub fn clear_connect_time(&mut self) {
            self.connect_time = ::std::option::Option::None;
        }

        pub fn has_connect_time(&self) -> bool {
            self.connect_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_connect_time(&mut self, v: u32) {
            self.connect_time = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(22);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "steam_id",
                |m: &Player| { &m.steam_id },
                |m: &mut Player| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "original_party_id",
                |m: &Player| { &m.original_party_id },
                |m: &mut Player| { &mut m.original_party_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team",
                |m: &Player| { &m.team },
                |m: &mut Player| { &mut m.team },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "score",
                |m: &Player| { &m.score },
                |m: &mut Player| { &mut m.score },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ping",
                |m: &Player| { &m.ping },
                |m: &mut Player| { &mut m.ping },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "flags",
                |m: &Player| { &m.flags },
                |m: &mut Player| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rank",
                |m: &Player| { &m.rank },
                |m: &mut Player| { &mut m.rank },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "classes_played",
                |m: &Player| { &m.classes_played },
                |m: &mut Player| { &mut m.classes_played },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "kills",
                |m: &Player| { &m.kills },
                |m: &mut Player| { &mut m.kills },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "deaths",
                |m: &Player| { &m.deaths },
                |m: &mut Player| { &mut m.deaths },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "damage",
                |m: &Player| { &m.damage },
                |m: &mut Player| { &mut m.damage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "healing",
                |m: &Player| { &m.healing },
                |m: &mut Player| { &mut m.healing },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "support",
                |m: &Player| { &m.support },
                |m: &mut Player| { &mut m.support },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "score_medal",
                |m: &Player| { &m.score_medal },
                |m: &mut Player| { &mut m.score_medal },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "kills_medal",
                |m: &Player| { &m.kills_medal },
                |m: &mut Player| { &mut m.kills_medal },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "damage_medal",
                |m: &Player| { &m.damage_medal },
                |m: &mut Player| { &mut m.damage_medal },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "healing_medal",
                |m: &Player| { &m.healing_medal },
                |m: &mut Player| { &mut m.healing_medal },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "support_medal",
                |m: &Player| { &m.support_medal },
                |m: &mut Player| { &mut m.support_medal },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "xp_breakdown",
                |m: &Player| { &m.xp_breakdown },
                |m: &mut Player| { &mut m.xp_breakdown },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "leave_time",
                |m: &Player| { &m.leave_time },
                |m: &mut Player| { &mut m.leave_time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "leave_reason",
                |m: &Player| { &m.leave_reason },
                |m: &mut Player| { &mut m.leave_reason },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "connect_time",
                |m: &Player| { &m.connect_time },
                |m: &mut Player| { &mut m.connect_time },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Player>(
                "CMsgGC_Match_Result.Player",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.original_party_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    24 => {
                        self.team = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.score = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.ping = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.flags = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    72 => {
                        self.rank = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.classes_played = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    88 => {
                        self.kills = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    96 => {
                        self.deaths = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    104 => {
                        self.damage = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    112 => {
                        self.healing = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    120 => {
                        self.support = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    128 => {
                        self.score_medal = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    136 => {
                        self.kills_medal = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    144 => {
                        self.damage_medal = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    152 => {
                        self.healing_medal = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    160 => {
                        self.support_medal = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    170 => {
                        self.xp_breakdown.push(is.read_message()?);
                    },
                    176 => {
                        self.leave_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    184 => {
                        self.leave_reason = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    192 => {
                        self.connect_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.original_party_id {
                my_size += ::protobuf::rt::uint64_size(2, v);
            }
            if let Some(v) = self.team {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.score {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.ping {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.flags {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.rank {
                my_size += ::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.classes_played {
                my_size += ::protobuf::rt::uint32_size(10, v);
            }
            if let Some(v) = self.kills {
                my_size += ::protobuf::rt::uint32_size(11, v);
            }
            if let Some(v) = self.deaths {
                my_size += ::protobuf::rt::uint32_size(12, v);
            }
            if let Some(v) = self.damage {
                my_size += ::protobuf::rt::uint32_size(13, v);
            }
            if let Some(v) = self.healing {
                my_size += ::protobuf::rt::uint32_size(14, v);
            }
            if let Some(v) = self.support {
                my_size += ::protobuf::rt::uint32_size(15, v);
            }
            if let Some(v) = self.score_medal {
                my_size += ::protobuf::rt::uint32_size(16, v);
            }
            if let Some(v) = self.kills_medal {
                my_size += ::protobuf::rt::uint32_size(17, v);
            }
            if let Some(v) = self.damage_medal {
                my_size += ::protobuf::rt::uint32_size(18, v);
            }
            if let Some(v) = self.healing_medal {
                my_size += ::protobuf::rt::uint32_size(19, v);
            }
            if let Some(v) = self.support_medal {
                my_size += ::protobuf::rt::uint32_size(20, v);
            }
            for value in &self.xp_breakdown {
                let len = value.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.leave_time {
                my_size += ::protobuf::rt::uint32_size(22, v);
            }
            if let Some(v) = self.leave_reason {
                my_size += ::protobuf::rt::int32_size(23, v.value());
            }
            if let Some(v) = self.connect_time {
                my_size += ::protobuf::rt::uint32_size(24, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steam_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.original_party_id {
                os.write_uint64(2, v)?;
            }
            if let Some(v) = self.team {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.score {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.ping {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.flags {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.rank {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.classes_played {
                os.write_uint32(10, v)?;
            }
            if let Some(v) = self.kills {
                os.write_uint32(11, v)?;
            }
            if let Some(v) = self.deaths {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.damage {
                os.write_uint32(13, v)?;
            }
            if let Some(v) = self.healing {
                os.write_uint32(14, v)?;
            }
            if let Some(v) = self.support {
                os.write_uint32(15, v)?;
            }
            if let Some(v) = self.score_medal {
                os.write_uint32(16, v)?;
            }
            if let Some(v) = self.kills_medal {
                os.write_uint32(17, v)?;
            }
            if let Some(v) = self.damage_medal {
                os.write_uint32(18, v)?;
            }
            if let Some(v) = self.healing_medal {
                os.write_uint32(19, v)?;
            }
            if let Some(v) = self.support_medal {
                os.write_uint32(20, v)?;
            }
            for v in &self.xp_breakdown {
                ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
            };
            if let Some(v) = self.leave_time {
                os.write_uint32(22, v)?;
            }
            if let Some(v) = self.leave_reason {
                os.write_enum(23, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.connect_time {
                os.write_uint32(24, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.original_party_id = ::std::option::Option::None;
            self.team = ::std::option::Option::None;
            self.score = ::std::option::Option::None;
            self.ping = ::std::option::Option::None;
            self.flags = ::std::option::Option::None;
            self.rank = ::std::option::Option::None;
            self.classes_played = ::std::option::Option::None;
            self.kills = ::std::option::Option::None;
            self.deaths = ::std::option::Option::None;
            self.damage = ::std::option::Option::None;
            self.healing = ::std::option::Option::None;
            self.support = ::std::option::Option::None;
            self.score_medal = ::std::option::Option::None;
            self.kills_medal = ::std::option::Option::None;
            self.damage_medal = ::std::option::Option::None;
            self.healing_medal = ::std::option::Option::None;
            self.support_medal = ::std::option::Option::None;
            self.xp_breakdown.clear();
            self.leave_time = ::std::option::Option::None;
            self.leave_reason = ::std::option::Option::None;
            self.connect_time = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                steam_id: ::std::option::Option::None,
                original_party_id: ::std::option::Option::None,
                team: ::std::option::Option::None,
                score: ::std::option::Option::None,
                ping: ::std::option::Option::None,
                flags: ::std::option::Option::None,
                rank: ::std::option::Option::None,
                classes_played: ::std::option::Option::None,
                kills: ::std::option::Option::None,
                deaths: ::std::option::Option::None,
                damage: ::std::option::Option::None,
                healing: ::std::option::Option::None,
                support: ::std::option::Option::None,
                score_medal: ::std::option::Option::None,
                kills_medal: ::std::option::Option::None,
                damage_medal: ::std::option::Option::None,
                healing_medal: ::std::option::Option::None,
                support_medal: ::std::option::Option::None,
                xp_breakdown: ::std::vec::Vec::new(),
                leave_time: ::std::option::Option::None,
                leave_reason: ::std::option::Option::None,
                connect_time: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Player {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGC_Match_Result.Player").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Player {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Player {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGC_Match_Result.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:CMsgGC_Match_Result.Status.MATCH_SUCCEEDED)
        MATCH_SUCCEEDED = 0,
        // @@protoc_insertion_point(enum_value:CMsgGC_Match_Result.Status.MATCH_FAILED_GC)
        MATCH_FAILED_GC = 1,
        // @@protoc_insertion_point(enum_value:CMsgGC_Match_Result.Status.MATCH_FAILED_TRUSTED)
        MATCH_FAILED_TRUSTED = 2,
        // @@protoc_insertion_point(enum_value:CMsgGC_Match_Result.Status.MATCH_FAILED_ABANDON)
        MATCH_FAILED_ABANDON = 3,
        // @@protoc_insertion_point(enum_value:CMsgGC_Match_Result.Status.MATCH_FAILED_UNKNOWN)
        MATCH_FAILED_UNKNOWN = 5,
        // @@protoc_insertion_point(enum_value:CMsgGC_Match_Result.Status.MATCH_FAILED_TIMEOUT)
        MATCH_FAILED_TIMEOUT = 6,
        // @@protoc_insertion_point(enum_value:CMsgGC_Match_Result.Status.MATCH_FINISHED_ABANDON)
        MATCH_FINISHED_ABANDON = 7,
    }

    impl ::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                0 => ::std::option::Option::Some(Status::MATCH_SUCCEEDED),
                1 => ::std::option::Option::Some(Status::MATCH_FAILED_GC),
                2 => ::std::option::Option::Some(Status::MATCH_FAILED_TRUSTED),
                3 => ::std::option::Option::Some(Status::MATCH_FAILED_ABANDON),
                5 => ::std::option::Option::Some(Status::MATCH_FAILED_UNKNOWN),
                6 => ::std::option::Option::Some(Status::MATCH_FAILED_TIMEOUT),
                7 => ::std::option::Option::Some(Status::MATCH_FINISHED_ABANDON),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Status> {
            match str {
                "MATCH_SUCCEEDED" => ::std::option::Option::Some(Status::MATCH_SUCCEEDED),
                "MATCH_FAILED_GC" => ::std::option::Option::Some(Status::MATCH_FAILED_GC),
                "MATCH_FAILED_TRUSTED" => ::std::option::Option::Some(Status::MATCH_FAILED_TRUSTED),
                "MATCH_FAILED_ABANDON" => ::std::option::Option::Some(Status::MATCH_FAILED_ABANDON),
                "MATCH_FAILED_UNKNOWN" => ::std::option::Option::Some(Status::MATCH_FAILED_UNKNOWN),
                "MATCH_FAILED_TIMEOUT" => ::std::option::Option::Some(Status::MATCH_FAILED_TIMEOUT),
                "MATCH_FINISHED_ABANDON" => ::std::option::Option::Some(Status::MATCH_FINISHED_ABANDON),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::MATCH_SUCCEEDED,
            Status::MATCH_FAILED_GC,
            Status::MATCH_FAILED_TRUSTED,
            Status::MATCH_FAILED_ABANDON,
            Status::MATCH_FAILED_UNKNOWN,
            Status::MATCH_FAILED_TIMEOUT,
            Status::MATCH_FINISHED_ABANDON,
        ];
    }

    impl ::protobuf::EnumFull for Status {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgGC_Match_Result.Status").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Status::MATCH_SUCCEEDED => 0,
                Status::MATCH_FAILED_GC => 1,
                Status::MATCH_FAILED_TRUSTED => 2,
                Status::MATCH_FAILED_ABANDON => 3,
                Status::MATCH_FAILED_UNKNOWN => 4,
                Status::MATCH_FAILED_TIMEOUT => 5,
                Status::MATCH_FINISHED_ABANDON => 6,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::MATCH_SUCCEEDED
        }
    }

    impl Status {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("CMsgGC_Match_Result.Status")
        }
    }
}

// @@protoc_insertion_point(message:CMsgGC_Match_ResultResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_Match_ResultResponse {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_Match_ResultResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_Match_ResultResponse {
    fn default() -> &'a CMsgGC_Match_ResultResponse {
        <CMsgGC_Match_ResultResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_Match_ResultResponse {
    pub fn new() -> CMsgGC_Match_ResultResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_Match_ResultResponse>(
            "CMsgGC_Match_ResultResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_Match_ResultResponse {
    const NAME: &'static str = "CMsgGC_Match_ResultResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_Match_ResultResponse {
        CMsgGC_Match_ResultResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_Match_ResultResponse {
        static instance: CMsgGC_Match_ResultResponse = CMsgGC_Match_ResultResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_Match_ResultResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_Match_ResultResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_Match_ResultResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_Match_ResultResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CEconItemPreviewDataBlock)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CEconItemPreviewDataBlock {
    // message fields
    // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.econitem)
    pub econitem: ::protobuf::MessageField<super::base_gcmessages::CSOEconItem>,
    // special fields
    // @@protoc_insertion_point(special_field:CEconItemPreviewDataBlock.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CEconItemPreviewDataBlock {
    fn default() -> &'a CEconItemPreviewDataBlock {
        <CEconItemPreviewDataBlock as ::protobuf::Message>::default_instance()
    }
}

impl CEconItemPreviewDataBlock {
    pub fn new() -> CEconItemPreviewDataBlock {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::base_gcmessages::CSOEconItem>(
            "econitem",
            |m: &CEconItemPreviewDataBlock| { &m.econitem },
            |m: &mut CEconItemPreviewDataBlock| { &mut m.econitem },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CEconItemPreviewDataBlock>(
            "CEconItemPreviewDataBlock",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CEconItemPreviewDataBlock {
    const NAME: &'static str = "CEconItemPreviewDataBlock";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.econitem)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.econitem.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.econitem.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CEconItemPreviewDataBlock {
        CEconItemPreviewDataBlock::new()
    }

    fn clear(&mut self) {
        self.econitem.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CEconItemPreviewDataBlock {
        static instance: CEconItemPreviewDataBlock = CEconItemPreviewDataBlock {
            econitem: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CEconItemPreviewDataBlock {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CEconItemPreviewDataBlock").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CEconItemPreviewDataBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CEconItemPreviewDataBlock {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGC_Client2GCEconPreviewDataBlockRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_Client2GCEconPreviewDataBlockRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_Client2GCEconPreviewDataBlockRequest.param_s)
    pub param_s: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGC_Client2GCEconPreviewDataBlockRequest.param_a)
    pub param_a: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGC_Client2GCEconPreviewDataBlockRequest.param_d)
    pub param_d: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGC_Client2GCEconPreviewDataBlockRequest.param_m)
    pub param_m: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_Client2GCEconPreviewDataBlockRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_Client2GCEconPreviewDataBlockRequest {
    fn default() -> &'a CMsgGC_Client2GCEconPreviewDataBlockRequest {
        <CMsgGC_Client2GCEconPreviewDataBlockRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_Client2GCEconPreviewDataBlockRequest {
    pub fn new() -> CMsgGC_Client2GCEconPreviewDataBlockRequest {
        ::std::default::Default::default()
    }

    // optional uint64 param_s = 1;

    pub fn param_s(&self) -> u64 {
        self.param_s.unwrap_or(0)
    }

    pub fn clear_param_s(&mut self) {
        self.param_s = ::std::option::Option::None;
    }

    pub fn has_param_s(&self) -> bool {
        self.param_s.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_s(&mut self, v: u64) {
        self.param_s = ::std::option::Option::Some(v);
    }

    // optional uint64 param_a = 2;

    pub fn param_a(&self) -> u64 {
        self.param_a.unwrap_or(0)
    }

    pub fn clear_param_a(&mut self) {
        self.param_a = ::std::option::Option::None;
    }

    pub fn has_param_a(&self) -> bool {
        self.param_a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_a(&mut self, v: u64) {
        self.param_a = ::std::option::Option::Some(v);
    }

    // optional uint64 param_d = 3;

    pub fn param_d(&self) -> u64 {
        self.param_d.unwrap_or(0)
    }

    pub fn clear_param_d(&mut self) {
        self.param_d = ::std::option::Option::None;
    }

    pub fn has_param_d(&self) -> bool {
        self.param_d.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_d(&mut self, v: u64) {
        self.param_d = ::std::option::Option::Some(v);
    }

    // optional uint64 param_m = 4;

    pub fn param_m(&self) -> u64 {
        self.param_m.unwrap_or(0)
    }

    pub fn clear_param_m(&mut self) {
        self.param_m = ::std::option::Option::None;
    }

    pub fn has_param_m(&self) -> bool {
        self.param_m.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_m(&mut self, v: u64) {
        self.param_m = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "param_s",
            |m: &CMsgGC_Client2GCEconPreviewDataBlockRequest| { &m.param_s },
            |m: &mut CMsgGC_Client2GCEconPreviewDataBlockRequest| { &mut m.param_s },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "param_a",
            |m: &CMsgGC_Client2GCEconPreviewDataBlockRequest| { &m.param_a },
            |m: &mut CMsgGC_Client2GCEconPreviewDataBlockRequest| { &mut m.param_a },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "param_d",
            |m: &CMsgGC_Client2GCEconPreviewDataBlockRequest| { &m.param_d },
            |m: &mut CMsgGC_Client2GCEconPreviewDataBlockRequest| { &mut m.param_d },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "param_m",
            |m: &CMsgGC_Client2GCEconPreviewDataBlockRequest| { &m.param_m },
            |m: &mut CMsgGC_Client2GCEconPreviewDataBlockRequest| { &mut m.param_m },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_Client2GCEconPreviewDataBlockRequest>(
            "CMsgGC_Client2GCEconPreviewDataBlockRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_Client2GCEconPreviewDataBlockRequest {
    const NAME: &'static str = "CMsgGC_Client2GCEconPreviewDataBlockRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.param_s = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.param_a = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.param_d = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.param_m = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.param_s {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.param_a {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.param_d {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.param_m {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.param_s {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.param_a {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.param_d {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.param_m {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_Client2GCEconPreviewDataBlockRequest {
        CMsgGC_Client2GCEconPreviewDataBlockRequest::new()
    }

    fn clear(&mut self) {
        self.param_s = ::std::option::Option::None;
        self.param_a = ::std::option::Option::None;
        self.param_d = ::std::option::Option::None;
        self.param_m = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_Client2GCEconPreviewDataBlockRequest {
        static instance: CMsgGC_Client2GCEconPreviewDataBlockRequest = CMsgGC_Client2GCEconPreviewDataBlockRequest {
            param_s: ::std::option::Option::None,
            param_a: ::std::option::Option::None,
            param_d: ::std::option::Option::None,
            param_m: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_Client2GCEconPreviewDataBlockRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_Client2GCEconPreviewDataBlockRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_Client2GCEconPreviewDataBlockRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_Client2GCEconPreviewDataBlockRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGC_Client2GCEconPreviewDataBlockResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_Client2GCEconPreviewDataBlockResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_Client2GCEconPreviewDataBlockResponse.iteminfo)
    pub iteminfo: ::protobuf::MessageField<CEconItemPreviewDataBlock>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_Client2GCEconPreviewDataBlockResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_Client2GCEconPreviewDataBlockResponse {
    fn default() -> &'a CMsgGC_Client2GCEconPreviewDataBlockResponse {
        <CMsgGC_Client2GCEconPreviewDataBlockResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_Client2GCEconPreviewDataBlockResponse {
    pub fn new() -> CMsgGC_Client2GCEconPreviewDataBlockResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CEconItemPreviewDataBlock>(
            "iteminfo",
            |m: &CMsgGC_Client2GCEconPreviewDataBlockResponse| { &m.iteminfo },
            |m: &mut CMsgGC_Client2GCEconPreviewDataBlockResponse| { &mut m.iteminfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_Client2GCEconPreviewDataBlockResponse>(
            "CMsgGC_Client2GCEconPreviewDataBlockResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_Client2GCEconPreviewDataBlockResponse {
    const NAME: &'static str = "CMsgGC_Client2GCEconPreviewDataBlockResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.iteminfo)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.iteminfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.iteminfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_Client2GCEconPreviewDataBlockResponse {
        CMsgGC_Client2GCEconPreviewDataBlockResponse::new()
    }

    fn clear(&mut self) {
        self.iteminfo.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_Client2GCEconPreviewDataBlockResponse {
        static instance: CMsgGC_Client2GCEconPreviewDataBlockResponse = CMsgGC_Client2GCEconPreviewDataBlockResponse {
            iteminfo: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_Client2GCEconPreviewDataBlockResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_Client2GCEconPreviewDataBlockResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_Client2GCEconPreviewDataBlockResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_Client2GCEconPreviewDataBlockResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSOTFLadderPlayerStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOTFLadderPlayerStats {
    // message fields
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.match_group)
    pub match_group: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.season_id)
    pub season_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.games)
    pub games: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.score)
    pub score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.kills)
    pub kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.deaths)
    pub deaths: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.damage)
    pub damage: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.healing)
    pub healing: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.support)
    pub support: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.score_bronze)
    pub score_bronze: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.score_silver)
    pub score_silver: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.score_gold)
    pub score_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.kills_bronze)
    pub kills_bronze: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.kills_silver)
    pub kills_silver: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.kills_gold)
    pub kills_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.damage_bronze)
    pub damage_bronze: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.damage_silver)
    pub damage_silver: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.damage_gold)
    pub damage_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.healing_bronze)
    pub healing_bronze: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.healing_silver)
    pub healing_silver: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.healing_gold)
    pub healing_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.support_bronze)
    pub support_bronze: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.support_silver)
    pub support_silver: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.support_gold)
    pub support_gold: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOTFLadderPlayerStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOTFLadderPlayerStats {
    fn default() -> &'a CSOTFLadderPlayerStats {
        <CSOTFLadderPlayerStats as ::protobuf::Message>::default_instance()
    }
}

impl CSOTFLadderPlayerStats {
    pub fn new() -> CSOTFLadderPlayerStats {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional int32 match_group = 2;

    pub fn match_group(&self) -> i32 {
        self.match_group.unwrap_or(0)
    }

    pub fn clear_match_group(&mut self) {
        self.match_group = ::std::option::Option::None;
    }

    pub fn has_match_group(&self) -> bool {
        self.match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_group(&mut self, v: i32) {
        self.match_group = ::std::option::Option::Some(v);
    }

    // optional uint32 season_id = 3;

    pub fn season_id(&self) -> u32 {
        self.season_id.unwrap_or(0)
    }

    pub fn clear_season_id(&mut self) {
        self.season_id = ::std::option::Option::None;
    }

    pub fn has_season_id(&self) -> bool {
        self.season_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_season_id(&mut self, v: u32) {
        self.season_id = ::std::option::Option::Some(v);
    }

    // optional uint32 games = 9;

    pub fn games(&self) -> u32 {
        self.games.unwrap_or(0)
    }

    pub fn clear_games(&mut self) {
        self.games = ::std::option::Option::None;
    }

    pub fn has_games(&self) -> bool {
        self.games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_games(&mut self, v: u32) {
        self.games = ::std::option::Option::Some(v);
    }

    // optional uint32 score = 10;

    pub fn score(&self) -> u32 {
        self.score.unwrap_or(0)
    }

    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: u32) {
        self.score = ::std::option::Option::Some(v);
    }

    // optional uint32 kills = 11;

    pub fn kills(&self) -> u32 {
        self.kills.unwrap_or(0)
    }

    pub fn clear_kills(&mut self) {
        self.kills = ::std::option::Option::None;
    }

    pub fn has_kills(&self) -> bool {
        self.kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills(&mut self, v: u32) {
        self.kills = ::std::option::Option::Some(v);
    }

    // optional uint32 deaths = 12;

    pub fn deaths(&self) -> u32 {
        self.deaths.unwrap_or(0)
    }

    pub fn clear_deaths(&mut self) {
        self.deaths = ::std::option::Option::None;
    }

    pub fn has_deaths(&self) -> bool {
        self.deaths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deaths(&mut self, v: u32) {
        self.deaths = ::std::option::Option::Some(v);
    }

    // optional uint32 damage = 13;

    pub fn damage(&self) -> u32 {
        self.damage.unwrap_or(0)
    }

    pub fn clear_damage(&mut self) {
        self.damage = ::std::option::Option::None;
    }

    pub fn has_damage(&self) -> bool {
        self.damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage(&mut self, v: u32) {
        self.damage = ::std::option::Option::Some(v);
    }

    // optional uint32 healing = 14;

    pub fn healing(&self) -> u32 {
        self.healing.unwrap_or(0)
    }

    pub fn clear_healing(&mut self) {
        self.healing = ::std::option::Option::None;
    }

    pub fn has_healing(&self) -> bool {
        self.healing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healing(&mut self, v: u32) {
        self.healing = ::std::option::Option::Some(v);
    }

    // optional uint32 support = 15;

    pub fn support(&self) -> u32 {
        self.support.unwrap_or(0)
    }

    pub fn clear_support(&mut self) {
        self.support = ::std::option::Option::None;
    }

    pub fn has_support(&self) -> bool {
        self.support.is_some()
    }

    // Param is passed by value, moved
    pub fn set_support(&mut self, v: u32) {
        self.support = ::std::option::Option::Some(v);
    }

    // optional uint32 score_bronze = 16;

    pub fn score_bronze(&self) -> u32 {
        self.score_bronze.unwrap_or(0)
    }

    pub fn clear_score_bronze(&mut self) {
        self.score_bronze = ::std::option::Option::None;
    }

    pub fn has_score_bronze(&self) -> bool {
        self.score_bronze.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score_bronze(&mut self, v: u32) {
        self.score_bronze = ::std::option::Option::Some(v);
    }

    // optional uint32 score_silver = 17;

    pub fn score_silver(&self) -> u32 {
        self.score_silver.unwrap_or(0)
    }

    pub fn clear_score_silver(&mut self) {
        self.score_silver = ::std::option::Option::None;
    }

    pub fn has_score_silver(&self) -> bool {
        self.score_silver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score_silver(&mut self, v: u32) {
        self.score_silver = ::std::option::Option::Some(v);
    }

    // optional uint32 score_gold = 18;

    pub fn score_gold(&self) -> u32 {
        self.score_gold.unwrap_or(0)
    }

    pub fn clear_score_gold(&mut self) {
        self.score_gold = ::std::option::Option::None;
    }

    pub fn has_score_gold(&self) -> bool {
        self.score_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score_gold(&mut self, v: u32) {
        self.score_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 kills_bronze = 19;

    pub fn kills_bronze(&self) -> u32 {
        self.kills_bronze.unwrap_or(0)
    }

    pub fn clear_kills_bronze(&mut self) {
        self.kills_bronze = ::std::option::Option::None;
    }

    pub fn has_kills_bronze(&self) -> bool {
        self.kills_bronze.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills_bronze(&mut self, v: u32) {
        self.kills_bronze = ::std::option::Option::Some(v);
    }

    // optional uint32 kills_silver = 20;

    pub fn kills_silver(&self) -> u32 {
        self.kills_silver.unwrap_or(0)
    }

    pub fn clear_kills_silver(&mut self) {
        self.kills_silver = ::std::option::Option::None;
    }

    pub fn has_kills_silver(&self) -> bool {
        self.kills_silver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills_silver(&mut self, v: u32) {
        self.kills_silver = ::std::option::Option::Some(v);
    }

    // optional uint32 kills_gold = 21;

    pub fn kills_gold(&self) -> u32 {
        self.kills_gold.unwrap_or(0)
    }

    pub fn clear_kills_gold(&mut self) {
        self.kills_gold = ::std::option::Option::None;
    }

    pub fn has_kills_gold(&self) -> bool {
        self.kills_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills_gold(&mut self, v: u32) {
        self.kills_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 damage_bronze = 22;

    pub fn damage_bronze(&self) -> u32 {
        self.damage_bronze.unwrap_or(0)
    }

    pub fn clear_damage_bronze(&mut self) {
        self.damage_bronze = ::std::option::Option::None;
    }

    pub fn has_damage_bronze(&self) -> bool {
        self.damage_bronze.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_bronze(&mut self, v: u32) {
        self.damage_bronze = ::std::option::Option::Some(v);
    }

    // optional uint32 damage_silver = 23;

    pub fn damage_silver(&self) -> u32 {
        self.damage_silver.unwrap_or(0)
    }

    pub fn clear_damage_silver(&mut self) {
        self.damage_silver = ::std::option::Option::None;
    }

    pub fn has_damage_silver(&self) -> bool {
        self.damage_silver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_silver(&mut self, v: u32) {
        self.damage_silver = ::std::option::Option::Some(v);
    }

    // optional uint32 damage_gold = 24;

    pub fn damage_gold(&self) -> u32 {
        self.damage_gold.unwrap_or(0)
    }

    pub fn clear_damage_gold(&mut self) {
        self.damage_gold = ::std::option::Option::None;
    }

    pub fn has_damage_gold(&self) -> bool {
        self.damage_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_gold(&mut self, v: u32) {
        self.damage_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 healing_bronze = 25;

    pub fn healing_bronze(&self) -> u32 {
        self.healing_bronze.unwrap_or(0)
    }

    pub fn clear_healing_bronze(&mut self) {
        self.healing_bronze = ::std::option::Option::None;
    }

    pub fn has_healing_bronze(&self) -> bool {
        self.healing_bronze.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healing_bronze(&mut self, v: u32) {
        self.healing_bronze = ::std::option::Option::Some(v);
    }

    // optional uint32 healing_silver = 26;

    pub fn healing_silver(&self) -> u32 {
        self.healing_silver.unwrap_or(0)
    }

    pub fn clear_healing_silver(&mut self) {
        self.healing_silver = ::std::option::Option::None;
    }

    pub fn has_healing_silver(&self) -> bool {
        self.healing_silver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healing_silver(&mut self, v: u32) {
        self.healing_silver = ::std::option::Option::Some(v);
    }

    // optional uint32 healing_gold = 27;

    pub fn healing_gold(&self) -> u32 {
        self.healing_gold.unwrap_or(0)
    }

    pub fn clear_healing_gold(&mut self) {
        self.healing_gold = ::std::option::Option::None;
    }

    pub fn has_healing_gold(&self) -> bool {
        self.healing_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healing_gold(&mut self, v: u32) {
        self.healing_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 support_bronze = 28;

    pub fn support_bronze(&self) -> u32 {
        self.support_bronze.unwrap_or(0)
    }

    pub fn clear_support_bronze(&mut self) {
        self.support_bronze = ::std::option::Option::None;
    }

    pub fn has_support_bronze(&self) -> bool {
        self.support_bronze.is_some()
    }

    // Param is passed by value, moved
    pub fn set_support_bronze(&mut self, v: u32) {
        self.support_bronze = ::std::option::Option::Some(v);
    }

    // optional uint32 support_silver = 29;

    pub fn support_silver(&self) -> u32 {
        self.support_silver.unwrap_or(0)
    }

    pub fn clear_support_silver(&mut self) {
        self.support_silver = ::std::option::Option::None;
    }

    pub fn has_support_silver(&self) -> bool {
        self.support_silver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_support_silver(&mut self, v: u32) {
        self.support_silver = ::std::option::Option::Some(v);
    }

    // optional uint32 support_gold = 30;

    pub fn support_gold(&self) -> u32 {
        self.support_gold.unwrap_or(0)
    }

    pub fn clear_support_gold(&mut self) {
        self.support_gold = ::std::option::Option::None;
    }

    pub fn has_support_gold(&self) -> bool {
        self.support_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_support_gold(&mut self, v: u32) {
        self.support_gold = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(25);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CSOTFLadderPlayerStats| { &m.account_id },
            |m: &mut CSOTFLadderPlayerStats| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_group",
            |m: &CSOTFLadderPlayerStats| { &m.match_group },
            |m: &mut CSOTFLadderPlayerStats| { &mut m.match_group },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "season_id",
            |m: &CSOTFLadderPlayerStats| { &m.season_id },
            |m: &mut CSOTFLadderPlayerStats| { &mut m.season_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "games",
            |m: &CSOTFLadderPlayerStats| { &m.games },
            |m: &mut CSOTFLadderPlayerStats| { &mut m.games },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "score",
            |m: &CSOTFLadderPlayerStats| { &m.score },
            |m: &mut CSOTFLadderPlayerStats| { &mut m.score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kills",
            |m: &CSOTFLadderPlayerStats| { &m.kills },
            |m: &mut CSOTFLadderPlayerStats| { &mut m.kills },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deaths",
            |m: &CSOTFLadderPlayerStats| { &m.deaths },
            |m: &mut CSOTFLadderPlayerStats| { &mut m.deaths },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "damage",
            |m: &CSOTFLadderPlayerStats| { &m.damage },
            |m: &mut CSOTFLadderPlayerStats| { &mut m.damage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "healing",
            |m: &CSOTFLadderPlayerStats| { &m.healing },
            |m: &mut CSOTFLadderPlayerStats| { &mut m.healing },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "support",
            |m: &CSOTFLadderPlayerStats| { &m.support },
            |m: &mut CSOTFLadderPlayerStats| { &mut m.support },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "score_bronze",
            |m: &CSOTFLadderPlayerStats| { &m.score_bronze },
            |m: &mut CSOTFLadderPlayerStats| { &mut m.score_bronze },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "score_silver",
            |m: &CSOTFLadderPlayerStats| { &m.score_silver },
            |m: &mut CSOTFLadderPlayerStats| { &mut m.score_silver },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "score_gold",
            |m: &CSOTFLadderPlayerStats| { &m.score_gold },
            |m: &mut CSOTFLadderPlayerStats| { &mut m.score_gold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kills_bronze",
            |m: &CSOTFLadderPlayerStats| { &m.kills_bronze },
            |m: &mut CSOTFLadderPlayerStats| { &mut m.kills_bronze },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kills_silver",
            |m: &CSOTFLadderPlayerStats| { &m.kills_silver },
            |m: &mut CSOTFLadderPlayerStats| { &mut m.kills_silver },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kills_gold",
            |m: &CSOTFLadderPlayerStats| { &m.kills_gold },
            |m: &mut CSOTFLadderPlayerStats| { &mut m.kills_gold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "damage_bronze",
            |m: &CSOTFLadderPlayerStats| { &m.damage_bronze },
            |m: &mut CSOTFLadderPlayerStats| { &mut m.damage_bronze },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "damage_silver",
            |m: &CSOTFLadderPlayerStats| { &m.damage_silver },
            |m: &mut CSOTFLadderPlayerStats| { &mut m.damage_silver },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "damage_gold",
            |m: &CSOTFLadderPlayerStats| { &m.damage_gold },
            |m: &mut CSOTFLadderPlayerStats| { &mut m.damage_gold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "healing_bronze",
            |m: &CSOTFLadderPlayerStats| { &m.healing_bronze },
            |m: &mut CSOTFLadderPlayerStats| { &mut m.healing_bronze },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "healing_silver",
            |m: &CSOTFLadderPlayerStats| { &m.healing_silver },
            |m: &mut CSOTFLadderPlayerStats| { &mut m.healing_silver },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "healing_gold",
            |m: &CSOTFLadderPlayerStats| { &m.healing_gold },
            |m: &mut CSOTFLadderPlayerStats| { &mut m.healing_gold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "support_bronze",
            |m: &CSOTFLadderPlayerStats| { &m.support_bronze },
            |m: &mut CSOTFLadderPlayerStats| { &mut m.support_bronze },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "support_silver",
            |m: &CSOTFLadderPlayerStats| { &m.support_silver },
            |m: &mut CSOTFLadderPlayerStats| { &mut m.support_silver },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "support_gold",
            |m: &CSOTFLadderPlayerStats| { &m.support_gold },
            |m: &mut CSOTFLadderPlayerStats| { &mut m.support_gold },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOTFLadderPlayerStats>(
            "CSOTFLadderPlayerStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOTFLadderPlayerStats {
    const NAME: &'static str = "CSOTFLadderPlayerStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.match_group = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.season_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.games = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.score = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.deaths = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.damage = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.healing = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.support = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.score_bronze = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.score_silver = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.score_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.kills_bronze = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.kills_silver = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.kills_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.damage_bronze = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.damage_silver = ::std::option::Option::Some(is.read_uint32()?);
                },
                192 => {
                    self.damage_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                200 => {
                    self.healing_bronze = ::std::option::Option::Some(is.read_uint32()?);
                },
                208 => {
                    self.healing_silver = ::std::option::Option::Some(is.read_uint32()?);
                },
                216 => {
                    self.healing_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                224 => {
                    self.support_bronze = ::std::option::Option::Some(is.read_uint32()?);
                },
                232 => {
                    self.support_silver = ::std::option::Option::Some(is.read_uint32()?);
                },
                240 => {
                    self.support_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.match_group {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.season_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.games {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.kills {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.deaths {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.damage {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.healing {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.support {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.score_bronze {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.score_silver {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.score_gold {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.kills_bronze {
            my_size += ::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.kills_silver {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.kills_gold {
            my_size += ::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.damage_bronze {
            my_size += ::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.damage_silver {
            my_size += ::protobuf::rt::uint32_size(23, v);
        }
        if let Some(v) = self.damage_gold {
            my_size += ::protobuf::rt::uint32_size(24, v);
        }
        if let Some(v) = self.healing_bronze {
            my_size += ::protobuf::rt::uint32_size(25, v);
        }
        if let Some(v) = self.healing_silver {
            my_size += ::protobuf::rt::uint32_size(26, v);
        }
        if let Some(v) = self.healing_gold {
            my_size += ::protobuf::rt::uint32_size(27, v);
        }
        if let Some(v) = self.support_bronze {
            my_size += ::protobuf::rt::uint32_size(28, v);
        }
        if let Some(v) = self.support_silver {
            my_size += ::protobuf::rt::uint32_size(29, v);
        }
        if let Some(v) = self.support_gold {
            my_size += ::protobuf::rt::uint32_size(30, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.match_group {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.season_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.games {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.score {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.kills {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.deaths {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.damage {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.healing {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.support {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.score_bronze {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.score_silver {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.score_gold {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.kills_bronze {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.kills_silver {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.kills_gold {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.damage_bronze {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.damage_silver {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.damage_gold {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.healing_bronze {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.healing_silver {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.healing_gold {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.support_bronze {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.support_silver {
            os.write_uint32(29, v)?;
        }
        if let Some(v) = self.support_gold {
            os.write_uint32(30, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOTFLadderPlayerStats {
        CSOTFLadderPlayerStats::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.match_group = ::std::option::Option::None;
        self.season_id = ::std::option::Option::None;
        self.games = ::std::option::Option::None;
        self.score = ::std::option::Option::None;
        self.kills = ::std::option::Option::None;
        self.deaths = ::std::option::Option::None;
        self.damage = ::std::option::Option::None;
        self.healing = ::std::option::Option::None;
        self.support = ::std::option::Option::None;
        self.score_bronze = ::std::option::Option::None;
        self.score_silver = ::std::option::Option::None;
        self.score_gold = ::std::option::Option::None;
        self.kills_bronze = ::std::option::Option::None;
        self.kills_silver = ::std::option::Option::None;
        self.kills_gold = ::std::option::Option::None;
        self.damage_bronze = ::std::option::Option::None;
        self.damage_silver = ::std::option::Option::None;
        self.damage_gold = ::std::option::Option::None;
        self.healing_bronze = ::std::option::Option::None;
        self.healing_silver = ::std::option::Option::None;
        self.healing_gold = ::std::option::Option::None;
        self.support_bronze = ::std::option::Option::None;
        self.support_silver = ::std::option::Option::None;
        self.support_gold = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOTFLadderPlayerStats {
        static instance: CSOTFLadderPlayerStats = CSOTFLadderPlayerStats {
            account_id: ::std::option::Option::None,
            match_group: ::std::option::Option::None,
            season_id: ::std::option::Option::None,
            games: ::std::option::Option::None,
            score: ::std::option::Option::None,
            kills: ::std::option::Option::None,
            deaths: ::std::option::Option::None,
            damage: ::std::option::Option::None,
            healing: ::std::option::Option::None,
            support: ::std::option::Option::None,
            score_bronze: ::std::option::Option::None,
            score_silver: ::std::option::Option::None,
            score_gold: ::std::option::Option::None,
            kills_bronze: ::std::option::Option::None,
            kills_silver: ::std::option::Option::None,
            kills_gold: ::std::option::Option::None,
            damage_bronze: ::std::option::Option::None,
            damage_silver: ::std::option::Option::None,
            damage_gold: ::std::option::Option::None,
            healing_bronze: ::std::option::Option::None,
            healing_silver: ::std::option::Option::None,
            healing_gold: ::std::option::Option::None,
            support_bronze: ::std::option::Option::None,
            support_silver: ::std::option::Option::None,
            support_gold: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOTFLadderPlayerStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOTFLadderPlayerStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOTFLadderPlayerStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOTFLadderPlayerStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSOTFRatingData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOTFRatingData {
    // message fields
    // @@protoc_insertion_point(field:CSOTFRatingData.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFRatingData.rating_type)
    pub rating_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSOTFRatingData.rating_primary)
    pub rating_primary: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFRatingData.rating_secondary)
    pub rating_secondary: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFRatingData.rating_tertiary)
    pub rating_tertiary: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOTFRatingData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOTFRatingData {
    fn default() -> &'a CSOTFRatingData {
        <CSOTFRatingData as ::protobuf::Message>::default_instance()
    }
}

impl CSOTFRatingData {
    pub fn new() -> CSOTFRatingData {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional int32 rating_type = 2;

    pub fn rating_type(&self) -> i32 {
        self.rating_type.unwrap_or(0)
    }

    pub fn clear_rating_type(&mut self) {
        self.rating_type = ::std::option::Option::None;
    }

    pub fn has_rating_type(&self) -> bool {
        self.rating_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rating_type(&mut self, v: i32) {
        self.rating_type = ::std::option::Option::Some(v);
    }

    // optional uint32 rating_primary = 3;

    pub fn rating_primary(&self) -> u32 {
        self.rating_primary.unwrap_or(0)
    }

    pub fn clear_rating_primary(&mut self) {
        self.rating_primary = ::std::option::Option::None;
    }

    pub fn has_rating_primary(&self) -> bool {
        self.rating_primary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rating_primary(&mut self, v: u32) {
        self.rating_primary = ::std::option::Option::Some(v);
    }

    // optional uint32 rating_secondary = 4;

    pub fn rating_secondary(&self) -> u32 {
        self.rating_secondary.unwrap_or(0)
    }

    pub fn clear_rating_secondary(&mut self) {
        self.rating_secondary = ::std::option::Option::None;
    }

    pub fn has_rating_secondary(&self) -> bool {
        self.rating_secondary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rating_secondary(&mut self, v: u32) {
        self.rating_secondary = ::std::option::Option::Some(v);
    }

    // optional uint32 rating_tertiary = 5;

    pub fn rating_tertiary(&self) -> u32 {
        self.rating_tertiary.unwrap_or(0)
    }

    pub fn clear_rating_tertiary(&mut self) {
        self.rating_tertiary = ::std::option::Option::None;
    }

    pub fn has_rating_tertiary(&self) -> bool {
        self.rating_tertiary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rating_tertiary(&mut self, v: u32) {
        self.rating_tertiary = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CSOTFRatingData| { &m.account_id },
            |m: &mut CSOTFRatingData| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rating_type",
            |m: &CSOTFRatingData| { &m.rating_type },
            |m: &mut CSOTFRatingData| { &mut m.rating_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rating_primary",
            |m: &CSOTFRatingData| { &m.rating_primary },
            |m: &mut CSOTFRatingData| { &mut m.rating_primary },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rating_secondary",
            |m: &CSOTFRatingData| { &m.rating_secondary },
            |m: &mut CSOTFRatingData| { &mut m.rating_secondary },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rating_tertiary",
            |m: &CSOTFRatingData| { &m.rating_tertiary },
            |m: &mut CSOTFRatingData| { &mut m.rating_tertiary },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOTFRatingData>(
            "CSOTFRatingData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOTFRatingData {
    const NAME: &'static str = "CSOTFRatingData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.rating_type = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.rating_primary = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.rating_secondary = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.rating_tertiary = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.rating_type {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.rating_primary {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.rating_secondary {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.rating_tertiary {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.rating_type {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.rating_primary {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.rating_secondary {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rating_tertiary {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOTFRatingData {
        CSOTFRatingData::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.rating_type = ::std::option::Option::None;
        self.rating_primary = ::std::option::Option::None;
        self.rating_secondary = ::std::option::Option::None;
        self.rating_tertiary = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOTFRatingData {
        static instance: CSOTFRatingData = CSOTFRatingData {
            account_id: ::std::option::Option::None,
            rating_type: ::std::option::Option::None,
            rating_primary: ::std::option::Option::None,
            rating_secondary: ::std::option::Option::None,
            rating_tertiary: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOTFRatingData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOTFRatingData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOTFRatingData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOTFRatingData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGC_TFVoteKickPlayerRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_TFVoteKickPlayerRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_TFVoteKickPlayerRequest.target_id)
    pub target_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGC_TFVoteKickPlayerRequest.voter_id)
    pub voter_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGC_TFVoteKickPlayerRequest.reason)
    pub reason: ::std::option::Option<::protobuf::EnumOrUnknown<TFVoteKickReason>>,
    // @@protoc_insertion_point(field:CMsgGC_TFVoteKickPlayerRequest.match_id)
    pub match_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_TFVoteKickPlayerRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_TFVoteKickPlayerRequest {
    fn default() -> &'a CMsgGC_TFVoteKickPlayerRequest {
        <CMsgGC_TFVoteKickPlayerRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_TFVoteKickPlayerRequest {
    pub fn new() -> CMsgGC_TFVoteKickPlayerRequest {
        ::std::default::Default::default()
    }

    // optional uint64 target_id = 2;

    pub fn target_id(&self) -> u64 {
        self.target_id.unwrap_or(0)
    }

    pub fn clear_target_id(&mut self) {
        self.target_id = ::std::option::Option::None;
    }

    pub fn has_target_id(&self) -> bool {
        self.target_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_id(&mut self, v: u64) {
        self.target_id = ::std::option::Option::Some(v);
    }

    // optional uint64 voter_id = 3;

    pub fn voter_id(&self) -> u64 {
        self.voter_id.unwrap_or(0)
    }

    pub fn clear_voter_id(&mut self) {
        self.voter_id = ::std::option::Option::None;
    }

    pub fn has_voter_id(&self) -> bool {
        self.voter_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voter_id(&mut self, v: u64) {
        self.voter_id = ::std::option::Option::Some(v);
    }

    // optional .TFVoteKickReason reason = 4;

    pub fn reason(&self) -> TFVoteKickReason {
        match self.reason {
            Some(e) => e.enum_value_or(TFVoteKickReason::TFVoteKickReason_Other),
            None => TFVoteKickReason::TFVoteKickReason_Other,
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: TFVoteKickReason) {
        self.reason = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 match_id = 5;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_id",
            |m: &CMsgGC_TFVoteKickPlayerRequest| { &m.target_id },
            |m: &mut CMsgGC_TFVoteKickPlayerRequest| { &mut m.target_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "voter_id",
            |m: &CMsgGC_TFVoteKickPlayerRequest| { &m.voter_id },
            |m: &mut CMsgGC_TFVoteKickPlayerRequest| { &mut m.voter_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &CMsgGC_TFVoteKickPlayerRequest| { &m.reason },
            |m: &mut CMsgGC_TFVoteKickPlayerRequest| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgGC_TFVoteKickPlayerRequest| { &m.match_id },
            |m: &mut CMsgGC_TFVoteKickPlayerRequest| { &mut m.match_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_TFVoteKickPlayerRequest>(
            "CMsgGC_TFVoteKickPlayerRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_TFVoteKickPlayerRequest {
    const NAME: &'static str = "CMsgGC_TFVoteKickPlayerRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.target_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.voter_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.reason = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.voter_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.target_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.voter_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.reason {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_TFVoteKickPlayerRequest {
        CMsgGC_TFVoteKickPlayerRequest::new()
    }

    fn clear(&mut self) {
        self.target_id = ::std::option::Option::None;
        self.voter_id = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_TFVoteKickPlayerRequest {
        static instance: CMsgGC_TFVoteKickPlayerRequest = CMsgGC_TFVoteKickPlayerRequest {
            target_id: ::std::option::Option::None,
            voter_id: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_TFVoteKickPlayerRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_TFVoteKickPlayerRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_TFVoteKickPlayerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_TFVoteKickPlayerRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGC_VoteKickPlayerRequestResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_VoteKickPlayerRequestResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_VoteKickPlayerRequestResponse.allowed)
    pub allowed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGC_VoteKickPlayerRequestResponse.voter_inhibit)
    pub voter_inhibit: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGC_VoteKickPlayerRequestResponse.target_inhibit)
    pub target_inhibit: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_VoteKickPlayerRequestResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_VoteKickPlayerRequestResponse {
    fn default() -> &'a CMsgGC_VoteKickPlayerRequestResponse {
        <CMsgGC_VoteKickPlayerRequestResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_VoteKickPlayerRequestResponse {
    pub fn new() -> CMsgGC_VoteKickPlayerRequestResponse {
        ::std::default::Default::default()
    }

    // optional bool allowed = 1;

    pub fn allowed(&self) -> bool {
        self.allowed.unwrap_or(false)
    }

    pub fn clear_allowed(&mut self) {
        self.allowed = ::std::option::Option::None;
    }

    pub fn has_allowed(&self) -> bool {
        self.allowed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allowed(&mut self, v: bool) {
        self.allowed = ::std::option::Option::Some(v);
    }

    // optional bool voter_inhibit = 3;

    pub fn voter_inhibit(&self) -> bool {
        self.voter_inhibit.unwrap_or(false)
    }

    pub fn clear_voter_inhibit(&mut self) {
        self.voter_inhibit = ::std::option::Option::None;
    }

    pub fn has_voter_inhibit(&self) -> bool {
        self.voter_inhibit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voter_inhibit(&mut self, v: bool) {
        self.voter_inhibit = ::std::option::Option::Some(v);
    }

    // optional bool target_inhibit = 4;

    pub fn target_inhibit(&self) -> bool {
        self.target_inhibit.unwrap_or(false)
    }

    pub fn clear_target_inhibit(&mut self) {
        self.target_inhibit = ::std::option::Option::None;
    }

    pub fn has_target_inhibit(&self) -> bool {
        self.target_inhibit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_inhibit(&mut self, v: bool) {
        self.target_inhibit = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "allowed",
            |m: &CMsgGC_VoteKickPlayerRequestResponse| { &m.allowed },
            |m: &mut CMsgGC_VoteKickPlayerRequestResponse| { &mut m.allowed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "voter_inhibit",
            |m: &CMsgGC_VoteKickPlayerRequestResponse| { &m.voter_inhibit },
            |m: &mut CMsgGC_VoteKickPlayerRequestResponse| { &mut m.voter_inhibit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_inhibit",
            |m: &CMsgGC_VoteKickPlayerRequestResponse| { &m.target_inhibit },
            |m: &mut CMsgGC_VoteKickPlayerRequestResponse| { &mut m.target_inhibit },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_VoteKickPlayerRequestResponse>(
            "CMsgGC_VoteKickPlayerRequestResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_VoteKickPlayerRequestResponse {
    const NAME: &'static str = "CMsgGC_VoteKickPlayerRequestResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.allowed = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.voter_inhibit = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.target_inhibit = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.allowed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.voter_inhibit {
            my_size += 1 + 1;
        }
        if let Some(v) = self.target_inhibit {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.allowed {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.voter_inhibit {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.target_inhibit {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_VoteKickPlayerRequestResponse {
        CMsgGC_VoteKickPlayerRequestResponse::new()
    }

    fn clear(&mut self) {
        self.allowed = ::std::option::Option::None;
        self.voter_inhibit = ::std::option::Option::None;
        self.target_inhibit = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_VoteKickPlayerRequestResponse {
        static instance: CMsgGC_VoteKickPlayerRequestResponse = CMsgGC_VoteKickPlayerRequestResponse {
            allowed: ::std::option::Option::None,
            voter_inhibit: ::std::option::Option::None,
            target_inhibit: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_VoteKickPlayerRequestResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_VoteKickPlayerRequestResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_VoteKickPlayerRequestResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_VoteKickPlayerRequestResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGC_DailyCompetitiveStatsRollup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_DailyCompetitiveStatsRollup {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_DailyCompetitiveStatsRollup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_DailyCompetitiveStatsRollup {
    fn default() -> &'a CMsgGC_DailyCompetitiveStatsRollup {
        <CMsgGC_DailyCompetitiveStatsRollup as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_DailyCompetitiveStatsRollup {
    pub fn new() -> CMsgGC_DailyCompetitiveStatsRollup {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_DailyCompetitiveStatsRollup>(
            "CMsgGC_DailyCompetitiveStatsRollup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_DailyCompetitiveStatsRollup {
    const NAME: &'static str = "CMsgGC_DailyCompetitiveStatsRollup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_DailyCompetitiveStatsRollup {
        CMsgGC_DailyCompetitiveStatsRollup::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_DailyCompetitiveStatsRollup {
        static instance: CMsgGC_DailyCompetitiveStatsRollup = CMsgGC_DailyCompetitiveStatsRollup {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_DailyCompetitiveStatsRollup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_DailyCompetitiveStatsRollup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_DailyCompetitiveStatsRollup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_DailyCompetitiveStatsRollup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGC_DailyCompetitiveStatsRollup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_DailyCompetitiveStatsRollup_Response {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_DailyCompetitiveStatsRollup_Response.rankdata)
    pub rankdata: ::std::vec::Vec<cmsg_gc_daily_competitive_stats_rollup_response::RankBucketEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_DailyCompetitiveStatsRollup_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_DailyCompetitiveStatsRollup_Response {
    fn default() -> &'a CMsgGC_DailyCompetitiveStatsRollup_Response {
        <CMsgGC_DailyCompetitiveStatsRollup_Response as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_DailyCompetitiveStatsRollup_Response {
    pub fn new() -> CMsgGC_DailyCompetitiveStatsRollup_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rankdata",
            |m: &CMsgGC_DailyCompetitiveStatsRollup_Response| { &m.rankdata },
            |m: &mut CMsgGC_DailyCompetitiveStatsRollup_Response| { &mut m.rankdata },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_DailyCompetitiveStatsRollup_Response>(
            "CMsgGC_DailyCompetitiveStatsRollup_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_DailyCompetitiveStatsRollup_Response {
    const NAME: &'static str = "CMsgGC_DailyCompetitiveStatsRollup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.rankdata.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.rankdata {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.rankdata {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_DailyCompetitiveStatsRollup_Response {
        CMsgGC_DailyCompetitiveStatsRollup_Response::new()
    }

    fn clear(&mut self) {
        self.rankdata.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_DailyCompetitiveStatsRollup_Response {
        static instance: CMsgGC_DailyCompetitiveStatsRollup_Response = CMsgGC_DailyCompetitiveStatsRollup_Response {
            rankdata: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_DailyCompetitiveStatsRollup_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_DailyCompetitiveStatsRollup_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_DailyCompetitiveStatsRollup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_DailyCompetitiveStatsRollup_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGC_DailyCompetitiveStatsRollup_Response`
pub mod cmsg_gc_daily_competitive_stats_rollup_response {
    // @@protoc_insertion_point(message:CMsgGC_DailyCompetitiveStatsRollup_Response.RankBucketEntry)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RankBucketEntry {
        // message fields
        // @@protoc_insertion_point(field:CMsgGC_DailyCompetitiveStatsRollup_Response.RankBucketEntry.rank)
        pub rank: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_DailyCompetitiveStatsRollup_Response.RankBucketEntry.records)
        pub records: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_DailyCompetitiveStatsRollup_Response.RankBucketEntry.avg_score)
        pub avg_score: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_DailyCompetitiveStatsRollup_Response.RankBucketEntry.stdev_score)
        pub stdev_score: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_DailyCompetitiveStatsRollup_Response.RankBucketEntry.avg_kills)
        pub avg_kills: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_DailyCompetitiveStatsRollup_Response.RankBucketEntry.stdev_kills)
        pub stdev_kills: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_DailyCompetitiveStatsRollup_Response.RankBucketEntry.avg_damage)
        pub avg_damage: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_DailyCompetitiveStatsRollup_Response.RankBucketEntry.stdev_damage)
        pub stdev_damage: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_DailyCompetitiveStatsRollup_Response.RankBucketEntry.avg_healing)
        pub avg_healing: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_DailyCompetitiveStatsRollup_Response.RankBucketEntry.stdev_healing)
        pub stdev_healing: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_DailyCompetitiveStatsRollup_Response.RankBucketEntry.avg_support)
        pub avg_support: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_DailyCompetitiveStatsRollup_Response.RankBucketEntry.stdev_support)
        pub stdev_support: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGC_DailyCompetitiveStatsRollup_Response.RankBucketEntry.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RankBucketEntry {
        fn default() -> &'a RankBucketEntry {
            <RankBucketEntry as ::protobuf::Message>::default_instance()
        }
    }

    impl RankBucketEntry {
        pub fn new() -> RankBucketEntry {
            ::std::default::Default::default()
        }

        // optional uint32 rank = 1;

        pub fn rank(&self) -> u32 {
            self.rank.unwrap_or(0)
        }

        pub fn clear_rank(&mut self) {
            self.rank = ::std::option::Option::None;
        }

        pub fn has_rank(&self) -> bool {
            self.rank.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank(&mut self, v: u32) {
            self.rank = ::std::option::Option::Some(v);
        }

        // optional uint32 records = 2;

        pub fn records(&self) -> u32 {
            self.records.unwrap_or(0)
        }

        pub fn clear_records(&mut self) {
            self.records = ::std::option::Option::None;
        }

        pub fn has_records(&self) -> bool {
            self.records.is_some()
        }

        // Param is passed by value, moved
        pub fn set_records(&mut self, v: u32) {
            self.records = ::std::option::Option::Some(v);
        }

        // optional uint32 avg_score = 3;

        pub fn avg_score(&self) -> u32 {
            self.avg_score.unwrap_or(0)
        }

        pub fn clear_avg_score(&mut self) {
            self.avg_score = ::std::option::Option::None;
        }

        pub fn has_avg_score(&self) -> bool {
            self.avg_score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avg_score(&mut self, v: u32) {
            self.avg_score = ::std::option::Option::Some(v);
        }

        // optional uint32 stdev_score = 4;

        pub fn stdev_score(&self) -> u32 {
            self.stdev_score.unwrap_or(0)
        }

        pub fn clear_stdev_score(&mut self) {
            self.stdev_score = ::std::option::Option::None;
        }

        pub fn has_stdev_score(&self) -> bool {
            self.stdev_score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stdev_score(&mut self, v: u32) {
            self.stdev_score = ::std::option::Option::Some(v);
        }

        // optional uint32 avg_kills = 5;

        pub fn avg_kills(&self) -> u32 {
            self.avg_kills.unwrap_or(0)
        }

        pub fn clear_avg_kills(&mut self) {
            self.avg_kills = ::std::option::Option::None;
        }

        pub fn has_avg_kills(&self) -> bool {
            self.avg_kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avg_kills(&mut self, v: u32) {
            self.avg_kills = ::std::option::Option::Some(v);
        }

        // optional uint32 stdev_kills = 6;

        pub fn stdev_kills(&self) -> u32 {
            self.stdev_kills.unwrap_or(0)
        }

        pub fn clear_stdev_kills(&mut self) {
            self.stdev_kills = ::std::option::Option::None;
        }

        pub fn has_stdev_kills(&self) -> bool {
            self.stdev_kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stdev_kills(&mut self, v: u32) {
            self.stdev_kills = ::std::option::Option::Some(v);
        }

        // optional uint32 avg_damage = 7;

        pub fn avg_damage(&self) -> u32 {
            self.avg_damage.unwrap_or(0)
        }

        pub fn clear_avg_damage(&mut self) {
            self.avg_damage = ::std::option::Option::None;
        }

        pub fn has_avg_damage(&self) -> bool {
            self.avg_damage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avg_damage(&mut self, v: u32) {
            self.avg_damage = ::std::option::Option::Some(v);
        }

        // optional uint32 stdev_damage = 8;

        pub fn stdev_damage(&self) -> u32 {
            self.stdev_damage.unwrap_or(0)
        }

        pub fn clear_stdev_damage(&mut self) {
            self.stdev_damage = ::std::option::Option::None;
        }

        pub fn has_stdev_damage(&self) -> bool {
            self.stdev_damage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stdev_damage(&mut self, v: u32) {
            self.stdev_damage = ::std::option::Option::Some(v);
        }

        // optional uint32 avg_healing = 9;

        pub fn avg_healing(&self) -> u32 {
            self.avg_healing.unwrap_or(0)
        }

        pub fn clear_avg_healing(&mut self) {
            self.avg_healing = ::std::option::Option::None;
        }

        pub fn has_avg_healing(&self) -> bool {
            self.avg_healing.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avg_healing(&mut self, v: u32) {
            self.avg_healing = ::std::option::Option::Some(v);
        }

        // optional uint32 stdev_healing = 10;

        pub fn stdev_healing(&self) -> u32 {
            self.stdev_healing.unwrap_or(0)
        }

        pub fn clear_stdev_healing(&mut self) {
            self.stdev_healing = ::std::option::Option::None;
        }

        pub fn has_stdev_healing(&self) -> bool {
            self.stdev_healing.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stdev_healing(&mut self, v: u32) {
            self.stdev_healing = ::std::option::Option::Some(v);
        }

        // optional uint32 avg_support = 11;

        pub fn avg_support(&self) -> u32 {
            self.avg_support.unwrap_or(0)
        }

        pub fn clear_avg_support(&mut self) {
            self.avg_support = ::std::option::Option::None;
        }

        pub fn has_avg_support(&self) -> bool {
            self.avg_support.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avg_support(&mut self, v: u32) {
            self.avg_support = ::std::option::Option::Some(v);
        }

        // optional uint32 stdev_support = 12;

        pub fn stdev_support(&self) -> u32 {
            self.stdev_support.unwrap_or(0)
        }

        pub fn clear_stdev_support(&mut self) {
            self.stdev_support = ::std::option::Option::None;
        }

        pub fn has_stdev_support(&self) -> bool {
            self.stdev_support.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stdev_support(&mut self, v: u32) {
            self.stdev_support = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(12);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rank",
                |m: &RankBucketEntry| { &m.rank },
                |m: &mut RankBucketEntry| { &mut m.rank },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "records",
                |m: &RankBucketEntry| { &m.records },
                |m: &mut RankBucketEntry| { &mut m.records },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "avg_score",
                |m: &RankBucketEntry| { &m.avg_score },
                |m: &mut RankBucketEntry| { &mut m.avg_score },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "stdev_score",
                |m: &RankBucketEntry| { &m.stdev_score },
                |m: &mut RankBucketEntry| { &mut m.stdev_score },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "avg_kills",
                |m: &RankBucketEntry| { &m.avg_kills },
                |m: &mut RankBucketEntry| { &mut m.avg_kills },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "stdev_kills",
                |m: &RankBucketEntry| { &m.stdev_kills },
                |m: &mut RankBucketEntry| { &mut m.stdev_kills },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "avg_damage",
                |m: &RankBucketEntry| { &m.avg_damage },
                |m: &mut RankBucketEntry| { &mut m.avg_damage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "stdev_damage",
                |m: &RankBucketEntry| { &m.stdev_damage },
                |m: &mut RankBucketEntry| { &mut m.stdev_damage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "avg_healing",
                |m: &RankBucketEntry| { &m.avg_healing },
                |m: &mut RankBucketEntry| { &mut m.avg_healing },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "stdev_healing",
                |m: &RankBucketEntry| { &m.stdev_healing },
                |m: &mut RankBucketEntry| { &mut m.stdev_healing },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "avg_support",
                |m: &RankBucketEntry| { &m.avg_support },
                |m: &mut RankBucketEntry| { &mut m.avg_support },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "stdev_support",
                |m: &RankBucketEntry| { &m.stdev_support },
                |m: &mut RankBucketEntry| { &mut m.stdev_support },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RankBucketEntry>(
                "CMsgGC_DailyCompetitiveStatsRollup_Response.RankBucketEntry",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RankBucketEntry {
        const NAME: &'static str = "RankBucketEntry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.rank = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.records = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.avg_score = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.stdev_score = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.avg_kills = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.stdev_kills = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.avg_damage = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.stdev_damage = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    72 => {
                        self.avg_healing = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.stdev_healing = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    88 => {
                        self.avg_support = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    96 => {
                        self.stdev_support = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.rank {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.records {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.avg_score {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.stdev_score {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.avg_kills {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.stdev_kills {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.avg_damage {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.stdev_damage {
                my_size += ::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.avg_healing {
                my_size += ::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.stdev_healing {
                my_size += ::protobuf::rt::uint32_size(10, v);
            }
            if let Some(v) = self.avg_support {
                my_size += ::protobuf::rt::uint32_size(11, v);
            }
            if let Some(v) = self.stdev_support {
                my_size += ::protobuf::rt::uint32_size(12, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.rank {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.records {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.avg_score {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.stdev_score {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.avg_kills {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.stdev_kills {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.avg_damage {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.stdev_damage {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.avg_healing {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.stdev_healing {
                os.write_uint32(10, v)?;
            }
            if let Some(v) = self.avg_support {
                os.write_uint32(11, v)?;
            }
            if let Some(v) = self.stdev_support {
                os.write_uint32(12, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RankBucketEntry {
            RankBucketEntry::new()
        }

        fn clear(&mut self) {
            self.rank = ::std::option::Option::None;
            self.records = ::std::option::Option::None;
            self.avg_score = ::std::option::Option::None;
            self.stdev_score = ::std::option::Option::None;
            self.avg_kills = ::std::option::Option::None;
            self.stdev_kills = ::std::option::Option::None;
            self.avg_damage = ::std::option::Option::None;
            self.stdev_damage = ::std::option::Option::None;
            self.avg_healing = ::std::option::Option::None;
            self.stdev_healing = ::std::option::Option::None;
            self.avg_support = ::std::option::Option::None;
            self.stdev_support = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RankBucketEntry {
            static instance: RankBucketEntry = RankBucketEntry {
                rank: ::std::option::Option::None,
                records: ::std::option::Option::None,
                avg_score: ::std::option::Option::None,
                stdev_score: ::std::option::Option::None,
                avg_kills: ::std::option::Option::None,
                stdev_kills: ::std::option::Option::None,
                avg_damage: ::std::option::Option::None,
                stdev_damage: ::std::option::Option::None,
                avg_healing: ::std::option::Option::None,
                stdev_healing: ::std::option::Option::None,
                avg_support: ::std::option::Option::None,
                stdev_support: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RankBucketEntry {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGC_DailyCompetitiveStatsRollup_Response.RankBucketEntry").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RankBucketEntry {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RankBucketEntry {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgGC_ReportPlayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_ReportPlayer {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_ReportPlayer.account_id_target)
    pub account_id_target: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGC_ReportPlayer.reason)
    pub reason: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_gc_report_player::EReason>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_ReportPlayer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_ReportPlayer {
    fn default() -> &'a CMsgGC_ReportPlayer {
        <CMsgGC_ReportPlayer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_ReportPlayer {
    pub fn new() -> CMsgGC_ReportPlayer {
        ::std::default::Default::default()
    }

    // optional uint32 account_id_target = 1;

    pub fn account_id_target(&self) -> u32 {
        self.account_id_target.unwrap_or(0)
    }

    pub fn clear_account_id_target(&mut self) {
        self.account_id_target = ::std::option::Option::None;
    }

    pub fn has_account_id_target(&self) -> bool {
        self.account_id_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id_target(&mut self, v: u32) {
        self.account_id_target = ::std::option::Option::Some(v);
    }

    // optional .CMsgGC_ReportPlayer.EReason reason = 2;

    pub fn reason(&self) -> cmsg_gc_report_player::EReason {
        match self.reason {
            Some(e) => e.enum_value_or(cmsg_gc_report_player::EReason::kReason_INVALID),
            None => cmsg_gc_report_player::EReason::kReason_INVALID,
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: cmsg_gc_report_player::EReason) {
        self.reason = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id_target",
            |m: &CMsgGC_ReportPlayer| { &m.account_id_target },
            |m: &mut CMsgGC_ReportPlayer| { &mut m.account_id_target },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &CMsgGC_ReportPlayer| { &m.reason },
            |m: &mut CMsgGC_ReportPlayer| { &mut m.reason },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_ReportPlayer>(
            "CMsgGC_ReportPlayer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_ReportPlayer {
    const NAME: &'static str = "CMsgGC_ReportPlayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id_target = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.reason = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id_target {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id_target {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.reason {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_ReportPlayer {
        CMsgGC_ReportPlayer::new()
    }

    fn clear(&mut self) {
        self.account_id_target = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_ReportPlayer {
        static instance: CMsgGC_ReportPlayer = CMsgGC_ReportPlayer {
            account_id_target: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_ReportPlayer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_ReportPlayer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_ReportPlayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_ReportPlayer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGC_ReportPlayer`
pub mod cmsg_gc_report_player {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGC_ReportPlayer.EReason)
    pub enum EReason {
        // @@protoc_insertion_point(enum_value:CMsgGC_ReportPlayer.EReason.kReason_INVALID)
        kReason_INVALID = 0,
        // @@protoc_insertion_point(enum_value:CMsgGC_ReportPlayer.EReason.kReason_CHEATING)
        kReason_CHEATING = 1,
        // @@protoc_insertion_point(enum_value:CMsgGC_ReportPlayer.EReason.kReason_IDLE)
        kReason_IDLE = 2,
        // @@protoc_insertion_point(enum_value:CMsgGC_ReportPlayer.EReason.kReason_HARASSMENT)
        kReason_HARASSMENT = 3,
        // @@protoc_insertion_point(enum_value:CMsgGC_ReportPlayer.EReason.kReason_GRIEFING)
        kReason_GRIEFING = 4,
        // @@protoc_insertion_point(enum_value:CMsgGC_ReportPlayer.EReason.kReason_COUNT)
        kReason_COUNT = 5,
    }

    impl ::protobuf::Enum for EReason {
        const NAME: &'static str = "EReason";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EReason> {
            match value {
                0 => ::std::option::Option::Some(EReason::kReason_INVALID),
                1 => ::std::option::Option::Some(EReason::kReason_CHEATING),
                2 => ::std::option::Option::Some(EReason::kReason_IDLE),
                3 => ::std::option::Option::Some(EReason::kReason_HARASSMENT),
                4 => ::std::option::Option::Some(EReason::kReason_GRIEFING),
                5 => ::std::option::Option::Some(EReason::kReason_COUNT),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EReason> {
            match str {
                "kReason_INVALID" => ::std::option::Option::Some(EReason::kReason_INVALID),
                "kReason_CHEATING" => ::std::option::Option::Some(EReason::kReason_CHEATING),
                "kReason_IDLE" => ::std::option::Option::Some(EReason::kReason_IDLE),
                "kReason_HARASSMENT" => ::std::option::Option::Some(EReason::kReason_HARASSMENT),
                "kReason_GRIEFING" => ::std::option::Option::Some(EReason::kReason_GRIEFING),
                "kReason_COUNT" => ::std::option::Option::Some(EReason::kReason_COUNT),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EReason] = &[
            EReason::kReason_INVALID,
            EReason::kReason_CHEATING,
            EReason::kReason_IDLE,
            EReason::kReason_HARASSMENT,
            EReason::kReason_GRIEFING,
            EReason::kReason_COUNT,
        ];
    }

    impl ::protobuf::EnumFull for EReason {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgGC_ReportPlayer.EReason").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EReason {
        fn default() -> Self {
            EReason::kReason_INVALID
        }
    }

    impl EReason {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EReason>("CMsgGC_ReportPlayer.EReason")
        }
    }
}

// @@protoc_insertion_point(message:CSOTFMatchResultPlayerStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOTFMatchResultPlayerStats {
    // message fields
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.match_group)
    pub match_group: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.endtime)
    pub endtime: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.season_id)
    pub season_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.status)
    pub status: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.original_party_id)
    pub original_party_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.team)
    pub team: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.score)
    pub score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.ping)
    pub ping: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.display_rating)
    pub display_rating: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.display_rating_change)
    pub display_rating_change: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.rank)
    pub rank: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.classes_played)
    pub classes_played: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.kills)
    pub kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.deaths)
    pub deaths: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.damage)
    pub damage: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.healing)
    pub healing: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.support)
    pub support: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.score_medal)
    pub score_medal: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.kills_medal)
    pub kills_medal: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.damage_medal)
    pub damage_medal: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.healing_medal)
    pub healing_medal: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.support_medal)
    pub support_medal: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.map_index)
    pub map_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.winning_team)
    pub winning_team: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOTFMatchResultPlayerStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOTFMatchResultPlayerStats {
    fn default() -> &'a CSOTFMatchResultPlayerStats {
        <CSOTFMatchResultPlayerStats as ::protobuf::Message>::default_instance()
    }
}

impl CSOTFMatchResultPlayerStats {
    pub fn new() -> CSOTFMatchResultPlayerStats {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id = 2;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional int32 match_group = 3;

    pub fn match_group(&self) -> i32 {
        self.match_group.unwrap_or(0)
    }

    pub fn clear_match_group(&mut self) {
        self.match_group = ::std::option::Option::None;
    }

    pub fn has_match_group(&self) -> bool {
        self.match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_group(&mut self, v: i32) {
        self.match_group = ::std::option::Option::Some(v);
    }

    // optional uint32 endtime = 4;

    pub fn endtime(&self) -> u32 {
        self.endtime.unwrap_or(0)
    }

    pub fn clear_endtime(&mut self) {
        self.endtime = ::std::option::Option::None;
    }

    pub fn has_endtime(&self) -> bool {
        self.endtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endtime(&mut self, v: u32) {
        self.endtime = ::std::option::Option::Some(v);
    }

    // optional uint32 season_id = 5;

    pub fn season_id(&self) -> u32 {
        self.season_id.unwrap_or(0)
    }

    pub fn clear_season_id(&mut self) {
        self.season_id = ::std::option::Option::None;
    }

    pub fn has_season_id(&self) -> bool {
        self.season_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_season_id(&mut self, v: u32) {
        self.season_id = ::std::option::Option::Some(v);
    }

    // optional uint32 status = 6;

    pub fn status(&self) -> u32 {
        self.status.unwrap_or(0)
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: u32) {
        self.status = ::std::option::Option::Some(v);
    }

    // optional uint32 original_party_id = 7;

    pub fn original_party_id(&self) -> u32 {
        self.original_party_id.unwrap_or(0)
    }

    pub fn clear_original_party_id(&mut self) {
        self.original_party_id = ::std::option::Option::None;
    }

    pub fn has_original_party_id(&self) -> bool {
        self.original_party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_party_id(&mut self, v: u32) {
        self.original_party_id = ::std::option::Option::Some(v);
    }

    // optional uint32 team = 8;

    pub fn team(&self) -> u32 {
        self.team.unwrap_or(0)
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: u32) {
        self.team = ::std::option::Option::Some(v);
    }

    // optional uint32 score = 9;

    pub fn score(&self) -> u32 {
        self.score.unwrap_or(0)
    }

    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: u32) {
        self.score = ::std::option::Option::Some(v);
    }

    // optional uint32 ping = 10;

    pub fn ping(&self) -> u32 {
        self.ping.unwrap_or(0)
    }

    pub fn clear_ping(&mut self) {
        self.ping = ::std::option::Option::None;
    }

    pub fn has_ping(&self) -> bool {
        self.ping.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping(&mut self, v: u32) {
        self.ping = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 11;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 display_rating = 12;

    pub fn display_rating(&self) -> u32 {
        self.display_rating.unwrap_or(0)
    }

    pub fn clear_display_rating(&mut self) {
        self.display_rating = ::std::option::Option::None;
    }

    pub fn has_display_rating(&self) -> bool {
        self.display_rating.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_rating(&mut self, v: u32) {
        self.display_rating = ::std::option::Option::Some(v);
    }

    // optional int32 display_rating_change = 13;

    pub fn display_rating_change(&self) -> i32 {
        self.display_rating_change.unwrap_or(0)
    }

    pub fn clear_display_rating_change(&mut self) {
        self.display_rating_change = ::std::option::Option::None;
    }

    pub fn has_display_rating_change(&self) -> bool {
        self.display_rating_change.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_rating_change(&mut self, v: i32) {
        self.display_rating_change = ::std::option::Option::Some(v);
    }

    // optional uint32 rank = 14;

    pub fn rank(&self) -> u32 {
        self.rank.unwrap_or(0)
    }

    pub fn clear_rank(&mut self) {
        self.rank = ::std::option::Option::None;
    }

    pub fn has_rank(&self) -> bool {
        self.rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank(&mut self, v: u32) {
        self.rank = ::std::option::Option::Some(v);
    }

    // optional uint32 classes_played = 15;

    pub fn classes_played(&self) -> u32 {
        self.classes_played.unwrap_or(0)
    }

    pub fn clear_classes_played(&mut self) {
        self.classes_played = ::std::option::Option::None;
    }

    pub fn has_classes_played(&self) -> bool {
        self.classes_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_classes_played(&mut self, v: u32) {
        self.classes_played = ::std::option::Option::Some(v);
    }

    // optional uint32 kills = 16;

    pub fn kills(&self) -> u32 {
        self.kills.unwrap_or(0)
    }

    pub fn clear_kills(&mut self) {
        self.kills = ::std::option::Option::None;
    }

    pub fn has_kills(&self) -> bool {
        self.kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills(&mut self, v: u32) {
        self.kills = ::std::option::Option::Some(v);
    }

    // optional uint32 deaths = 17;

    pub fn deaths(&self) -> u32 {
        self.deaths.unwrap_or(0)
    }

    pub fn clear_deaths(&mut self) {
        self.deaths = ::std::option::Option::None;
    }

    pub fn has_deaths(&self) -> bool {
        self.deaths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deaths(&mut self, v: u32) {
        self.deaths = ::std::option::Option::Some(v);
    }

    // optional uint32 damage = 18;

    pub fn damage(&self) -> u32 {
        self.damage.unwrap_or(0)
    }

    pub fn clear_damage(&mut self) {
        self.damage = ::std::option::Option::None;
    }

    pub fn has_damage(&self) -> bool {
        self.damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage(&mut self, v: u32) {
        self.damage = ::std::option::Option::Some(v);
    }

    // optional uint32 healing = 19;

    pub fn healing(&self) -> u32 {
        self.healing.unwrap_or(0)
    }

    pub fn clear_healing(&mut self) {
        self.healing = ::std::option::Option::None;
    }

    pub fn has_healing(&self) -> bool {
        self.healing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healing(&mut self, v: u32) {
        self.healing = ::std::option::Option::Some(v);
    }

    // optional uint32 support = 20;

    pub fn support(&self) -> u32 {
        self.support.unwrap_or(0)
    }

    pub fn clear_support(&mut self) {
        self.support = ::std::option::Option::None;
    }

    pub fn has_support(&self) -> bool {
        self.support.is_some()
    }

    // Param is passed by value, moved
    pub fn set_support(&mut self, v: u32) {
        self.support = ::std::option::Option::Some(v);
    }

    // optional uint32 score_medal = 21;

    pub fn score_medal(&self) -> u32 {
        self.score_medal.unwrap_or(0)
    }

    pub fn clear_score_medal(&mut self) {
        self.score_medal = ::std::option::Option::None;
    }

    pub fn has_score_medal(&self) -> bool {
        self.score_medal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score_medal(&mut self, v: u32) {
        self.score_medal = ::std::option::Option::Some(v);
    }

    // optional uint32 kills_medal = 22;

    pub fn kills_medal(&self) -> u32 {
        self.kills_medal.unwrap_or(0)
    }

    pub fn clear_kills_medal(&mut self) {
        self.kills_medal = ::std::option::Option::None;
    }

    pub fn has_kills_medal(&self) -> bool {
        self.kills_medal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills_medal(&mut self, v: u32) {
        self.kills_medal = ::std::option::Option::Some(v);
    }

    // optional uint32 damage_medal = 23;

    pub fn damage_medal(&self) -> u32 {
        self.damage_medal.unwrap_or(0)
    }

    pub fn clear_damage_medal(&mut self) {
        self.damage_medal = ::std::option::Option::None;
    }

    pub fn has_damage_medal(&self) -> bool {
        self.damage_medal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_medal(&mut self, v: u32) {
        self.damage_medal = ::std::option::Option::Some(v);
    }

    // optional uint32 healing_medal = 24;

    pub fn healing_medal(&self) -> u32 {
        self.healing_medal.unwrap_or(0)
    }

    pub fn clear_healing_medal(&mut self) {
        self.healing_medal = ::std::option::Option::None;
    }

    pub fn has_healing_medal(&self) -> bool {
        self.healing_medal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healing_medal(&mut self, v: u32) {
        self.healing_medal = ::std::option::Option::Some(v);
    }

    // optional uint32 support_medal = 25;

    pub fn support_medal(&self) -> u32 {
        self.support_medal.unwrap_or(0)
    }

    pub fn clear_support_medal(&mut self) {
        self.support_medal = ::std::option::Option::None;
    }

    pub fn has_support_medal(&self) -> bool {
        self.support_medal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_support_medal(&mut self, v: u32) {
        self.support_medal = ::std::option::Option::Some(v);
    }

    // optional uint32 map_index = 26;

    pub fn map_index(&self) -> u32 {
        self.map_index.unwrap_or(0)
    }

    pub fn clear_map_index(&mut self) {
        self.map_index = ::std::option::Option::None;
    }

    pub fn has_map_index(&self) -> bool {
        self.map_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_index(&mut self, v: u32) {
        self.map_index = ::std::option::Option::Some(v);
    }

    // optional uint32 winning_team = 27;

    pub fn winning_team(&self) -> u32 {
        self.winning_team.unwrap_or(0)
    }

    pub fn clear_winning_team(&mut self) {
        self.winning_team = ::std::option::Option::None;
    }

    pub fn has_winning_team(&self) -> bool {
        self.winning_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_winning_team(&mut self, v: u32) {
        self.winning_team = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(27);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CSOTFMatchResultPlayerStats| { &m.match_id },
            |m: &mut CSOTFMatchResultPlayerStats| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CSOTFMatchResultPlayerStats| { &m.account_id },
            |m: &mut CSOTFMatchResultPlayerStats| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_group",
            |m: &CSOTFMatchResultPlayerStats| { &m.match_group },
            |m: &mut CSOTFMatchResultPlayerStats| { &mut m.match_group },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "endtime",
            |m: &CSOTFMatchResultPlayerStats| { &m.endtime },
            |m: &mut CSOTFMatchResultPlayerStats| { &mut m.endtime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "season_id",
            |m: &CSOTFMatchResultPlayerStats| { &m.season_id },
            |m: &mut CSOTFMatchResultPlayerStats| { &mut m.season_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &CSOTFMatchResultPlayerStats| { &m.status },
            |m: &mut CSOTFMatchResultPlayerStats| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "original_party_id",
            |m: &CSOTFMatchResultPlayerStats| { &m.original_party_id },
            |m: &mut CSOTFMatchResultPlayerStats| { &mut m.original_party_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team",
            |m: &CSOTFMatchResultPlayerStats| { &m.team },
            |m: &mut CSOTFMatchResultPlayerStats| { &mut m.team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "score",
            |m: &CSOTFMatchResultPlayerStats| { &m.score },
            |m: &mut CSOTFMatchResultPlayerStats| { &mut m.score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ping",
            |m: &CSOTFMatchResultPlayerStats| { &m.ping },
            |m: &mut CSOTFMatchResultPlayerStats| { &mut m.ping },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CSOTFMatchResultPlayerStats| { &m.flags },
            |m: &mut CSOTFMatchResultPlayerStats| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_rating",
            |m: &CSOTFMatchResultPlayerStats| { &m.display_rating },
            |m: &mut CSOTFMatchResultPlayerStats| { &mut m.display_rating },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_rating_change",
            |m: &CSOTFMatchResultPlayerStats| { &m.display_rating_change },
            |m: &mut CSOTFMatchResultPlayerStats| { &mut m.display_rating_change },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rank",
            |m: &CSOTFMatchResultPlayerStats| { &m.rank },
            |m: &mut CSOTFMatchResultPlayerStats| { &mut m.rank },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "classes_played",
            |m: &CSOTFMatchResultPlayerStats| { &m.classes_played },
            |m: &mut CSOTFMatchResultPlayerStats| { &mut m.classes_played },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kills",
            |m: &CSOTFMatchResultPlayerStats| { &m.kills },
            |m: &mut CSOTFMatchResultPlayerStats| { &mut m.kills },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deaths",
            |m: &CSOTFMatchResultPlayerStats| { &m.deaths },
            |m: &mut CSOTFMatchResultPlayerStats| { &mut m.deaths },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "damage",
            |m: &CSOTFMatchResultPlayerStats| { &m.damage },
            |m: &mut CSOTFMatchResultPlayerStats| { &mut m.damage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "healing",
            |m: &CSOTFMatchResultPlayerStats| { &m.healing },
            |m: &mut CSOTFMatchResultPlayerStats| { &mut m.healing },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "support",
            |m: &CSOTFMatchResultPlayerStats| { &m.support },
            |m: &mut CSOTFMatchResultPlayerStats| { &mut m.support },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "score_medal",
            |m: &CSOTFMatchResultPlayerStats| { &m.score_medal },
            |m: &mut CSOTFMatchResultPlayerStats| { &mut m.score_medal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kills_medal",
            |m: &CSOTFMatchResultPlayerStats| { &m.kills_medal },
            |m: &mut CSOTFMatchResultPlayerStats| { &mut m.kills_medal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "damage_medal",
            |m: &CSOTFMatchResultPlayerStats| { &m.damage_medal },
            |m: &mut CSOTFMatchResultPlayerStats| { &mut m.damage_medal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "healing_medal",
            |m: &CSOTFMatchResultPlayerStats| { &m.healing_medal },
            |m: &mut CSOTFMatchResultPlayerStats| { &mut m.healing_medal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "support_medal",
            |m: &CSOTFMatchResultPlayerStats| { &m.support_medal },
            |m: &mut CSOTFMatchResultPlayerStats| { &mut m.support_medal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map_index",
            |m: &CSOTFMatchResultPlayerStats| { &m.map_index },
            |m: &mut CSOTFMatchResultPlayerStats| { &mut m.map_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "winning_team",
            |m: &CSOTFMatchResultPlayerStats| { &m.winning_team },
            |m: &mut CSOTFMatchResultPlayerStats| { &mut m.winning_team },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOTFMatchResultPlayerStats>(
            "CSOTFMatchResultPlayerStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOTFMatchResultPlayerStats {
    const NAME: &'static str = "CSOTFMatchResultPlayerStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.match_group = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.endtime = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.season_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.status = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.original_party_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.team = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.score = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.ping = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.display_rating = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.display_rating_change = ::std::option::Option::Some(is.read_int32()?);
                },
                112 => {
                    self.rank = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.classes_played = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.deaths = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.damage = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.healing = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.support = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.score_medal = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.kills_medal = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.damage_medal = ::std::option::Option::Some(is.read_uint32()?);
                },
                192 => {
                    self.healing_medal = ::std::option::Option::Some(is.read_uint32()?);
                },
                200 => {
                    self.support_medal = ::std::option::Option::Some(is.read_uint32()?);
                },
                208 => {
                    self.map_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                216 => {
                    self.winning_team = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.match_group {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.endtime {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.season_id {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.original_party_id {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.ping {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.display_rating {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.display_rating_change {
            my_size += ::protobuf::rt::int32_size(13, v);
        }
        if let Some(v) = self.rank {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.classes_played {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.kills {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.deaths {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.damage {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.healing {
            my_size += ::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.support {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.score_medal {
            my_size += ::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.kills_medal {
            my_size += ::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.damage_medal {
            my_size += ::protobuf::rt::uint32_size(23, v);
        }
        if let Some(v) = self.healing_medal {
            my_size += ::protobuf::rt::uint32_size(24, v);
        }
        if let Some(v) = self.support_medal {
            my_size += ::protobuf::rt::uint32_size(25, v);
        }
        if let Some(v) = self.map_index {
            my_size += ::protobuf::rt::uint32_size(26, v);
        }
        if let Some(v) = self.winning_team {
            my_size += ::protobuf::rt::uint32_size(27, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.match_group {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.endtime {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.season_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.status {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.original_party_id {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.team {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.score {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.ping {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.display_rating {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.display_rating_change {
            os.write_int32(13, v)?;
        }
        if let Some(v) = self.rank {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.classes_played {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.kills {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.deaths {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.damage {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.healing {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.support {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.score_medal {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.kills_medal {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.damage_medal {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.healing_medal {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.support_medal {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.map_index {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.winning_team {
            os.write_uint32(27, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOTFMatchResultPlayerStats {
        CSOTFMatchResultPlayerStats::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.match_group = ::std::option::Option::None;
        self.endtime = ::std::option::Option::None;
        self.season_id = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.original_party_id = ::std::option::Option::None;
        self.team = ::std::option::Option::None;
        self.score = ::std::option::Option::None;
        self.ping = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.display_rating = ::std::option::Option::None;
        self.display_rating_change = ::std::option::Option::None;
        self.rank = ::std::option::Option::None;
        self.classes_played = ::std::option::Option::None;
        self.kills = ::std::option::Option::None;
        self.deaths = ::std::option::Option::None;
        self.damage = ::std::option::Option::None;
        self.healing = ::std::option::Option::None;
        self.support = ::std::option::Option::None;
        self.score_medal = ::std::option::Option::None;
        self.kills_medal = ::std::option::Option::None;
        self.damage_medal = ::std::option::Option::None;
        self.healing_medal = ::std::option::Option::None;
        self.support_medal = ::std::option::Option::None;
        self.map_index = ::std::option::Option::None;
        self.winning_team = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOTFMatchResultPlayerStats {
        static instance: CSOTFMatchResultPlayerStats = CSOTFMatchResultPlayerStats {
            match_id: ::std::option::Option::None,
            account_id: ::std::option::Option::None,
            match_group: ::std::option::Option::None,
            endtime: ::std::option::Option::None,
            season_id: ::std::option::Option::None,
            status: ::std::option::Option::None,
            original_party_id: ::std::option::Option::None,
            team: ::std::option::Option::None,
            score: ::std::option::Option::None,
            ping: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            display_rating: ::std::option::Option::None,
            display_rating_change: ::std::option::Option::None,
            rank: ::std::option::Option::None,
            classes_played: ::std::option::Option::None,
            kills: ::std::option::Option::None,
            deaths: ::std::option::Option::None,
            damage: ::std::option::Option::None,
            healing: ::std::option::Option::None,
            support: ::std::option::Option::None,
            score_medal: ::std::option::Option::None,
            kills_medal: ::std::option::Option::None,
            damage_medal: ::std::option::Option::None,
            healing_medal: ::std::option::Option::None,
            support_medal: ::std::option::Option::None,
            map_index: ::std::option::Option::None,
            winning_team: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOTFMatchResultPlayerStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOTFMatchResultPlayerStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOTFMatchResultPlayerStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOTFMatchResultPlayerStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCRequestMatchMakerStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCRequestMatchMakerStats {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCRequestMatchMakerStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCRequestMatchMakerStats {
    fn default() -> &'a CMsgGCRequestMatchMakerStats {
        <CMsgGCRequestMatchMakerStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRequestMatchMakerStats {
    pub fn new() -> CMsgGCRequestMatchMakerStats {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCRequestMatchMakerStats>(
            "CMsgGCRequestMatchMakerStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCRequestMatchMakerStats {
    const NAME: &'static str = "CMsgGCRequestMatchMakerStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCRequestMatchMakerStats {
        CMsgGCRequestMatchMakerStats::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCRequestMatchMakerStats {
        static instance: CMsgGCRequestMatchMakerStats = CMsgGCRequestMatchMakerStats {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCRequestMatchMakerStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCRequestMatchMakerStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCRequestMatchMakerStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCRequestMatchMakerStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCDataCenterPopulation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCDataCenterPopulation {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCDataCenterPopulation.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCDataCenterPopulation.health_ratio)
    pub health_ratio: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCDataCenterPopulation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCDataCenterPopulation {
    fn default() -> &'a CMsgGCDataCenterPopulation {
        <CMsgGCDataCenterPopulation as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCDataCenterPopulation {
    pub fn new() -> CMsgGCDataCenterPopulation {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float health_ratio = 2;

    pub fn health_ratio(&self) -> f32 {
        self.health_ratio.unwrap_or(0.)
    }

    pub fn clear_health_ratio(&mut self) {
        self.health_ratio = ::std::option::Option::None;
    }

    pub fn has_health_ratio(&self) -> bool {
        self.health_ratio.is_some()
    }

    // Param is passed by value, moved
    pub fn set_health_ratio(&mut self, v: f32) {
        self.health_ratio = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgGCDataCenterPopulation| { &m.name },
            |m: &mut CMsgGCDataCenterPopulation| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "health_ratio",
            |m: &CMsgGCDataCenterPopulation| { &m.health_ratio },
            |m: &mut CMsgGCDataCenterPopulation| { &mut m.health_ratio },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCDataCenterPopulation>(
            "CMsgGCDataCenterPopulation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCDataCenterPopulation {
    const NAME: &'static str = "CMsgGCDataCenterPopulation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                21 => {
                    self.health_ratio = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.health_ratio {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.health_ratio {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCDataCenterPopulation {
        CMsgGCDataCenterPopulation::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.health_ratio = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCDataCenterPopulation {
        static instance: CMsgGCDataCenterPopulation = CMsgGCDataCenterPopulation {
            name: ::std::option::Option::None,
            health_ratio: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCDataCenterPopulation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCDataCenterPopulation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCDataCenterPopulation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCDataCenterPopulation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCMatchGroupDataCenterPopulation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCMatchGroupDataCenterPopulation {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCMatchGroupDataCenterPopulation.data_center_population)
    pub data_center_population: ::std::vec::Vec<CMsgGCDataCenterPopulation>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCMatchGroupDataCenterPopulation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCMatchGroupDataCenterPopulation {
    fn default() -> &'a CMsgGCMatchGroupDataCenterPopulation {
        <CMsgGCMatchGroupDataCenterPopulation as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCMatchGroupDataCenterPopulation {
    pub fn new() -> CMsgGCMatchGroupDataCenterPopulation {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data_center_population",
            |m: &CMsgGCMatchGroupDataCenterPopulation| { &m.data_center_population },
            |m: &mut CMsgGCMatchGroupDataCenterPopulation| { &mut m.data_center_population },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCMatchGroupDataCenterPopulation>(
            "CMsgGCMatchGroupDataCenterPopulation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCMatchGroupDataCenterPopulation {
    const NAME: &'static str = "CMsgGCMatchGroupDataCenterPopulation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data_center_population.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.data_center_population {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.data_center_population {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCMatchGroupDataCenterPopulation {
        CMsgGCMatchGroupDataCenterPopulation::new()
    }

    fn clear(&mut self) {
        self.data_center_population.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCMatchGroupDataCenterPopulation {
        static instance: CMsgGCMatchGroupDataCenterPopulation = CMsgGCMatchGroupDataCenterPopulation {
            data_center_population: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCMatchGroupDataCenterPopulation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCMatchGroupDataCenterPopulation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCMatchGroupDataCenterPopulation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCMatchGroupDataCenterPopulation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCMatchMakerStatsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCMatchMakerStatsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCMatchMakerStatsResponse.map_count)
    pub map_count: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCMatchMakerStatsResponse.matchgroup_data_center_population)
    pub matchgroup_data_center_population: ::std::vec::Vec<CMsgGCMatchGroupDataCenterPopulation>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCMatchMakerStatsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCMatchMakerStatsResponse {
    fn default() -> &'a CMsgGCMatchMakerStatsResponse {
        <CMsgGCMatchMakerStatsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCMatchMakerStatsResponse {
    pub fn new() -> CMsgGCMatchMakerStatsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "map_count",
            |m: &CMsgGCMatchMakerStatsResponse| { &m.map_count },
            |m: &mut CMsgGCMatchMakerStatsResponse| { &mut m.map_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "matchgroup_data_center_population",
            |m: &CMsgGCMatchMakerStatsResponse| { &m.matchgroup_data_center_population },
            |m: &mut CMsgGCMatchMakerStatsResponse| { &mut m.matchgroup_data_center_population },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCMatchMakerStatsResponse>(
            "CMsgGCMatchMakerStatsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCMatchMakerStatsResponse {
    const NAME: &'static str = "CMsgGCMatchMakerStatsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.map_count)?;
                },
                8 => {
                    self.map_count.push(is.read_uint32()?);
                },
                18 => {
                    self.matchgroup_data_center_population.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.map_count {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        for value in &self.matchgroup_data_center_population {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.map_count {
            os.write_uint32(1, *v)?;
        };
        for v in &self.matchgroup_data_center_population {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCMatchMakerStatsResponse {
        CMsgGCMatchMakerStatsResponse::new()
    }

    fn clear(&mut self) {
        self.map_count.clear();
        self.matchgroup_data_center_population.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCMatchMakerStatsResponse {
        static instance: CMsgGCMatchMakerStatsResponse = CMsgGCMatchMakerStatsResponse {
            map_count: ::std::vec::Vec::new(),
            matchgroup_data_center_population: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCMatchMakerStatsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCMatchMakerStatsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCMatchMakerStatsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCMatchMakerStatsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCMatchHistoryLoad)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCMatchHistoryLoad {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCMatchHistoryLoad.match_group)
    pub match_group: ::std::option::Option<::protobuf::EnumOrUnknown<ETFMatchGroup>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCMatchHistoryLoad.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCMatchHistoryLoad {
    fn default() -> &'a CMsgGCMatchHistoryLoad {
        <CMsgGCMatchHistoryLoad as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCMatchHistoryLoad {
    pub fn new() -> CMsgGCMatchHistoryLoad {
        ::std::default::Default::default()
    }

    // optional .ETFMatchGroup match_group = 1;

    pub fn match_group(&self) -> ETFMatchGroup {
        match self.match_group {
            Some(e) => e.enum_value_or(ETFMatchGroup::k_eTFMatchGroup_Invalid),
            None => ETFMatchGroup::k_eTFMatchGroup_Invalid,
        }
    }

    pub fn clear_match_group(&mut self) {
        self.match_group = ::std::option::Option::None;
    }

    pub fn has_match_group(&self) -> bool {
        self.match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_group(&mut self, v: ETFMatchGroup) {
        self.match_group = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_group",
            |m: &CMsgGCMatchHistoryLoad| { &m.match_group },
            |m: &mut CMsgGCMatchHistoryLoad| { &mut m.match_group },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCMatchHistoryLoad>(
            "CMsgGCMatchHistoryLoad",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCMatchHistoryLoad {
    const NAME: &'static str = "CMsgGCMatchHistoryLoad";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_group = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_group {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.match_group {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCMatchHistoryLoad {
        CMsgGCMatchHistoryLoad::new()
    }

    fn clear(&mut self) {
        self.match_group = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCMatchHistoryLoad {
        static instance: CMsgGCMatchHistoryLoad = CMsgGCMatchHistoryLoad {
            match_group: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCMatchHistoryLoad {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCMatchHistoryLoad").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCMatchHistoryLoad {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCMatchHistoryLoad {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCDataCenterPing_Update)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCDataCenterPing_Update {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCDataCenterPing_Update.pingdata)
    pub pingdata: ::std::vec::Vec<cmsg_gcdata_center_ping_update::PingEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCDataCenterPing_Update.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCDataCenterPing_Update {
    fn default() -> &'a CMsgGCDataCenterPing_Update {
        <CMsgGCDataCenterPing_Update as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCDataCenterPing_Update {
    pub fn new() -> CMsgGCDataCenterPing_Update {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pingdata",
            |m: &CMsgGCDataCenterPing_Update| { &m.pingdata },
            |m: &mut CMsgGCDataCenterPing_Update| { &mut m.pingdata },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCDataCenterPing_Update>(
            "CMsgGCDataCenterPing_Update",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCDataCenterPing_Update {
    const NAME: &'static str = "CMsgGCDataCenterPing_Update";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.pingdata.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.pingdata {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.pingdata {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCDataCenterPing_Update {
        CMsgGCDataCenterPing_Update::new()
    }

    fn clear(&mut self) {
        self.pingdata.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCDataCenterPing_Update {
        static instance: CMsgGCDataCenterPing_Update = CMsgGCDataCenterPing_Update {
            pingdata: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCDataCenterPing_Update {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCDataCenterPing_Update").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCDataCenterPing_Update {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCDataCenterPing_Update {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGCDataCenterPing_Update`
pub mod cmsg_gcdata_center_ping_update {
    // @@protoc_insertion_point(message:CMsgGCDataCenterPing_Update.PingEntry)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PingEntry {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCDataCenterPing_Update.PingEntry.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGCDataCenterPing_Update.PingEntry.ping)
        pub ping: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCDataCenterPing_Update.PingEntry.ping_status)
        pub ping_status: ::std::option::Option<::protobuf::EnumOrUnknown<Status>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCDataCenterPing_Update.PingEntry.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PingEntry {
        fn default() -> &'a PingEntry {
            <PingEntry as ::protobuf::Message>::default_instance()
        }
    }

    impl PingEntry {
        pub fn new() -> PingEntry {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 ping = 2;

        pub fn ping(&self) -> u32 {
            self.ping.unwrap_or(0)
        }

        pub fn clear_ping(&mut self) {
            self.ping = ::std::option::Option::None;
        }

        pub fn has_ping(&self) -> bool {
            self.ping.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ping(&mut self, v: u32) {
            self.ping = ::std::option::Option::Some(v);
        }

        // optional .CMsgGCDataCenterPing_Update.Status ping_status = 3;

        pub fn ping_status(&self) -> Status {
            match self.ping_status {
                Some(e) => e.enum_value_or(Status::Normal),
                None => Status::Normal,
            }
        }

        pub fn clear_ping_status(&mut self) {
            self.ping_status = ::std::option::Option::None;
        }

        pub fn has_ping_status(&self) -> bool {
            self.ping_status.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ping_status(&mut self, v: Status) {
            self.ping_status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &PingEntry| { &m.name },
                |m: &mut PingEntry| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ping",
                |m: &PingEntry| { &m.ping },
                |m: &mut PingEntry| { &mut m.ping },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ping_status",
                |m: &PingEntry| { &m.ping_status },
                |m: &mut PingEntry| { &mut m.ping_status },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PingEntry>(
                "CMsgGCDataCenterPing_Update.PingEntry",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PingEntry {
        const NAME: &'static str = "PingEntry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.ping = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.ping_status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.ping {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.ping_status {
                my_size += ::protobuf::rt::int32_size(3, v.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.ping {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.ping_status {
                os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PingEntry {
            PingEntry::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.ping = ::std::option::Option::None;
            self.ping_status = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PingEntry {
            static instance: PingEntry = PingEntry {
                name: ::std::option::Option::None,
                ping: ::std::option::Option::None,
                ping_status: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PingEntry {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGCDataCenterPing_Update.PingEntry").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PingEntry {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PingEntry {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGCDataCenterPing_Update.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:CMsgGCDataCenterPing_Update.Status.Invalid)
        Invalid = 0,
        // @@protoc_insertion_point(enum_value:CMsgGCDataCenterPing_Update.Status.Normal)
        Normal = 1,
        // @@protoc_insertion_point(enum_value:CMsgGCDataCenterPing_Update.Status.Unreachable)
        Unreachable = 2,
        // @@protoc_insertion_point(enum_value:CMsgGCDataCenterPing_Update.Status.FallbackToDCPing)
        FallbackToDCPing = 3,
    }

    impl ::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                0 => ::std::option::Option::Some(Status::Invalid),
                1 => ::std::option::Option::Some(Status::Normal),
                2 => ::std::option::Option::Some(Status::Unreachable),
                3 => ::std::option::Option::Some(Status::FallbackToDCPing),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Status> {
            match str {
                "Invalid" => ::std::option::Option::Some(Status::Invalid),
                "Normal" => ::std::option::Option::Some(Status::Normal),
                "Unreachable" => ::std::option::Option::Some(Status::Unreachable),
                "FallbackToDCPing" => ::std::option::Option::Some(Status::FallbackToDCPing),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::Invalid,
            Status::Normal,
            Status::Unreachable,
            Status::FallbackToDCPing,
        ];
    }

    impl ::protobuf::EnumFull for Status {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgGCDataCenterPing_Update.Status").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::Invalid
        }
    }

    impl Status {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("CMsgGCDataCenterPing_Update.Status")
        }
    }
}

// @@protoc_insertion_point(message:CMsgGC_KickPlayerFromLobby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_KickPlayerFromLobby {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_KickPlayerFromLobby.targetID)
    pub targetID: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_KickPlayerFromLobby.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_KickPlayerFromLobby {
    fn default() -> &'a CMsgGC_KickPlayerFromLobby {
        <CMsgGC_KickPlayerFromLobby as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_KickPlayerFromLobby {
    pub fn new() -> CMsgGC_KickPlayerFromLobby {
        ::std::default::Default::default()
    }

    // optional uint64 targetID = 1;

    pub fn targetID(&self) -> u64 {
        self.targetID.unwrap_or(0)
    }

    pub fn clear_targetID(&mut self) {
        self.targetID = ::std::option::Option::None;
    }

    pub fn has_targetID(&self) -> bool {
        self.targetID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_targetID(&mut self, v: u64) {
        self.targetID = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "targetID",
            |m: &CMsgGC_KickPlayerFromLobby| { &m.targetID },
            |m: &mut CMsgGC_KickPlayerFromLobby| { &mut m.targetID },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_KickPlayerFromLobby>(
            "CMsgGC_KickPlayerFromLobby",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_KickPlayerFromLobby {
    const NAME: &'static str = "CMsgGC_KickPlayerFromLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.targetID = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.targetID {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.targetID {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_KickPlayerFromLobby {
        CMsgGC_KickPlayerFromLobby::new()
    }

    fn clear(&mut self) {
        self.targetID = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_KickPlayerFromLobby {
        static instance: CMsgGC_KickPlayerFromLobby = CMsgGC_KickPlayerFromLobby {
            targetID: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_KickPlayerFromLobby {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_KickPlayerFromLobby").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_KickPlayerFromLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_KickPlayerFromLobby {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCSurveyRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCSurveyRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCSurveyRequest.question_type)
    pub question_type: ::std::option::Option<::protobuf::EnumOrUnknown<SurveyQuestionType>>,
    // @@protoc_insertion_point(field:CMsgGCSurveyRequest.match_id)
    pub match_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCSurveyRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCSurveyRequest {
    fn default() -> &'a CMsgGCSurveyRequest {
        <CMsgGCSurveyRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCSurveyRequest {
    pub fn new() -> CMsgGCSurveyRequest {
        ::std::default::Default::default()
    }

    // optional .SurveyQuestionType question_type = 1;

    pub fn question_type(&self) -> SurveyQuestionType {
        match self.question_type {
            Some(e) => e.enum_value_or(SurveyQuestionType::QUESTION_MATCH_QUALITY),
            None => SurveyQuestionType::QUESTION_MATCH_QUALITY,
        }
    }

    pub fn clear_question_type(&mut self) {
        self.question_type = ::std::option::Option::None;
    }

    pub fn has_question_type(&self) -> bool {
        self.question_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_question_type(&mut self, v: SurveyQuestionType) {
        self.question_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 match_id = 2;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "question_type",
            |m: &CMsgGCSurveyRequest| { &m.question_type },
            |m: &mut CMsgGCSurveyRequest| { &mut m.question_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgGCSurveyRequest| { &m.match_id },
            |m: &mut CMsgGCSurveyRequest| { &mut m.match_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCSurveyRequest>(
            "CMsgGCSurveyRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCSurveyRequest {
    const NAME: &'static str = "CMsgGCSurveyRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.question_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.question_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.question_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCSurveyRequest {
        CMsgGCSurveyRequest::new()
    }

    fn clear(&mut self) {
        self.question_type = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCSurveyRequest {
        static instance: CMsgGCSurveyRequest = CMsgGCSurveyRequest {
            question_type: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCSurveyRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCSurveyRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCSurveyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCSurveyRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCSurveyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCSurveyResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCSurveyResponse.question_type)
    pub question_type: ::std::option::Option<::protobuf::EnumOrUnknown<SurveyQuestionType>>,
    // @@protoc_insertion_point(field:CMsgGCSurveyResponse.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCSurveyResponse.response)
    pub response: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCSurveyResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCSurveyResponse {
    fn default() -> &'a CMsgGCSurveyResponse {
        <CMsgGCSurveyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCSurveyResponse {
    pub fn new() -> CMsgGCSurveyResponse {
        ::std::default::Default::default()
    }

    // optional .SurveyQuestionType question_type = 1;

    pub fn question_type(&self) -> SurveyQuestionType {
        match self.question_type {
            Some(e) => e.enum_value_or(SurveyQuestionType::QUESTION_MATCH_QUALITY),
            None => SurveyQuestionType::QUESTION_MATCH_QUALITY,
        }
    }

    pub fn clear_question_type(&mut self) {
        self.question_type = ::std::option::Option::None;
    }

    pub fn has_question_type(&self) -> bool {
        self.question_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_question_type(&mut self, v: SurveyQuestionType) {
        self.question_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 match_id = 2;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional int32 response = 3;

    pub fn response(&self) -> i32 {
        self.response.unwrap_or(0)
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: i32) {
        self.response = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "question_type",
            |m: &CMsgGCSurveyResponse| { &m.question_type },
            |m: &mut CMsgGCSurveyResponse| { &mut m.question_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgGCSurveyResponse| { &m.match_id },
            |m: &mut CMsgGCSurveyResponse| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &CMsgGCSurveyResponse| { &m.response },
            |m: &mut CMsgGCSurveyResponse| { &mut m.response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCSurveyResponse>(
            "CMsgGCSurveyResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCSurveyResponse {
    const NAME: &'static str = "CMsgGCSurveyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.question_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.response = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.question_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.question_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.response {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCSurveyResponse {
        CMsgGCSurveyResponse::new()
    }

    fn clear(&mut self) {
        self.question_type = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCSurveyResponse {
        static instance: CMsgGCSurveyResponse = CMsgGCSurveyResponse {
            question_type: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            response: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCSurveyResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCSurveyResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCSurveyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCSurveyResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSOQuestMapNode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOQuestMapNode {
    // message fields
    // @@protoc_insertion_point(field:CSOQuestMapNode.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOQuestMapNode.defindex)
    pub defindex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOQuestMapNode.node_id)
    pub node_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOQuestMapNode.star_0_earned)
    pub star_0_earned: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOQuestMapNode.star_1_earned)
    pub star_1_earned: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOQuestMapNode.star_2_earned)
    pub star_2_earned: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOQuestMapNode.loot_claimed)
    pub loot_claimed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOQuestMapNode.selected_quest_def)
    pub selected_quest_def: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOQuestMapNode.map_cycle)
    pub map_cycle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOQuestMapNode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOQuestMapNode {
    fn default() -> &'a CSOQuestMapNode {
        <CSOQuestMapNode as ::protobuf::Message>::default_instance()
    }
}

impl CSOQuestMapNode {
    pub fn new() -> CSOQuestMapNode {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 defindex = 3;

    pub fn defindex(&self) -> u32 {
        self.defindex.unwrap_or(0)
    }

    pub fn clear_defindex(&mut self) {
        self.defindex = ::std::option::Option::None;
    }

    pub fn has_defindex(&self) -> bool {
        self.defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defindex(&mut self, v: u32) {
        self.defindex = ::std::option::Option::Some(v);
    }

    // optional uint32 node_id = 4;

    pub fn node_id(&self) -> u32 {
        self.node_id.unwrap_or(0)
    }

    pub fn clear_node_id(&mut self) {
        self.node_id = ::std::option::Option::None;
    }

    pub fn has_node_id(&self) -> bool {
        self.node_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_id(&mut self, v: u32) {
        self.node_id = ::std::option::Option::Some(v);
    }

    // optional bool star_0_earned = 6;

    pub fn star_0_earned(&self) -> bool {
        self.star_0_earned.unwrap_or(false)
    }

    pub fn clear_star_0_earned(&mut self) {
        self.star_0_earned = ::std::option::Option::None;
    }

    pub fn has_star_0_earned(&self) -> bool {
        self.star_0_earned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_star_0_earned(&mut self, v: bool) {
        self.star_0_earned = ::std::option::Option::Some(v);
    }

    // optional bool star_1_earned = 7;

    pub fn star_1_earned(&self) -> bool {
        self.star_1_earned.unwrap_or(false)
    }

    pub fn clear_star_1_earned(&mut self) {
        self.star_1_earned = ::std::option::Option::None;
    }

    pub fn has_star_1_earned(&self) -> bool {
        self.star_1_earned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_star_1_earned(&mut self, v: bool) {
        self.star_1_earned = ::std::option::Option::Some(v);
    }

    // optional bool star_2_earned = 8;

    pub fn star_2_earned(&self) -> bool {
        self.star_2_earned.unwrap_or(false)
    }

    pub fn clear_star_2_earned(&mut self) {
        self.star_2_earned = ::std::option::Option::None;
    }

    pub fn has_star_2_earned(&self) -> bool {
        self.star_2_earned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_star_2_earned(&mut self, v: bool) {
        self.star_2_earned = ::std::option::Option::Some(v);
    }

    // optional bool loot_claimed = 9;

    pub fn loot_claimed(&self) -> bool {
        self.loot_claimed.unwrap_or(false)
    }

    pub fn clear_loot_claimed(&mut self) {
        self.loot_claimed = ::std::option::Option::None;
    }

    pub fn has_loot_claimed(&self) -> bool {
        self.loot_claimed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loot_claimed(&mut self, v: bool) {
        self.loot_claimed = ::std::option::Option::Some(v);
    }

    // optional uint32 selected_quest_def = 10;

    pub fn selected_quest_def(&self) -> u32 {
        self.selected_quest_def.unwrap_or(0u32)
    }

    pub fn clear_selected_quest_def(&mut self) {
        self.selected_quest_def = ::std::option::Option::None;
    }

    pub fn has_selected_quest_def(&self) -> bool {
        self.selected_quest_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected_quest_def(&mut self, v: u32) {
        self.selected_quest_def = ::std::option::Option::Some(v);
    }

    // optional uint32 map_cycle = 11;

    pub fn map_cycle(&self) -> u32 {
        self.map_cycle.unwrap_or(0)
    }

    pub fn clear_map_cycle(&mut self) {
        self.map_cycle = ::std::option::Option::None;
    }

    pub fn has_map_cycle(&self) -> bool {
        self.map_cycle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_cycle(&mut self, v: u32) {
        self.map_cycle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CSOQuestMapNode| { &m.account_id },
            |m: &mut CSOQuestMapNode| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "defindex",
            |m: &CSOQuestMapNode| { &m.defindex },
            |m: &mut CSOQuestMapNode| { &mut m.defindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "node_id",
            |m: &CSOQuestMapNode| { &m.node_id },
            |m: &mut CSOQuestMapNode| { &mut m.node_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "star_0_earned",
            |m: &CSOQuestMapNode| { &m.star_0_earned },
            |m: &mut CSOQuestMapNode| { &mut m.star_0_earned },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "star_1_earned",
            |m: &CSOQuestMapNode| { &m.star_1_earned },
            |m: &mut CSOQuestMapNode| { &mut m.star_1_earned },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "star_2_earned",
            |m: &CSOQuestMapNode| { &m.star_2_earned },
            |m: &mut CSOQuestMapNode| { &mut m.star_2_earned },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "loot_claimed",
            |m: &CSOQuestMapNode| { &m.loot_claimed },
            |m: &mut CSOQuestMapNode| { &mut m.loot_claimed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "selected_quest_def",
            |m: &CSOQuestMapNode| { &m.selected_quest_def },
            |m: &mut CSOQuestMapNode| { &mut m.selected_quest_def },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map_cycle",
            |m: &CSOQuestMapNode| { &m.map_cycle },
            |m: &mut CSOQuestMapNode| { &mut m.map_cycle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOQuestMapNode>(
            "CSOQuestMapNode",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOQuestMapNode {
    const NAME: &'static str = "CSOQuestMapNode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.defindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.node_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.star_0_earned = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.star_1_earned = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.star_2_earned = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.loot_claimed = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.selected_quest_def = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.map_cycle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.defindex {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.node_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.star_0_earned {
            my_size += 1 + 1;
        }
        if let Some(v) = self.star_1_earned {
            my_size += 1 + 1;
        }
        if let Some(v) = self.star_2_earned {
            my_size += 1 + 1;
        }
        if let Some(v) = self.loot_claimed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.selected_quest_def {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.map_cycle {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.defindex {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.node_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.star_0_earned {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.star_1_earned {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.star_2_earned {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.loot_claimed {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.selected_quest_def {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.map_cycle {
            os.write_uint32(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOQuestMapNode {
        CSOQuestMapNode::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.defindex = ::std::option::Option::None;
        self.node_id = ::std::option::Option::None;
        self.star_0_earned = ::std::option::Option::None;
        self.star_1_earned = ::std::option::Option::None;
        self.star_2_earned = ::std::option::Option::None;
        self.loot_claimed = ::std::option::Option::None;
        self.selected_quest_def = ::std::option::Option::None;
        self.map_cycle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOQuestMapNode {
        static instance: CSOQuestMapNode = CSOQuestMapNode {
            account_id: ::std::option::Option::None,
            defindex: ::std::option::Option::None,
            node_id: ::std::option::Option::None,
            star_0_earned: ::std::option::Option::None,
            star_1_earned: ::std::option::Option::None,
            star_2_earned: ::std::option::Option::None,
            loot_claimed: ::std::option::Option::None,
            selected_quest_def: ::std::option::Option::None,
            map_cycle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOQuestMapNode {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOQuestMapNode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOQuestMapNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOQuestMapNode {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSOQuest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOQuest {
    // message fields
    // @@protoc_insertion_point(field:CSOQuest.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOQuest.quest_id)
    pub quest_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSOQuest.defindex)
    pub defindex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOQuest.active)
    pub active: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOQuest.points_0)
    pub points_0: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOQuest.points_1)
    pub points_1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOQuest.points_2)
    pub points_2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOQuest.quest_map_node_source_id)
    pub quest_map_node_source_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOQuest.map_cycle)
    pub map_cycle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOQuest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOQuest {
    fn default() -> &'a CSOQuest {
        <CSOQuest as ::protobuf::Message>::default_instance()
    }
}

impl CSOQuest {
    pub fn new() -> CSOQuest {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 quest_id = 2;

    pub fn quest_id(&self) -> u64 {
        self.quest_id.unwrap_or(0)
    }

    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u64) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    // optional uint32 defindex = 3;

    pub fn defindex(&self) -> u32 {
        self.defindex.unwrap_or(0)
    }

    pub fn clear_defindex(&mut self) {
        self.defindex = ::std::option::Option::None;
    }

    pub fn has_defindex(&self) -> bool {
        self.defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defindex(&mut self, v: u32) {
        self.defindex = ::std::option::Option::Some(v);
    }

    // optional bool active = 4;

    pub fn active(&self) -> bool {
        self.active.unwrap_or(false)
    }

    pub fn clear_active(&mut self) {
        self.active = ::std::option::Option::None;
    }

    pub fn has_active(&self) -> bool {
        self.active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active(&mut self, v: bool) {
        self.active = ::std::option::Option::Some(v);
    }

    // optional uint32 points_0 = 5;

    pub fn points_0(&self) -> u32 {
        self.points_0.unwrap_or(0)
    }

    pub fn clear_points_0(&mut self) {
        self.points_0 = ::std::option::Option::None;
    }

    pub fn has_points_0(&self) -> bool {
        self.points_0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_0(&mut self, v: u32) {
        self.points_0 = ::std::option::Option::Some(v);
    }

    // optional uint32 points_1 = 6;

    pub fn points_1(&self) -> u32 {
        self.points_1.unwrap_or(0)
    }

    pub fn clear_points_1(&mut self) {
        self.points_1 = ::std::option::Option::None;
    }

    pub fn has_points_1(&self) -> bool {
        self.points_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_1(&mut self, v: u32) {
        self.points_1 = ::std::option::Option::Some(v);
    }

    // optional uint32 points_2 = 7;

    pub fn points_2(&self) -> u32 {
        self.points_2.unwrap_or(0)
    }

    pub fn clear_points_2(&mut self) {
        self.points_2 = ::std::option::Option::None;
    }

    pub fn has_points_2(&self) -> bool {
        self.points_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_2(&mut self, v: u32) {
        self.points_2 = ::std::option::Option::Some(v);
    }

    // optional uint32 quest_map_node_source_id = 8;

    pub fn quest_map_node_source_id(&self) -> u32 {
        self.quest_map_node_source_id.unwrap_or(0)
    }

    pub fn clear_quest_map_node_source_id(&mut self) {
        self.quest_map_node_source_id = ::std::option::Option::None;
    }

    pub fn has_quest_map_node_source_id(&self) -> bool {
        self.quest_map_node_source_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_map_node_source_id(&mut self, v: u32) {
        self.quest_map_node_source_id = ::std::option::Option::Some(v);
    }

    // optional uint32 map_cycle = 9;

    pub fn map_cycle(&self) -> u32 {
        self.map_cycle.unwrap_or(0)
    }

    pub fn clear_map_cycle(&mut self) {
        self.map_cycle = ::std::option::Option::None;
    }

    pub fn has_map_cycle(&self) -> bool {
        self.map_cycle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_cycle(&mut self, v: u32) {
        self.map_cycle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CSOQuest| { &m.account_id },
            |m: &mut CSOQuest| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quest_id",
            |m: &CSOQuest| { &m.quest_id },
            |m: &mut CSOQuest| { &mut m.quest_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "defindex",
            |m: &CSOQuest| { &m.defindex },
            |m: &mut CSOQuest| { &mut m.defindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "active",
            |m: &CSOQuest| { &m.active },
            |m: &mut CSOQuest| { &mut m.active },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "points_0",
            |m: &CSOQuest| { &m.points_0 },
            |m: &mut CSOQuest| { &mut m.points_0 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "points_1",
            |m: &CSOQuest| { &m.points_1 },
            |m: &mut CSOQuest| { &mut m.points_1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "points_2",
            |m: &CSOQuest| { &m.points_2 },
            |m: &mut CSOQuest| { &mut m.points_2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quest_map_node_source_id",
            |m: &CSOQuest| { &m.quest_map_node_source_id },
            |m: &mut CSOQuest| { &mut m.quest_map_node_source_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map_cycle",
            |m: &CSOQuest| { &m.map_cycle },
            |m: &mut CSOQuest| { &mut m.map_cycle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOQuest>(
            "CSOQuest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOQuest {
    const NAME: &'static str = "CSOQuest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.quest_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.defindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.active = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.points_0 = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.points_1 = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.points_2 = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.quest_map_node_source_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.map_cycle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.quest_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.defindex {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.active {
            my_size += 1 + 1;
        }
        if let Some(v) = self.points_0 {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.points_1 {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.points_2 {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.quest_map_node_source_id {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.map_cycle {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.quest_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.defindex {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.active {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.points_0 {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.points_1 {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.points_2 {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.quest_map_node_source_id {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.map_cycle {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOQuest {
        CSOQuest::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.quest_id = ::std::option::Option::None;
        self.defindex = ::std::option::Option::None;
        self.active = ::std::option::Option::None;
        self.points_0 = ::std::option::Option::None;
        self.points_1 = ::std::option::Option::None;
        self.points_2 = ::std::option::Option::None;
        self.quest_map_node_source_id = ::std::option::Option::None;
        self.map_cycle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOQuest {
        static instance: CSOQuest = CSOQuest {
            account_id: ::std::option::Option::None,
            quest_id: ::std::option::Option::None,
            defindex: ::std::option::Option::None,
            active: ::std::option::Option::None,
            points_0: ::std::option::Option::None,
            points_1: ::std::option::Option::None,
            points_2: ::std::option::Option::None,
            quest_map_node_source_id: ::std::option::Option::None,
            map_cycle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOQuest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOQuest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOQuest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOQuest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSOQuestMapRewardPurchase)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOQuestMapRewardPurchase {
    // message fields
    // @@protoc_insertion_point(field:CSOQuestMapRewardPurchase.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOQuestMapRewardPurchase.defindex)
    pub defindex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOQuestMapRewardPurchase.count)
    pub count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOQuestMapRewardPurchase.map_cycle)
    pub map_cycle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOQuestMapRewardPurchase.purchase_id)
    pub purchase_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOQuestMapRewardPurchase.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOQuestMapRewardPurchase {
    fn default() -> &'a CSOQuestMapRewardPurchase {
        <CSOQuestMapRewardPurchase as ::protobuf::Message>::default_instance()
    }
}

impl CSOQuestMapRewardPurchase {
    pub fn new() -> CSOQuestMapRewardPurchase {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 defindex = 2;

    pub fn defindex(&self) -> u32 {
        self.defindex.unwrap_or(0)
    }

    pub fn clear_defindex(&mut self) {
        self.defindex = ::std::option::Option::None;
    }

    pub fn has_defindex(&self) -> bool {
        self.defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defindex(&mut self, v: u32) {
        self.defindex = ::std::option::Option::Some(v);
    }

    // optional uint32 count = 3;

    pub fn count(&self) -> u32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional uint32 map_cycle = 4;

    pub fn map_cycle(&self) -> u32 {
        self.map_cycle.unwrap_or(0)
    }

    pub fn clear_map_cycle(&mut self) {
        self.map_cycle = ::std::option::Option::None;
    }

    pub fn has_map_cycle(&self) -> bool {
        self.map_cycle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_cycle(&mut self, v: u32) {
        self.map_cycle = ::std::option::Option::Some(v);
    }

    // optional uint32 purchase_id = 5;

    pub fn purchase_id(&self) -> u32 {
        self.purchase_id.unwrap_or(0)
    }

    pub fn clear_purchase_id(&mut self) {
        self.purchase_id = ::std::option::Option::None;
    }

    pub fn has_purchase_id(&self) -> bool {
        self.purchase_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchase_id(&mut self, v: u32) {
        self.purchase_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CSOQuestMapRewardPurchase| { &m.account_id },
            |m: &mut CSOQuestMapRewardPurchase| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "defindex",
            |m: &CSOQuestMapRewardPurchase| { &m.defindex },
            |m: &mut CSOQuestMapRewardPurchase| { &mut m.defindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "count",
            |m: &CSOQuestMapRewardPurchase| { &m.count },
            |m: &mut CSOQuestMapRewardPurchase| { &mut m.count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map_cycle",
            |m: &CSOQuestMapRewardPurchase| { &m.map_cycle },
            |m: &mut CSOQuestMapRewardPurchase| { &mut m.map_cycle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "purchase_id",
            |m: &CSOQuestMapRewardPurchase| { &m.purchase_id },
            |m: &mut CSOQuestMapRewardPurchase| { &mut m.purchase_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOQuestMapRewardPurchase>(
            "CSOQuestMapRewardPurchase",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOQuestMapRewardPurchase {
    const NAME: &'static str = "CSOQuestMapRewardPurchase";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.defindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.count = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.map_cycle = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.purchase_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.defindex {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.map_cycle {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.purchase_id {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.defindex {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.count {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.map_cycle {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.purchase_id {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOQuestMapRewardPurchase {
        CSOQuestMapRewardPurchase::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.defindex = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.map_cycle = ::std::option::Option::None;
        self.purchase_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOQuestMapRewardPurchase {
        static instance: CSOQuestMapRewardPurchase = CSOQuestMapRewardPurchase {
            account_id: ::std::option::Option::None,
            defindex: ::std::option::Option::None,
            count: ::std::option::Option::None,
            map_cycle: ::std::option::Option::None,
            purchase_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOQuestMapRewardPurchase {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOQuestMapRewardPurchase").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOQuestMapRewardPurchase {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOQuestMapRewardPurchase {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCQuestIdentify)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCQuestIdentify {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCQuestIdentify.quest_id)
    pub quest_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCQuestIdentify.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestIdentify {
    fn default() -> &'a CMsgGCQuestIdentify {
        <CMsgGCQuestIdentify as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestIdentify {
    pub fn new() -> CMsgGCQuestIdentify {
        ::std::default::Default::default()
    }

    // optional uint64 quest_id = 1;

    pub fn quest_id(&self) -> u64 {
        self.quest_id.unwrap_or(0)
    }

    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u64) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quest_id",
            |m: &CMsgGCQuestIdentify| { &m.quest_id },
            |m: &mut CMsgGCQuestIdentify| { &mut m.quest_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCQuestIdentify>(
            "CMsgGCQuestIdentify",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCQuestIdentify {
    const NAME: &'static str = "CMsgGCQuestIdentify";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.quest_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.quest_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCQuestIdentify {
        CMsgGCQuestIdentify::new()
    }

    fn clear(&mut self) {
        self.quest_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCQuestIdentify {
        static instance: CMsgGCQuestIdentify = CMsgGCQuestIdentify {
            quest_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCQuestIdentify {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCQuestIdentify").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCQuestIdentify {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCQuestIdentify {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCQuestDevGive)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCQuestDevGive {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCQuestDevGive.quest_def_index)
    pub quest_def_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCQuestDevGive.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestDevGive {
    fn default() -> &'a CMsgGCQuestDevGive {
        <CMsgGCQuestDevGive as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestDevGive {
    pub fn new() -> CMsgGCQuestDevGive {
        ::std::default::Default::default()
    }

    // optional uint32 quest_def_index = 1;

    pub fn quest_def_index(&self) -> u32 {
        self.quest_def_index.unwrap_or(0)
    }

    pub fn clear_quest_def_index(&mut self) {
        self.quest_def_index = ::std::option::Option::None;
    }

    pub fn has_quest_def_index(&self) -> bool {
        self.quest_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_def_index(&mut self, v: u32) {
        self.quest_def_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quest_def_index",
            |m: &CMsgGCQuestDevGive| { &m.quest_def_index },
            |m: &mut CMsgGCQuestDevGive| { &mut m.quest_def_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCQuestDevGive>(
            "CMsgGCQuestDevGive",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCQuestDevGive {
    const NAME: &'static str = "CMsgGCQuestDevGive";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.quest_def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quest_def_index {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.quest_def_index {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCQuestDevGive {
        CMsgGCQuestDevGive::new()
    }

    fn clear(&mut self) {
        self.quest_def_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCQuestDevGive {
        static instance: CMsgGCQuestDevGive = CMsgGCQuestDevGive {
            quest_def_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCQuestDevGive {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCQuestDevGive").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCQuestDevGive {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCQuestDevGive {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCQuestNodeTurnIn)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCQuestNodeTurnIn {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCQuestNodeTurnIn.node_defindex)
    pub node_defindex: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCQuestNodeTurnIn.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestNodeTurnIn {
    fn default() -> &'a CMsgGCQuestNodeTurnIn {
        <CMsgGCQuestNodeTurnIn as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestNodeTurnIn {
    pub fn new() -> CMsgGCQuestNodeTurnIn {
        ::std::default::Default::default()
    }

    // optional uint32 node_defindex = 1;

    pub fn node_defindex(&self) -> u32 {
        self.node_defindex.unwrap_or(0)
    }

    pub fn clear_node_defindex(&mut self) {
        self.node_defindex = ::std::option::Option::None;
    }

    pub fn has_node_defindex(&self) -> bool {
        self.node_defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_defindex(&mut self, v: u32) {
        self.node_defindex = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "node_defindex",
            |m: &CMsgGCQuestNodeTurnIn| { &m.node_defindex },
            |m: &mut CMsgGCQuestNodeTurnIn| { &mut m.node_defindex },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCQuestNodeTurnIn>(
            "CMsgGCQuestNodeTurnIn",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCQuestNodeTurnIn {
    const NAME: &'static str = "CMsgGCQuestNodeTurnIn";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.node_defindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.node_defindex {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.node_defindex {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCQuestNodeTurnIn {
        CMsgGCQuestNodeTurnIn::new()
    }

    fn clear(&mut self) {
        self.node_defindex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCQuestNodeTurnIn {
        static instance: CMsgGCQuestNodeTurnIn = CMsgGCQuestNodeTurnIn {
            node_defindex: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCQuestNodeTurnIn {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCQuestNodeTurnIn").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCQuestNodeTurnIn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCQuestNodeTurnIn {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCQuestMapUnlockNode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCQuestMapUnlockNode {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCQuestMapUnlockNode.node_defindex)
    pub node_defindex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCQuestMapUnlockNode.quest_defindex)
    pub quest_defindex: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCQuestMapUnlockNode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestMapUnlockNode {
    fn default() -> &'a CMsgGCQuestMapUnlockNode {
        <CMsgGCQuestMapUnlockNode as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestMapUnlockNode {
    pub fn new() -> CMsgGCQuestMapUnlockNode {
        ::std::default::Default::default()
    }

    // optional uint32 node_defindex = 1;

    pub fn node_defindex(&self) -> u32 {
        self.node_defindex.unwrap_or(0)
    }

    pub fn clear_node_defindex(&mut self) {
        self.node_defindex = ::std::option::Option::None;
    }

    pub fn has_node_defindex(&self) -> bool {
        self.node_defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_defindex(&mut self, v: u32) {
        self.node_defindex = ::std::option::Option::Some(v);
    }

    // optional uint32 quest_defindex = 2;

    pub fn quest_defindex(&self) -> u32 {
        self.quest_defindex.unwrap_or(0)
    }

    pub fn clear_quest_defindex(&mut self) {
        self.quest_defindex = ::std::option::Option::None;
    }

    pub fn has_quest_defindex(&self) -> bool {
        self.quest_defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_defindex(&mut self, v: u32) {
        self.quest_defindex = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "node_defindex",
            |m: &CMsgGCQuestMapUnlockNode| { &m.node_defindex },
            |m: &mut CMsgGCQuestMapUnlockNode| { &mut m.node_defindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quest_defindex",
            |m: &CMsgGCQuestMapUnlockNode| { &m.quest_defindex },
            |m: &mut CMsgGCQuestMapUnlockNode| { &mut m.quest_defindex },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCQuestMapUnlockNode>(
            "CMsgGCQuestMapUnlockNode",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCQuestMapUnlockNode {
    const NAME: &'static str = "CMsgGCQuestMapUnlockNode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.node_defindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.quest_defindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.node_defindex {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.quest_defindex {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.node_defindex {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.quest_defindex {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCQuestMapUnlockNode {
        CMsgGCQuestMapUnlockNode::new()
    }

    fn clear(&mut self) {
        self.node_defindex = ::std::option::Option::None;
        self.quest_defindex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCQuestMapUnlockNode {
        static instance: CMsgGCQuestMapUnlockNode = CMsgGCQuestMapUnlockNode {
            node_defindex: ::std::option::Option::None,
            quest_defindex: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCQuestMapUnlockNode {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCQuestMapUnlockNode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCQuestMapUnlockNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCQuestMapUnlockNode {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCNewMatchForLobbyRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCNewMatchForLobbyRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCNewMatchForLobbyRequest.current_match_id)
    pub current_match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCNewMatchForLobbyRequest.next_map_id)
    pub next_map_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCNewMatchForLobbyRequest.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCNewMatchForLobbyRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCNewMatchForLobbyRequest {
    fn default() -> &'a CMsgGCNewMatchForLobbyRequest {
        <CMsgGCNewMatchForLobbyRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCNewMatchForLobbyRequest {
    pub fn new() -> CMsgGCNewMatchForLobbyRequest {
        ::std::default::Default::default()
    }

    // optional uint64 current_match_id = 1;

    pub fn current_match_id(&self) -> u64 {
        self.current_match_id.unwrap_or(0)
    }

    pub fn clear_current_match_id(&mut self) {
        self.current_match_id = ::std::option::Option::None;
    }

    pub fn has_current_match_id(&self) -> bool {
        self.current_match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_match_id(&mut self, v: u64) {
        self.current_match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 next_map_id = 2;

    pub fn next_map_id(&self) -> u32 {
        self.next_map_id.unwrap_or(0)
    }

    pub fn clear_next_map_id(&mut self) {
        self.next_map_id = ::std::option::Option::None;
    }

    pub fn has_next_map_id(&self) -> bool {
        self.next_map_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_next_map_id(&mut self, v: u32) {
        self.next_map_id = ::std::option::Option::Some(v);
    }

    // optional uint64 lobby_id = 3;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "current_match_id",
            |m: &CMsgGCNewMatchForLobbyRequest| { &m.current_match_id },
            |m: &mut CMsgGCNewMatchForLobbyRequest| { &mut m.current_match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "next_map_id",
            |m: &CMsgGCNewMatchForLobbyRequest| { &m.next_map_id },
            |m: &mut CMsgGCNewMatchForLobbyRequest| { &mut m.next_map_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_id",
            |m: &CMsgGCNewMatchForLobbyRequest| { &m.lobby_id },
            |m: &mut CMsgGCNewMatchForLobbyRequest| { &mut m.lobby_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCNewMatchForLobbyRequest>(
            "CMsgGCNewMatchForLobbyRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCNewMatchForLobbyRequest {
    const NAME: &'static str = "CMsgGCNewMatchForLobbyRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.current_match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.next_map_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.current_match_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.next_map_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.lobby_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.current_match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.next_map_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.lobby_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCNewMatchForLobbyRequest {
        CMsgGCNewMatchForLobbyRequest::new()
    }

    fn clear(&mut self) {
        self.current_match_id = ::std::option::Option::None;
        self.next_map_id = ::std::option::Option::None;
        self.lobby_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCNewMatchForLobbyRequest {
        static instance: CMsgGCNewMatchForLobbyRequest = CMsgGCNewMatchForLobbyRequest {
            current_match_id: ::std::option::Option::None,
            next_map_id: ::std::option::Option::None,
            lobby_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCNewMatchForLobbyRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCNewMatchForLobbyRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCNewMatchForLobbyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCNewMatchForLobbyRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCNewMatchForLobbyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCNewMatchForLobbyResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCNewMatchForLobbyResponse.success)
    pub success: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCNewMatchForLobbyResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCNewMatchForLobbyResponse {
    fn default() -> &'a CMsgGCNewMatchForLobbyResponse {
        <CMsgGCNewMatchForLobbyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCNewMatchForLobbyResponse {
    pub fn new() -> CMsgGCNewMatchForLobbyResponse {
        ::std::default::Default::default()
    }

    // optional bool success = 1;

    pub fn success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "success",
            |m: &CMsgGCNewMatchForLobbyResponse| { &m.success },
            |m: &mut CMsgGCNewMatchForLobbyResponse| { &mut m.success },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCNewMatchForLobbyResponse>(
            "CMsgGCNewMatchForLobbyResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCNewMatchForLobbyResponse {
    const NAME: &'static str = "CMsgGCNewMatchForLobbyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCNewMatchForLobbyResponse {
        CMsgGCNewMatchForLobbyResponse::new()
    }

    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCNewMatchForLobbyResponse {
        static instance: CMsgGCNewMatchForLobbyResponse = CMsgGCNewMatchForLobbyResponse {
            success: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCNewMatchForLobbyResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCNewMatchForLobbyResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCNewMatchForLobbyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCNewMatchForLobbyResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCChangeMatchPlayerTeamsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCChangeMatchPlayerTeamsRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCChangeMatchPlayerTeamsRequest.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCChangeMatchPlayerTeamsRequest.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCChangeMatchPlayerTeamsRequest.member)
    pub member: ::std::vec::Vec<cmsg_gcchange_match_player_teams_request::Member>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCChangeMatchPlayerTeamsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCChangeMatchPlayerTeamsRequest {
    fn default() -> &'a CMsgGCChangeMatchPlayerTeamsRequest {
        <CMsgGCChangeMatchPlayerTeamsRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCChangeMatchPlayerTeamsRequest {
    pub fn new() -> CMsgGCChangeMatchPlayerTeamsRequest {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint64 lobby_id = 2;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgGCChangeMatchPlayerTeamsRequest| { &m.match_id },
            |m: &mut CMsgGCChangeMatchPlayerTeamsRequest| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_id",
            |m: &CMsgGCChangeMatchPlayerTeamsRequest| { &m.lobby_id },
            |m: &mut CMsgGCChangeMatchPlayerTeamsRequest| { &mut m.lobby_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "member",
            |m: &CMsgGCChangeMatchPlayerTeamsRequest| { &m.member },
            |m: &mut CMsgGCChangeMatchPlayerTeamsRequest| { &mut m.member },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCChangeMatchPlayerTeamsRequest>(
            "CMsgGCChangeMatchPlayerTeamsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCChangeMatchPlayerTeamsRequest {
    const NAME: &'static str = "CMsgGCChangeMatchPlayerTeamsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.member.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.lobby_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        for value in &self.member {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.lobby_id {
            os.write_uint64(2, v)?;
        }
        for v in &self.member {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCChangeMatchPlayerTeamsRequest {
        CMsgGCChangeMatchPlayerTeamsRequest::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.lobby_id = ::std::option::Option::None;
        self.member.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCChangeMatchPlayerTeamsRequest {
        static instance: CMsgGCChangeMatchPlayerTeamsRequest = CMsgGCChangeMatchPlayerTeamsRequest {
            match_id: ::std::option::Option::None,
            lobby_id: ::std::option::Option::None,
            member: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCChangeMatchPlayerTeamsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCChangeMatchPlayerTeamsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCChangeMatchPlayerTeamsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCChangeMatchPlayerTeamsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGCChangeMatchPlayerTeamsRequest`
pub mod cmsg_gcchange_match_player_teams_request {
    // @@protoc_insertion_point(message:CMsgGCChangeMatchPlayerTeamsRequest.Member)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Member {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCChangeMatchPlayerTeamsRequest.Member.member_id)
        pub member_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgGCChangeMatchPlayerTeamsRequest.Member.new_team)
        pub new_team: ::std::option::Option<::protobuf::EnumOrUnknown<super::TF_GC_TEAM>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCChangeMatchPlayerTeamsRequest.Member.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Member {
        fn default() -> &'a Member {
            <Member as ::protobuf::Message>::default_instance()
        }
    }

    impl Member {
        pub fn new() -> Member {
            ::std::default::Default::default()
        }

        // optional uint64 member_id = 1;

        pub fn member_id(&self) -> u64 {
            self.member_id.unwrap_or(0)
        }

        pub fn clear_member_id(&mut self) {
            self.member_id = ::std::option::Option::None;
        }

        pub fn has_member_id(&self) -> bool {
            self.member_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_member_id(&mut self, v: u64) {
            self.member_id = ::std::option::Option::Some(v);
        }

        // optional .TF_GC_TEAM new_team = 2;

        pub fn new_team(&self) -> super::TF_GC_TEAM {
            match self.new_team {
                Some(e) => e.enum_value_or(super::TF_GC_TEAM::TF_GC_TEAM_NOTEAM),
                None => super::TF_GC_TEAM::TF_GC_TEAM_NOTEAM,
            }
        }

        pub fn clear_new_team(&mut self) {
            self.new_team = ::std::option::Option::None;
        }

        pub fn has_new_team(&self) -> bool {
            self.new_team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_new_team(&mut self, v: super::TF_GC_TEAM) {
            self.new_team = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "member_id",
                |m: &Member| { &m.member_id },
                |m: &mut Member| { &mut m.member_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "new_team",
                |m: &Member| { &m.new_team },
                |m: &mut Member| { &mut m.new_team },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Member>(
                "CMsgGCChangeMatchPlayerTeamsRequest.Member",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Member {
        const NAME: &'static str = "Member";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.member_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.new_team = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.member_id {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.new_team {
                my_size += ::protobuf::rt::int32_size(2, v.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.member_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.new_team {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Member {
            Member::new()
        }

        fn clear(&mut self) {
            self.member_id = ::std::option::Option::None;
            self.new_team = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Member {
            static instance: Member = Member {
                member_id: ::std::option::Option::None,
                new_team: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Member {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGCChangeMatchPlayerTeamsRequest.Member").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Member {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Member {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgGCChangeMatchPlayerTeamsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCChangeMatchPlayerTeamsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCChangeMatchPlayerTeamsResponse.success)
    pub success: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCChangeMatchPlayerTeamsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCChangeMatchPlayerTeamsResponse {
    fn default() -> &'a CMsgGCChangeMatchPlayerTeamsResponse {
        <CMsgGCChangeMatchPlayerTeamsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCChangeMatchPlayerTeamsResponse {
    pub fn new() -> CMsgGCChangeMatchPlayerTeamsResponse {
        ::std::default::Default::default()
    }

    // optional bool success = 1;

    pub fn success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "success",
            |m: &CMsgGCChangeMatchPlayerTeamsResponse| { &m.success },
            |m: &mut CMsgGCChangeMatchPlayerTeamsResponse| { &mut m.success },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCChangeMatchPlayerTeamsResponse>(
            "CMsgGCChangeMatchPlayerTeamsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCChangeMatchPlayerTeamsResponse {
    const NAME: &'static str = "CMsgGCChangeMatchPlayerTeamsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCChangeMatchPlayerTeamsResponse {
        CMsgGCChangeMatchPlayerTeamsResponse::new()
    }

    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCChangeMatchPlayerTeamsResponse {
        static instance: CMsgGCChangeMatchPlayerTeamsResponse = CMsgGCChangeMatchPlayerTeamsResponse {
            success: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCChangeMatchPlayerTeamsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCChangeMatchPlayerTeamsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCChangeMatchPlayerTeamsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCChangeMatchPlayerTeamsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCQuestComplete_Debug)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCQuestComplete_Debug {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCQuestComplete_Debug.quest_id)
    pub quest_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCQuestComplete_Debug.points_type)
    pub points_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCQuestComplete_Debug.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestComplete_Debug {
    fn default() -> &'a CMsgGCQuestComplete_Debug {
        <CMsgGCQuestComplete_Debug as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestComplete_Debug {
    pub fn new() -> CMsgGCQuestComplete_Debug {
        ::std::default::Default::default()
    }

    // optional uint64 quest_id = 1;

    pub fn quest_id(&self) -> u64 {
        self.quest_id.unwrap_or(0)
    }

    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u64) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    // optional uint32 points_type = 2;

    pub fn points_type(&self) -> u32 {
        self.points_type.unwrap_or(0)
    }

    pub fn clear_points_type(&mut self) {
        self.points_type = ::std::option::Option::None;
    }

    pub fn has_points_type(&self) -> bool {
        self.points_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_type(&mut self, v: u32) {
        self.points_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quest_id",
            |m: &CMsgGCQuestComplete_Debug| { &m.quest_id },
            |m: &mut CMsgGCQuestComplete_Debug| { &mut m.quest_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "points_type",
            |m: &CMsgGCQuestComplete_Debug| { &m.points_type },
            |m: &mut CMsgGCQuestComplete_Debug| { &mut m.points_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCQuestComplete_Debug>(
            "CMsgGCQuestComplete_Debug",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCQuestComplete_Debug {
    const NAME: &'static str = "CMsgGCQuestComplete_Debug";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.quest_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.points_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.points_type {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.quest_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.points_type {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCQuestComplete_Debug {
        CMsgGCQuestComplete_Debug::new()
    }

    fn clear(&mut self) {
        self.quest_id = ::std::option::Option::None;
        self.points_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCQuestComplete_Debug {
        static instance: CMsgGCQuestComplete_Debug = CMsgGCQuestComplete_Debug {
            quest_id: ::std::option::Option::None,
            points_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCQuestComplete_Debug {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCQuestComplete_Debug").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCQuestComplete_Debug {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCQuestComplete_Debug {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCQuestMap_Debug)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCQuestMap_Debug {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCQuestMap_Debug.reset_operation)
    pub reset_operation: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCQuestMap_Debug.give_credit)
    pub give_credit: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCQuestMap_Debug.unlock_node)
    pub unlock_node: ::protobuf::MessageField<CMsgGCQuestMapUnlockNode>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCQuestMap_Debug.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestMap_Debug {
    fn default() -> &'a CMsgGCQuestMap_Debug {
        <CMsgGCQuestMap_Debug as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestMap_Debug {
    pub fn new() -> CMsgGCQuestMap_Debug {
        ::std::default::Default::default()
    }

    // optional uint32 reset_operation = 1;

    pub fn reset_operation(&self) -> u32 {
        self.reset_operation.unwrap_or(0)
    }

    pub fn clear_reset_operation(&mut self) {
        self.reset_operation = ::std::option::Option::None;
    }

    pub fn has_reset_operation(&self) -> bool {
        self.reset_operation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reset_operation(&mut self, v: u32) {
        self.reset_operation = ::std::option::Option::Some(v);
    }

    // optional uint32 give_credit = 2;

    pub fn give_credit(&self) -> u32 {
        self.give_credit.unwrap_or(0)
    }

    pub fn clear_give_credit(&mut self) {
        self.give_credit = ::std::option::Option::None;
    }

    pub fn has_give_credit(&self) -> bool {
        self.give_credit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_give_credit(&mut self, v: u32) {
        self.give_credit = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reset_operation",
            |m: &CMsgGCQuestMap_Debug| { &m.reset_operation },
            |m: &mut CMsgGCQuestMap_Debug| { &mut m.reset_operation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "give_credit",
            |m: &CMsgGCQuestMap_Debug| { &m.give_credit },
            |m: &mut CMsgGCQuestMap_Debug| { &mut m.give_credit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGCQuestMapUnlockNode>(
            "unlock_node",
            |m: &CMsgGCQuestMap_Debug| { &m.unlock_node },
            |m: &mut CMsgGCQuestMap_Debug| { &mut m.unlock_node },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCQuestMap_Debug>(
            "CMsgGCQuestMap_Debug",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCQuestMap_Debug {
    const NAME: &'static str = "CMsgGCQuestMap_Debug";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.reset_operation = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.give_credit = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.unlock_node)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.reset_operation {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.give_credit {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.unlock_node.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.reset_operation {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.give_credit {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.unlock_node.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCQuestMap_Debug {
        CMsgGCQuestMap_Debug::new()
    }

    fn clear(&mut self) {
        self.reset_operation = ::std::option::Option::None;
        self.give_credit = ::std::option::Option::None;
        self.unlock_node.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCQuestMap_Debug {
        static instance: CMsgGCQuestMap_Debug = CMsgGCQuestMap_Debug {
            reset_operation: ::std::option::Option::None,
            give_credit: ::std::option::Option::None,
            unlock_node: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCQuestMap_Debug {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCQuestMap_Debug").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCQuestMap_Debug {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCQuestMap_Debug {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCQuestMapPurchaseReward)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCQuestMapPurchaseReward {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCQuestMapPurchaseReward.store_item_defindex)
    pub store_item_defindex: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCQuestMapPurchaseReward.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestMapPurchaseReward {
    fn default() -> &'a CMsgGCQuestMapPurchaseReward {
        <CMsgGCQuestMapPurchaseReward as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestMapPurchaseReward {
    pub fn new() -> CMsgGCQuestMapPurchaseReward {
        ::std::default::Default::default()
    }

    // optional uint32 store_item_defindex = 1;

    pub fn store_item_defindex(&self) -> u32 {
        self.store_item_defindex.unwrap_or(0)
    }

    pub fn clear_store_item_defindex(&mut self) {
        self.store_item_defindex = ::std::option::Option::None;
    }

    pub fn has_store_item_defindex(&self) -> bool {
        self.store_item_defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_store_item_defindex(&mut self, v: u32) {
        self.store_item_defindex = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "store_item_defindex",
            |m: &CMsgGCQuestMapPurchaseReward| { &m.store_item_defindex },
            |m: &mut CMsgGCQuestMapPurchaseReward| { &mut m.store_item_defindex },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCQuestMapPurchaseReward>(
            "CMsgGCQuestMapPurchaseReward",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCQuestMapPurchaseReward {
    const NAME: &'static str = "CMsgGCQuestMapPurchaseReward";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.store_item_defindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.store_item_defindex {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.store_item_defindex {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCQuestMapPurchaseReward {
        CMsgGCQuestMapPurchaseReward::new()
    }

    fn clear(&mut self) {
        self.store_item_defindex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCQuestMapPurchaseReward {
        static instance: CMsgGCQuestMapPurchaseReward = CMsgGCQuestMapPurchaseReward {
            store_item_defindex: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCQuestMapPurchaseReward {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCQuestMapPurchaseReward").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCQuestMapPurchaseReward {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCQuestMapPurchaseReward {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCQuestResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCQuestResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCQuestResponse.success)
    pub success: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCQuestResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestResponse {
    fn default() -> &'a CMsgGCQuestResponse {
        <CMsgGCQuestResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestResponse {
    pub fn new() -> CMsgGCQuestResponse {
        ::std::default::Default::default()
    }

    // optional bool success = 1;

    pub fn success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "success",
            |m: &CMsgGCQuestResponse| { &m.success },
            |m: &mut CMsgGCQuestResponse| { &mut m.success },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCQuestResponse>(
            "CMsgGCQuestResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCQuestResponse {
    const NAME: &'static str = "CMsgGCQuestResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCQuestResponse {
        CMsgGCQuestResponse::new()
    }

    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCQuestResponse {
        static instance: CMsgGCQuestResponse = CMsgGCQuestResponse {
            success: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCQuestResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCQuestResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCQuestResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCQuestResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCSetDisablePartyQuestProgress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCSetDisablePartyQuestProgress {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCSetDisablePartyQuestProgress.state)
    pub state: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCSetDisablePartyQuestProgress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCSetDisablePartyQuestProgress {
    fn default() -> &'a CMsgGCSetDisablePartyQuestProgress {
        <CMsgGCSetDisablePartyQuestProgress as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCSetDisablePartyQuestProgress {
    pub fn new() -> CMsgGCSetDisablePartyQuestProgress {
        ::std::default::Default::default()
    }

    // optional bool state = 1;

    pub fn state(&self) -> bool {
        self.state.unwrap_or(false)
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: bool) {
        self.state = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "state",
            |m: &CMsgGCSetDisablePartyQuestProgress| { &m.state },
            |m: &mut CMsgGCSetDisablePartyQuestProgress| { &mut m.state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCSetDisablePartyQuestProgress>(
            "CMsgGCSetDisablePartyQuestProgress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCSetDisablePartyQuestProgress {
    const NAME: &'static str = "CMsgGCSetDisablePartyQuestProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.state = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.state {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.state {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCSetDisablePartyQuestProgress {
        CMsgGCSetDisablePartyQuestProgress::new()
    }

    fn clear(&mut self) {
        self.state = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCSetDisablePartyQuestProgress {
        static instance: CMsgGCSetDisablePartyQuestProgress = CMsgGCSetDisablePartyQuestProgress {
            state: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCSetDisablePartyQuestProgress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCSetDisablePartyQuestProgress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCSetDisablePartyQuestProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCSetDisablePartyQuestProgress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgQuestProgressReport)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgQuestProgressReport {
    // message fields
    // @@protoc_insertion_point(field:CMsgQuestProgressReport.quest_id)
    pub quest_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgQuestProgressReport.star_0_earned)
    pub star_0_earned: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgQuestProgressReport.star_1_earned)
    pub star_1_earned: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgQuestProgressReport.star_2_earned)
    pub star_2_earned: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgQuestProgressReport.items_earned)
    pub items_earned: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CMsgQuestProgressReport.reward_credits_earned)
    pub reward_credits_earned: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgQuestProgressReport.contract_completed)
    pub contract_completed: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgQuestProgressReport.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgQuestProgressReport {
    fn default() -> &'a CMsgQuestProgressReport {
        <CMsgQuestProgressReport as ::protobuf::Message>::default_instance()
    }
}

impl CMsgQuestProgressReport {
    pub fn new() -> CMsgQuestProgressReport {
        ::std::default::Default::default()
    }

    // optional uint64 quest_id = 1;

    pub fn quest_id(&self) -> u64 {
        self.quest_id.unwrap_or(0)
    }

    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u64) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    // optional bool star_0_earned = 2;

    pub fn star_0_earned(&self) -> bool {
        self.star_0_earned.unwrap_or(false)
    }

    pub fn clear_star_0_earned(&mut self) {
        self.star_0_earned = ::std::option::Option::None;
    }

    pub fn has_star_0_earned(&self) -> bool {
        self.star_0_earned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_star_0_earned(&mut self, v: bool) {
        self.star_0_earned = ::std::option::Option::Some(v);
    }

    // optional bool star_1_earned = 3;

    pub fn star_1_earned(&self) -> bool {
        self.star_1_earned.unwrap_or(false)
    }

    pub fn clear_star_1_earned(&mut self) {
        self.star_1_earned = ::std::option::Option::None;
    }

    pub fn has_star_1_earned(&self) -> bool {
        self.star_1_earned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_star_1_earned(&mut self, v: bool) {
        self.star_1_earned = ::std::option::Option::Some(v);
    }

    // optional bool star_2_earned = 4;

    pub fn star_2_earned(&self) -> bool {
        self.star_2_earned.unwrap_or(false)
    }

    pub fn clear_star_2_earned(&mut self) {
        self.star_2_earned = ::std::option::Option::None;
    }

    pub fn has_star_2_earned(&self) -> bool {
        self.star_2_earned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_star_2_earned(&mut self, v: bool) {
        self.star_2_earned = ::std::option::Option::Some(v);
    }

    // optional uint32 reward_credits_earned = 6;

    pub fn reward_credits_earned(&self) -> u32 {
        self.reward_credits_earned.unwrap_or(0)
    }

    pub fn clear_reward_credits_earned(&mut self) {
        self.reward_credits_earned = ::std::option::Option::None;
    }

    pub fn has_reward_credits_earned(&self) -> bool {
        self.reward_credits_earned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_credits_earned(&mut self, v: u32) {
        self.reward_credits_earned = ::std::option::Option::Some(v);
    }

    // optional bool contract_completed = 7;

    pub fn contract_completed(&self) -> bool {
        self.contract_completed.unwrap_or(false)
    }

    pub fn clear_contract_completed(&mut self) {
        self.contract_completed = ::std::option::Option::None;
    }

    pub fn has_contract_completed(&self) -> bool {
        self.contract_completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contract_completed(&mut self, v: bool) {
        self.contract_completed = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quest_id",
            |m: &CMsgQuestProgressReport| { &m.quest_id },
            |m: &mut CMsgQuestProgressReport| { &mut m.quest_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "star_0_earned",
            |m: &CMsgQuestProgressReport| { &m.star_0_earned },
            |m: &mut CMsgQuestProgressReport| { &mut m.star_0_earned },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "star_1_earned",
            |m: &CMsgQuestProgressReport| { &m.star_1_earned },
            |m: &mut CMsgQuestProgressReport| { &mut m.star_1_earned },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "star_2_earned",
            |m: &CMsgQuestProgressReport| { &m.star_2_earned },
            |m: &mut CMsgQuestProgressReport| { &mut m.star_2_earned },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items_earned",
            |m: &CMsgQuestProgressReport| { &m.items_earned },
            |m: &mut CMsgQuestProgressReport| { &mut m.items_earned },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reward_credits_earned",
            |m: &CMsgQuestProgressReport| { &m.reward_credits_earned },
            |m: &mut CMsgQuestProgressReport| { &mut m.reward_credits_earned },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "contract_completed",
            |m: &CMsgQuestProgressReport| { &m.contract_completed },
            |m: &mut CMsgQuestProgressReport| { &mut m.contract_completed },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgQuestProgressReport>(
            "CMsgQuestProgressReport",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgQuestProgressReport {
    const NAME: &'static str = "CMsgQuestProgressReport";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.quest_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.star_0_earned = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.star_1_earned = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.star_2_earned = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    is.read_repeated_packed_uint64_into(&mut self.items_earned)?;
                },
                40 => {
                    self.items_earned.push(is.read_uint64()?);
                },
                48 => {
                    self.reward_credits_earned = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.contract_completed = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.star_0_earned {
            my_size += 1 + 1;
        }
        if let Some(v) = self.star_1_earned {
            my_size += 1 + 1;
        }
        if let Some(v) = self.star_2_earned {
            my_size += 1 + 1;
        }
        for value in &self.items_earned {
            my_size += ::protobuf::rt::uint64_size(5, *value);
        };
        if let Some(v) = self.reward_credits_earned {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.contract_completed {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.quest_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.star_0_earned {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.star_1_earned {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.star_2_earned {
            os.write_bool(4, v)?;
        }
        for v in &self.items_earned {
            os.write_uint64(5, *v)?;
        };
        if let Some(v) = self.reward_credits_earned {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.contract_completed {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgQuestProgressReport {
        CMsgQuestProgressReport::new()
    }

    fn clear(&mut self) {
        self.quest_id = ::std::option::Option::None;
        self.star_0_earned = ::std::option::Option::None;
        self.star_1_earned = ::std::option::Option::None;
        self.star_2_earned = ::std::option::Option::None;
        self.items_earned.clear();
        self.reward_credits_earned = ::std::option::Option::None;
        self.contract_completed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgQuestProgressReport {
        static instance: CMsgQuestProgressReport = CMsgQuestProgressReport {
            quest_id: ::std::option::Option::None,
            star_0_earned: ::std::option::Option::None,
            star_1_earned: ::std::option::Option::None,
            star_2_earned: ::std::option::Option::None,
            items_earned: ::std::vec::Vec::new(),
            reward_credits_earned: ::std::option::Option::None,
            contract_completed: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgQuestProgressReport {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgQuestProgressReport").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgQuestProgressReport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgQuestProgressReport {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgConsumePaintkit)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgConsumePaintkit {
    // message fields
    // @@protoc_insertion_point(field:CMsgConsumePaintkit.source_id)
    pub source_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgConsumePaintkit.target_defindex)
    pub target_defindex: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgConsumePaintkit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgConsumePaintkit {
    fn default() -> &'a CMsgConsumePaintkit {
        <CMsgConsumePaintkit as ::protobuf::Message>::default_instance()
    }
}

impl CMsgConsumePaintkit {
    pub fn new() -> CMsgConsumePaintkit {
        ::std::default::Default::default()
    }

    // optional fixed64 source_id = 1;

    pub fn source_id(&self) -> u64 {
        self.source_id.unwrap_or(0)
    }

    pub fn clear_source_id(&mut self) {
        self.source_id = ::std::option::Option::None;
    }

    pub fn has_source_id(&self) -> bool {
        self.source_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_id(&mut self, v: u64) {
        self.source_id = ::std::option::Option::Some(v);
    }

    // optional uint32 target_defindex = 2;

    pub fn target_defindex(&self) -> u32 {
        self.target_defindex.unwrap_or(0)
    }

    pub fn clear_target_defindex(&mut self) {
        self.target_defindex = ::std::option::Option::None;
    }

    pub fn has_target_defindex(&self) -> bool {
        self.target_defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_defindex(&mut self, v: u32) {
        self.target_defindex = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_id",
            |m: &CMsgConsumePaintkit| { &m.source_id },
            |m: &mut CMsgConsumePaintkit| { &mut m.source_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_defindex",
            |m: &CMsgConsumePaintkit| { &m.target_defindex },
            |m: &mut CMsgConsumePaintkit| { &mut m.target_defindex },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgConsumePaintkit>(
            "CMsgConsumePaintkit",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgConsumePaintkit {
    const NAME: &'static str = "CMsgConsumePaintkit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.source_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.target_defindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.source_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.target_defindex {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.source_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.target_defindex {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgConsumePaintkit {
        CMsgConsumePaintkit::new()
    }

    fn clear(&mut self) {
        self.source_id = ::std::option::Option::None;
        self.target_defindex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgConsumePaintkit {
        static instance: CMsgConsumePaintkit = CMsgConsumePaintkit {
            source_id: ::std::option::Option::None,
            target_defindex: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgConsumePaintkit {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgConsumePaintkit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgConsumePaintkit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgConsumePaintkit {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPainkitDevGrant)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPainkitDevGrant {
    // message fields
    // @@protoc_insertion_point(field:CMsgPainkitDevGrant.paintkit_defindex)
    pub paintkit_defindex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPainkitDevGrant.wear)
    pub wear: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgPainkitDevGrant.item_defindex)
    pub item_defindex: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPainkitDevGrant.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPainkitDevGrant {
    fn default() -> &'a CMsgPainkitDevGrant {
        <CMsgPainkitDevGrant as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPainkitDevGrant {
    pub fn new() -> CMsgPainkitDevGrant {
        ::std::default::Default::default()
    }

    // optional uint32 paintkit_defindex = 1;

    pub fn paintkit_defindex(&self) -> u32 {
        self.paintkit_defindex.unwrap_or(0)
    }

    pub fn clear_paintkit_defindex(&mut self) {
        self.paintkit_defindex = ::std::option::Option::None;
    }

    pub fn has_paintkit_defindex(&self) -> bool {
        self.paintkit_defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paintkit_defindex(&mut self, v: u32) {
        self.paintkit_defindex = ::std::option::Option::Some(v);
    }

    // optional float wear = 2;

    pub fn wear(&self) -> f32 {
        self.wear.unwrap_or(0.)
    }

    pub fn clear_wear(&mut self) {
        self.wear = ::std::option::Option::None;
    }

    pub fn has_wear(&self) -> bool {
        self.wear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wear(&mut self, v: f32) {
        self.wear = ::std::option::Option::Some(v);
    }

    // optional uint32 item_defindex = 3;

    pub fn item_defindex(&self) -> u32 {
        self.item_defindex.unwrap_or(0)
    }

    pub fn clear_item_defindex(&mut self) {
        self.item_defindex = ::std::option::Option::None;
    }

    pub fn has_item_defindex(&self) -> bool {
        self.item_defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_defindex(&mut self, v: u32) {
        self.item_defindex = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "paintkit_defindex",
            |m: &CMsgPainkitDevGrant| { &m.paintkit_defindex },
            |m: &mut CMsgPainkitDevGrant| { &mut m.paintkit_defindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "wear",
            |m: &CMsgPainkitDevGrant| { &m.wear },
            |m: &mut CMsgPainkitDevGrant| { &mut m.wear },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_defindex",
            |m: &CMsgPainkitDevGrant| { &m.item_defindex },
            |m: &mut CMsgPainkitDevGrant| { &mut m.item_defindex },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPainkitDevGrant>(
            "CMsgPainkitDevGrant",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPainkitDevGrant {
    const NAME: &'static str = "CMsgPainkitDevGrant";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.paintkit_defindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.wear = ::std::option::Option::Some(is.read_float()?);
                },
                24 => {
                    self.item_defindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.paintkit_defindex {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.wear {
            my_size += 1 + 4;
        }
        if let Some(v) = self.item_defindex {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.paintkit_defindex {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.wear {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.item_defindex {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPainkitDevGrant {
        CMsgPainkitDevGrant::new()
    }

    fn clear(&mut self) {
        self.paintkit_defindex = ::std::option::Option::None;
        self.wear = ::std::option::Option::None;
        self.item_defindex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPainkitDevGrant {
        static instance: CMsgPainkitDevGrant = CMsgPainkitDevGrant {
            paintkit_defindex: ::std::option::Option::None,
            wear: ::std::option::Option::None,
            item_defindex: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPainkitDevGrant {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPainkitDevGrant").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPainkitDevGrant {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPainkitDevGrant {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GCQuestStrangeEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GCQuestStrangeEvent {
    // message fields
    // @@protoc_insertion_point(field:GCQuestStrangeEvent.owner_account_id)
    pub owner_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:GCQuestStrangeEvent.scorer_account_id)
    pub scorer_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:GCQuestStrangeEvent.quest_id)
    pub quest_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:GCQuestStrangeEvent.strange_event_id)
    pub strange_event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:GCQuestStrangeEvent.score)
    pub score: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:GCQuestStrangeEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GCQuestStrangeEvent {
    fn default() -> &'a GCQuestStrangeEvent {
        <GCQuestStrangeEvent as ::protobuf::Message>::default_instance()
    }
}

impl GCQuestStrangeEvent {
    pub fn new() -> GCQuestStrangeEvent {
        ::std::default::Default::default()
    }

    // optional uint32 owner_account_id = 1;

    pub fn owner_account_id(&self) -> u32 {
        self.owner_account_id.unwrap_or(0)
    }

    pub fn clear_owner_account_id(&mut self) {
        self.owner_account_id = ::std::option::Option::None;
    }

    pub fn has_owner_account_id(&self) -> bool {
        self.owner_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_account_id(&mut self, v: u32) {
        self.owner_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 scorer_account_id = 2;

    pub fn scorer_account_id(&self) -> u32 {
        self.scorer_account_id.unwrap_or(0)
    }

    pub fn clear_scorer_account_id(&mut self) {
        self.scorer_account_id = ::std::option::Option::None;
    }

    pub fn has_scorer_account_id(&self) -> bool {
        self.scorer_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scorer_account_id(&mut self, v: u32) {
        self.scorer_account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 quest_id = 3;

    pub fn quest_id(&self) -> u64 {
        self.quest_id.unwrap_or(0)
    }

    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u64) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    // optional uint32 strange_event_id = 4;

    pub fn strange_event_id(&self) -> u32 {
        self.strange_event_id.unwrap_or(0)
    }

    pub fn clear_strange_event_id(&mut self) {
        self.strange_event_id = ::std::option::Option::None;
    }

    pub fn has_strange_event_id(&self) -> bool {
        self.strange_event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strange_event_id(&mut self, v: u32) {
        self.strange_event_id = ::std::option::Option::Some(v);
    }

    // optional uint32 score = 5;

    pub fn score(&self) -> u32 {
        self.score.unwrap_or(0)
    }

    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: u32) {
        self.score = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "owner_account_id",
            |m: &GCQuestStrangeEvent| { &m.owner_account_id },
            |m: &mut GCQuestStrangeEvent| { &mut m.owner_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scorer_account_id",
            |m: &GCQuestStrangeEvent| { &m.scorer_account_id },
            |m: &mut GCQuestStrangeEvent| { &mut m.scorer_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quest_id",
            |m: &GCQuestStrangeEvent| { &m.quest_id },
            |m: &mut GCQuestStrangeEvent| { &mut m.quest_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "strange_event_id",
            |m: &GCQuestStrangeEvent| { &m.strange_event_id },
            |m: &mut GCQuestStrangeEvent| { &mut m.strange_event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "score",
            |m: &GCQuestStrangeEvent| { &m.score },
            |m: &mut GCQuestStrangeEvent| { &mut m.score },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GCQuestStrangeEvent>(
            "GCQuestStrangeEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GCQuestStrangeEvent {
    const NAME: &'static str = "GCQuestStrangeEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.owner_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.scorer_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.quest_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.strange_event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.score = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.owner_account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.scorer_account_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.quest_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.strange_event_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.owner_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scorer_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.quest_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.strange_event_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.score {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GCQuestStrangeEvent {
        GCQuestStrangeEvent::new()
    }

    fn clear(&mut self) {
        self.owner_account_id = ::std::option::Option::None;
        self.scorer_account_id = ::std::option::Option::None;
        self.quest_id = ::std::option::Option::None;
        self.strange_event_id = ::std::option::Option::None;
        self.score = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GCQuestStrangeEvent {
        static instance: GCQuestStrangeEvent = GCQuestStrangeEvent {
            owner_account_id: ::std::option::Option::None,
            scorer_account_id: ::std::option::Option::None,
            quest_id: ::std::option::Option::None,
            strange_event_id: ::std::option::Option::None,
            score: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GCQuestStrangeEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GCQuestStrangeEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GCQuestStrangeEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GCQuestStrangeEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSDRTicket)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSDRTicket {
    // message fields
    // @@protoc_insertion_point(field:CMsgSDRTicket.serialized_ticket)
    pub serialized_ticket: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSDRTicket.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSDRTicket {
    fn default() -> &'a CMsgSDRTicket {
        <CMsgSDRTicket as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSDRTicket {
    pub fn new() -> CMsgSDRTicket {
        ::std::default::Default::default()
    }

    // optional bytes serialized_ticket = 1;

    pub fn serialized_ticket(&self) -> &[u8] {
        match self.serialized_ticket.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_serialized_ticket(&mut self) {
        self.serialized_ticket = ::std::option::Option::None;
    }

    pub fn has_serialized_ticket(&self) -> bool {
        self.serialized_ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serialized_ticket(&mut self, v: ::std::vec::Vec<u8>) {
        self.serialized_ticket = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serialized_ticket(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.serialized_ticket.is_none() {
            self.serialized_ticket = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.serialized_ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_serialized_ticket(&mut self) -> ::std::vec::Vec<u8> {
        self.serialized_ticket.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serialized_ticket",
            |m: &CMsgSDRTicket| { &m.serialized_ticket },
            |m: &mut CMsgSDRTicket| { &mut m.serialized_ticket },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSDRTicket>(
            "CMsgSDRTicket",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSDRTicket {
    const NAME: &'static str = "CMsgSDRTicket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.serialized_ticket = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.serialized_ticket.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.serialized_ticket.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSDRTicket {
        CMsgSDRTicket::new()
    }

    fn clear(&mut self) {
        self.serialized_ticket = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSDRTicket {
        static instance: CMsgSDRTicket = CMsgSDRTicket {
            serialized_ticket: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSDRTicket {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSDRTicket").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSDRTicket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSDRTicket {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ETFGCMsg)
pub enum ETFGCMsg {
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCReportWarKill)
    k_EMsgGCReportWarKill = 5001,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCKickPlayer_DEPRECATED)
    k_EMsgGCKickPlayer_DEPRECATED = 5020,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCStartedTraining_DEPRECATED)
    k_EMsgGCStartedTraining_DEPRECATED = 5021,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCFreeTrial_ChooseMostHelpfulFriend)
    k_EMsgGCFreeTrial_ChooseMostHelpfulFriend = 5022,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCRequestTF2Friends)
    k_EMsgGCRequestTF2Friends = 5023,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCRequestTF2FriendsResponse)
    k_EMsgGCRequestTF2FriendsResponse = 5024,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCReplay_SubmitContestEntry)
    k_EMsgGCReplay_SubmitContestEntry = 5026,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCReplay_SubmitContestEntryResponse)
    k_EMsgGCReplay_SubmitContestEntryResponse = 5027,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCSaxxy_Awarded)
    k_EMsgGCSaxxy_Awarded = 5029,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCFreeTrial_ThankedBySomeone)
    k_EMsgGCFreeTrial_ThankedBySomeone = 5028,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCFreeTrial_ThankedSomeone)
    k_EMsgGCFreeTrial_ThankedSomeone = 5030,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCFreeTrial_ConvertedToPremium)
    k_EMsgGCFreeTrial_ConvertedToPremium = 5031,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCMeetThePyroSilliness_BananaCraft_DEPRECATED)
    k_EMsgGCMeetThePyroSilliness_BananaCraft_DEPRECATED = 5032,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCMVMARG_HighFiveSuccessResponse_DEPRECATED)
    k_EMsgGCMVMARG_HighFiveSuccessResponse_DEPRECATED = 5033,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCMVMARG_HighFiveOnClient_DEPRECATED)
    k_EMsgGCMVMARG_HighFiveOnClient_DEPRECATED = 5034,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCCoaching_AddToCoaches)
    k_EMsgGCCoaching_AddToCoaches = 5200,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCCoaching_AddToCoachesResponse)
    k_EMsgGCCoaching_AddToCoachesResponse = 5201,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCCoaching_RemoveFromCoaches)
    k_EMsgGCCoaching_RemoveFromCoaches = 5202,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCCoaching_RemoveFromCoachesResponse)
    k_EMsgGCCoaching_RemoveFromCoachesResponse = 5203,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCCoaching_FindCoach)
    k_EMsgGCCoaching_FindCoach = 5204,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCCoaching_FindCoachResponse)
    k_EMsgGCCoaching_FindCoachResponse = 5205,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCCoaching_AskCoach)
    k_EMsgGCCoaching_AskCoach = 5206,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCCoaching_AskCoachResponse)
    k_EMsgGCCoaching_AskCoachResponse = 5207,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCCoaching_CoachJoinGame)
    k_EMsgGCCoaching_CoachJoinGame = 5208,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCCoaching_CoachJoining)
    k_EMsgGCCoaching_CoachJoining = 5209,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCCoaching_CoachJoined)
    k_EMsgGCCoaching_CoachJoined = 5210,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCCoaching_LikeCurrentCoach)
    k_EMsgGCCoaching_LikeCurrentCoach = 5211,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCCoaching_RemoveCurrentCoach)
    k_EMsgGCCoaching_RemoveCurrentCoach = 5212,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCCoaching_AlreadyRatedCoach)
    k_EMsgGCCoaching_AlreadyRatedCoach = 5213,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Duel_Request)
    k_EMsgGC_Duel_Request = 5500,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Duel_Response)
    k_EMsgGC_Duel_Response = 5501,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Duel_Results)
    k_EMsgGC_Duel_Results = 5502,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Duel_Status)
    k_EMsgGC_Duel_Status = 5503,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Halloween_ReservedItem_DEPRECATED)
    k_EMsgGC_Halloween_ReservedItem_DEPRECATED = 5600,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Halloween_GrantItem_DEPRECATED)
    k_EMsgGC_Halloween_GrantItem_DEPRECATED = 5601,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Halloween_GrantItemResponse_DEPRECATED)
    k_EMsgGC_Halloween_GrantItemResponse_DEPRECATED = 5604,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Halloween_Cheat_QueryResponse_DEPRECATED)
    k_EMsgGC_Halloween_Cheat_QueryResponse_DEPRECATED = 5605,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Halloween_ItemClaimed_DEPRECATED)
    k_EMsgGC_Halloween_ItemClaimed_DEPRECATED = 5606,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Halloween_ReservedItem)
    k_EMsgGC_Halloween_ReservedItem = 5607,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Halloween_GrantItem)
    k_EMsgGC_Halloween_GrantItem = 5608,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Halloween_GrantItemResponse)
    k_EMsgGC_Halloween_GrantItemResponse = 5609,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Halloween_Cheat_QueryResponse_DEPRECATED_2)
    k_EMsgGC_Halloween_Cheat_QueryResponse_DEPRECATED_2 = 5610,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Halloween_ItemClaimed_DEPRECATED_2)
    k_EMsgGC_Halloween_ItemClaimed_DEPRECATED_2 = 5611,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Halloween_ServerBossEvent)
    k_EMsgGC_Halloween_ServerBossEvent = 5612,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Halloween_Merasmus2012)
    k_EMsgGC_Halloween_Merasmus2012 = 5613,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Halloween_UpdateMerasmusLootLevel)
    k_EMsgGC_Halloween_UpdateMerasmusLootLevel = 5614,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_GameServer_LevelInfo)
    k_EMsgGC_GameServer_LevelInfo = 5700,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_GameServer_AuthChallenge)
    k_EMsgGC_GameServer_AuthChallenge = 5701,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_GameServer_AuthChallengeResponse)
    k_EMsgGC_GameServer_AuthChallengeResponse = 5702,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_GameServer_CreateIdentity)
    k_EMsgGC_GameServer_CreateIdentity = 5703,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_GameServer_CreateIdentityResponse)
    k_EMsgGC_GameServer_CreateIdentityResponse = 5704,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_GameServer_List)
    k_EMsgGC_GameServer_List = 5705,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_GameServer_ListResponse)
    k_EMsgGC_GameServer_ListResponse = 5706,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_GameServer_AuthResult)
    k_EMsgGC_GameServer_AuthResult = 5707,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_GameServer_ResetIdentity)
    k_EMsgGC_GameServer_ResetIdentity = 5708,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_GameServer_ResetIdentityResponse)
    k_EMsgGC_GameServer_ResetIdentityResponse = 5709,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Client_UseServerModificationItem)
    k_EMsgGC_Client_UseServerModificationItem = 5710,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Client_UseServerModificationItem_Response)
    k_EMsgGC_Client_UseServerModificationItem_Response = 5711,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_GameServer_UseServerModificationItem)
    k_EMsgGC_GameServer_UseServerModificationItem = 5712,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_GameServer_UseServerModificationItem_Response)
    k_EMsgGC_GameServer_UseServerModificationItem_Response = 5713,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_GameServer_ServerModificationItemExpired)
    k_EMsgGC_GameServer_ServerModificationItemExpired = 5714,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_GameServer_ModificationItemState)
    k_EMsgGC_GameServer_ModificationItemState = 5715,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_GameServer_AckPolicy)
    k_EMsgGC_GameServer_AckPolicy = 5716,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_GameServer_AckPolicyResponse)
    k_EMsgGC_GameServer_AckPolicyResponse = 5717,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_QP_ScoreServers)
    k_EMsgGC_QP_ScoreServers = 5800,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_QP_ScoreServersResponse)
    k_EMsgGC_QP_ScoreServersResponse = 5801,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_QP_PlayerJoining)
    k_EMsgGC_QP_PlayerJoining = 5802,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_PickupItemEligibility_Query_DEPRECATED)
    k_EMsgGC_PickupItemEligibility_Query_DEPRECATED = 6000,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_PickupItemEligibility_Query_DEPRECATED_2)
    k_EMsgGC_PickupItemEligibility_Query_DEPRECATED_2 = 6001,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_IncrementKillCountAttribute_DEPRECATED)
    k_EMsgGC_IncrementKillCountAttribute_DEPRECATED = 6100,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_IncrementKillCountResponse_DEPRECATED)
    k_EMsgGC_IncrementKillCountResponse_DEPRECATED = 6101,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCAbandonCurrentGame)
    k_EMsgGCAbandonCurrentGame = 6235,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgForceSOCacheResend)
    k_EMsgForceSOCacheResend = 6237,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCRequestChatChannelList)
    k_EMsgGCRequestChatChannelList = 6260,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCRequestChatChannelListResponse)
    k_EMsgGCRequestChatChannelListResponse = 6261,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCReadyUp)
    k_EMsgGCReadyUp = 6270,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCKickedFromMatchmakingQueue)
    k_EMsgGCKickedFromMatchmakingQueue = 6271,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCLeaverDetected)
    k_EMsgGCLeaverDetected = 6272,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCLeaverDetectedResponse)
    k_EMsgGCLeaverDetectedResponse = 6287,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCExitMatchmaking)
    k_EMsgGCExitMatchmaking = 6289,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCMatchmakingProgress)
    k_EMsgGCMatchmakingProgress = 6293,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCMvMVictoryInfo)
    k_EMsgGCMvMVictoryInfo = 6294,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCGameServerMatchmakingStatus)
    k_EMsgGCGameServerMatchmakingStatus = 6295,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCMvMVictory)
    k_EMsgGCMvMVictory = 6297,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCMvMVictoryReply)
    k_EMsgGCMvMVictoryReply = 6298,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCGameServerKickingLobby)
    k_EMsgGCGameServerKickingLobby = 6299,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCLeaveGameAndPrepareToJoinParty)
    k_EMsgGCLeaveGameAndPrepareToJoinParty = 6300,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_UpdatePeriodicEvent)
    k_EMsgGC_UpdatePeriodicEvent = 6400,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_DuckLeaderboard_IndividualUpdate)
    k_EMsgGC_DuckLeaderboard_IndividualUpdate = 6401,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Client2GCEconPreviewDataBlockRequest)
    k_EMsgGC_Client2GCEconPreviewDataBlockRequest = 6402,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Client2GCEconPreviewDataBlockResponse)
    k_EMsgGC_Client2GCEconPreviewDataBlockResponse = 6403,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_ClientVerificationChallenge)
    k_EMsgGC_ClientVerificationChallenge = 6500,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_ClientVerificationChallengeResponse)
    k_EMsgGC_ClientVerificationChallengeResponse = 6501,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_ClientVerificationVerboseResponse)
    k_EMsgGC_ClientVerificationVerboseResponse = 6502,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_ClientSetItemSlotAttribute)
    k_EMsgGC_ClientSetItemSlotAttribute = 6503,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_War_IndividualUpdate)
    k_EMsgGC_War_IndividualUpdate = 6505,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_War_JoinWar)
    k_EMsgGC_War_JoinWar = 6506,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_War_RequestGlobalStats)
    k_EMsgGC_War_RequestGlobalStats = 6507,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_War_GlobalStatsResponse)
    k_EMsgGC_War_GlobalStatsResponse = 6508,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_WorldItemPlacement_Attribute)
    k_EMsgGC_WorldItemPlacement_Attribute = 6510,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_WorldItemPlacement_Update)
    k_EMsgGC_WorldItemPlacement_Update = 6511,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Match_Result)
    k_EMsgGC_Match_Result = 6512,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCVoteKickPlayerRequest)
    k_EMsgGCVoteKickPlayerRequest = 6513,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCVoteKickPlayerRequestResponse)
    k_EMsgGCVoteKickPlayerRequestResponse = 6514,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_DailyCompetitiveStatsRollup)
    k_EMsgGC_DailyCompetitiveStatsRollup = 6516,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_DailyCompetitiveStatsRollup_Response)
    k_EMsgGC_DailyCompetitiveStatsRollup_Response = 6517,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_WorldStatusBroadcast)
    k_EMsgGC_WorldStatusBroadcast = 6518,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_ReportPlayer)
    k_EMsgGC_ReportPlayer = 6519,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Match_ResultResponse)
    k_EMsgGC_Match_ResultResponse = 6520,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCGameServerKickingLobbyResponse)
    k_EMsgGCGameServerKickingLobbyResponse = 6521,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCPlayerLeftMatch)
    k_EMsgGCPlayerLeftMatch = 6522,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCPlayerLeftMatchResponse)
    k_EMsgGCPlayerLeftMatchResponse = 6523,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCRequestMatchMakerStats)
    k_EMsgGCRequestMatchMakerStats = 6524,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCMatchMakerStatsResponse)
    k_EMsgGCMatchMakerStatsResponse = 6525,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCMatchHistoryLoad)
    k_EMsgGCMatchHistoryLoad = 6526,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_AcknowledgeXP)
    k_EMsgGC_AcknowledgeXP = 6527,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCDataCenterPing_Update)
    k_EMsgGCDataCenterPing_Update = 6528,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_NotificationAcknowledge)
    k_EMsgGC_NotificationAcknowledge = 6529,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_NotificationAcknowledgeReply)
    k_EMsgGC_NotificationAcknowledgeReply = 6530,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_KickPlayerFromLobby)
    k_EMsgGC_KickPlayerFromLobby = 6531,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_SurveyQuestionRequest)
    k_EMsgGC_SurveyQuestionRequest = 6534,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_SurveyQuestionResponse)
    k_EMsgGC_SurveyQuestionResponse = 6535,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_TFClientInit)
    k_EMsgGC_TFClientInit = 6536,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_NewMatchForLobbyRequest)
    k_EMsgGC_NewMatchForLobbyRequest = 6537,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_NewMatchForLobbyResponse)
    k_EMsgGC_NewMatchForLobbyResponse = 6538,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_ChangeMatchPlayerTeamsRequest)
    k_EMsgGC_ChangeMatchPlayerTeamsRequest = 6539,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_ChangeMatchPlayerTeamsResponse)
    k_EMsgGC_ChangeMatchPlayerTeamsResponse = 6540,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_QuestIdentify)
    k_EMsgGC_QuestIdentify = 6541,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_QuestDevGive)
    k_EMsgGC_QuestDevGive = 6542,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCQuestComplete_Debug)
    k_EMsgGCQuestComplete_Debug = 6544,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_QuestMapDebug)
    k_EMsgGC_QuestMapDebug = 6545,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_QuestMapUnlockNode)
    k_EMsgGC_QuestMapUnlockNode = 6547,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_QuestMapPurchaseReward)
    k_EMsgGC_QuestMapPurchaseReward = 6549,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_SetDisablePartyQuestProgress)
    k_EMsgGC_SetDisablePartyQuestProgress = 6550,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCQuestProgressReport)
    k_EMsgGCQuestProgressReport = 6553,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_SetOptions)
    k_EMsgGCParty_SetOptions = 6554,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_SetOptionsResponse)
    k_EMsgGCParty_SetOptionsResponse = 6555,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_QueueForMatch)
    k_EMsgGCParty_QueueForMatch = 6556,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_QueueForMatchResponse)
    k_EMsgGCParty_QueueForMatchResponse = 6557,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_RemoveFromQueue)
    k_EMsgGCParty_RemoveFromQueue = 6558,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_RemoveFromQueueResponse)
    k_EMsgGCParty_RemoveFromQueueResponse = 6559,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_InvitePlayer)
    k_EMsgGCParty_InvitePlayer = 6560,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_RequestJoinPlayer)
    k_EMsgGCParty_RequestJoinPlayer = 6561,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_SendChat)
    k_EMsgGCParty_SendChat = 6562,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_ChatMsg)
    k_EMsgGCParty_ChatMsg = 6563,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCQuestNodeTurnIn)
    k_EMsgGCQuestNodeTurnIn = 6564,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCConsumePaintKit)
    k_EMsgGCConsumePaintKit = 6565,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Painkit_DevGrant)
    k_EMsgGC_Painkit_DevGrant = 6566,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_QueueForStandby)
    k_EMsgGCParty_QueueForStandby = 6567,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_QueueForStandbyResponse)
    k_EMsgGCParty_QueueForStandbyResponse = 6568,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_RemoveFromStandbyQueue)
    k_EMsgGCParty_RemoveFromStandbyQueue = 6569,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_RemoveFromStandbyQueueResponse)
    k_EMsgGCParty_RemoveFromStandbyQueueResponse = 6570,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_ClearPendingPlayer)
    k_EMsgGCParty_ClearPendingPlayer = 6571,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_ClearPendingPlayerResponse)
    k_EMsgGCParty_ClearPendingPlayerResponse = 6572,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_ClearOtherPartyRequest)
    k_EMsgGCParty_ClearOtherPartyRequest = 6573,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_ClearOtherPartyRequestResponse)
    k_EMsgGCParty_ClearOtherPartyRequestResponse = 6574,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_PromoteToLeader)
    k_EMsgGCParty_PromoteToLeader = 6575,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_KickMember)
    k_EMsgGCParty_KickMember = 6576,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCQuestStrangeEvent)
    k_EMsgGCQuestStrangeEvent = 6577,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_AcceptLobbyInvite)
    k_EMsgGC_AcceptLobbyInvite = 6578,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_AcceptLobbyInviteReply)
    k_EMsgGC_AcceptLobbyInviteReply = 6579,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_SDRTicket)
    k_EMsgGC_SDRTicket = 6580,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_ProcessMatchVoteKick)
    k_EMsgGC_ProcessMatchVoteKick = 6581,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_ProcessMatchVoteKickResponse)
    k_EMsgGC_ProcessMatchVoteKickResponse = 6582,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCDev_GrantWarKill)
    k_EMsgGCDev_GrantWarKill = 10001,
}

impl ::protobuf::Enum for ETFGCMsg {
    const NAME: &'static str = "ETFGCMsg";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ETFGCMsg> {
        match value {
            5001 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCReportWarKill),
            5020 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCKickPlayer_DEPRECATED),
            5021 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCStartedTraining_DEPRECATED),
            5022 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCFreeTrial_ChooseMostHelpfulFriend),
            5023 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCRequestTF2Friends),
            5024 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCRequestTF2FriendsResponse),
            5026 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCReplay_SubmitContestEntry),
            5027 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCReplay_SubmitContestEntryResponse),
            5029 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCSaxxy_Awarded),
            5028 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCFreeTrial_ThankedBySomeone),
            5030 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCFreeTrial_ThankedSomeone),
            5031 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCFreeTrial_ConvertedToPremium),
            5032 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMeetThePyroSilliness_BananaCraft_DEPRECATED),
            5033 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMVMARG_HighFiveSuccessResponse_DEPRECATED),
            5034 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMVMARG_HighFiveOnClient_DEPRECATED),
            5200 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_AddToCoaches),
            5201 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_AddToCoachesResponse),
            5202 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_RemoveFromCoaches),
            5203 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_RemoveFromCoachesResponse),
            5204 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_FindCoach),
            5205 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_FindCoachResponse),
            5206 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_AskCoach),
            5207 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_AskCoachResponse),
            5208 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_CoachJoinGame),
            5209 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_CoachJoining),
            5210 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_CoachJoined),
            5211 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_LikeCurrentCoach),
            5212 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_RemoveCurrentCoach),
            5213 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_AlreadyRatedCoach),
            5500 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Duel_Request),
            5501 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Duel_Response),
            5502 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Duel_Results),
            5503 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Duel_Status),
            5600 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_ReservedItem_DEPRECATED),
            5601 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_GrantItem_DEPRECATED),
            5604 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_GrantItemResponse_DEPRECATED),
            5605 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_Cheat_QueryResponse_DEPRECATED),
            5606 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_ItemClaimed_DEPRECATED),
            5607 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_ReservedItem),
            5608 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_GrantItem),
            5609 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_GrantItemResponse),
            5610 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_Cheat_QueryResponse_DEPRECATED_2),
            5611 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_ItemClaimed_DEPRECATED_2),
            5612 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_ServerBossEvent),
            5613 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_Merasmus2012),
            5614 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_UpdateMerasmusLootLevel),
            5700 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_LevelInfo),
            5701 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_AuthChallenge),
            5702 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_AuthChallengeResponse),
            5703 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_CreateIdentity),
            5704 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_CreateIdentityResponse),
            5705 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_List),
            5706 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_ListResponse),
            5707 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_AuthResult),
            5708 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_ResetIdentity),
            5709 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_ResetIdentityResponse),
            5710 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Client_UseServerModificationItem),
            5711 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Client_UseServerModificationItem_Response),
            5712 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_UseServerModificationItem),
            5713 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_UseServerModificationItem_Response),
            5714 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_ServerModificationItemExpired),
            5715 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_ModificationItemState),
            5716 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_AckPolicy),
            5717 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_AckPolicyResponse),
            5800 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QP_ScoreServers),
            5801 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QP_ScoreServersResponse),
            5802 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QP_PlayerJoining),
            6000 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_PickupItemEligibility_Query_DEPRECATED),
            6001 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_PickupItemEligibility_Query_DEPRECATED_2),
            6100 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_IncrementKillCountAttribute_DEPRECATED),
            6101 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_IncrementKillCountResponse_DEPRECATED),
            6235 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCAbandonCurrentGame),
            6237 => ::std::option::Option::Some(ETFGCMsg::k_EMsgForceSOCacheResend),
            6260 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCRequestChatChannelList),
            6261 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCRequestChatChannelListResponse),
            6270 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCReadyUp),
            6271 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCKickedFromMatchmakingQueue),
            6272 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCLeaverDetected),
            6287 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCLeaverDetectedResponse),
            6289 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCExitMatchmaking),
            6293 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMatchmakingProgress),
            6294 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMvMVictoryInfo),
            6295 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCGameServerMatchmakingStatus),
            6297 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMvMVictory),
            6298 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMvMVictoryReply),
            6299 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCGameServerKickingLobby),
            6300 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCLeaveGameAndPrepareToJoinParty),
            6400 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_UpdatePeriodicEvent),
            6401 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_DuckLeaderboard_IndividualUpdate),
            6402 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Client2GCEconPreviewDataBlockRequest),
            6403 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Client2GCEconPreviewDataBlockResponse),
            6500 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ClientVerificationChallenge),
            6501 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ClientVerificationChallengeResponse),
            6502 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ClientVerificationVerboseResponse),
            6503 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ClientSetItemSlotAttribute),
            6505 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_War_IndividualUpdate),
            6506 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_War_JoinWar),
            6507 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_War_RequestGlobalStats),
            6508 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_War_GlobalStatsResponse),
            6510 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_WorldItemPlacement_Attribute),
            6511 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_WorldItemPlacement_Update),
            6512 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Match_Result),
            6513 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCVoteKickPlayerRequest),
            6514 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCVoteKickPlayerRequestResponse),
            6516 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_DailyCompetitiveStatsRollup),
            6517 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_DailyCompetitiveStatsRollup_Response),
            6518 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_WorldStatusBroadcast),
            6519 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ReportPlayer),
            6520 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Match_ResultResponse),
            6521 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCGameServerKickingLobbyResponse),
            6522 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCPlayerLeftMatch),
            6523 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCPlayerLeftMatchResponse),
            6524 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCRequestMatchMakerStats),
            6525 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMatchMakerStatsResponse),
            6526 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMatchHistoryLoad),
            6527 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_AcknowledgeXP),
            6528 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCDataCenterPing_Update),
            6529 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_NotificationAcknowledge),
            6530 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_NotificationAcknowledgeReply),
            6531 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_KickPlayerFromLobby),
            6534 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_SurveyQuestionRequest),
            6535 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_SurveyQuestionResponse),
            6536 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_TFClientInit),
            6537 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_NewMatchForLobbyRequest),
            6538 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_NewMatchForLobbyResponse),
            6539 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ChangeMatchPlayerTeamsRequest),
            6540 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ChangeMatchPlayerTeamsResponse),
            6541 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QuestIdentify),
            6542 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QuestDevGive),
            6544 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCQuestComplete_Debug),
            6545 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QuestMapDebug),
            6547 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QuestMapUnlockNode),
            6549 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QuestMapPurchaseReward),
            6550 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_SetDisablePartyQuestProgress),
            6553 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCQuestProgressReport),
            6554 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_SetOptions),
            6555 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_SetOptionsResponse),
            6556 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_QueueForMatch),
            6557 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_QueueForMatchResponse),
            6558 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_RemoveFromQueue),
            6559 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_RemoveFromQueueResponse),
            6560 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_InvitePlayer),
            6561 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_RequestJoinPlayer),
            6562 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_SendChat),
            6563 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_ChatMsg),
            6564 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCQuestNodeTurnIn),
            6565 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCConsumePaintKit),
            6566 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Painkit_DevGrant),
            6567 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_QueueForStandby),
            6568 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_QueueForStandbyResponse),
            6569 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_RemoveFromStandbyQueue),
            6570 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_RemoveFromStandbyQueueResponse),
            6571 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_ClearPendingPlayer),
            6572 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_ClearPendingPlayerResponse),
            6573 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_ClearOtherPartyRequest),
            6574 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_ClearOtherPartyRequestResponse),
            6575 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_PromoteToLeader),
            6576 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_KickMember),
            6577 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCQuestStrangeEvent),
            6578 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_AcceptLobbyInvite),
            6579 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_AcceptLobbyInviteReply),
            6580 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_SDRTicket),
            6581 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ProcessMatchVoteKick),
            6582 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ProcessMatchVoteKickResponse),
            10001 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCDev_GrantWarKill),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ETFGCMsg> {
        match str {
            "k_EMsgGCReportWarKill" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCReportWarKill),
            "k_EMsgGCKickPlayer_DEPRECATED" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCKickPlayer_DEPRECATED),
            "k_EMsgGCStartedTraining_DEPRECATED" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCStartedTraining_DEPRECATED),
            "k_EMsgGCFreeTrial_ChooseMostHelpfulFriend" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCFreeTrial_ChooseMostHelpfulFriend),
            "k_EMsgGCRequestTF2Friends" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCRequestTF2Friends),
            "k_EMsgGCRequestTF2FriendsResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCRequestTF2FriendsResponse),
            "k_EMsgGCReplay_SubmitContestEntry" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCReplay_SubmitContestEntry),
            "k_EMsgGCReplay_SubmitContestEntryResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCReplay_SubmitContestEntryResponse),
            "k_EMsgGCSaxxy_Awarded" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCSaxxy_Awarded),
            "k_EMsgGCFreeTrial_ThankedBySomeone" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCFreeTrial_ThankedBySomeone),
            "k_EMsgGCFreeTrial_ThankedSomeone" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCFreeTrial_ThankedSomeone),
            "k_EMsgGCFreeTrial_ConvertedToPremium" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCFreeTrial_ConvertedToPremium),
            "k_EMsgGCMeetThePyroSilliness_BananaCraft_DEPRECATED" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMeetThePyroSilliness_BananaCraft_DEPRECATED),
            "k_EMsgGCMVMARG_HighFiveSuccessResponse_DEPRECATED" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMVMARG_HighFiveSuccessResponse_DEPRECATED),
            "k_EMsgGCMVMARG_HighFiveOnClient_DEPRECATED" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMVMARG_HighFiveOnClient_DEPRECATED),
            "k_EMsgGCCoaching_AddToCoaches" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_AddToCoaches),
            "k_EMsgGCCoaching_AddToCoachesResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_AddToCoachesResponse),
            "k_EMsgGCCoaching_RemoveFromCoaches" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_RemoveFromCoaches),
            "k_EMsgGCCoaching_RemoveFromCoachesResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_RemoveFromCoachesResponse),
            "k_EMsgGCCoaching_FindCoach" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_FindCoach),
            "k_EMsgGCCoaching_FindCoachResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_FindCoachResponse),
            "k_EMsgGCCoaching_AskCoach" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_AskCoach),
            "k_EMsgGCCoaching_AskCoachResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_AskCoachResponse),
            "k_EMsgGCCoaching_CoachJoinGame" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_CoachJoinGame),
            "k_EMsgGCCoaching_CoachJoining" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_CoachJoining),
            "k_EMsgGCCoaching_CoachJoined" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_CoachJoined),
            "k_EMsgGCCoaching_LikeCurrentCoach" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_LikeCurrentCoach),
            "k_EMsgGCCoaching_RemoveCurrentCoach" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_RemoveCurrentCoach),
            "k_EMsgGCCoaching_AlreadyRatedCoach" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_AlreadyRatedCoach),
            "k_EMsgGC_Duel_Request" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Duel_Request),
            "k_EMsgGC_Duel_Response" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Duel_Response),
            "k_EMsgGC_Duel_Results" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Duel_Results),
            "k_EMsgGC_Duel_Status" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Duel_Status),
            "k_EMsgGC_Halloween_ReservedItem_DEPRECATED" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_ReservedItem_DEPRECATED),
            "k_EMsgGC_Halloween_GrantItem_DEPRECATED" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_GrantItem_DEPRECATED),
            "k_EMsgGC_Halloween_GrantItemResponse_DEPRECATED" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_GrantItemResponse_DEPRECATED),
            "k_EMsgGC_Halloween_Cheat_QueryResponse_DEPRECATED" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_Cheat_QueryResponse_DEPRECATED),
            "k_EMsgGC_Halloween_ItemClaimed_DEPRECATED" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_ItemClaimed_DEPRECATED),
            "k_EMsgGC_Halloween_ReservedItem" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_ReservedItem),
            "k_EMsgGC_Halloween_GrantItem" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_GrantItem),
            "k_EMsgGC_Halloween_GrantItemResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_GrantItemResponse),
            "k_EMsgGC_Halloween_Cheat_QueryResponse_DEPRECATED_2" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_Cheat_QueryResponse_DEPRECATED_2),
            "k_EMsgGC_Halloween_ItemClaimed_DEPRECATED_2" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_ItemClaimed_DEPRECATED_2),
            "k_EMsgGC_Halloween_ServerBossEvent" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_ServerBossEvent),
            "k_EMsgGC_Halloween_Merasmus2012" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_Merasmus2012),
            "k_EMsgGC_Halloween_UpdateMerasmusLootLevel" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_UpdateMerasmusLootLevel),
            "k_EMsgGC_GameServer_LevelInfo" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_LevelInfo),
            "k_EMsgGC_GameServer_AuthChallenge" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_AuthChallenge),
            "k_EMsgGC_GameServer_AuthChallengeResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_AuthChallengeResponse),
            "k_EMsgGC_GameServer_CreateIdentity" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_CreateIdentity),
            "k_EMsgGC_GameServer_CreateIdentityResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_CreateIdentityResponse),
            "k_EMsgGC_GameServer_List" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_List),
            "k_EMsgGC_GameServer_ListResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_ListResponse),
            "k_EMsgGC_GameServer_AuthResult" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_AuthResult),
            "k_EMsgGC_GameServer_ResetIdentity" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_ResetIdentity),
            "k_EMsgGC_GameServer_ResetIdentityResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_ResetIdentityResponse),
            "k_EMsgGC_Client_UseServerModificationItem" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Client_UseServerModificationItem),
            "k_EMsgGC_Client_UseServerModificationItem_Response" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Client_UseServerModificationItem_Response),
            "k_EMsgGC_GameServer_UseServerModificationItem" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_UseServerModificationItem),
            "k_EMsgGC_GameServer_UseServerModificationItem_Response" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_UseServerModificationItem_Response),
            "k_EMsgGC_GameServer_ServerModificationItemExpired" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_ServerModificationItemExpired),
            "k_EMsgGC_GameServer_ModificationItemState" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_ModificationItemState),
            "k_EMsgGC_GameServer_AckPolicy" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_AckPolicy),
            "k_EMsgGC_GameServer_AckPolicyResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_AckPolicyResponse),
            "k_EMsgGC_QP_ScoreServers" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QP_ScoreServers),
            "k_EMsgGC_QP_ScoreServersResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QP_ScoreServersResponse),
            "k_EMsgGC_QP_PlayerJoining" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QP_PlayerJoining),
            "k_EMsgGC_PickupItemEligibility_Query_DEPRECATED" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_PickupItemEligibility_Query_DEPRECATED),
            "k_EMsgGC_PickupItemEligibility_Query_DEPRECATED_2" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_PickupItemEligibility_Query_DEPRECATED_2),
            "k_EMsgGC_IncrementKillCountAttribute_DEPRECATED" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_IncrementKillCountAttribute_DEPRECATED),
            "k_EMsgGC_IncrementKillCountResponse_DEPRECATED" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_IncrementKillCountResponse_DEPRECATED),
            "k_EMsgGCAbandonCurrentGame" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCAbandonCurrentGame),
            "k_EMsgForceSOCacheResend" => ::std::option::Option::Some(ETFGCMsg::k_EMsgForceSOCacheResend),
            "k_EMsgGCRequestChatChannelList" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCRequestChatChannelList),
            "k_EMsgGCRequestChatChannelListResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCRequestChatChannelListResponse),
            "k_EMsgGCReadyUp" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCReadyUp),
            "k_EMsgGCKickedFromMatchmakingQueue" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCKickedFromMatchmakingQueue),
            "k_EMsgGCLeaverDetected" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCLeaverDetected),
            "k_EMsgGCLeaverDetectedResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCLeaverDetectedResponse),
            "k_EMsgGCExitMatchmaking" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCExitMatchmaking),
            "k_EMsgGCMatchmakingProgress" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMatchmakingProgress),
            "k_EMsgGCMvMVictoryInfo" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMvMVictoryInfo),
            "k_EMsgGCGameServerMatchmakingStatus" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCGameServerMatchmakingStatus),
            "k_EMsgGCMvMVictory" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMvMVictory),
            "k_EMsgGCMvMVictoryReply" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMvMVictoryReply),
            "k_EMsgGCGameServerKickingLobby" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCGameServerKickingLobby),
            "k_EMsgGCLeaveGameAndPrepareToJoinParty" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCLeaveGameAndPrepareToJoinParty),
            "k_EMsgGC_UpdatePeriodicEvent" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_UpdatePeriodicEvent),
            "k_EMsgGC_DuckLeaderboard_IndividualUpdate" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_DuckLeaderboard_IndividualUpdate),
            "k_EMsgGC_Client2GCEconPreviewDataBlockRequest" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Client2GCEconPreviewDataBlockRequest),
            "k_EMsgGC_Client2GCEconPreviewDataBlockResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Client2GCEconPreviewDataBlockResponse),
            "k_EMsgGC_ClientVerificationChallenge" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ClientVerificationChallenge),
            "k_EMsgGC_ClientVerificationChallengeResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ClientVerificationChallengeResponse),
            "k_EMsgGC_ClientVerificationVerboseResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ClientVerificationVerboseResponse),
            "k_EMsgGC_ClientSetItemSlotAttribute" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ClientSetItemSlotAttribute),
            "k_EMsgGC_War_IndividualUpdate" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_War_IndividualUpdate),
            "k_EMsgGC_War_JoinWar" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_War_JoinWar),
            "k_EMsgGC_War_RequestGlobalStats" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_War_RequestGlobalStats),
            "k_EMsgGC_War_GlobalStatsResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_War_GlobalStatsResponse),
            "k_EMsgGC_WorldItemPlacement_Attribute" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_WorldItemPlacement_Attribute),
            "k_EMsgGC_WorldItemPlacement_Update" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_WorldItemPlacement_Update),
            "k_EMsgGC_Match_Result" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Match_Result),
            "k_EMsgGCVoteKickPlayerRequest" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCVoteKickPlayerRequest),
            "k_EMsgGCVoteKickPlayerRequestResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCVoteKickPlayerRequestResponse),
            "k_EMsgGC_DailyCompetitiveStatsRollup" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_DailyCompetitiveStatsRollup),
            "k_EMsgGC_DailyCompetitiveStatsRollup_Response" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_DailyCompetitiveStatsRollup_Response),
            "k_EMsgGC_WorldStatusBroadcast" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_WorldStatusBroadcast),
            "k_EMsgGC_ReportPlayer" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ReportPlayer),
            "k_EMsgGC_Match_ResultResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Match_ResultResponse),
            "k_EMsgGCGameServerKickingLobbyResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCGameServerKickingLobbyResponse),
            "k_EMsgGCPlayerLeftMatch" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCPlayerLeftMatch),
            "k_EMsgGCPlayerLeftMatchResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCPlayerLeftMatchResponse),
            "k_EMsgGCRequestMatchMakerStats" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCRequestMatchMakerStats),
            "k_EMsgGCMatchMakerStatsResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMatchMakerStatsResponse),
            "k_EMsgGCMatchHistoryLoad" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMatchHistoryLoad),
            "k_EMsgGC_AcknowledgeXP" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_AcknowledgeXP),
            "k_EMsgGCDataCenterPing_Update" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCDataCenterPing_Update),
            "k_EMsgGC_NotificationAcknowledge" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_NotificationAcknowledge),
            "k_EMsgGC_NotificationAcknowledgeReply" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_NotificationAcknowledgeReply),
            "k_EMsgGC_KickPlayerFromLobby" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_KickPlayerFromLobby),
            "k_EMsgGC_SurveyQuestionRequest" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_SurveyQuestionRequest),
            "k_EMsgGC_SurveyQuestionResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_SurveyQuestionResponse),
            "k_EMsgGC_TFClientInit" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_TFClientInit),
            "k_EMsgGC_NewMatchForLobbyRequest" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_NewMatchForLobbyRequest),
            "k_EMsgGC_NewMatchForLobbyResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_NewMatchForLobbyResponse),
            "k_EMsgGC_ChangeMatchPlayerTeamsRequest" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ChangeMatchPlayerTeamsRequest),
            "k_EMsgGC_ChangeMatchPlayerTeamsResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ChangeMatchPlayerTeamsResponse),
            "k_EMsgGC_QuestIdentify" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QuestIdentify),
            "k_EMsgGC_QuestDevGive" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QuestDevGive),
            "k_EMsgGCQuestComplete_Debug" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCQuestComplete_Debug),
            "k_EMsgGC_QuestMapDebug" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QuestMapDebug),
            "k_EMsgGC_QuestMapUnlockNode" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QuestMapUnlockNode),
            "k_EMsgGC_QuestMapPurchaseReward" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QuestMapPurchaseReward),
            "k_EMsgGC_SetDisablePartyQuestProgress" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_SetDisablePartyQuestProgress),
            "k_EMsgGCQuestProgressReport" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCQuestProgressReport),
            "k_EMsgGCParty_SetOptions" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_SetOptions),
            "k_EMsgGCParty_SetOptionsResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_SetOptionsResponse),
            "k_EMsgGCParty_QueueForMatch" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_QueueForMatch),
            "k_EMsgGCParty_QueueForMatchResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_QueueForMatchResponse),
            "k_EMsgGCParty_RemoveFromQueue" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_RemoveFromQueue),
            "k_EMsgGCParty_RemoveFromQueueResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_RemoveFromQueueResponse),
            "k_EMsgGCParty_InvitePlayer" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_InvitePlayer),
            "k_EMsgGCParty_RequestJoinPlayer" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_RequestJoinPlayer),
            "k_EMsgGCParty_SendChat" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_SendChat),
            "k_EMsgGCParty_ChatMsg" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_ChatMsg),
            "k_EMsgGCQuestNodeTurnIn" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCQuestNodeTurnIn),
            "k_EMsgGCConsumePaintKit" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCConsumePaintKit),
            "k_EMsgGC_Painkit_DevGrant" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Painkit_DevGrant),
            "k_EMsgGCParty_QueueForStandby" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_QueueForStandby),
            "k_EMsgGCParty_QueueForStandbyResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_QueueForStandbyResponse),
            "k_EMsgGCParty_RemoveFromStandbyQueue" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_RemoveFromStandbyQueue),
            "k_EMsgGCParty_RemoveFromStandbyQueueResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_RemoveFromStandbyQueueResponse),
            "k_EMsgGCParty_ClearPendingPlayer" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_ClearPendingPlayer),
            "k_EMsgGCParty_ClearPendingPlayerResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_ClearPendingPlayerResponse),
            "k_EMsgGCParty_ClearOtherPartyRequest" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_ClearOtherPartyRequest),
            "k_EMsgGCParty_ClearOtherPartyRequestResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_ClearOtherPartyRequestResponse),
            "k_EMsgGCParty_PromoteToLeader" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_PromoteToLeader),
            "k_EMsgGCParty_KickMember" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_KickMember),
            "k_EMsgGCQuestStrangeEvent" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCQuestStrangeEvent),
            "k_EMsgGC_AcceptLobbyInvite" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_AcceptLobbyInvite),
            "k_EMsgGC_AcceptLobbyInviteReply" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_AcceptLobbyInviteReply),
            "k_EMsgGC_SDRTicket" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_SDRTicket),
            "k_EMsgGC_ProcessMatchVoteKick" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ProcessMatchVoteKick),
            "k_EMsgGC_ProcessMatchVoteKickResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ProcessMatchVoteKickResponse),
            "k_EMsgGCDev_GrantWarKill" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCDev_GrantWarKill),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ETFGCMsg] = &[
        ETFGCMsg::k_EMsgGCReportWarKill,
        ETFGCMsg::k_EMsgGCKickPlayer_DEPRECATED,
        ETFGCMsg::k_EMsgGCStartedTraining_DEPRECATED,
        ETFGCMsg::k_EMsgGCFreeTrial_ChooseMostHelpfulFriend,
        ETFGCMsg::k_EMsgGCRequestTF2Friends,
        ETFGCMsg::k_EMsgGCRequestTF2FriendsResponse,
        ETFGCMsg::k_EMsgGCReplay_SubmitContestEntry,
        ETFGCMsg::k_EMsgGCReplay_SubmitContestEntryResponse,
        ETFGCMsg::k_EMsgGCSaxxy_Awarded,
        ETFGCMsg::k_EMsgGCFreeTrial_ThankedBySomeone,
        ETFGCMsg::k_EMsgGCFreeTrial_ThankedSomeone,
        ETFGCMsg::k_EMsgGCFreeTrial_ConvertedToPremium,
        ETFGCMsg::k_EMsgGCMeetThePyroSilliness_BananaCraft_DEPRECATED,
        ETFGCMsg::k_EMsgGCMVMARG_HighFiveSuccessResponse_DEPRECATED,
        ETFGCMsg::k_EMsgGCMVMARG_HighFiveOnClient_DEPRECATED,
        ETFGCMsg::k_EMsgGCCoaching_AddToCoaches,
        ETFGCMsg::k_EMsgGCCoaching_AddToCoachesResponse,
        ETFGCMsg::k_EMsgGCCoaching_RemoveFromCoaches,
        ETFGCMsg::k_EMsgGCCoaching_RemoveFromCoachesResponse,
        ETFGCMsg::k_EMsgGCCoaching_FindCoach,
        ETFGCMsg::k_EMsgGCCoaching_FindCoachResponse,
        ETFGCMsg::k_EMsgGCCoaching_AskCoach,
        ETFGCMsg::k_EMsgGCCoaching_AskCoachResponse,
        ETFGCMsg::k_EMsgGCCoaching_CoachJoinGame,
        ETFGCMsg::k_EMsgGCCoaching_CoachJoining,
        ETFGCMsg::k_EMsgGCCoaching_CoachJoined,
        ETFGCMsg::k_EMsgGCCoaching_LikeCurrentCoach,
        ETFGCMsg::k_EMsgGCCoaching_RemoveCurrentCoach,
        ETFGCMsg::k_EMsgGCCoaching_AlreadyRatedCoach,
        ETFGCMsg::k_EMsgGC_Duel_Request,
        ETFGCMsg::k_EMsgGC_Duel_Response,
        ETFGCMsg::k_EMsgGC_Duel_Results,
        ETFGCMsg::k_EMsgGC_Duel_Status,
        ETFGCMsg::k_EMsgGC_Halloween_ReservedItem_DEPRECATED,
        ETFGCMsg::k_EMsgGC_Halloween_GrantItem_DEPRECATED,
        ETFGCMsg::k_EMsgGC_Halloween_GrantItemResponse_DEPRECATED,
        ETFGCMsg::k_EMsgGC_Halloween_Cheat_QueryResponse_DEPRECATED,
        ETFGCMsg::k_EMsgGC_Halloween_ItemClaimed_DEPRECATED,
        ETFGCMsg::k_EMsgGC_Halloween_ReservedItem,
        ETFGCMsg::k_EMsgGC_Halloween_GrantItem,
        ETFGCMsg::k_EMsgGC_Halloween_GrantItemResponse,
        ETFGCMsg::k_EMsgGC_Halloween_Cheat_QueryResponse_DEPRECATED_2,
        ETFGCMsg::k_EMsgGC_Halloween_ItemClaimed_DEPRECATED_2,
        ETFGCMsg::k_EMsgGC_Halloween_ServerBossEvent,
        ETFGCMsg::k_EMsgGC_Halloween_Merasmus2012,
        ETFGCMsg::k_EMsgGC_Halloween_UpdateMerasmusLootLevel,
        ETFGCMsg::k_EMsgGC_GameServer_LevelInfo,
        ETFGCMsg::k_EMsgGC_GameServer_AuthChallenge,
        ETFGCMsg::k_EMsgGC_GameServer_AuthChallengeResponse,
        ETFGCMsg::k_EMsgGC_GameServer_CreateIdentity,
        ETFGCMsg::k_EMsgGC_GameServer_CreateIdentityResponse,
        ETFGCMsg::k_EMsgGC_GameServer_List,
        ETFGCMsg::k_EMsgGC_GameServer_ListResponse,
        ETFGCMsg::k_EMsgGC_GameServer_AuthResult,
        ETFGCMsg::k_EMsgGC_GameServer_ResetIdentity,
        ETFGCMsg::k_EMsgGC_GameServer_ResetIdentityResponse,
        ETFGCMsg::k_EMsgGC_Client_UseServerModificationItem,
        ETFGCMsg::k_EMsgGC_Client_UseServerModificationItem_Response,
        ETFGCMsg::k_EMsgGC_GameServer_UseServerModificationItem,
        ETFGCMsg::k_EMsgGC_GameServer_UseServerModificationItem_Response,
        ETFGCMsg::k_EMsgGC_GameServer_ServerModificationItemExpired,
        ETFGCMsg::k_EMsgGC_GameServer_ModificationItemState,
        ETFGCMsg::k_EMsgGC_GameServer_AckPolicy,
        ETFGCMsg::k_EMsgGC_GameServer_AckPolicyResponse,
        ETFGCMsg::k_EMsgGC_QP_ScoreServers,
        ETFGCMsg::k_EMsgGC_QP_ScoreServersResponse,
        ETFGCMsg::k_EMsgGC_QP_PlayerJoining,
        ETFGCMsg::k_EMsgGC_PickupItemEligibility_Query_DEPRECATED,
        ETFGCMsg::k_EMsgGC_PickupItemEligibility_Query_DEPRECATED_2,
        ETFGCMsg::k_EMsgGC_IncrementKillCountAttribute_DEPRECATED,
        ETFGCMsg::k_EMsgGC_IncrementKillCountResponse_DEPRECATED,
        ETFGCMsg::k_EMsgGCAbandonCurrentGame,
        ETFGCMsg::k_EMsgForceSOCacheResend,
        ETFGCMsg::k_EMsgGCRequestChatChannelList,
        ETFGCMsg::k_EMsgGCRequestChatChannelListResponse,
        ETFGCMsg::k_EMsgGCReadyUp,
        ETFGCMsg::k_EMsgGCKickedFromMatchmakingQueue,
        ETFGCMsg::k_EMsgGCLeaverDetected,
        ETFGCMsg::k_EMsgGCLeaverDetectedResponse,
        ETFGCMsg::k_EMsgGCExitMatchmaking,
        ETFGCMsg::k_EMsgGCMatchmakingProgress,
        ETFGCMsg::k_EMsgGCMvMVictoryInfo,
        ETFGCMsg::k_EMsgGCGameServerMatchmakingStatus,
        ETFGCMsg::k_EMsgGCMvMVictory,
        ETFGCMsg::k_EMsgGCMvMVictoryReply,
        ETFGCMsg::k_EMsgGCGameServerKickingLobby,
        ETFGCMsg::k_EMsgGCLeaveGameAndPrepareToJoinParty,
        ETFGCMsg::k_EMsgGC_UpdatePeriodicEvent,
        ETFGCMsg::k_EMsgGC_DuckLeaderboard_IndividualUpdate,
        ETFGCMsg::k_EMsgGC_Client2GCEconPreviewDataBlockRequest,
        ETFGCMsg::k_EMsgGC_Client2GCEconPreviewDataBlockResponse,
        ETFGCMsg::k_EMsgGC_ClientVerificationChallenge,
        ETFGCMsg::k_EMsgGC_ClientVerificationChallengeResponse,
        ETFGCMsg::k_EMsgGC_ClientVerificationVerboseResponse,
        ETFGCMsg::k_EMsgGC_ClientSetItemSlotAttribute,
        ETFGCMsg::k_EMsgGC_War_IndividualUpdate,
        ETFGCMsg::k_EMsgGC_War_JoinWar,
        ETFGCMsg::k_EMsgGC_War_RequestGlobalStats,
        ETFGCMsg::k_EMsgGC_War_GlobalStatsResponse,
        ETFGCMsg::k_EMsgGC_WorldItemPlacement_Attribute,
        ETFGCMsg::k_EMsgGC_WorldItemPlacement_Update,
        ETFGCMsg::k_EMsgGC_Match_Result,
        ETFGCMsg::k_EMsgGCVoteKickPlayerRequest,
        ETFGCMsg::k_EMsgGCVoteKickPlayerRequestResponse,
        ETFGCMsg::k_EMsgGC_DailyCompetitiveStatsRollup,
        ETFGCMsg::k_EMsgGC_DailyCompetitiveStatsRollup_Response,
        ETFGCMsg::k_EMsgGC_WorldStatusBroadcast,
        ETFGCMsg::k_EMsgGC_ReportPlayer,
        ETFGCMsg::k_EMsgGC_Match_ResultResponse,
        ETFGCMsg::k_EMsgGCGameServerKickingLobbyResponse,
        ETFGCMsg::k_EMsgGCPlayerLeftMatch,
        ETFGCMsg::k_EMsgGCPlayerLeftMatchResponse,
        ETFGCMsg::k_EMsgGCRequestMatchMakerStats,
        ETFGCMsg::k_EMsgGCMatchMakerStatsResponse,
        ETFGCMsg::k_EMsgGCMatchHistoryLoad,
        ETFGCMsg::k_EMsgGC_AcknowledgeXP,
        ETFGCMsg::k_EMsgGCDataCenterPing_Update,
        ETFGCMsg::k_EMsgGC_NotificationAcknowledge,
        ETFGCMsg::k_EMsgGC_NotificationAcknowledgeReply,
        ETFGCMsg::k_EMsgGC_KickPlayerFromLobby,
        ETFGCMsg::k_EMsgGC_SurveyQuestionRequest,
        ETFGCMsg::k_EMsgGC_SurveyQuestionResponse,
        ETFGCMsg::k_EMsgGC_TFClientInit,
        ETFGCMsg::k_EMsgGC_NewMatchForLobbyRequest,
        ETFGCMsg::k_EMsgGC_NewMatchForLobbyResponse,
        ETFGCMsg::k_EMsgGC_ChangeMatchPlayerTeamsRequest,
        ETFGCMsg::k_EMsgGC_ChangeMatchPlayerTeamsResponse,
        ETFGCMsg::k_EMsgGC_QuestIdentify,
        ETFGCMsg::k_EMsgGC_QuestDevGive,
        ETFGCMsg::k_EMsgGCQuestComplete_Debug,
        ETFGCMsg::k_EMsgGC_QuestMapDebug,
        ETFGCMsg::k_EMsgGC_QuestMapUnlockNode,
        ETFGCMsg::k_EMsgGC_QuestMapPurchaseReward,
        ETFGCMsg::k_EMsgGC_SetDisablePartyQuestProgress,
        ETFGCMsg::k_EMsgGCQuestProgressReport,
        ETFGCMsg::k_EMsgGCParty_SetOptions,
        ETFGCMsg::k_EMsgGCParty_SetOptionsResponse,
        ETFGCMsg::k_EMsgGCParty_QueueForMatch,
        ETFGCMsg::k_EMsgGCParty_QueueForMatchResponse,
        ETFGCMsg::k_EMsgGCParty_RemoveFromQueue,
        ETFGCMsg::k_EMsgGCParty_RemoveFromQueueResponse,
        ETFGCMsg::k_EMsgGCParty_InvitePlayer,
        ETFGCMsg::k_EMsgGCParty_RequestJoinPlayer,
        ETFGCMsg::k_EMsgGCParty_SendChat,
        ETFGCMsg::k_EMsgGCParty_ChatMsg,
        ETFGCMsg::k_EMsgGCQuestNodeTurnIn,
        ETFGCMsg::k_EMsgGCConsumePaintKit,
        ETFGCMsg::k_EMsgGC_Painkit_DevGrant,
        ETFGCMsg::k_EMsgGCParty_QueueForStandby,
        ETFGCMsg::k_EMsgGCParty_QueueForStandbyResponse,
        ETFGCMsg::k_EMsgGCParty_RemoveFromStandbyQueue,
        ETFGCMsg::k_EMsgGCParty_RemoveFromStandbyQueueResponse,
        ETFGCMsg::k_EMsgGCParty_ClearPendingPlayer,
        ETFGCMsg::k_EMsgGCParty_ClearPendingPlayerResponse,
        ETFGCMsg::k_EMsgGCParty_ClearOtherPartyRequest,
        ETFGCMsg::k_EMsgGCParty_ClearOtherPartyRequestResponse,
        ETFGCMsg::k_EMsgGCParty_PromoteToLeader,
        ETFGCMsg::k_EMsgGCParty_KickMember,
        ETFGCMsg::k_EMsgGCQuestStrangeEvent,
        ETFGCMsg::k_EMsgGC_AcceptLobbyInvite,
        ETFGCMsg::k_EMsgGC_AcceptLobbyInviteReply,
        ETFGCMsg::k_EMsgGC_SDRTicket,
        ETFGCMsg::k_EMsgGC_ProcessMatchVoteKick,
        ETFGCMsg::k_EMsgGC_ProcessMatchVoteKickResponse,
        ETFGCMsg::k_EMsgGCDev_GrantWarKill,
    ];
}

impl ::protobuf::EnumFull for ETFGCMsg {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ETFGCMsg").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ETFGCMsg::k_EMsgGCReportWarKill => 0,
            ETFGCMsg::k_EMsgGCKickPlayer_DEPRECATED => 1,
            ETFGCMsg::k_EMsgGCStartedTraining_DEPRECATED => 2,
            ETFGCMsg::k_EMsgGCFreeTrial_ChooseMostHelpfulFriend => 3,
            ETFGCMsg::k_EMsgGCRequestTF2Friends => 4,
            ETFGCMsg::k_EMsgGCRequestTF2FriendsResponse => 5,
            ETFGCMsg::k_EMsgGCReplay_SubmitContestEntry => 6,
            ETFGCMsg::k_EMsgGCReplay_SubmitContestEntryResponse => 7,
            ETFGCMsg::k_EMsgGCSaxxy_Awarded => 8,
            ETFGCMsg::k_EMsgGCFreeTrial_ThankedBySomeone => 9,
            ETFGCMsg::k_EMsgGCFreeTrial_ThankedSomeone => 10,
            ETFGCMsg::k_EMsgGCFreeTrial_ConvertedToPremium => 11,
            ETFGCMsg::k_EMsgGCMeetThePyroSilliness_BananaCraft_DEPRECATED => 12,
            ETFGCMsg::k_EMsgGCMVMARG_HighFiveSuccessResponse_DEPRECATED => 13,
            ETFGCMsg::k_EMsgGCMVMARG_HighFiveOnClient_DEPRECATED => 14,
            ETFGCMsg::k_EMsgGCCoaching_AddToCoaches => 15,
            ETFGCMsg::k_EMsgGCCoaching_AddToCoachesResponse => 16,
            ETFGCMsg::k_EMsgGCCoaching_RemoveFromCoaches => 17,
            ETFGCMsg::k_EMsgGCCoaching_RemoveFromCoachesResponse => 18,
            ETFGCMsg::k_EMsgGCCoaching_FindCoach => 19,
            ETFGCMsg::k_EMsgGCCoaching_FindCoachResponse => 20,
            ETFGCMsg::k_EMsgGCCoaching_AskCoach => 21,
            ETFGCMsg::k_EMsgGCCoaching_AskCoachResponse => 22,
            ETFGCMsg::k_EMsgGCCoaching_CoachJoinGame => 23,
            ETFGCMsg::k_EMsgGCCoaching_CoachJoining => 24,
            ETFGCMsg::k_EMsgGCCoaching_CoachJoined => 25,
            ETFGCMsg::k_EMsgGCCoaching_LikeCurrentCoach => 26,
            ETFGCMsg::k_EMsgGCCoaching_RemoveCurrentCoach => 27,
            ETFGCMsg::k_EMsgGCCoaching_AlreadyRatedCoach => 28,
            ETFGCMsg::k_EMsgGC_Duel_Request => 29,
            ETFGCMsg::k_EMsgGC_Duel_Response => 30,
            ETFGCMsg::k_EMsgGC_Duel_Results => 31,
            ETFGCMsg::k_EMsgGC_Duel_Status => 32,
            ETFGCMsg::k_EMsgGC_Halloween_ReservedItem_DEPRECATED => 33,
            ETFGCMsg::k_EMsgGC_Halloween_GrantItem_DEPRECATED => 34,
            ETFGCMsg::k_EMsgGC_Halloween_GrantItemResponse_DEPRECATED => 35,
            ETFGCMsg::k_EMsgGC_Halloween_Cheat_QueryResponse_DEPRECATED => 36,
            ETFGCMsg::k_EMsgGC_Halloween_ItemClaimed_DEPRECATED => 37,
            ETFGCMsg::k_EMsgGC_Halloween_ReservedItem => 38,
            ETFGCMsg::k_EMsgGC_Halloween_GrantItem => 39,
            ETFGCMsg::k_EMsgGC_Halloween_GrantItemResponse => 40,
            ETFGCMsg::k_EMsgGC_Halloween_Cheat_QueryResponse_DEPRECATED_2 => 41,
            ETFGCMsg::k_EMsgGC_Halloween_ItemClaimed_DEPRECATED_2 => 42,
            ETFGCMsg::k_EMsgGC_Halloween_ServerBossEvent => 43,
            ETFGCMsg::k_EMsgGC_Halloween_Merasmus2012 => 44,
            ETFGCMsg::k_EMsgGC_Halloween_UpdateMerasmusLootLevel => 45,
            ETFGCMsg::k_EMsgGC_GameServer_LevelInfo => 46,
            ETFGCMsg::k_EMsgGC_GameServer_AuthChallenge => 47,
            ETFGCMsg::k_EMsgGC_GameServer_AuthChallengeResponse => 48,
            ETFGCMsg::k_EMsgGC_GameServer_CreateIdentity => 49,
            ETFGCMsg::k_EMsgGC_GameServer_CreateIdentityResponse => 50,
            ETFGCMsg::k_EMsgGC_GameServer_List => 51,
            ETFGCMsg::k_EMsgGC_GameServer_ListResponse => 52,
            ETFGCMsg::k_EMsgGC_GameServer_AuthResult => 53,
            ETFGCMsg::k_EMsgGC_GameServer_ResetIdentity => 54,
            ETFGCMsg::k_EMsgGC_GameServer_ResetIdentityResponse => 55,
            ETFGCMsg::k_EMsgGC_Client_UseServerModificationItem => 56,
            ETFGCMsg::k_EMsgGC_Client_UseServerModificationItem_Response => 57,
            ETFGCMsg::k_EMsgGC_GameServer_UseServerModificationItem => 58,
            ETFGCMsg::k_EMsgGC_GameServer_UseServerModificationItem_Response => 59,
            ETFGCMsg::k_EMsgGC_GameServer_ServerModificationItemExpired => 60,
            ETFGCMsg::k_EMsgGC_GameServer_ModificationItemState => 61,
            ETFGCMsg::k_EMsgGC_GameServer_AckPolicy => 62,
            ETFGCMsg::k_EMsgGC_GameServer_AckPolicyResponse => 63,
            ETFGCMsg::k_EMsgGC_QP_ScoreServers => 64,
            ETFGCMsg::k_EMsgGC_QP_ScoreServersResponse => 65,
            ETFGCMsg::k_EMsgGC_QP_PlayerJoining => 66,
            ETFGCMsg::k_EMsgGC_PickupItemEligibility_Query_DEPRECATED => 67,
            ETFGCMsg::k_EMsgGC_PickupItemEligibility_Query_DEPRECATED_2 => 68,
            ETFGCMsg::k_EMsgGC_IncrementKillCountAttribute_DEPRECATED => 69,
            ETFGCMsg::k_EMsgGC_IncrementKillCountResponse_DEPRECATED => 70,
            ETFGCMsg::k_EMsgGCAbandonCurrentGame => 71,
            ETFGCMsg::k_EMsgForceSOCacheResend => 72,
            ETFGCMsg::k_EMsgGCRequestChatChannelList => 73,
            ETFGCMsg::k_EMsgGCRequestChatChannelListResponse => 74,
            ETFGCMsg::k_EMsgGCReadyUp => 75,
            ETFGCMsg::k_EMsgGCKickedFromMatchmakingQueue => 76,
            ETFGCMsg::k_EMsgGCLeaverDetected => 77,
            ETFGCMsg::k_EMsgGCLeaverDetectedResponse => 78,
            ETFGCMsg::k_EMsgGCExitMatchmaking => 79,
            ETFGCMsg::k_EMsgGCMatchmakingProgress => 80,
            ETFGCMsg::k_EMsgGCMvMVictoryInfo => 81,
            ETFGCMsg::k_EMsgGCGameServerMatchmakingStatus => 82,
            ETFGCMsg::k_EMsgGCMvMVictory => 83,
            ETFGCMsg::k_EMsgGCMvMVictoryReply => 84,
            ETFGCMsg::k_EMsgGCGameServerKickingLobby => 85,
            ETFGCMsg::k_EMsgGCLeaveGameAndPrepareToJoinParty => 86,
            ETFGCMsg::k_EMsgGC_UpdatePeriodicEvent => 87,
            ETFGCMsg::k_EMsgGC_DuckLeaderboard_IndividualUpdate => 88,
            ETFGCMsg::k_EMsgGC_Client2GCEconPreviewDataBlockRequest => 89,
            ETFGCMsg::k_EMsgGC_Client2GCEconPreviewDataBlockResponse => 90,
            ETFGCMsg::k_EMsgGC_ClientVerificationChallenge => 91,
            ETFGCMsg::k_EMsgGC_ClientVerificationChallengeResponse => 92,
            ETFGCMsg::k_EMsgGC_ClientVerificationVerboseResponse => 93,
            ETFGCMsg::k_EMsgGC_ClientSetItemSlotAttribute => 94,
            ETFGCMsg::k_EMsgGC_War_IndividualUpdate => 95,
            ETFGCMsg::k_EMsgGC_War_JoinWar => 96,
            ETFGCMsg::k_EMsgGC_War_RequestGlobalStats => 97,
            ETFGCMsg::k_EMsgGC_War_GlobalStatsResponse => 98,
            ETFGCMsg::k_EMsgGC_WorldItemPlacement_Attribute => 99,
            ETFGCMsg::k_EMsgGC_WorldItemPlacement_Update => 100,
            ETFGCMsg::k_EMsgGC_Match_Result => 101,
            ETFGCMsg::k_EMsgGCVoteKickPlayerRequest => 102,
            ETFGCMsg::k_EMsgGCVoteKickPlayerRequestResponse => 103,
            ETFGCMsg::k_EMsgGC_DailyCompetitiveStatsRollup => 104,
            ETFGCMsg::k_EMsgGC_DailyCompetitiveStatsRollup_Response => 105,
            ETFGCMsg::k_EMsgGC_WorldStatusBroadcast => 106,
            ETFGCMsg::k_EMsgGC_ReportPlayer => 107,
            ETFGCMsg::k_EMsgGC_Match_ResultResponse => 108,
            ETFGCMsg::k_EMsgGCGameServerKickingLobbyResponse => 109,
            ETFGCMsg::k_EMsgGCPlayerLeftMatch => 110,
            ETFGCMsg::k_EMsgGCPlayerLeftMatchResponse => 111,
            ETFGCMsg::k_EMsgGCRequestMatchMakerStats => 112,
            ETFGCMsg::k_EMsgGCMatchMakerStatsResponse => 113,
            ETFGCMsg::k_EMsgGCMatchHistoryLoad => 114,
            ETFGCMsg::k_EMsgGC_AcknowledgeXP => 115,
            ETFGCMsg::k_EMsgGCDataCenterPing_Update => 116,
            ETFGCMsg::k_EMsgGC_NotificationAcknowledge => 117,
            ETFGCMsg::k_EMsgGC_NotificationAcknowledgeReply => 118,
            ETFGCMsg::k_EMsgGC_KickPlayerFromLobby => 119,
            ETFGCMsg::k_EMsgGC_SurveyQuestionRequest => 120,
            ETFGCMsg::k_EMsgGC_SurveyQuestionResponse => 121,
            ETFGCMsg::k_EMsgGC_TFClientInit => 122,
            ETFGCMsg::k_EMsgGC_NewMatchForLobbyRequest => 123,
            ETFGCMsg::k_EMsgGC_NewMatchForLobbyResponse => 124,
            ETFGCMsg::k_EMsgGC_ChangeMatchPlayerTeamsRequest => 125,
            ETFGCMsg::k_EMsgGC_ChangeMatchPlayerTeamsResponse => 126,
            ETFGCMsg::k_EMsgGC_QuestIdentify => 127,
            ETFGCMsg::k_EMsgGC_QuestDevGive => 128,
            ETFGCMsg::k_EMsgGCQuestComplete_Debug => 129,
            ETFGCMsg::k_EMsgGC_QuestMapDebug => 130,
            ETFGCMsg::k_EMsgGC_QuestMapUnlockNode => 131,
            ETFGCMsg::k_EMsgGC_QuestMapPurchaseReward => 132,
            ETFGCMsg::k_EMsgGC_SetDisablePartyQuestProgress => 133,
            ETFGCMsg::k_EMsgGCQuestProgressReport => 134,
            ETFGCMsg::k_EMsgGCParty_SetOptions => 135,
            ETFGCMsg::k_EMsgGCParty_SetOptionsResponse => 136,
            ETFGCMsg::k_EMsgGCParty_QueueForMatch => 137,
            ETFGCMsg::k_EMsgGCParty_QueueForMatchResponse => 138,
            ETFGCMsg::k_EMsgGCParty_RemoveFromQueue => 139,
            ETFGCMsg::k_EMsgGCParty_RemoveFromQueueResponse => 140,
            ETFGCMsg::k_EMsgGCParty_InvitePlayer => 141,
            ETFGCMsg::k_EMsgGCParty_RequestJoinPlayer => 142,
            ETFGCMsg::k_EMsgGCParty_SendChat => 143,
            ETFGCMsg::k_EMsgGCParty_ChatMsg => 144,
            ETFGCMsg::k_EMsgGCQuestNodeTurnIn => 145,
            ETFGCMsg::k_EMsgGCConsumePaintKit => 146,
            ETFGCMsg::k_EMsgGC_Painkit_DevGrant => 147,
            ETFGCMsg::k_EMsgGCParty_QueueForStandby => 148,
            ETFGCMsg::k_EMsgGCParty_QueueForStandbyResponse => 149,
            ETFGCMsg::k_EMsgGCParty_RemoveFromStandbyQueue => 150,
            ETFGCMsg::k_EMsgGCParty_RemoveFromStandbyQueueResponse => 151,
            ETFGCMsg::k_EMsgGCParty_ClearPendingPlayer => 152,
            ETFGCMsg::k_EMsgGCParty_ClearPendingPlayerResponse => 153,
            ETFGCMsg::k_EMsgGCParty_ClearOtherPartyRequest => 154,
            ETFGCMsg::k_EMsgGCParty_ClearOtherPartyRequestResponse => 155,
            ETFGCMsg::k_EMsgGCParty_PromoteToLeader => 156,
            ETFGCMsg::k_EMsgGCParty_KickMember => 157,
            ETFGCMsg::k_EMsgGCQuestStrangeEvent => 158,
            ETFGCMsg::k_EMsgGC_AcceptLobbyInvite => 159,
            ETFGCMsg::k_EMsgGC_AcceptLobbyInviteReply => 160,
            ETFGCMsg::k_EMsgGC_SDRTicket => 161,
            ETFGCMsg::k_EMsgGC_ProcessMatchVoteKick => 162,
            ETFGCMsg::k_EMsgGC_ProcessMatchVoteKickResponse => 163,
            ETFGCMsg::k_EMsgGCDev_GrantWarKill => 164,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ETFGCMsg {
    fn default() -> Self {
        ETFGCMsg::k_EMsgGCReportWarKill
    }
}

impl ETFGCMsg {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ETFGCMsg>("ETFGCMsg")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EServerModificationItemType)
pub enum EServerModificationItemType {
    // @@protoc_insertion_point(enum_value:EServerModificationItemType.kGameServerModificationItem_Halloween)
    kGameServerModificationItem_Halloween = 1,
}

impl ::protobuf::Enum for EServerModificationItemType {
    const NAME: &'static str = "EServerModificationItemType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EServerModificationItemType> {
        match value {
            1 => ::std::option::Option::Some(EServerModificationItemType::kGameServerModificationItem_Halloween),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EServerModificationItemType> {
        match str {
            "kGameServerModificationItem_Halloween" => ::std::option::Option::Some(EServerModificationItemType::kGameServerModificationItem_Halloween),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EServerModificationItemType] = &[
        EServerModificationItemType::kGameServerModificationItem_Halloween,
    ];
}

impl ::protobuf::EnumFull for EServerModificationItemType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EServerModificationItemType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EServerModificationItemType::kGameServerModificationItem_Halloween => 0,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EServerModificationItemType {
    fn default() -> Self {
        EServerModificationItemType::kGameServerModificationItem_Halloween
    }
}

impl EServerModificationItemType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EServerModificationItemType>("EServerModificationItemType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ETFSyncedMMMenuStep)
pub enum ETFSyncedMMMenuStep {
    // @@protoc_insertion_point(enum_value:ETFSyncedMMMenuStep.k_eTFSyncedMMMenuStep_Invalid)
    k_eTFSyncedMMMenuStep_Invalid = -1,
    // @@protoc_insertion_point(enum_value:ETFSyncedMMMenuStep.k_eTFSyncedMMMenuStep_None)
    k_eTFSyncedMMMenuStep_None = 0,
    // @@protoc_insertion_point(enum_value:ETFSyncedMMMenuStep.k_eTFSyncedMMMenuStep_Configuring_Mode)
    k_eTFSyncedMMMenuStep_Configuring_Mode = 1,
    // @@protoc_insertion_point(enum_value:ETFSyncedMMMenuStep.k_eTFSyncedMMMenuStep_MvM_Selecting_Mode)
    k_eTFSyncedMMMenuStep_MvM_Selecting_Mode = 2,
    // @@protoc_insertion_point(enum_value:ETFSyncedMMMenuStep.k_eTFSyncedMMMenuStep_MvM_Selecting_Tour)
    k_eTFSyncedMMMenuStep_MvM_Selecting_Tour = 3,
    // @@protoc_insertion_point(enum_value:ETFSyncedMMMenuStep.k_eTFSyncedMMMenuStep_MvM_Selecting_Missions)
    k_eTFSyncedMMMenuStep_MvM_Selecting_Missions = 4,
}

impl ::protobuf::Enum for ETFSyncedMMMenuStep {
    const NAME: &'static str = "ETFSyncedMMMenuStep";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ETFSyncedMMMenuStep> {
        match value {
            -1 => ::std::option::Option::Some(ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_Invalid),
            0 => ::std::option::Option::Some(ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_None),
            1 => ::std::option::Option::Some(ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_Configuring_Mode),
            2 => ::std::option::Option::Some(ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_MvM_Selecting_Mode),
            3 => ::std::option::Option::Some(ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_MvM_Selecting_Tour),
            4 => ::std::option::Option::Some(ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_MvM_Selecting_Missions),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ETFSyncedMMMenuStep> {
        match str {
            "k_eTFSyncedMMMenuStep_Invalid" => ::std::option::Option::Some(ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_Invalid),
            "k_eTFSyncedMMMenuStep_None" => ::std::option::Option::Some(ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_None),
            "k_eTFSyncedMMMenuStep_Configuring_Mode" => ::std::option::Option::Some(ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_Configuring_Mode),
            "k_eTFSyncedMMMenuStep_MvM_Selecting_Mode" => ::std::option::Option::Some(ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_MvM_Selecting_Mode),
            "k_eTFSyncedMMMenuStep_MvM_Selecting_Tour" => ::std::option::Option::Some(ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_MvM_Selecting_Tour),
            "k_eTFSyncedMMMenuStep_MvM_Selecting_Missions" => ::std::option::Option::Some(ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_MvM_Selecting_Missions),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ETFSyncedMMMenuStep] = &[
        ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_Invalid,
        ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_None,
        ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_Configuring_Mode,
        ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_MvM_Selecting_Mode,
        ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_MvM_Selecting_Tour,
        ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_MvM_Selecting_Missions,
    ];
}

impl ::protobuf::EnumFull for ETFSyncedMMMenuStep {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ETFSyncedMMMenuStep").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_Invalid => 0,
            ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_None => 1,
            ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_Configuring_Mode => 2,
            ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_MvM_Selecting_Mode => 3,
            ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_MvM_Selecting_Tour => 4,
            ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_MvM_Selecting_Missions => 5,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ETFSyncedMMMenuStep {
    fn default() -> Self {
        ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_Invalid
    }
}

impl ETFSyncedMMMenuStep {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ETFSyncedMMMenuStep>("ETFSyncedMMMenuStep")
    }
}

// Note: you cannot use pattern matching for enums with allow_alias option
#[derive(Clone,Copy,Eq,Debug)]
// @@protoc_insertion_point(enum:ETFMatchGroup)
pub enum ETFMatchGroup {
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_Invalid)
    k_eTFMatchGroup_Invalid, // -1
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_MvM_Practice)
    k_eTFMatchGroup_MvM_Practice, // 0
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_MvM_MannUp)
    k_eTFMatchGroup_MvM_MannUp, // 1
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_First)
    k_eTFMatchGroup_First, // 0
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_MvM_Default)
    k_eTFMatchGroup_MvM_Default, // 0
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_MvM_First)
    k_eTFMatchGroup_MvM_First, // 0
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_MvM_Last)
    k_eTFMatchGroup_MvM_Last, // 1
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_Ladder_6v6)
    k_eTFMatchGroup_Ladder_6v6, // 2
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_Ladder_9v9)
    k_eTFMatchGroup_Ladder_9v9, // 3
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_Ladder_12v12)
    k_eTFMatchGroup_Ladder_12v12, // 4
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_Ladder_Default)
    k_eTFMatchGroup_Ladder_Default, // 2
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_Ladder_First)
    k_eTFMatchGroup_Ladder_First, // 2
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_Ladder_Last)
    k_eTFMatchGroup_Ladder_Last, // 4
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_Casual_6v6)
    k_eTFMatchGroup_Casual_6v6, // 5
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_Casual_9v9)
    k_eTFMatchGroup_Casual_9v9, // 6
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_Casual_12v12)
    k_eTFMatchGroup_Casual_12v12, // 7
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_Casual_Default)
    k_eTFMatchGroup_Casual_Default, // 7
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_Casual_First)
    k_eTFMatchGroup_Casual_First, // 5
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_Casual_Last)
    k_eTFMatchGroup_Casual_Last, // 7
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_Event_Placeholder)
    k_eTFMatchGroup_Event_Placeholder, // 8
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_Event_Default)
    k_eTFMatchGroup_Event_Default, // 8
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_Event_First)
    k_eTFMatchGroup_Event_First, // 8
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_Event_Last)
    k_eTFMatchGroup_Event_Last, // 8
}

impl ::std::cmp::PartialEq for ETFMatchGroup {
    fn eq(&self, other: &Self) -> bool {
        ::protobuf::Enum::value(self) == ::protobuf::Enum::value(other)
    }
}

impl ::std::hash::Hash for ETFMatchGroup {
    fn hash<H : ::std::hash::Hasher>(&self, state: &mut H) {
        state.write_i32(::protobuf::Enum::value(self))
    }
}

impl ::protobuf::Enum for ETFMatchGroup {
    const NAME: &'static str = "ETFMatchGroup";

    fn value(&self) -> i32 {
        match *self {
            ETFMatchGroup::k_eTFMatchGroup_Invalid => -1,
            ETFMatchGroup::k_eTFMatchGroup_MvM_Practice => 0,
            ETFMatchGroup::k_eTFMatchGroup_MvM_MannUp => 1,
            ETFMatchGroup::k_eTFMatchGroup_First => 0,
            ETFMatchGroup::k_eTFMatchGroup_MvM_Default => 0,
            ETFMatchGroup::k_eTFMatchGroup_MvM_First => 0,
            ETFMatchGroup::k_eTFMatchGroup_MvM_Last => 1,
            ETFMatchGroup::k_eTFMatchGroup_Ladder_6v6 => 2,
            ETFMatchGroup::k_eTFMatchGroup_Ladder_9v9 => 3,
            ETFMatchGroup::k_eTFMatchGroup_Ladder_12v12 => 4,
            ETFMatchGroup::k_eTFMatchGroup_Ladder_Default => 2,
            ETFMatchGroup::k_eTFMatchGroup_Ladder_First => 2,
            ETFMatchGroup::k_eTFMatchGroup_Ladder_Last => 4,
            ETFMatchGroup::k_eTFMatchGroup_Casual_6v6 => 5,
            ETFMatchGroup::k_eTFMatchGroup_Casual_9v9 => 6,
            ETFMatchGroup::k_eTFMatchGroup_Casual_12v12 => 7,
            ETFMatchGroup::k_eTFMatchGroup_Casual_Default => 7,
            ETFMatchGroup::k_eTFMatchGroup_Casual_First => 5,
            ETFMatchGroup::k_eTFMatchGroup_Casual_Last => 7,
            ETFMatchGroup::k_eTFMatchGroup_Event_Placeholder => 8,
            ETFMatchGroup::k_eTFMatchGroup_Event_Default => 8,
            ETFMatchGroup::k_eTFMatchGroup_Event_First => 8,
            ETFMatchGroup::k_eTFMatchGroup_Event_Last => 8,
        }
    }

    fn from_i32(value: i32) -> ::std::option::Option<ETFMatchGroup> {
        match value {
            -1 => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Invalid),
            0 => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_MvM_Practice),
            1 => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_MvM_MannUp),
            2 => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Ladder_6v6),
            3 => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Ladder_9v9),
            4 => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Ladder_12v12),
            5 => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Casual_6v6),
            6 => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Casual_9v9),
            7 => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Casual_12v12),
            8 => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Event_Placeholder),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ETFMatchGroup> {
        match str {
            "k_eTFMatchGroup_Invalid" => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Invalid),
            "k_eTFMatchGroup_MvM_Practice" => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_MvM_Practice),
            "k_eTFMatchGroup_MvM_MannUp" => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_MvM_MannUp),
            "k_eTFMatchGroup_Ladder_6v6" => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Ladder_6v6),
            "k_eTFMatchGroup_Ladder_9v9" => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Ladder_9v9),
            "k_eTFMatchGroup_Ladder_12v12" => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Ladder_12v12),
            "k_eTFMatchGroup_Casual_6v6" => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Casual_6v6),
            "k_eTFMatchGroup_Casual_9v9" => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Casual_9v9),
            "k_eTFMatchGroup_Casual_12v12" => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Casual_12v12),
            "k_eTFMatchGroup_Event_Placeholder" => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Event_Placeholder),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ETFMatchGroup] = &[
        ETFMatchGroup::k_eTFMatchGroup_Invalid,
        ETFMatchGroup::k_eTFMatchGroup_MvM_Practice,
        ETFMatchGroup::k_eTFMatchGroup_MvM_MannUp,
        ETFMatchGroup::k_eTFMatchGroup_First,
        ETFMatchGroup::k_eTFMatchGroup_MvM_Default,
        ETFMatchGroup::k_eTFMatchGroup_MvM_First,
        ETFMatchGroup::k_eTFMatchGroup_MvM_Last,
        ETFMatchGroup::k_eTFMatchGroup_Ladder_6v6,
        ETFMatchGroup::k_eTFMatchGroup_Ladder_9v9,
        ETFMatchGroup::k_eTFMatchGroup_Ladder_12v12,
        ETFMatchGroup::k_eTFMatchGroup_Ladder_Default,
        ETFMatchGroup::k_eTFMatchGroup_Ladder_First,
        ETFMatchGroup::k_eTFMatchGroup_Ladder_Last,
        ETFMatchGroup::k_eTFMatchGroup_Casual_6v6,
        ETFMatchGroup::k_eTFMatchGroup_Casual_9v9,
        ETFMatchGroup::k_eTFMatchGroup_Casual_12v12,
        ETFMatchGroup::k_eTFMatchGroup_Casual_Default,
        ETFMatchGroup::k_eTFMatchGroup_Casual_First,
        ETFMatchGroup::k_eTFMatchGroup_Casual_Last,
        ETFMatchGroup::k_eTFMatchGroup_Event_Placeholder,
        ETFMatchGroup::k_eTFMatchGroup_Event_Default,
        ETFMatchGroup::k_eTFMatchGroup_Event_First,
        ETFMatchGroup::k_eTFMatchGroup_Event_Last,
    ];
}

impl ::protobuf::EnumFull for ETFMatchGroup {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ETFMatchGroup").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ETFMatchGroup::k_eTFMatchGroup_Invalid => 0,
            ETFMatchGroup::k_eTFMatchGroup_MvM_Practice => 1,
            ETFMatchGroup::k_eTFMatchGroup_MvM_MannUp => 2,
            ETFMatchGroup::k_eTFMatchGroup_First => 3,
            ETFMatchGroup::k_eTFMatchGroup_MvM_Default => 4,
            ETFMatchGroup::k_eTFMatchGroup_MvM_First => 5,
            ETFMatchGroup::k_eTFMatchGroup_MvM_Last => 6,
            ETFMatchGroup::k_eTFMatchGroup_Ladder_6v6 => 7,
            ETFMatchGroup::k_eTFMatchGroup_Ladder_9v9 => 8,
            ETFMatchGroup::k_eTFMatchGroup_Ladder_12v12 => 9,
            ETFMatchGroup::k_eTFMatchGroup_Ladder_Default => 10,
            ETFMatchGroup::k_eTFMatchGroup_Ladder_First => 11,
            ETFMatchGroup::k_eTFMatchGroup_Ladder_Last => 12,
            ETFMatchGroup::k_eTFMatchGroup_Casual_6v6 => 13,
            ETFMatchGroup::k_eTFMatchGroup_Casual_9v9 => 14,
            ETFMatchGroup::k_eTFMatchGroup_Casual_12v12 => 15,
            ETFMatchGroup::k_eTFMatchGroup_Casual_Default => 16,
            ETFMatchGroup::k_eTFMatchGroup_Casual_First => 17,
            ETFMatchGroup::k_eTFMatchGroup_Casual_Last => 18,
            ETFMatchGroup::k_eTFMatchGroup_Event_Placeholder => 19,
            ETFMatchGroup::k_eTFMatchGroup_Event_Default => 20,
            ETFMatchGroup::k_eTFMatchGroup_Event_First => 21,
            ETFMatchGroup::k_eTFMatchGroup_Event_Last => 22,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ETFMatchGroup {
    fn default() -> Self {
        ETFMatchGroup::k_eTFMatchGroup_Invalid
    }
}

impl ETFMatchGroup {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ETFMatchGroup>("ETFMatchGroup")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ETFPartyChatType)
pub enum ETFPartyChatType {
    // @@protoc_insertion_point(enum_value:ETFPartyChatType.k_eTFPartyChatType_Invalid)
    k_eTFPartyChatType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ETFPartyChatType.k_eTFPartyChatType_MemberChat)
    k_eTFPartyChatType_MemberChat = 1,
    // @@protoc_insertion_point(enum_value:ETFPartyChatType.k_eTFPartyChatType_Synthetic_MemberJoin)
    k_eTFPartyChatType_Synthetic_MemberJoin = 1000,
    // @@protoc_insertion_point(enum_value:ETFPartyChatType.k_eTFPartyChatType_Synthetic_MemberLeave)
    k_eTFPartyChatType_Synthetic_MemberLeave = 1001,
    // @@protoc_insertion_point(enum_value:ETFPartyChatType.k_eTFPartyChatType_Synthetic_SendFailed)
    k_eTFPartyChatType_Synthetic_SendFailed = 1002,
    // @@protoc_insertion_point(enum_value:ETFPartyChatType.k_eTFPartyChatType_Synthetic_MemberOnline)
    k_eTFPartyChatType_Synthetic_MemberOnline = 1003,
    // @@protoc_insertion_point(enum_value:ETFPartyChatType.k_eTFPartyChatType_Synthetic_MemberOffline)
    k_eTFPartyChatType_Synthetic_MemberOffline = 1004,
}

impl ::protobuf::Enum for ETFPartyChatType {
    const NAME: &'static str = "ETFPartyChatType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ETFPartyChatType> {
        match value {
            0 => ::std::option::Option::Some(ETFPartyChatType::k_eTFPartyChatType_Invalid),
            1 => ::std::option::Option::Some(ETFPartyChatType::k_eTFPartyChatType_MemberChat),
            1000 => ::std::option::Option::Some(ETFPartyChatType::k_eTFPartyChatType_Synthetic_MemberJoin),
            1001 => ::std::option::Option::Some(ETFPartyChatType::k_eTFPartyChatType_Synthetic_MemberLeave),
            1002 => ::std::option::Option::Some(ETFPartyChatType::k_eTFPartyChatType_Synthetic_SendFailed),
            1003 => ::std::option::Option::Some(ETFPartyChatType::k_eTFPartyChatType_Synthetic_MemberOnline),
            1004 => ::std::option::Option::Some(ETFPartyChatType::k_eTFPartyChatType_Synthetic_MemberOffline),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ETFPartyChatType> {
        match str {
            "k_eTFPartyChatType_Invalid" => ::std::option::Option::Some(ETFPartyChatType::k_eTFPartyChatType_Invalid),
            "k_eTFPartyChatType_MemberChat" => ::std::option::Option::Some(ETFPartyChatType::k_eTFPartyChatType_MemberChat),
            "k_eTFPartyChatType_Synthetic_MemberJoin" => ::std::option::Option::Some(ETFPartyChatType::k_eTFPartyChatType_Synthetic_MemberJoin),
            "k_eTFPartyChatType_Synthetic_MemberLeave" => ::std::option::Option::Some(ETFPartyChatType::k_eTFPartyChatType_Synthetic_MemberLeave),
            "k_eTFPartyChatType_Synthetic_SendFailed" => ::std::option::Option::Some(ETFPartyChatType::k_eTFPartyChatType_Synthetic_SendFailed),
            "k_eTFPartyChatType_Synthetic_MemberOnline" => ::std::option::Option::Some(ETFPartyChatType::k_eTFPartyChatType_Synthetic_MemberOnline),
            "k_eTFPartyChatType_Synthetic_MemberOffline" => ::std::option::Option::Some(ETFPartyChatType::k_eTFPartyChatType_Synthetic_MemberOffline),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ETFPartyChatType] = &[
        ETFPartyChatType::k_eTFPartyChatType_Invalid,
        ETFPartyChatType::k_eTFPartyChatType_MemberChat,
        ETFPartyChatType::k_eTFPartyChatType_Synthetic_MemberJoin,
        ETFPartyChatType::k_eTFPartyChatType_Synthetic_MemberLeave,
        ETFPartyChatType::k_eTFPartyChatType_Synthetic_SendFailed,
        ETFPartyChatType::k_eTFPartyChatType_Synthetic_MemberOnline,
        ETFPartyChatType::k_eTFPartyChatType_Synthetic_MemberOffline,
    ];
}

impl ::protobuf::EnumFull for ETFPartyChatType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ETFPartyChatType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ETFPartyChatType::k_eTFPartyChatType_Invalid => 0,
            ETFPartyChatType::k_eTFPartyChatType_MemberChat => 1,
            ETFPartyChatType::k_eTFPartyChatType_Synthetic_MemberJoin => 2,
            ETFPartyChatType::k_eTFPartyChatType_Synthetic_MemberLeave => 3,
            ETFPartyChatType::k_eTFPartyChatType_Synthetic_SendFailed => 4,
            ETFPartyChatType::k_eTFPartyChatType_Synthetic_MemberOnline => 5,
            ETFPartyChatType::k_eTFPartyChatType_Synthetic_MemberOffline => 6,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ETFPartyChatType {
    fn default() -> Self {
        ETFPartyChatType::k_eTFPartyChatType_Invalid
    }
}

impl ETFPartyChatType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ETFPartyChatType>("ETFPartyChatType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TF_GC_GameState)
pub enum TF_GC_GameState {
    // @@protoc_insertion_point(enum_value:TF_GC_GameState.TF_GC_GAMESTATE_STATE_INIT)
    TF_GC_GAMESTATE_STATE_INIT = 0,
    // @@protoc_insertion_point(enum_value:TF_GC_GameState.TF_GC_GAMESTATE_WAIT_FOR_PLAYERS_TO_LOAD)
    TF_GC_GAMESTATE_WAIT_FOR_PLAYERS_TO_LOAD = 1,
    // @@protoc_insertion_point(enum_value:TF_GC_GameState.TF_GC_GAMESTATE_STRATEGY_TIME)
    TF_GC_GAMESTATE_STRATEGY_TIME = 3,
    // @@protoc_insertion_point(enum_value:TF_GC_GameState.TF_GC_GAMESTATE_GAME_IN_PROGRESS)
    TF_GC_GAMESTATE_GAME_IN_PROGRESS = 5,
    // @@protoc_insertion_point(enum_value:TF_GC_GameState.TF_GC_GAMESTATE_POST_GAME)
    TF_GC_GAMESTATE_POST_GAME = 6,
    // @@protoc_insertion_point(enum_value:TF_GC_GameState.TF_GC_GAMESTATE_DISCONNECT)
    TF_GC_GAMESTATE_DISCONNECT = 7,
    // @@protoc_insertion_point(enum_value:TF_GC_GameState.TF_GC_GAMESTATE_LAST)
    TF_GC_GAMESTATE_LAST = 8,
}

impl ::protobuf::Enum for TF_GC_GameState {
    const NAME: &'static str = "TF_GC_GameState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TF_GC_GameState> {
        match value {
            0 => ::std::option::Option::Some(TF_GC_GameState::TF_GC_GAMESTATE_STATE_INIT),
            1 => ::std::option::Option::Some(TF_GC_GameState::TF_GC_GAMESTATE_WAIT_FOR_PLAYERS_TO_LOAD),
            3 => ::std::option::Option::Some(TF_GC_GameState::TF_GC_GAMESTATE_STRATEGY_TIME),
            5 => ::std::option::Option::Some(TF_GC_GameState::TF_GC_GAMESTATE_GAME_IN_PROGRESS),
            6 => ::std::option::Option::Some(TF_GC_GameState::TF_GC_GAMESTATE_POST_GAME),
            7 => ::std::option::Option::Some(TF_GC_GameState::TF_GC_GAMESTATE_DISCONNECT),
            8 => ::std::option::Option::Some(TF_GC_GameState::TF_GC_GAMESTATE_LAST),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<TF_GC_GameState> {
        match str {
            "TF_GC_GAMESTATE_STATE_INIT" => ::std::option::Option::Some(TF_GC_GameState::TF_GC_GAMESTATE_STATE_INIT),
            "TF_GC_GAMESTATE_WAIT_FOR_PLAYERS_TO_LOAD" => ::std::option::Option::Some(TF_GC_GameState::TF_GC_GAMESTATE_WAIT_FOR_PLAYERS_TO_LOAD),
            "TF_GC_GAMESTATE_STRATEGY_TIME" => ::std::option::Option::Some(TF_GC_GameState::TF_GC_GAMESTATE_STRATEGY_TIME),
            "TF_GC_GAMESTATE_GAME_IN_PROGRESS" => ::std::option::Option::Some(TF_GC_GameState::TF_GC_GAMESTATE_GAME_IN_PROGRESS),
            "TF_GC_GAMESTATE_POST_GAME" => ::std::option::Option::Some(TF_GC_GameState::TF_GC_GAMESTATE_POST_GAME),
            "TF_GC_GAMESTATE_DISCONNECT" => ::std::option::Option::Some(TF_GC_GameState::TF_GC_GAMESTATE_DISCONNECT),
            "TF_GC_GAMESTATE_LAST" => ::std::option::Option::Some(TF_GC_GameState::TF_GC_GAMESTATE_LAST),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TF_GC_GameState] = &[
        TF_GC_GameState::TF_GC_GAMESTATE_STATE_INIT,
        TF_GC_GameState::TF_GC_GAMESTATE_WAIT_FOR_PLAYERS_TO_LOAD,
        TF_GC_GameState::TF_GC_GAMESTATE_STRATEGY_TIME,
        TF_GC_GameState::TF_GC_GAMESTATE_GAME_IN_PROGRESS,
        TF_GC_GameState::TF_GC_GAMESTATE_POST_GAME,
        TF_GC_GameState::TF_GC_GAMESTATE_DISCONNECT,
        TF_GC_GameState::TF_GC_GAMESTATE_LAST,
    ];
}

impl ::protobuf::EnumFull for TF_GC_GameState {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("TF_GC_GameState").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            TF_GC_GameState::TF_GC_GAMESTATE_STATE_INIT => 0,
            TF_GC_GameState::TF_GC_GAMESTATE_WAIT_FOR_PLAYERS_TO_LOAD => 1,
            TF_GC_GameState::TF_GC_GAMESTATE_STRATEGY_TIME => 2,
            TF_GC_GameState::TF_GC_GAMESTATE_GAME_IN_PROGRESS => 3,
            TF_GC_GameState::TF_GC_GAMESTATE_POST_GAME => 4,
            TF_GC_GameState::TF_GC_GAMESTATE_DISCONNECT => 5,
            TF_GC_GameState::TF_GC_GAMESTATE_LAST => 6,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for TF_GC_GameState {
    fn default() -> Self {
        TF_GC_GameState::TF_GC_GAMESTATE_STATE_INIT
    }
}

impl TF_GC_GameState {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TF_GC_GameState>("TF_GC_GameState")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TF_GC_TEAM)
pub enum TF_GC_TEAM {
    // @@protoc_insertion_point(enum_value:TF_GC_TEAM.TF_GC_TEAM_DEFENDERS)
    TF_GC_TEAM_DEFENDERS = 0,
    // @@protoc_insertion_point(enum_value:TF_GC_TEAM.TF_GC_TEAM_INVADERS)
    TF_GC_TEAM_INVADERS = 1,
    // @@protoc_insertion_point(enum_value:TF_GC_TEAM.TF_GC_TEAM_BROADCASTER)
    TF_GC_TEAM_BROADCASTER = 2,
    // @@protoc_insertion_point(enum_value:TF_GC_TEAM.TF_GC_TEAM_SPECTATOR)
    TF_GC_TEAM_SPECTATOR = 3,
    // @@protoc_insertion_point(enum_value:TF_GC_TEAM.TF_GC_TEAM_PLAYER_POOL)
    TF_GC_TEAM_PLAYER_POOL = 4,
    // @@protoc_insertion_point(enum_value:TF_GC_TEAM.TF_GC_TEAM_NOTEAM)
    TF_GC_TEAM_NOTEAM = 5,
}

impl ::protobuf::Enum for TF_GC_TEAM {
    const NAME: &'static str = "TF_GC_TEAM";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TF_GC_TEAM> {
        match value {
            0 => ::std::option::Option::Some(TF_GC_TEAM::TF_GC_TEAM_DEFENDERS),
            1 => ::std::option::Option::Some(TF_GC_TEAM::TF_GC_TEAM_INVADERS),
            2 => ::std::option::Option::Some(TF_GC_TEAM::TF_GC_TEAM_BROADCASTER),
            3 => ::std::option::Option::Some(TF_GC_TEAM::TF_GC_TEAM_SPECTATOR),
            4 => ::std::option::Option::Some(TF_GC_TEAM::TF_GC_TEAM_PLAYER_POOL),
            5 => ::std::option::Option::Some(TF_GC_TEAM::TF_GC_TEAM_NOTEAM),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<TF_GC_TEAM> {
        match str {
            "TF_GC_TEAM_DEFENDERS" => ::std::option::Option::Some(TF_GC_TEAM::TF_GC_TEAM_DEFENDERS),
            "TF_GC_TEAM_INVADERS" => ::std::option::Option::Some(TF_GC_TEAM::TF_GC_TEAM_INVADERS),
            "TF_GC_TEAM_BROADCASTER" => ::std::option::Option::Some(TF_GC_TEAM::TF_GC_TEAM_BROADCASTER),
            "TF_GC_TEAM_SPECTATOR" => ::std::option::Option::Some(TF_GC_TEAM::TF_GC_TEAM_SPECTATOR),
            "TF_GC_TEAM_PLAYER_POOL" => ::std::option::Option::Some(TF_GC_TEAM::TF_GC_TEAM_PLAYER_POOL),
            "TF_GC_TEAM_NOTEAM" => ::std::option::Option::Some(TF_GC_TEAM::TF_GC_TEAM_NOTEAM),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TF_GC_TEAM] = &[
        TF_GC_TEAM::TF_GC_TEAM_DEFENDERS,
        TF_GC_TEAM::TF_GC_TEAM_INVADERS,
        TF_GC_TEAM::TF_GC_TEAM_BROADCASTER,
        TF_GC_TEAM::TF_GC_TEAM_SPECTATOR,
        TF_GC_TEAM::TF_GC_TEAM_PLAYER_POOL,
        TF_GC_TEAM::TF_GC_TEAM_NOTEAM,
    ];
}

impl ::protobuf::EnumFull for TF_GC_TEAM {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("TF_GC_TEAM").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for TF_GC_TEAM {
    fn default() -> Self {
        TF_GC_TEAM::TF_GC_TEAM_DEFENDERS
    }
}

impl TF_GC_TEAM {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TF_GC_TEAM>("TF_GC_TEAM")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TFMatchLeaveReason)
pub enum TFMatchLeaveReason {
    // @@protoc_insertion_point(enum_value:TFMatchLeaveReason.TFMatchLeaveReason_UNSPECIFIED)
    TFMatchLeaveReason_UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:TFMatchLeaveReason.TFMatchLeaveReason_VOTE_KICK)
    TFMatchLeaveReason_VOTE_KICK = 1,
    // @@protoc_insertion_point(enum_value:TFMatchLeaveReason.TFMatchLeaveReason_IDLE)
    TFMatchLeaveReason_IDLE = 2,
    // @@protoc_insertion_point(enum_value:TFMatchLeaveReason.TFMatchLeaveReason_ADMIN_KICK)
    TFMatchLeaveReason_ADMIN_KICK = 3,
    // @@protoc_insertion_point(enum_value:TFMatchLeaveReason.TFMatchLeaveReason_AWOL)
    TFMatchLeaveReason_AWOL = 4,
    // @@protoc_insertion_point(enum_value:TFMatchLeaveReason.TFMatchLeaveReason_NO_SHOW)
    TFMatchLeaveReason_NO_SHOW = 5,
    // @@protoc_insertion_point(enum_value:TFMatchLeaveReason.TFMatchLeaveReason_GC_REMOVED)
    TFMatchLeaveReason_GC_REMOVED = 6,
}

impl ::protobuf::Enum for TFMatchLeaveReason {
    const NAME: &'static str = "TFMatchLeaveReason";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TFMatchLeaveReason> {
        match value {
            0 => ::std::option::Option::Some(TFMatchLeaveReason::TFMatchLeaveReason_UNSPECIFIED),
            1 => ::std::option::Option::Some(TFMatchLeaveReason::TFMatchLeaveReason_VOTE_KICK),
            2 => ::std::option::Option::Some(TFMatchLeaveReason::TFMatchLeaveReason_IDLE),
            3 => ::std::option::Option::Some(TFMatchLeaveReason::TFMatchLeaveReason_ADMIN_KICK),
            4 => ::std::option::Option::Some(TFMatchLeaveReason::TFMatchLeaveReason_AWOL),
            5 => ::std::option::Option::Some(TFMatchLeaveReason::TFMatchLeaveReason_NO_SHOW),
            6 => ::std::option::Option::Some(TFMatchLeaveReason::TFMatchLeaveReason_GC_REMOVED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<TFMatchLeaveReason> {
        match str {
            "TFMatchLeaveReason_UNSPECIFIED" => ::std::option::Option::Some(TFMatchLeaveReason::TFMatchLeaveReason_UNSPECIFIED),
            "TFMatchLeaveReason_VOTE_KICK" => ::std::option::Option::Some(TFMatchLeaveReason::TFMatchLeaveReason_VOTE_KICK),
            "TFMatchLeaveReason_IDLE" => ::std::option::Option::Some(TFMatchLeaveReason::TFMatchLeaveReason_IDLE),
            "TFMatchLeaveReason_ADMIN_KICK" => ::std::option::Option::Some(TFMatchLeaveReason::TFMatchLeaveReason_ADMIN_KICK),
            "TFMatchLeaveReason_AWOL" => ::std::option::Option::Some(TFMatchLeaveReason::TFMatchLeaveReason_AWOL),
            "TFMatchLeaveReason_NO_SHOW" => ::std::option::Option::Some(TFMatchLeaveReason::TFMatchLeaveReason_NO_SHOW),
            "TFMatchLeaveReason_GC_REMOVED" => ::std::option::Option::Some(TFMatchLeaveReason::TFMatchLeaveReason_GC_REMOVED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TFMatchLeaveReason] = &[
        TFMatchLeaveReason::TFMatchLeaveReason_UNSPECIFIED,
        TFMatchLeaveReason::TFMatchLeaveReason_VOTE_KICK,
        TFMatchLeaveReason::TFMatchLeaveReason_IDLE,
        TFMatchLeaveReason::TFMatchLeaveReason_ADMIN_KICK,
        TFMatchLeaveReason::TFMatchLeaveReason_AWOL,
        TFMatchLeaveReason::TFMatchLeaveReason_NO_SHOW,
        TFMatchLeaveReason::TFMatchLeaveReason_GC_REMOVED,
    ];
}

impl ::protobuf::EnumFull for TFMatchLeaveReason {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("TFMatchLeaveReason").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for TFMatchLeaveReason {
    fn default() -> Self {
        TFMatchLeaveReason::TFMatchLeaveReason_UNSPECIFIED
    }
}

impl TFMatchLeaveReason {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TFMatchLeaveReason>("TFMatchLeaveReason")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TFVoteKickReason)
pub enum TFVoteKickReason {
    // @@protoc_insertion_point(enum_value:TFVoteKickReason.TFVoteKickReason_Other)
    TFVoteKickReason_Other = 0,
    // @@protoc_insertion_point(enum_value:TFVoteKickReason.TFVoteKickReason_Cheating)
    TFVoteKickReason_Cheating = 1,
    // @@protoc_insertion_point(enum_value:TFVoteKickReason.TFVoteKickReason_Idle)
    TFVoteKickReason_Idle = 2,
    // @@protoc_insertion_point(enum_value:TFVoteKickReason.TFVoteKickReason_Scamming)
    TFVoteKickReason_Scamming = 3,
}

impl ::protobuf::Enum for TFVoteKickReason {
    const NAME: &'static str = "TFVoteKickReason";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TFVoteKickReason> {
        match value {
            0 => ::std::option::Option::Some(TFVoteKickReason::TFVoteKickReason_Other),
            1 => ::std::option::Option::Some(TFVoteKickReason::TFVoteKickReason_Cheating),
            2 => ::std::option::Option::Some(TFVoteKickReason::TFVoteKickReason_Idle),
            3 => ::std::option::Option::Some(TFVoteKickReason::TFVoteKickReason_Scamming),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<TFVoteKickReason> {
        match str {
            "TFVoteKickReason_Other" => ::std::option::Option::Some(TFVoteKickReason::TFVoteKickReason_Other),
            "TFVoteKickReason_Cheating" => ::std::option::Option::Some(TFVoteKickReason::TFVoteKickReason_Cheating),
            "TFVoteKickReason_Idle" => ::std::option::Option::Some(TFVoteKickReason::TFVoteKickReason_Idle),
            "TFVoteKickReason_Scamming" => ::std::option::Option::Some(TFVoteKickReason::TFVoteKickReason_Scamming),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TFVoteKickReason] = &[
        TFVoteKickReason::TFVoteKickReason_Other,
        TFVoteKickReason::TFVoteKickReason_Cheating,
        TFVoteKickReason::TFVoteKickReason_Idle,
        TFVoteKickReason::TFVoteKickReason_Scamming,
    ];
}

impl ::protobuf::EnumFull for TFVoteKickReason {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("TFVoteKickReason").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for TFVoteKickReason {
    fn default() -> Self {
        TFVoteKickReason::TFVoteKickReason_Other
    }
}

impl TFVoteKickReason {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TFVoteKickReason>("TFVoteKickReason")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ServerMatchmakingState)
pub enum ServerMatchmakingState {
    // @@protoc_insertion_point(enum_value:ServerMatchmakingState.ServerMatchmakingState_INVALID)
    ServerMatchmakingState_INVALID = 0,
    // @@protoc_insertion_point(enum_value:ServerMatchmakingState.ServerMatchmakingState_NOT_PARTICIPATING)
    ServerMatchmakingState_NOT_PARTICIPATING = 1,
    // @@protoc_insertion_point(enum_value:ServerMatchmakingState.ServerMatchmakingState_EMPTY)
    ServerMatchmakingState_EMPTY = 2,
    // @@protoc_insertion_point(enum_value:ServerMatchmakingState.ServerMatchmakingState_ACTIVE_MATCH_REQUESTING_LATE_JOIN)
    ServerMatchmakingState_ACTIVE_MATCH_REQUESTING_LATE_JOIN = 3,
    // @@protoc_insertion_point(enum_value:ServerMatchmakingState.ServerMatchmakingState_ACTIVE_MATCH)
    ServerMatchmakingState_ACTIVE_MATCH = 4,
}

impl ::protobuf::Enum for ServerMatchmakingState {
    const NAME: &'static str = "ServerMatchmakingState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ServerMatchmakingState> {
        match value {
            0 => ::std::option::Option::Some(ServerMatchmakingState::ServerMatchmakingState_INVALID),
            1 => ::std::option::Option::Some(ServerMatchmakingState::ServerMatchmakingState_NOT_PARTICIPATING),
            2 => ::std::option::Option::Some(ServerMatchmakingState::ServerMatchmakingState_EMPTY),
            3 => ::std::option::Option::Some(ServerMatchmakingState::ServerMatchmakingState_ACTIVE_MATCH_REQUESTING_LATE_JOIN),
            4 => ::std::option::Option::Some(ServerMatchmakingState::ServerMatchmakingState_ACTIVE_MATCH),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ServerMatchmakingState> {
        match str {
            "ServerMatchmakingState_INVALID" => ::std::option::Option::Some(ServerMatchmakingState::ServerMatchmakingState_INVALID),
            "ServerMatchmakingState_NOT_PARTICIPATING" => ::std::option::Option::Some(ServerMatchmakingState::ServerMatchmakingState_NOT_PARTICIPATING),
            "ServerMatchmakingState_EMPTY" => ::std::option::Option::Some(ServerMatchmakingState::ServerMatchmakingState_EMPTY),
            "ServerMatchmakingState_ACTIVE_MATCH_REQUESTING_LATE_JOIN" => ::std::option::Option::Some(ServerMatchmakingState::ServerMatchmakingState_ACTIVE_MATCH_REQUESTING_LATE_JOIN),
            "ServerMatchmakingState_ACTIVE_MATCH" => ::std::option::Option::Some(ServerMatchmakingState::ServerMatchmakingState_ACTIVE_MATCH),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ServerMatchmakingState] = &[
        ServerMatchmakingState::ServerMatchmakingState_INVALID,
        ServerMatchmakingState::ServerMatchmakingState_NOT_PARTICIPATING,
        ServerMatchmakingState::ServerMatchmakingState_EMPTY,
        ServerMatchmakingState::ServerMatchmakingState_ACTIVE_MATCH_REQUESTING_LATE_JOIN,
        ServerMatchmakingState::ServerMatchmakingState_ACTIVE_MATCH,
    ];
}

impl ::protobuf::EnumFull for ServerMatchmakingState {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ServerMatchmakingState").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ServerMatchmakingState {
    fn default() -> Self {
        ServerMatchmakingState::ServerMatchmakingState_INVALID
    }
}

impl ServerMatchmakingState {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ServerMatchmakingState>("ServerMatchmakingState")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:SurveyQuestionType)
pub enum SurveyQuestionType {
    // @@protoc_insertion_point(enum_value:SurveyQuestionType.QUESTION_MATCH_QUALITY)
    QUESTION_MATCH_QUALITY = 0,
    // @@protoc_insertion_point(enum_value:SurveyQuestionType.QUESTION_MAP_QUALITY)
    QUESTION_MAP_QUALITY = 1,
    // @@protoc_insertion_point(enum_value:SurveyQuestionType.QUESTION_COMP_INQUIRY)
    QUESTION_COMP_INQUIRY = 2,
    // @@protoc_insertion_point(enum_value:SurveyQuestionType.QUESTION_CASUAL_INQUIRY)
    QUESTION_CASUAL_INQUIRY = 3,
    // @@protoc_insertion_point(enum_value:SurveyQuestionType.QUESTION_RANDOM_CRIT)
    QUESTION_RANDOM_CRIT = 4,
}

impl ::protobuf::Enum for SurveyQuestionType {
    const NAME: &'static str = "SurveyQuestionType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SurveyQuestionType> {
        match value {
            0 => ::std::option::Option::Some(SurveyQuestionType::QUESTION_MATCH_QUALITY),
            1 => ::std::option::Option::Some(SurveyQuestionType::QUESTION_MAP_QUALITY),
            2 => ::std::option::Option::Some(SurveyQuestionType::QUESTION_COMP_INQUIRY),
            3 => ::std::option::Option::Some(SurveyQuestionType::QUESTION_CASUAL_INQUIRY),
            4 => ::std::option::Option::Some(SurveyQuestionType::QUESTION_RANDOM_CRIT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SurveyQuestionType> {
        match str {
            "QUESTION_MATCH_QUALITY" => ::std::option::Option::Some(SurveyQuestionType::QUESTION_MATCH_QUALITY),
            "QUESTION_MAP_QUALITY" => ::std::option::Option::Some(SurveyQuestionType::QUESTION_MAP_QUALITY),
            "QUESTION_COMP_INQUIRY" => ::std::option::Option::Some(SurveyQuestionType::QUESTION_COMP_INQUIRY),
            "QUESTION_CASUAL_INQUIRY" => ::std::option::Option::Some(SurveyQuestionType::QUESTION_CASUAL_INQUIRY),
            "QUESTION_RANDOM_CRIT" => ::std::option::Option::Some(SurveyQuestionType::QUESTION_RANDOM_CRIT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SurveyQuestionType] = &[
        SurveyQuestionType::QUESTION_MATCH_QUALITY,
        SurveyQuestionType::QUESTION_MAP_QUALITY,
        SurveyQuestionType::QUESTION_COMP_INQUIRY,
        SurveyQuestionType::QUESTION_CASUAL_INQUIRY,
        SurveyQuestionType::QUESTION_RANDOM_CRIT,
    ];
}

impl ::protobuf::EnumFull for SurveyQuestionType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SurveyQuestionType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for SurveyQuestionType {
    fn default() -> Self {
        SurveyQuestionType::QUESTION_MATCH_QUALITY
    }
}

impl SurveyQuestionType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SurveyQuestionType>("SurveyQuestionType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x17tf2/tf_gcmessages.proto\x1a\x13steammessages.proto\x1a\x15base_gcm\
    essages.proto\"y\n\x1bCMsgTFGoldenWrenchBroadcast\x12#\n\rwrench_number\
    \x18\x01\x20\x01(\x05R\x0cwrenchNumber\x12\x18\n\x07deleted\x18\x02\x20\
    \x01(\x08R\x07deleted\x12\x1b\n\tuser_name\x18\x03\x20\x01(\tR\x08userNa\
    me\"\\\n\x14CMsgTFSaxxyBroadcast\x12'\n\x0fcategory_number\x18\x01\x20\
    \x01(\x05R\x0ecategoryNumber\x12\x1b\n\tuser_name\x18\x02\x20\x01(\tR\
    \x08userName\"\x8b\x01\n\x1dCMsgGCTFSpecificItemBroadcast\x12$\n\x0eitem\
    _def_index\x18\x01\x20\x01(\rR\x0citemDefIndex\x12'\n\x0fwas_destruction\
    \x18\x02\x20\x01(\x08R\x0ewasDestruction\x12\x1b\n\tuser_name\x18\x03\
    \x20\x01(\tR\x08userName\"\xd8\x02\n\x11CMsgTFWorldStatus\x12G\n\x1dbeta\
    _stress_test_event_active\x18\x01\x20\x01(\x08:\x05falseR\x19betaStressT\
    estEventActive\x12S\n\x11event_match_group\x18\x02\x20\x01(\x0e2\x0e.ETF\
    MatchGroup:\x17k_eTFMatchGroup_InvalidR\x0feventMatchGroup\x12-\n\x11eve\
    nt_expire_time\x18\x03\x20\x01(\x07:\x010R\x0feventExpireTime\x122\n\x15\
    active_client_version\x18\x04\x20\x01(\rR\x13activeClientVersion\x12B\n\
    \x15disabled_match_groups\x18\x05\x20\x03(\x0e2\x0e.ETFMatchGroupR\x13di\
    sabledMatchGroups\"\x80\x02\n\x10CSOTFDuelSummary\x12#\n\naccount_id\x18\
    \x01\x20\x01(\rR\taccountIdB\x04\x80\xa6\x1d\x01\x12\x1b\n\tduel_wins\
    \x18\x02\x20\x01(\rR\x08duelWins\x12\x1f\n\x0bduel_losses\x18\x03\x20\
    \x01(\rR\nduelLosses\x12/\n\x14last_duel_account_id\x18\x04\x20\x01(\rR\
    \x11lastDuelAccountId\x12.\n\x13last_duel_timestamp\x18\x05\x20\x01(\rR\
    \x11lastDuelTimestamp\x12(\n\x10last_duel_status\x18\x06\x20\x01(\rR\x0e\
    lastDuelStatus\"\x8d\x01\n\x14CSOTFMapContribution\x12#\n\naccount_id\
    \x18\x01\x20\x01(\rR\taccountIdB\x04\x80\xa6\x1d\x01\x12!\n\tdef_index\
    \x18\x02\x20\x01(\rR\x08defIndexB\x04\x80\xa6\x1d\x01\x12-\n\x12contribu\
    tion_level\x18\x03\x20\x01(\rR\x11contributionLevel\"T\n&CMsgTFFreeTrial\
    ChooseMostHelpfulFriend\x12*\n\x11account_id_friend\x18\x01\x20\x01(\rR\
    \x0faccountIdFriend\":\n\x17CMsgTFRequestTF2Friends\x12\x1f\n\x0baccount\
    _ids\x18\x01\x20\x03(\rR\naccountIds\"B\n\x1fCMsgTFRequestTF2FriendsResp\
    onse\x12\x1f\n\x0baccount_ids\x18\x01\x20\x03(\rR\naccountIds\"B\n\x0fCS\
    OTFPlayerInfo\x12/\n\x14num_new_users_helped\x18\x01\x20\x01(\rR\x11numN\
    ewUsersHelped\"B\n\x16CMsgTFThankedBySomeone\x12(\n\x10thanker_steam_id\
    \x18\x01\x20\x01(\x04R\x0ethankerSteamId\"\x16\n\x14CMsgTFThankedSomeone\
    \"#\n!CMsgTFFreeTrialConvertedToPremium\"Q\n\x10CMsgSaxxyAwarded\x12\x1a\
    \n\x08category\x18\x01\x20\x01(\rR\x08category\x12!\n\x0cwinner_names\
    \x18\x02\x20\x03(\tR\x0bwinnerNames\"[\n\x1cCMsgReplaySubmitContestEntry\
    \x12\x1f\n\x0byoutube_url\x18\x01\x20\x01(\tR\nyoutubeUrl\x12\x1a\n\x08c\
    ategory\x18\x02\x20\x01(\rR\x08category\"@\n$CMsgReplaySubmitContestEntr\
    yResponse\x12\x18\n\x07success\x18\x01\x20\x01(\x08R\x07success\"\xba\
    \x01\n\x18CReplayCachedContestData\x12\x1c\n\ttimestamp\x18\x01\x20\x01(\
    \x07R\ttimestamp\x12+\n\x12num_votes_last_day\x18\x02\x20\x01(\rR\x0fnum\
    VotesLastDay\x12&\n\x0fvideo_entry_ids\x18\x03\x20\x03(\rR\rvideoEntryId\
    s\x12+\n\x12num_flags_last_day\x18\x04\x20\x01(\rR\x0fnumFlagsLastDay\"\
    \x1d\n\x1bCMsgTFCoaching_AddToCoaches\"\"\n\x20CMsgTFCoaching_RemoveFrom\
    Coaches\"V\n\x18CMsgTFCoaching_FindCoach\x12:\n\x1aaccount_id_friend_as_\
    coach\x18\x01\x20\x01(\rR\x16accountIdFriendAsCoach\"\x7f\n\x20CMsgTFCoa\
    ching_FindCoachResponse\x12\x1f\n\x0bfound_coach\x18\x01\x20\x01(\x08R\n\
    foundCoach\x12\x1b\n\tnum_likes\x18\x02\x20\x01(\rR\x08numLikes\x12\x1d\
    \n\ncoach_name\x18\x03\x20\x01(\tR\tcoachName\"s\n\x17CMsgTFCoaching_Ask\
    Coach\x12,\n\x12account_id_student\x18\x01\x20\x01(\rR\x10accountIdStude\
    nt\x12*\n\x11student_is_friend\x18\x02\x20\x01(\x08R\x0fstudentIsFriend\
    \"_\n\x1fCMsgTFCoaching_AskCoachResponse\x12<\n\x1aaccept_coaching_assig\
    nment\x18\x01\x20\x01(\x08R\x18acceptCoachingAssignment\"\xb1\x01\n\x1cC\
    MsgTFCoaching_CoachJoinGame\x12\x1b\n\tjoin_game\x18\x01\x20\x01(\x08R\
    \x08joinGame\x12%\n\x0eserver_address\x18\x02\x20\x01(\rR\rserverAddress\
    \x12\x1f\n\x0bserver_port\x18\x03\x20\x01(\rR\nserverPort\x12,\n\x12acco\
    unt_id_student\x18\x04\x20\x01(\rR\x10accountIdStudent\"u\n\x1bCMsgTFCoa\
    ching_CoachJoining\x12(\n\x10account_id_coach\x18\x01\x20\x01(\rR\x0eacc\
    ountIdCoach\x12,\n\x12account_id_student\x18\x02\x20\x01(\rR\x10accountI\
    dStudent\"F\n\x1aCMsgTFCoaching_CoachJoined\x12(\n\x10account_id_coach\
    \x18\x01\x20\x01(\rR\x0eaccountIdCoach\"@\n\x1fCMsgTFCoaching_LikeCurren\
    tCoach\x12\x1d\n\nlike_coach\x18\x01\x20\x01(\x08R\tlikeCoach\"M\n!CMsgT\
    FCoaching_RemoveCurrentCoach\x12(\n\x10account_id_coach\x18\x01\x20\x01(\
    \rR\x0eaccountIdCoach\"\xad\x02\n\x1cCMsgTFQuickplay_ScoreServers\x12B\n\
    \x07servers\x18\x01\x20\x03(\x0b2(.CMsgTFQuickplay_ScoreServers.ServerIn\
    foR\x07servers\x1a\xc8\x01\n\nServerInfo\x12%\n\x0eserver_address\x18\
    \x01\x20\x01(\rR\rserverAddress\x12\x1f\n\x0bserver_port\x18\x02\x20\x01\
    (\rR\nserverPort\x12\x1b\n\tnum_users\x18\x03\x20\x01(\rR\x08numUsers\
    \x12\x19\n\x08steam_id\x18\x04\x20\x01(\x04R\x07steamId\x12\x1b\n\tmax_u\
    sers\x18\x05\x20\x01(\rR\x08maxUsers\x12\x1d\n\nuser_score\x18\x06\x20\
    \x01(\x02R\tuserScore\"\xaa\x02\n$CMsgTFQuickplay_ScoreServersResponse\
    \x12J\n\x07servers\x18\x01\x20\x03(\x0b20.CMsgTFQuickplay_ScoreServersRe\
    sponse.ServerInfoR\x07servers\x1a\xb5\x01\n\nServerInfo\x12%\n\x0eserver\
    _address\x18\x01\x20\x01(\rR\rserverAddress\x12\x1f\n\x0bserver_port\x18\
    \x02\x20\x01(\rR\nserverPort\x12\x1f\n\x0btotal_score\x18\x03\x20\x01(\
    \x02R\ntotalScore\x12\x19\n\x08steam_id\x18\x04\x20\x01(\x04R\x07steamId\
    \x12#\n\roptions_score\x18\x05\x20\x01(\rR\x0coptionsScore\">\n\x1dCMsgT\
    FQuickplay_PlayerJoining\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\tacco\
    untId\"_\n\x1bCMsgGC_GameServer_LevelInfo\x12!\n\x0clevel_loaded\x18\x01\
    \x20\x01(\x08R\x0blevelLoaded\x12\x1d\n\nlevel_name\x18\x02\x20\x01(\tR\
    \tlevelName\"L\n\x1fCMsgGC_GameServer_AuthChallenge\x12)\n\x10challenge_\
    string\x18\x01\x20\x01(\tR\x0fchallengeString\"\xf5\x01\n\x1cCMsgGC_Game\
    Server_AuthResult\x12$\n\rauthenticated\x18\x01\x20\x01(\x08R\rauthentic\
    ated\x120\n\x14game_server_standing\x18\x02\x20\x01(\x05R\x12gameServerS\
    tanding\x12;\n\x1agame_server_standing_trend\x18\x03\x20\x01(\x05R\x17ga\
    meServerStandingTrend\x12&\n\x0fis_valve_server\x18\x04\x20\x01(\x08R\ri\
    sValveServer\x12\x18\n\x07message\x18\x05\x20\x01(\tR\x07message\"\x96\
    \x01\n'CMsgGC_GameServer_AuthChallengeResponse\x123\n\x16game_server_acc\
    ount_id\x18\x01\x20\x01(\rR\x13gameServerAccountId\x126\n\x17hashed_chal\
    lenge_string\x18\x02\x20\x01(\x0cR\x15hashedChallengeString\"A\n\x20CMsg\
    GC_GameServer_CreateIdentity\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\t\
    accountId\"\xa0\x03\n(CMsgGC_GameServer_CreateIdentityResponse\x12'\n\
    \x0faccount_created\x18\x01\x20\x01(\x08R\x0eaccountCreated\x123\n\x16ga\
    me_server_account_id\x18\x02\x20\x01(\rR\x13gameServerAccountId\x12;\n\
    \x1agame_server_identity_token\x18\x03\x20\x01(\tR\x17gameServerIdentity\
    Token\x12a\n\x06status\x18\x04\x20\x01(\x0e21.CMsgGC_GameServer_CreateId\
    entityResponse.EStatus:\x16kStatus_GenericFailureR\x06status\"v\n\x07ESt\
    atus\x12\x1a\n\x16kStatus_GenericFailure\x10\0\x12\x1c\n\x0fkStatus_TooM\
    any\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12\x1c\n\x0fkStatus_NoP\
    rivs\x10\xfe\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12\x13\n\x0fkStatus_Cr\
    eated\x10\x01\"7\n\x16CMsgGC_GameServer_List\x12\x1d\n\naccount_id\x18\
    \x01\x20\x01(\rR\taccountId\"\xfa\x02\n\x1eCMsgGC_GameServer_ListRespons\
    e\x12`\n\x12owned_game_servers\x18\x01\x20\x03(\x0b22.CMsgGC_GameServer_\
    ListResponse.GameServerIdentityR\x10ownedGameServers\x1a\xf5\x01\n\x12Ga\
    meServerIdentity\x123\n\x16game_server_account_id\x18\x01\x20\x01(\rR\
    \x13gameServerAccountId\x12;\n\x1agame_server_identity_token\x18\x02\x20\
    \x01(\tR\x17gameServerIdentityToken\x120\n\x14game_server_standing\x18\
    \x03\x20\x01(\x05R\x12gameServerStanding\x12;\n\x1agame_server_standing_\
    trend\x18\x04\x20\x01(\x05R\x17gameServerStandingTrend\"V\n\x1fCMsgGC_Ga\
    meServer_ResetIdentity\x123\n\x16game_server_account_id\x18\x01\x20\x01(\
    \rR\x13gameServerAccountId\"\xe3\x01\n'CMsgGC_GameServer_ResetIdentityRe\
    sponse\x12F\n\x20game_server_identity_token_reset\x18\x01\x20\x01(\x08R\
    \x1cgameServerIdentityTokenReset\x123\n\x16game_server_account_id\x18\
    \x02\x20\x01(\rR\x13gameServerAccountId\x12;\n\x1agame_server_identity_t\
    oken\x18\x03\x20\x01(\tR\x17gameServerIdentityToken\"\x1d\n\x1bCMsgGC_Ga\
    meServer_AckPolicy\"W\n#CMsgGC_GameServer_AckPolicyResponse\x12\x16\n\
    \x06result\x18\x01\x20\x01(\rR\x06result\x12\x18\n\x07message\x18\x02\
    \x20\x01(\tR\x07message\"B\n'CMsgGC_Client_UseServerModificationItem\x12\
    \x17\n\x07item_id\x18\x01\x20\x01(\x04R\x06itemId\"\x8a\x04\n0CMsgGC_Cli\
    ent_UseServerModificationItem_Response\x12\xa4\x01\n\rresponse_code\x18\
    \x01\x20\x01(\x0e2Q.CMsgGC_Client_UseServerModificationItem_Response.ESe\
    rverModificationItemResponse:,kServerModificationItemResponse_AlreadyInU\
    seR\x0cresponseCode\"\xae\x02\n\x1fEServerModificationItemResponse\x120\
    \n,kServerModificationItemResponse_AlreadyInUse\x10\x01\x12<\n8kServerMo\
    dificationItemResponse_NotOnAuthenticatedServer\x10\x02\x120\n,kServerMo\
    dificationItemResponse_ServerReject\x10\x03\x121\n-kServerModificationIt\
    emResponse_InternalError\x10\x04\x126\n2kServerModificationItemResponse_\
    EventAlreadyActive\x10\x05\"\x9f\x01\n+CMsgGC_GameServer_UseServerModifi\
    cationItem\x12p\n\x11modification_type\x18\x01\x20\x01(\x0e2\x1c.EServer\
    ModificationItemType:%kGameServerModificationItem_HalloweenR\x10modifica\
    tionType\"\xb4\x04\n4CMsgGC_GameServer_UseServerModificationItem_Respons\
    e\x12p\n\x11modification_type\x18\x01\x20\x01(\x0e2\x1c.EServerModificat\
    ionItemType:%kGameServerModificationItem_HalloweenR\x10modificationType\
    \x12\xbd\x01\n\x14server_response_code\x18\x02\x20\x01(\x0e2[.CMsgGC_Gam\
    eServer_UseServerModificationItem_Response.EServerModificationItemServer\
    Response:.kServerModificationItemServerResponse_AcceptedR\x12serverRespo\
    nseCode\"\xc9\x01\n%EServerModificationItemServerResponse\x122\n.kServer\
    ModificationItemServerResponse_Accepted\x10\x01\x126\n2kServerModificati\
    onItemServerResponse_NoVoteCalled\x10\x02\x124\n0kServerModificationItem\
    ServerResponse_VoteFailed\x10\x03\"\xa3\x01\n/CMsgGC_GameServer_ServerMo\
    dificationItemExpired\x12p\n\x11modification_type\x18\x01\x20\x01(\x0e2\
    \x1c.EServerModificationItemType:%kGameServerModificationItem_HalloweenR\
    \x10modificationType\"\xb4\x01\n(CMsgGC_GameServer_ServerModificationIte\
    m\x12p\n\x11modification_type\x18\x01\x20\x01(\x0e2\x1c.EServerModificat\
    ionItemType:%kGameServerModificationItem_HalloweenR\x10modificationType\
    \x12\x16\n\x06active\x18\x02\x20\x01(\x08R\x06active\"q\n\x1dCMsgGC_Hall\
    oween_ReservedItem\x12\x0c\n\x01x\x18\x01\x20\x03(\x02R\x01x\x12\x0c\n\
    \x01y\x18\x02\x20\x03(\x02R\x01y\x12\x0c\n\x01z\x18\x03\x20\x03(\x02R\
    \x01z\x12&\n\x0fspawn_meta_info\x18\x07\x20\x01(\rR\rspawnMetaInfo\"\x83\
    \x01\n\x1aCMsgGC_Halloween_GrantItem\x120\n\x14recipient_account_id\x18\
    \x01\x20\x01(\rR\x12recipientAccountId\x12\x19\n\x08level_id\x18\x02\x20\
    \x01(\rR\x07levelId\x12\x18\n\x07flagged\x18\x03\x20\x01(\x08R\x07flagge\
    d\"V\n\"CMsgGC_Halloween_GrantItemResponse\x120\n\x14recipient_account_i\
    d\x18\x01\x20\x01(\rR\x12recipientAccountId\"\x1e\n\x1cCMsgGC_Halloween_\
    ItemClaimed\"d\n\"CMsgGC_PickupItemEligibility_Query\x12\x1d\n\naccount_\
    id\x18\x01\x20\x01(\rR\taccountId\x12\x1f\n\x0bseconds_ago\x18\x02\x20\
    \x01(\rR\nsecondsAgo\"\x89\x01\n*CMsgGC_PickupItemEligibility_QueryRespo\
    nse\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12!\n\x0cwas_e\
    ligible\x18\x02\x20\x01(\x08R\x0bwasEligible\x12\x19\n\x08level_id\x18\
    \x03\x20\x01(\rR\x07levelId\"\x8e\x06\n\x10CSOTFPartyMember\x12\x1f\n\
    \x0bowns_ticket\x18\x02\x20\x01(\x08R\nownsTicket\x12-\n\x12completed_mi\
    ssions\x18\x03\x20\x01(\rR\x11completedMissions\x12\x1f\n\x0bbadge_level\
    \x18\x04\x20\x01(\rR\nbadgeLevel\x12-\n\x12competitive_access\x18\t\x20\
    \x01(\x08R\x11competitiveAccess\x12\x1e\n\nexperience\x18\x0e\x20\x01(\r\
    R\nexperience\x12H\n\x0fplayer_criteria\x18\x10\x20\x01(\x0b2\x1f.CTFPer\
    PlayerMatchCriteriaProtoR\x0eplayerCriteria\x126\n\x08activity\x18\x11\
    \x20\x01(\x0b2\x1a.CSOTFPartyMember.ActivityR\x08activity\x12#\n\rcasual\
    _banned\x18\x12\x20\x01(\x08R\x0ccasualBanned\x12#\n\rranked_banned\x18\
    \x13\x20\x01(\x08R\x0crankedBanned\x12.\n\x13casual_low_priority\x18\x14\
    \x20\x01(\x08R\x11casualLowPriority\x12.\n\x13ranked_low_priority\x18\
    \x15\x20\x01(\x08R\x11rankedLowPriority\x12#\n\rlobby_standby\x18\x16\
    \x20\x01(\x08R\x0clobbyStandby\x1a\xe8\x01\n\x08Activity\x12\x19\n\x08lo\
    bby_id\x18\x01\x20\x01(\x06R\x07lobbyId\x12S\n\x11lobby_match_group\x18\
    \x02\x20\x01(\x0e2\x0e.ETFMatchGroup:\x17k_eTFMatchGroup_InvalidR\x0flob\
    byMatchGroup\x12-\n\x12multiqueue_blocked\x18\x03\x20\x01(\x08R\x11multi\
    queueBlocked\x12\x16\n\x06online\x18\x04\x20\x01(\x08R\x06online\x12%\n\
    \x0eclient_version\x18\x05\x20\x01(\rR\rclientVersion\"\xaf\x01\n\x14TFP\
    endingPartyMember\x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\
    \x128\n\x04type\x18\x02\x20\x01(\x0e2\x1b.TFPendingPartyMember.EType:\
    \x07InvitedR\x04type\x12\x18\n\x07inviter\x18\x03\x20\x01(\x06R\x07invit\
    er\")\n\x05EType\x12\x0b\n\x07Invited\x10\0\x12\x13\n\x0fRequestedToJoin\
    \x10\x01\"\xac\x01\n\x11TFSyncedMMUIState\x12M\n\tmenu_step\x18\x01\x20\
    \x01(\x0e2\x14.ETFSyncedMMMenuStep:\x1ak_eTFSyncedMMMenuStep_NoneR\x08me\
    nuStep\x12H\n\x0bmatch_group\x18\x02\x20\x01(\x0e2\x0e.ETFMatchGroup:\
    \x17k_eTFMatchGroup_InvalidR\nmatchGroup\"\xc3\x02\n\x1aCTFGroupMatchCri\
    teriaProto\x12\x20\n\x0clate_join_ok\x18\x05\x20\x01(\x08R\nlateJoinOk\
    \x125\n\x15custom_ping_tolerance\x18\r\x20\x01(\r:\x010R\x13customPingTo\
    lerance\x12&\n\x0fmvm_mannup_tour\x18\n\x20\x01(\tR\rmvmMannupTour\x12.\
    \n\x13mvm_mannup_missions\x18\x0f\x20\x03(\tR\x11mvmMannupMissions\x122\
    \n\x15mvm_bootcamp_missions\x18\x10\x20\x03(\tR\x13mvmBootcampMissions\
    \x12@\n\x0fcasual_criteria\x18\x0c\x20\x01(\x0b2\x17.CTFCasualMatchCrite\
    riaR\x0ecasualCriteria\"F\n\x16CTFCasualMatchCriteria\x12,\n\x12selected\
    _maps_bits\x18\x03\x20\x03(\x07R\x10selectedMapsBits\"L\n\x1eCTFPerPlaye\
    rMatchCriteriaProto\x12*\n\x11mvm_squad_surplus\x18\x01\x20\x01(\x08R\
    \x0fmvmSquadSurplus\"\x89\x02\n\x0fCTFPartyOptions\x12-\n\x12overwrite_e\
    xisting\x18\x01\x20\x01(\x08R\x11overwriteExisting\x12B\n\x0egroup_crite\
    ria\x18\x02\x20\x01(\x0b2\x1b.CTFGroupMatchCriteriaProtoR\rgroupCriteria\
    \x12H\n\x0fplayer_criteria\x18\x03\x20\x01(\x0b2\x1f.CTFPerPlayerMatchCr\
    iteriaProtoR\x0eplayerCriteria\x129\n\x0eplayer_uistate\x18\x05\x20\x01(\
    \x0b2\x12.TFSyncedMMUIStateR\rplayerUistate\"\\\n\x13CMsgPartySetOptions\
    \x12\x19\n\x08party_id\x18\x01\x20\x01(\x06R\x07partyId\x12*\n\x07option\
    s\x18\x02\x20\x01(\x0b2\x10.CTFPartyOptionsR\x07options\"\x1d\n\x1bCMsgP\
    artySetOptionsResponse\"\xb4\x01\n\x16CMsgPartyQueueForMatch\x12\x19\n\
    \x08party_id\x18\x01\x20\x01(\x06R\x07partyId\x125\n\rfinal_options\x18\
    \x02\x20\x01(\x0b2\x10.CTFPartyOptionsR\x0cfinalOptions\x12H\n\x0bmatch_\
    group\x18\x03\x20\x01(\x0e2\x0e.ETFMatchGroup:\x17k_eTFMatchGroup_Invali\
    dR\nmatchGroup\"\x20\n\x1eCMsgPartyQueueForMatchResponse\"[\n\x18CMsgPar\
    tyQueueForStandby\x12\x19\n\x08party_id\x18\x01\x20\x01(\x06R\x07partyId\
    \x12$\n\x0eparty_lobby_id\x18\x02\x20\x01(\x06R\x0cpartyLobbyId\"\"\n\
    \x20CMsgPartyQueueForStandbyResponse\"\x7f\n\x18CMsgPartyRemoveFromQueue\
    \x12\x19\n\x08party_id\x18\x01\x20\x01(\x06R\x07partyId\x12H\n\x0bmatch_\
    group\x18\x02\x20\x01(\x0e2\x0e.ETFMatchGroup:\x17k_eTFMatchGroup_Invali\
    dR\nmatchGroup\"\"\n\x20CMsgPartyRemoveFromQueueResponse\"<\n\x1fCMsgPar\
    tyRemoveFromStandbyQueue\x12\x19\n\x08party_id\x18\x01\x20\x01(\x06R\x07\
    partyId\")\n'CMsgPartyRemoveFromStandbyQueueResponse\"\x8a\x01\n\x15CMsg\
    PartyInvitePlayer\x12\x19\n\x08party_id\x18\x01\x20\x01(\x06R\x07partyId\
    \x12\x1b\n\tplayer_id\x18\x02\x20\x01(\x06R\x08playerId\x129\n\x19expect\
    ing_request_to_join\x18\x03\x20\x01(\x08R\x16expectingRequestToJoin\"\
    \xbb\x01\n\x1aCMsgPartyRequestJoinPlayer\x12(\n\x10current_party_id\x18\
    \x01\x20\x01(\x06R\x0ecurrentPartyId\x12$\n\x0ejoin_player_id\x18\x02\
    \x20\x01(\x06R\x0cjoinPlayerId\x12\"\n\rjoin_party_id\x18\x03\x20\x01(\
    \x06R\x0bjoinPartyId\x12)\n\x10expecting_invite\x18\x04\x20\x01(\x08R\
    \x0fexpectingInvite\"d\n\x1bCMsgPartyClearPendingPlayer\x12\x19\n\x08par\
    ty_id\x18\x01\x20\x01(\x06R\x07partyId\x12*\n\x11pending_player_id\x18\
    \x02\x20\x01(\x06R\x0fpendingPlayerId\"%\n#CMsgPartyClearPendingPlayerRe\
    sponse\"G\n\x1fCMsgPartyClearOtherPartyRequest\x12$\n\x0eother_party_id\
    \x18\x01\x20\x01(\x06R\x0cotherPartyId\")\n'CMsgPartyClearOtherPartyRequ\
    estResponse\"Y\n\x18CMsgPartyPromoteToLeader\x12\x19\n\x08party_id\x18\
    \x01\x20\x01(\x06R\x07partyId\x12\"\n\rnew_leader_id\x18\x02\x20\x01(\
    \x06R\x0bnewLeaderId\"M\n\x13CMsgPartyKickMember\x12\x19\n\x08party_id\
    \x18\x01\x20\x01(\x06R\x07partyId\x12\x1b\n\ttarget_id\x18\x02\x20\x01(\
    \x06R\x08targetId\"@\n\x11CMsgPartySendChat\x12\x19\n\x08party_id\x18\
    \x01\x20\x01(\x06R\x07partyId\x12\x10\n\x03msg\x18\x02\x20\x01(\tR\x03ms\
    g\"\x82\x01\n\x10CMsgPartyChatMsg\x12A\n\x04type\x18\x01\x20\x01(\x0e2\
    \x11.ETFPartyChatType:\x1ak_eTFPartyChatType_InvalidR\x04type\x12\x19\n\
    \x08actor_id\x18\x02\x20\x01(\x06R\x07actorId\x12\x10\n\x03msg\x18\x03\
    \x20\x01(\tR\x03msg\"\xfe\x06\n\nCSOTFParty\x12\x1f\n\x08party_id\x18\
    \x01\x20\x01(\x04R\x07partyIdB\x04\x80\xa6\x1d\x01\x12\x1b\n\tleader_id\
    \x18\x02\x20\x01(\x06R\x08leaderId\x12\x1d\n\nmember_ids\x18\x03\x20\x03\
    (\x06R\tmemberIds\x12+\n\x07members\x18\r\x20\x03(\x0b2\x11.CSOTFPartyMe\
    mberR\x07members\x12.\n\x13associated_lobby_id\x18#\x20\x01(\x04R\x11ass\
    ociatedLobbyId\x12h\n\x1cassociated_lobby_match_group\x18(\x20\x01(\x0e2\
    \x0e.ETFMatchGroup:\x17k_eTFMatchGroup_InvalidR\x19associatedLobbyMatchG\
    roup\x12E\n\x12matchmaking_queues\x18+\x20\x03(\x0b2\x16.CSOTFParty.Queu\
    eEntryR\x11matchmakingQueues\x12B\n\x0egroup_criteria\x18%\x20\x01(\x0b2\
    \x1b.CTFGroupMatchCriteriaProtoR\rgroupCriteria\x12,\n\x12casual_banned_\
    time\x18\x12\x20\x01(\rR\x10casualBannedTime\x127\n\x18casual_low_priori\
    ty_time\x18\x14\x20\x01(\rR\x15casualLowPriorityTime\x12,\n\x12ranked_ba\
    nned_time\x18)\x20\x01(\rR\x10rankedBannedTime\x127\n\x18ranked_low_prio\
    rity_time\x18*\x20\x01(\rR\x15rankedLowPriorityTime\x12:\n\x0fleader_ui_\
    state\x18,\x20\x01(\x0b2\x12.TFSyncedMMUIStateR\rleaderUiState\x12>\n\
    \x0fpending_members\x18'\x20\x03(\x0b2\x15.TFPendingPartyMemberR\x0epend\
    ingMembers\x1aw\n\nQueueEntry\x12H\n\x0bmatch_group\x18\x01\x20\x01(\x0e\
    2\x0e.ETFMatchGroup:\x17k_eTFMatchGroup_InvalidR\nmatchGroup\x12\x1f\n\
    \x0bqueued_time\x18\x02\x20\x01(\x07R\nqueuedTime\"\xa1\x02\n\x10CSOTFPa\
    rtyInvite\x12\x1f\n\x08group_id\x18\x01\x20\x01(\x04R\x07groupIdB\x04\
    \x80\xa6\x1d\x01\x12\x18\n\x07inviter\x18\x02\x20\x01(\x06R\x07inviter\
    \x127\n\x07members\x18\x04\x20\x03(\x0b2\x1d.CSOTFPartyInvite.PartyMembe\
    rR\x07members\x12:\n\x04type\x18\x05\x20\x01(\x0e2\x16.CSOTFPartyInvite.\
    Type:\x0ePENDING_INVITER\x04type\x1a'\n\x0bPartyMember\x12\x18\n\x07stea\
    mid\x18\x02\x20\x01(\x06R\x07steamid\"4\n\x04Type\x12\x12\n\x0ePENDING_I\
    NVITE\x10\x01\x12\x18\n\x14PENDING_JOIN_REQUEST\x10\x02\"\x82\x06\n\x13C\
    TFLobbyPlayerProto\x12\x14\n\x02id\x18\x01\x20\x01(\x06R\x02idB\x04\x80\
    \xa6\x1d\x01\x125\n\x04team\x18\x03\x20\x01(\x0e2\x0b.TF_GC_TEAM:\x14TF_\
    GC_TEAM_DEFENDERSR\x04team\x12O\n\rconnect_state\x18\r\x20\x01(\x0e2!.CT\
    FLobbyPlayerProto.ConnectState:\x07INVALIDR\x0cconnectState\x12\x12\n\
    \x04name\x18\x06\x20\x01(\tR\x04name\x12*\n\x11original_party_id\x18\x0c\
    \x20\x01(\x04R\x0foriginalPartyId\x12#\n\rsquad_surplus\x18\x0e\x20\x01(\
    \x08R\x0csquadSurplus\x12\x1f\n\x0bbadge_level\x18\x0f\x20\x01(\rR\nbadg\
    eLevel\x12*\n\x11last_connect_time\x18\x11\x20\x01(\rR\x0flastConnectTim\
    e\x12=\n\x04type\x18\x13\x20\x01(\x0e2\x19.CTFLobbyPlayerProto.Type:\x0e\
    INVALID_PLAYERR\x04type\x12+\n\x11normalized_rating\x18\x14\x20\x01(\x01\
    R\x10normalizedRating\x125\n\x16normalized_uncertainty\x18\x16\x20\x01(\
    \x01R\x15normalizedUncertainty\x12\x12\n\x04rank\x18\x15\x20\x01(\rR\x04\
    rank\x12'\n\x0fchat_suspension\x18\x17\x20\x01(\x08R\x0echatSuspension\"\
    c\n\x0cConnectState\x12\x0b\n\x07INVALID\x10\0\x12\x17\n\x13RESERVATION_\
    PENDING\x10\x01\x12\x0c\n\x08RESERVED\x10\x02\x12\r\n\tCONNECTED\x10\x03\
    \x12\x10\n\x0cDISCONNECTED\x10\x05\"V\n\x04Type\x12\x12\n\x0eINVALID_PLA\
    YER\x10\0\x12\x10\n\x0cMATCH_PLAYER\x10\x01\x12\x12\n\x0eSTANDBY_PLAYER\
    \x10\x02\x12\x14\n\x10OBSERVING_PLAYER\x10\x03\"\x80\x01\n\x13CTFLobbyIn\
    viteProto\x12\x1f\n\x08lobby_id\x18\x01\x20\x01(\x06R\x07lobbyIdB\x04\
    \x80\xa6\x1d\x01\x12H\n\x0bmatch_group\x18\x02\x20\x01(\x0e2\x0e.ETFMatc\
    hGroup:\x17k_eTFMatchGroup_InvalidR\nmatchGroup\"\xee\x07\n\x14CSOTFGame\
    ServerLobby\x12\x1f\n\x08lobby_id\x18\x01\x20\x01(\x04R\x07lobbyIdB\x04\
    \x80\xa6\x1d\x01\x12.\n\x07members\x18\x02\x20\x03(\x0b2\x14.CTFLobbyPla\
    yerProtoR\x07members\x12\x1e\n\tserver_id\x18\x06\x20\x01(\x06:\x010R\
    \x08serverId\x12:\n\x05state\x18\x04\x20\x01(\x0e2\x1b.CSOTFGameServerLo\
    bby.State:\x07UNKNOWNR\x05state\x12\x18\n\x07connect\x18\x05\x20\x01(\tR\
    \x07connect\x12K\n\ngame_state\x18\x16\x20\x01(\x0e2\x10.TF_GC_GameState\
    :\x1aTF_GC_GAMESTATE_STATE_INITR\tgameState\x129\n\x19initial_average_mm\
    _rating\x18\x20\x20\x01(\x01R\x16initialAverageMmRating\x12(\n\x10mannup\
    _tour_name\x18*\x20\x01(\tR\x0emannupTourName\x12\x19\n\x08map_name\x18&\
    \x20\x01(\tR\x07mapName\x12!\n\x0cmission_name\x18'\x20\x01(\tR\x0bmissi\
    onName\x12\x1f\n\x0bmatch_group\x18)\x20\x01(\rR\nmatchGroup\x12\x1c\n\
    \x08match_id\x18\x1e\x20\x01(\x04:\x010R\x07matchId\x12\x1f\n\x0bformed_\
    time\x18$\x20\x01(\rR\nformedTime\x12\x14\n\x05flags\x18+\x20\x01(\rR\
    \x05flags\x12,\n\x12late_join_eligible\x18,\x20\x01(\x08R\x10lateJoinEli\
    gible\x12(\n\x10fixed_match_size\x18-\x20\x01(\rR\x0efixedMatchSize\x12F\
    \n\x0cis_war_match\x18.\x20\x01(\x0e2\x1e.CSOTFGameServerLobby.WarMatch:\
    \x04NOPER\nisWarMatch\x12+\n\x12next_maps_for_vote\x18/\x20\x03(\rR\x0fn\
    extMapsForVote\x12(\n\x10lobby_mm_version\x180\x20\x01(\rR\x0elobbyMmVer\
    sion\x12=\n\x0fpending_members\x181\x20\x03(\x0b2\x14.CTFLobbyPlayerProt\
    oR\x0ependingMembers\".\n\x05State\x12\x0b\n\x07UNKNOWN\x10\0\x12\x0f\n\
    \x0bSERVERSETUP\x10\x01\x12\x07\n\x03RUN\x10\x02\"C\n\x08WarMatch\x12\
    \x08\n\x04NOPE\x10\0\x12\x15\n\x11INVADERS_ARE_PYRO\x10\x01\x12\x16\n\
    \x12INVADERS_ARE_HEAVY\x10\x02\"v\n\x13CMsgExitMatchmaking\x12)\n\x10exp\
    licit_abandon\x18\x01\x20\x01(\x08R\x0fexplicitAbandon\x12\x19\n\x08part\
    y_id\x18\x02\x20\x01(\x04R\x07partyId\x12\x19\n\x08lobby_id\x18\x03\x20\
    \x01(\x04R\x07lobbyId\"\xb0\x01\n\x15CMsgAcceptLobbyInvite\x12(\n\x10inv\
    ited_lobby_id\x18\x01\x20\x01(\x04R\x0einvitedLobbyId\x12.\n\x13abandoni\
    ng_match_id\x18\x02\x20\x01(\x04R\x11abandoningMatchId\x12=\n\x1babandon\
    ing_invite_lobby_ids\x18\x03\x20\x03(\x04R\x18abandoningInviteLobbyIds\"\
    \x1c\n\x1aCMsgAcceptLobbyInviteReply\"#\n!CMsgMatchmakingSearchCountRequ\
    est\"a\n\"CMsgMatchmakingSearchCountResponse\x12;\n\x1asearching_players\
    _by_group\x18\x01\x20\x03(\rR\x17searchingPlayersByGroup\"\x20\n\x1eCMsg\
    KickedFromMatchmakingQueue\"\xe0\t\n\x1fCMsgGameServerMatchmakingStatus\
    \x12+\n\x0eserver_version\x18\x10\x20\x01(\r:\x041225R\rserverVersion\
    \x12d\n\x11matchmaking_state\x18\x01\x20\x01(\x0e2\x17.ServerMatchmaking\
    State:\x1eServerMatchmakingState_INVALIDR\x10matchmakingState\x12\x10\n\
    \x03map\x18\x03\x20\x01(\tR\x03map\x12\x12\n\x04tags\x18\x04\x20\x01(\tR\
    \x04tags\x12\x1b\n\tbot_count\x18\x05\x20\x01(\rR\x08botCount\x12%\n\x0e\
    num_spectators\x18\x06\x20\x01(\rR\rnumSpectators\x12\x1f\n\x0bmax_playe\
    rs\x18\x07\x20\x01(\rR\nmaxPlayers\x12\x1d\n\nslots_free\x18\x08\x20\x01\
    (\rR\tslotsFree\x12#\n\rserver_region\x18\t\x20\x01(\rR\x0cserverRegion\
    \x12%\n\x0eserver_loadavg\x18\n\x20\x01(\x02R\rserverLoadavg\x12%\n\x0es\
    erver_trusted\x18\x0b\x20\x01(\x08R\rserverTrusted\x12)\n\x10server_dedi\
    cated\x18\x0c\x20\x01(\x08R\x0fserverDedicated\x12\x16\n\x06strict\x18\
    \x11\x20\x01(\rR\x06strict\x12\x17\n\x07fake_ip\x18\x19\x20\x01(\tR\x06f\
    akeIp\x12A\n\x07players\x18\r\x20\x03(\x0b2'.CMsgGameServerMatchmakingSt\
    atus.PlayerR\x07players\x12K\n\ngame_state\x18\x0e\x20\x01(\x0e2\x10.TF_\
    GC_GameState:\x1aTF_GC_GAMESTATE_STATE_INITR\tgameState\x12B\n\x05event\
    \x18\x0f\x20\x01(\x0e2&.CMsgGameServerMatchmakingStatus.Event:\x04NoneR\
    \x05event\x12\x19\n\x08mvm_wave\x18\x12\x20\x01(\rR\x07mvmWave\x120\n\
    \x14mvm_credits_acquired\x18\x13\x20\x01(\rR\x12mvmCreditsAcquired\x12.\
    \n\x13mvm_credits_dropped\x18\x14\x20\x01(\rR\x11mvmCreditsDropped\x12#\
    \n\x0bmatch_group\x18\x17\x20\x01(\x11:\x02-1R\nmatchGroup\x12(\n\x10lob\
    by_mm_version\x18\x18\x20\x01(\rR\x0elobbyMmVersion\x1a\x86\x01\n\x06Pla\
    yer\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\x12a\n\rconne\
    ct_state\x18\x02\x20\x01(\x0e23.CMsgGameServerMatchmakingStatus.PlayerCo\
    nnectState:\x07INVALIDR\x0cconnectState\">\n\x12PlayerConnectState\x12\
    \x0b\n\x07INVALID\x10\0\x12\r\n\tCONNECTED\x10\x01\x12\x0c\n\x08RESERVED\
    \x10\x02\"H\n\x05Event\x12\x08\n\x04None\x10\0\x12\x0e\n\nMvMVictory\x10\
    \x01\x12\r\n\tMvMDefeat\x10\x02\x12\x16\n\x12AcknowledgePlayers\x10\x03\
    \"\xbf\x08\n\x17CMsgMatchmakingProgress\x12)\n\x11avg_wait_time_new\x18\
    \x04\x20\x01(\rR\x0eavgWaitTimeNew\x124\n\x17avg_wait_time_join_late\x18\
    \x05\x20\x01(\rR\x13avgWaitTimeJoinLate\x12$\n\x0eyour_wait_time\x18\x06\
    \x20\x01(\rR\x0cyourWaitTime\x12O\n$matching_worldwide_searching_players\
    \x18\x08\x20\x01(\rR!matchingWorldwideSearchingPlayers\x12L\n#matching_n\
    ear_you_searching_players\x18\t\x20\x01(\rR\x1fmatchingNearYouSearchingP\
    layers\x12I\n!total_worldwide_searching_players\x18\r\x20\x01(\rR\x1etot\
    alWorldwideSearchingPlayers\x12F\n\x20total_near_you_searching_players\
    \x18\x0e\x20\x01(\rR\x1ctotalNearYouSearchingPlayers\x12I\n!matching_wor\
    ldwide_active_players\x18\x0f\x20\x01(\rR\x1ematchingWorldwideActivePlay\
    ers\x12F\n\x20matching_near_you_active_players\x18\x10\x20\x01(\rR\x1cma\
    tchingNearYouActivePlayers\x12C\n\x1etotal_worldwide_active_players\x18\
    \x11\x20\x01(\rR\x1btotalWorldwideActivePlayers\x12@\n\x1dtotal_near_you\
    _active_players\x18\x12\x20\x01(\rR\x19totalNearYouActivePlayers\x12O\n$\
    matching_worldwide_empty_gameservers\x18\x13\x20\x01(\rR!matchingWorldwi\
    deEmptyGameservers\x12L\n#matching_near_you_empty_gameservers\x18\x14\
    \x20\x01(\rR\x1fmatchingNearYouEmptyGameservers\x12I\n!total_worldwide_e\
    mpty_gameservers\x18\x15\x20\x01(\rR\x1etotalWorldwideEmptyGameservers\
    \x12F\n\x20total_near_you_empty_gameservers\x18\x16\x20\x01(\rR\x1ctotal\
    NearYouEmptyGameservers\x12\x1f\n\x0burgency_pct\x18\x01\x20\x01(\rR\nur\
    gencyPct\"\x94\x06\n\x12CMsgMvMVictoryInfo\x124\n\x07players\x18\x01\x20\
    \x03(\x0b2\x1a.CMsgMvMVictoryInfo.PlayerR\x07players\x12\x1b\n\ttour_nam\
    e\x18\x02\x20\x01(\tR\x08tourName\x12!\n\x0cmission_name\x18\x03\x20\x01\
    (\tR\x0bmissionName\x1a\xb4\x01\n\x04Item\x12K\n\x0cgrant_reason\x18\x01\
    \x20\x01(\x0e2\x1f.CMsgMvMVictoryInfo.GrantReason:\x07INVALIDR\x0bgrantR\
    eason\x12\x1b\n\titem_data\x18\x02\x20\x01(\x0cR\x08itemData\x12B\n\x1es\
    quad_surplus_claimer_steam_id\x18\x03\x20\x01(\x06R\x1asquadSurplusClaim\
    erSteamId\x1a\xf0\x02\n\x06Player\x12\x19\n\x08steam_id\x18\x01\x20\x01(\
    \x06R\x07steamId\x12#\n\rbadge_granted\x18\x03\x20\x01(\x08R\x0cbadgeGra\
    nted\x124\n\x16badge_progress_updated\x18\x04\x20\x01(\x08R\x14badgeProg\
    ressUpdated\x12#\n\rbadge_leveled\x18\x05\x20\x01(\x08R\x0cbadgeLeveled\
    \x12\x1f\n\x0bbadge_level\x18\x06\x20\x01(\rR\nbadgeLevel\x12.\n\x13badg\
    e_progress_bits\x18\x07\x20\x01(\rR\x11badgeProgressBits\x12.\n\x05items\
    \x18\x08\x20\x03(\x0b2\x18.CMsgMvMVictoryInfo.ItemR\x05items\x12'\n\x0fv\
    oucher_missing\x18\t\x20\x01(\x08R\x0evoucherMissing\x12!\n\x0cbadge_poi\
    nts\x18\n\x20\x01(\rR\x0bbadgePoints\"^\n\x0bGrantReason\x12\x0b\n\x07IN\
    VALID\x10\0\x12\x11\n\rBADGE_LEVELED\x10\x01\x12\x11\n\rSQUAD_SURPLUS\
    \x10\x02\x12\x0b\n\x07MANN_UP\x10\x03\x12\x0f\n\x0bHELP_A_NOOB\x10\x04\"\
    \x90\x01\n\x15CGCMsgTFHelloResponse\x12#\n\rversion_check\x18\x01\x20\
    \x01(\rR\x0cversionCheck\x12)\n\x10version_checksum\x18\x02\x20\x03(\x04\
    R\x0fversionChecksum\x12'\n\x0fversion_verbose\x18\x03\x20\x01(\rR\x0eve\
    rsionVerbose\"\xe4\x01\n\x0cCGCMsgTFSync\x12)\n\x10version_checksum\x18\
    \x01\x20\x01(\x0cR\x0fversionChecksum\x12#\n\rversion_check\x18\x02\x20\
    \x01(\rR\x0cversionCheck\x12(\n\x10version_check_ex\x18\x03\x20\x01(\rR\
    \x0eversionCheckEx\x12*\n\x11version_check_ex2\x18\x04\x20\x01(\rR\x0fve\
    rsionCheckEx2\x12.\n\x13version_checksum_ex\x18\x05\x20\x01(\x0cR\x11ver\
    sionChecksumEx\"\x90\x01\n\x0eCGCMsgTFSyncEx\x12)\n\x10version_checksum\
    \x18\x01\x20\x01(\tR\x0fversionChecksum\x12.\n\x13version_checksum_ex\
    \x18\x02\x20\x01(\x0cR\x11versionChecksumEx\x12#\n\rversion_check\x18\
    \x03\x20\x01(\rR\x0cversionCheck\"\xc5\x02\n\x0eCMsgMvMVictory\x120\n\
    \x14legacy_mission_index\x18\x01\x20\x01(\rR\x12legacyMissionIndex\x12(\
    \n\x10tour_name_mannup\x18\x05\x20\x01(\tR\x0etourNameMannup\x12!\n\x0cm\
    ission_name\x18\x06\x20\x01(\tR\x0bmissionName\x120\n\x07players\x18\x02\
    \x20\x03(\x0b2\x16.CMsgMvMVictory.PlayerR\x07players\x12\x19\n\x08lobby_\
    id\x18\x03\x20\x01(\x04R\x07lobbyId\x12\x1d\n\nevent_time\x18\x04\x20\
    \x01(\x07R\teventTime\x1aH\n\x06Player\x12\x19\n\x08steam_id\x18\x01\x20\
    \x01(\x06R\x07steamId\x12#\n\rsquad_surplus\x18\x02\x20\x01(\x08R\x0csqu\
    adSurplus\"\x1b\n\x19CMsgMvMMannUpVictoryReply\"R\n\x1aCMsgGameServerKic\
    kingLobby\x12\x19\n\x08lobby_id\x18\x03\x20\x01(\x04R\x07lobbyId\x12\x19\
    \n\x08match_id\x18\x04\x20\x01(\x04R\x07matchId\"$\n\"CMsgGameServerKick\
    ingLobbyResponse\"?\n\"CMsgLeaveGameAndPrepareToJoinParty\x12\x19\n\x08p\
    arty_id\x18\x01\x20\x01(\x06R\x07partyId\"\x93\x02\n\x13CMsgPlayerLeftMa\
    tch\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\x12V\n\x0clea\
    ve_reason\x18\x02\x20\x01(\x0e2\x13.TFMatchLeaveReason:\x1eTFMatchLeaveR\
    eason_UNSPECIFIEDR\x0bleaveReason\x12\x1f\n\x0bwas_abandon\x18\x03\x20\
    \x01(\x08R\nwasAbandon\x12\x19\n\x08lobby_id\x18\x04\x20\x01(\x04R\x07lo\
    bbyId\x12\x19\n\x08match_id\x18\x05\x20\x01(\x04R\x07matchId\x122\n\x0cx\
    p_breakdown\x18\x06\x20\x03(\x0b2\x0f.CMsgTFXPSourceR\x0bxpBreakdown\"\
    \x1d\n\x1bCMsgPlayerLeftMatchResponse\"\xe5\x02\n\x18CMsgProcessMatchVot\
    eKick\x12\x19\n\x08match_id\x18\x01\x20\x01(\x06R\x07matchId\x12,\n\x12i\
    nitiator_steam_id\x18\x02\x20\x01(\x06R\x10initiatorSteamId\x12&\n\x0fta\
    rget_steam_id\x18\x03\x20\x01(\x06R\rtargetSteamId\x12A\n\x06reason\x18\
    \x04\x20\x01(\x0e2\x11.TFVoteKickReason:\x16TFVoteKickReason_OtherR\x06r\
    eason\x124\n\x05votes\x18\x05\x20\x03(\x0b2\x1e.CMsgProcessMatchVoteKick\
    .VoteR\x05votes\x12!\n\x0cdefault_pass\x18\x06\x20\x01(\x08R\x0bdefaultP\
    ass\x1a<\n\x04Vote\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamI\
    d\x12\x19\n\x08vote_yay\x18\x02\x20\x01(\x08R\x07voteYay\"4\n\x20CMsgPro\
    cessMatchVoteKickResponse\x12\x10\n\x03rip\x18\x01\x20\x01(\x08R\x03rip\
    \"/\n-CMsgPlayerVoteKickedAfterLeavingMatchResponse\"\x8b\x02\n\x1dCMsgH\
    alloween_ServerBossEvent\x12#\n\revent_counter\x18\x01\x20\x01(\rR\x0cev\
    entCounter\x12\x1c\n\ttimestamp\x18\x02\x20\x01(\rR\ttimestamp\x12\x1b\n\
    \tboss_type\x18\x03\x20\x01(\rR\x08bossType\x12\x1d\n\nboss_level\x18\
    \x04\x20\x01(\rR\tbossLevel\x12\x1d\n\nevent_type\x18\x05\x20\x01(\rR\te\
    ventType\x12)\n\x10players_involved\x18\x06\x20\x01(\rR\x0fplayersInvolv\
    ed\x12!\n\x0celapsed_time\x18\x07\x20\x01(\x02R\x0belapsedTime\"\xff\x07\
    \n\x1aCMsgHalloween_Merasmus2012\x12#\n\revent_counter\x18\x01\x20\x01(\
    \rR\x0ceventCounter\x12%\n\x0etime_submitted\x18\x02\x20\x01(\x07R\rtime\
    Submitted\x12&\n\x0fis_valve_server\x18\x03\x20\x01(\x08R\risValveServer\
    \x12\x1d\n\nboss_level\x18\x04\x20\x01(\rR\tbossLevel\x12%\n\x0espawned_\
    health\x18\x05\x20\x01(\rR\rspawnedHealth\x12)\n\x10remaining_health\x18\
    \x06\x20\x01(\rR\x0fremainingHealth\x12\x1b\n\tlife_time\x18\x07\x20\x01\
    (\rR\x08lifeTime\x12\x1d\n\nbomb_kills\x18\x08\x20\x01(\rR\tbombKills\
    \x12\x1f\n\x0bstaff_kills\x18\t\x20\x01(\rR\nstaffKills\x12\x1b\n\tpvp_k\
    ills\x18\n\x20\x01(\rR\x08pvpKills\x12%\n\x0eprophunt_time1\x18\x0b\x20\
    \x01(\rR\rprophuntTime1\x12%\n\x0eprophunt_time2\x18\x0c\x20\x01(\rR\rpr\
    ophuntTime2\x12\x1b\n\tdmg_scout\x18\r\x20\x01(\rR\x08dmgScout\x12\x1d\n\
    \ndmg_sniper\x18\x0e\x20\x01(\rR\tdmgSniper\x12\x1f\n\x0bdmg_soldier\x18\
    \x0f\x20\x01(\rR\ndmgSoldier\x12\x19\n\x08dmg_demo\x18\x10\x20\x01(\rR\
    \x07dmgDemo\x12\x1b\n\tdmg_medic\x18\x11\x20\x01(\rR\x08dmgMedic\x12\x1b\
    \n\tdmg_heavy\x18\x12\x20\x01(\rR\x08dmgHeavy\x12\x19\n\x08dmg_pyro\x18\
    \x13\x20\x01(\rR\x07dmgPyro\x12\x17\n\x07dmg_spy\x18\x14\x20\x01(\rR\x06\
    dmgSpy\x12!\n\x0cdmg_engineer\x18\x15\x20\x01(\rR\x0bdmgEngineer\x12\x1f\
    \n\x0bscout_count\x18\x16\x20\x01(\rR\nscoutCount\x12!\n\x0csniper_count\
    \x18\x17\x20\x01(\rR\x0bsniperCount\x12#\n\rsolider_count\x18\x18\x20\
    \x01(\rR\x0csoliderCount\x12\x1d\n\ndemo_count\x18\x19\x20\x01(\rR\tdemo\
    Count\x12\x1f\n\x0bmedic_count\x18\x1a\x20\x01(\rR\nmedicCount\x12\x1f\n\
    \x0bheavy_count\x18\x1b\x20\x01(\rR\nheavyCount\x12\x1d\n\npyro_count\
    \x18\x1c\x20\x01(\rR\tpyroCount\x12\x1b\n\tspy_count\x18\x1d\x20\x01(\rR\
    \x08spyCount\x12%\n\x0eengineer_count\x18\x1e\x20\x01(\rR\rengineerCount\
    \"\xba\x01\n$CMsgUpdateHalloweenMerasmusLootLevel\x12F\n\x07players\x18\
    \x01\x20\x03(\x0b2,.CMsgUpdateHalloweenMerasmusLootLevel.PlayerR\x07play\
    ers\x12%\n\x0emerasmus_level\x18\x02\x20\x01(\rR\rmerasmusLevel\x1a#\n\
    \x06Player\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\")\n\
    \x11CAttribute_String\x12\x14\n\x05value\x18\x01\x20\x01(\tR\x05value\"\
    \x81\x02\n!CAttribute_DynamicRecipeComponent\x12\x1b\n\tdef_index\x18\
    \x01\x20\x01(\rR\x08defIndex\x12!\n\x0citem_quality\x18\x02\x20\x01(\rR\
    \x0bitemQuality\x12'\n\x0fcomponent_flags\x18\x03\x20\x01(\rR\x0ecompone\
    ntFlags\x12+\n\x11attributes_string\x18\x04\x20\x01(\tR\x10attributesStr\
    ing\x12!\n\x0cnum_required\x18\x05\x20\x01(\rR\x0bnumRequired\x12#\n\rnu\
    m_fulfilled\x18\x06\x20\x01(\rR\x0cnumFulfilled\"\xa3\x03\nACAttribute_D\
    ynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT\x12\x1b\n\tdef_ind\
    ex\x18\x01\x20\x01(\rR\x08defIndex\x12\x19\n\x08item_def\x18\x02\x20\x01\
    (\rR\x07itemDef\x12!\n\x0citem_quality\x18\x03\x20\x01(\rR\x0bitemQualit\
    y\x12'\n\x0fcomponent_flags\x18\x04\x20\x01(\rR\x0ecomponentFlags\x12\
    \x1d\n\nitem_flags\x18\x05\x20\x01(\rR\titemFlags\x12+\n\x11attributes_s\
    tring\x18\x06\x20\x01(\tR\x10attributesString\x12!\n\x0cnum_required\x18\
    \x07\x20\x01(\rR\x0bnumRequired\x12\x1d\n\nitem_count\x18\x08\x20\x01(\r\
    R\titemCount\x12#\n\rnum_fulfilled\x18\t\x20\x01(\rR\x0cnumFulfilled\x12\
    '\n\x0fitems_fulfilled\x18\n\x20\x01(\rR\x0eitemsFulfilled\"1\n\x1bCAttr\
    ibute_ItemSlotCriteria\x12\x12\n\x04tags\x18\x01\x20\x01(\tR\x04tags\"\
    \x85\x01\n\x18CMsgSetItemSlotAttribute\x12\x17\n\x07item_id\x18\x01\x20\
    \x01(\x04R\x06itemId\x121\n\x15slot_item_original_id\x18\x02\x20\x01(\
    \x04R\x12slotItemOriginalId\x12\x1d\n\nslot_index\x18\x03\x20\x01(\rR\ts\
    lotIndex\"\x95\x01\n\nCSOWarData\x12#\n\naccount_id\x18\x01\x20\x01(\rR\
    \taccountIdB\x04\x80\xa6\x1d\x01\x12\x1b\n\x06war_id\x18\x02\x20\x01(\rR\
    \x05warIdB\x04\x80\xa6\x1d\x01\x12\x20\n\x0baffiliation\x18\x03\x20\x01(\
    \rR\x0baffiliation\x12#\n\rpoints_scored\x18\x04\x20\x01(\rR\x0cpointsSc\
    ored\"g\n\x1dCGCMsgGC_War_IndividualUpdate\x12\x19\n\x08steam_id\x18\x01\
    \x20\x01(\x06R\x07steamId\x12\x15\n\x06war_id\x18\x02\x20\x01(\rR\x05war\
    Id\x12\x14\n\x05score\x18\x03\x20\x01(\rR\x05score\"O\n\x14CGCMsgGC_War_\
    JoinWar\x12\x20\n\x0baffiliation\x18\x01\x20\x01(\rR\x0baffiliation\x12\
    \x15\n\x06war_id\x18\x02\x20\x01(\rR\x05warId\"8\n\x1fCGCMsgGC_War_Reque\
    stGlobalStats\x12\x15\n\x06war_id\x18\x01\x20\x01(\rR\x05warId\"\xbe\x01\
    \n\x20CGCMsgGC_War_GlobalStatsResponse\x12L\n\x0bside_scores\x18\x01\x20\
    \x03(\x0b2+.CGCMsgGC_War_GlobalStatsResponse.SideScoreR\nsideScores\x12\
    \x15\n\x06war_id\x18\x02\x20\x01(\rR\x05warId\x1a5\n\tSideScore\x12\x12\
    \n\x04side\x18\x01\x20\x01(\rR\x04side\x12\x14\n\x05score\x18\x02\x20\
    \x01(\x04R\x05score\"\x97\x01\n/CGCMsgGC_PlayerDuckLeaderboard_Individua\
    lUpdate\x12\x14\n\x05score\x18\x02\x20\x01(\rR\x05score\x12\x12\n\x04typ\
    e\x18\x03\x20\x01(\rR\x04type\x12\x19\n\x08score_id\x18\x04\x20\x01(\x0c\
    R\x07scoreId\x12\x1f\n\x0bscore_check\x18\x05\x20\x01(\rR\nscoreCheck\"\
    \xc7\x01\n\x1dCAttribute_WorldItemPlacement\x12(\n\x10original_item_id\
    \x18\x01\x20\x01(\x04R\x0eoriginalItemId\x12\x13\n\x05pos_x\x18\x02\x20\
    \x01(\x02R\x04posX\x12\x13\n\x05pos_y\x18\x03\x20\x01(\x02R\x04posY\x12\
    \x13\n\x05pos_z\x18\x04\x20\x01(\x02R\x04posZ\x12\x13\n\x05ang_x\x18\x05\
    \x20\x01(\x02R\x04angX\x12\x13\n\x05ang_y\x18\x06\x20\x01(\x02R\x04angY\
    \x12\x13\n\x05ang_z\x18\x07\x20\x01(\x02R\x04angZ\"\x95\x02\n\x20CGCMsg_\
    WorldItemPlacement_Update\x12(\n\x10original_item_id\x18\x01\x20\x01(\
    \x04R\x0eoriginalItemId\x12\x13\n\x05pos_x\x18\x02\x20\x01(\x02R\x04posX\
    \x12\x13\n\x05pos_y\x18\x03\x20\x01(\x02R\x04posY\x12\x13\n\x05pos_z\x18\
    \x04\x20\x01(\x02R\x04posZ\x12\x13\n\x05ang_x\x18\x05\x20\x01(\x02R\x04a\
    ngX\x12\x13\n\x05ang_y\x18\x06\x20\x01(\x02R\x04angY\x12\x13\n\x05ang_z\
    \x18\x07\x20\x01(\x02R\x04angZ\x12(\n\x10force_remove_all\x18\x08\x20\
    \x01(\x08R\x0eforceRemoveAll\x12\x1f\n\x0battrib_name\x18\t\x20\x01(\tR\
    \nattribName\"g\n\x11CMsgAcknowledgeXP\x12\x1f\n\x0bmatch_group\x18\x01\
    \x20\x01(\x05R\nmatchGroup\x121\n\x14predicted_experience\x18\x02\x20\
    \x01(\rR\x13predictedExperience\"\xc2\x03\n\x0eCMsgTFXPSource\x12D\n\x04\
    type\x18\x01\x20\x01(\x0e2\x1c.CMsgTFXPSource.XPSourceType:\x0cSOURCE_SC\
    ORER\x04typeB\x04\x80\xa6\x1d\x01\x12\x16\n\x06amount\x18\x02\x20\x01(\
    \x05R\x06amount\x12\x1f\n\x0bmatch_group\x18\x03\x20\x01(\x05R\nmatchGro\
    up\x12#\n\naccount_id\x18\x04\x20\x01(\rR\taccountIdB\x04\x80\xa6\x1d\
    \x01\x12\x1f\n\x08match_id\x18\x05\x20\x01(\x04R\x07matchIdB\x04\x80\xa6\
    \x1d\x01\"\xea\x01\n\x0cXPSourceType\x12\x10\n\x0cSOURCE_SCORE\x10\0\x12\
    \x1a\n\x16SOURCE_OBJECTIVE_BONUS\x10\x01\x12\x1a\n\x16SOURCE_COMPLETED_M\
    ATCH\x10\x02\x12\x1e\n\x1aSOURCE_COMPETITIVE_ABANDON\x10\x03\x12\x1a\n\
    \x16SOURCE_COMPETITIVE_WIN\x10\x04\x12\x1b\n\x17SOURCE_COMPETITIVE_LOSS\
    \x10\x05\x12\x1c\n\x18SOURCE_AUTOBALANCE_BONUS\x10\x06\x12\x19\n\x15SOUR\
    CE_PRESTIGE_BONUS\x10\x07\"D\n\x17CMsgTFXPSourceBreakdown\x12)\n\x07sour\
    ces\x18\x01\x20\x03(\x0b2\x0f.CMsgTFXPSourceR\x07sources\"U\n\x10CMsgTFC\
    lientInit\x12%\n\x0eclient_version\x18\x01\x20\x01(\rR\rclientVersion\
    \x12\x1a\n\x08language\x18\x02\x20\x01(\x05R\x08language\"\x8d\x04\n\x12\
    CMsgGCNotification\x12-\n\x0fnotification_id\x18\x01\x20\x01(\x04R\x0eno\
    tificationIdB\x04\x80\xa6\x1d\x01\x12\x1d\n\naccount_id\x18\x02\x20\x01(\
    \rR\taccountId\x12'\n\x0fexpiration_time\x18\x03\x20\x01(\x07R\x0eexpira\
    tionTime\x12T\n\x04type\x18\x04\x20\x01(\x0e2$.CMsgGCNotification.Notifi\
    cationType:\x1aNOTIFICATION_CUSTOM_STRINGR\x04type\x12/\n\x13notificatio\
    n_string\x18\x05\x20\x01(\tR\x12notificationString\"\xf8\x01\n\x10Notifi\
    cationType\x12'\n#NOTIFICATION_REPORTED_PLAYER_BANNED\x10\0\x12\x1e\n\
    \x1aNOTIFICATION_CUSTOM_STRING\x10\x01\x120\n,NOTIFICATION_MM_BAN_DUE_TO\
    _EXCESSIVE_REPORTS\x10\x02\x12+\n'NOTIFICATION_REPORTED_PLAYER_WAS_BANNE\
    D\x10\x03\x12\x20\n\x1cNOTIFICATION_SUPPORT_MESSAGE\x10\x04\x12\x1a\n\
    \x16NOTIFICATION_NUM_TYPES\x10\x05\"T\n\x17CMsgGCNotificationQueue\x129\
    \n\rnotifications\x18\x01\x20\x03(\x0b2\x13.CMsgGCNotificationR\rnotific\
    ations\"e\n\x1bCMsgNotificationAcknowledge\x12\x1d\n\naccount_id\x18\x01\
    \x20\x01(\rR\taccountId\x12'\n\x0fnotification_id\x18\x02\x20\x01(\x04R\
    \x0enotificationId\"\"\n\x20CMsgNotificationAcknowledgeReply\"\xe6\n\n\
    \x13CMsgGC_Match_Result\x12\x1f\n\x08match_id\x18\x01\x20\x01(\x04R\x07m\
    atchIdB\x04\x80\xa6\x1d\x01\x12\x1f\n\x0bmatch_group\x18\x02\x20\x01(\
    \x05R\nmatchGroup\x12D\n\x06status\x18\x03\x20\x01(\x0e2\x1b.CMsgGC_Matc\
    h_Result.Status:\x0fMATCH_SUCCEEDEDR\x06status\x12\x1a\n\x08duration\x18\
    \x04\x20\x01(\rR\x08duration\x12\x1b\n\tred_score\x18\x05\x20\x01(\rR\
    \x08redScore\x12\x1d\n\nblue_score\x18\x06\x20\x01(\rR\tblueScore\x12!\n\
    \x0cwinning_team\x18\x07\x20\x01(\rR\x0bwinningTeam\x12\x1b\n\tmap_index\
    \x18\x08\x20\x01(\rR\x08mapIndex\x12\x1e\n\tgame_type\x18\t\x20\x01(\r:\
    \x010R\x08gameType\x125\n\x07players\x18\n\x20\x03(\x0b2\x1b.CMsgGC_Matc\
    h_Result.PlayerR\x07players\x12\x1d\n\nwin_reason\x18\r\x20\x01(\rR\twin\
    Reason\x12\x14\n\x05flags\x18\x0e\x20\x01(\rR\x05flags\x12\x12\n\x04bots\
    \x18\x10\x20\x01(\rR\x04bots\x1a\xd5\x05\n\x06Player\x12\x19\n\x08steam_\
    id\x18\x01\x20\x01(\x06R\x07steamId\x12*\n\x11original_party_id\x18\x02\
    \x20\x01(\x04R\x0foriginalPartyId\x12\x12\n\x04team\x18\x03\x20\x01(\rR\
    \x04team\x12\x14\n\x05score\x18\x04\x20\x01(\rR\x05score\x12\x12\n\x04pi\
    ng\x18\x05\x20\x01(\rR\x04ping\x12\x14\n\x05flags\x18\x06\x20\x01(\rR\
    \x05flags\x12\x12\n\x04rank\x18\t\x20\x01(\rR\x04rank\x12%\n\x0eclasses_\
    played\x18\n\x20\x01(\rR\rclassesPlayed\x12\x14\n\x05kills\x18\x0b\x20\
    \x01(\rR\x05kills\x12\x16\n\x06deaths\x18\x0c\x20\x01(\rR\x06deaths\x12\
    \x16\n\x06damage\x18\r\x20\x01(\rR\x06damage\x12\x18\n\x07healing\x18\
    \x0e\x20\x01(\rR\x07healing\x12\x18\n\x07support\x18\x0f\x20\x01(\rR\x07\
    support\x12\x1f\n\x0bscore_medal\x18\x10\x20\x01(\rR\nscoreMedal\x12\x1f\
    \n\x0bkills_medal\x18\x11\x20\x01(\rR\nkillsMedal\x12!\n\x0cdamage_medal\
    \x18\x12\x20\x01(\rR\x0bdamageMedal\x12#\n\rhealing_medal\x18\x13\x20\
    \x01(\rR\x0chealingMedal\x12#\n\rsupport_medal\x18\x14\x20\x01(\rR\x0csu\
    pportMedal\x122\n\x0cxp_breakdown\x18\x15\x20\x03(\x0b2\x0f.CMsgTFXPSour\
    ceR\x0bxpBreakdown\x12\x1d\n\nleave_time\x18\x16\x20\x01(\rR\tleaveTime\
    \x12V\n\x0cleave_reason\x18\x17\x20\x01(\x0e2\x13.TFMatchLeaveReason:\
    \x1eTFMatchLeaveReason_UNSPECIFIEDR\x0bleaveReason\x12!\n\x0cconnect_tim\
    e\x18\x18\x20\x01(\rR\x0bconnectTime\"\xb6\x01\n\x06Status\x12\x13\n\x0f\
    MATCH_SUCCEEDED\x10\0\x12\x13\n\x0fMATCH_FAILED_GC\x10\x01\x12\x18\n\x14\
    MATCH_FAILED_TRUSTED\x10\x02\x12\x18\n\x14MATCH_FAILED_ABANDON\x10\x03\
    \x12\x18\n\x14MATCH_FAILED_UNKNOWN\x10\x05\x12\x18\n\x14MATCH_FAILED_TIM\
    EOUT\x10\x06\x12\x1a\n\x16MATCH_FINISHED_ABANDON\x10\x07\"\x1d\n\x1bCMsg\
    GC_Match_ResultResponse\"E\n\x19CEconItemPreviewDataBlock\x12(\n\x08econ\
    item\x18\x01\x20\x01(\x0b2\x0c.CSOEconItemR\x08econitem\"\x91\x01\n+CMsg\
    GC_Client2GCEconPreviewDataBlockRequest\x12\x17\n\x07param_s\x18\x01\x20\
    \x01(\x04R\x06paramS\x12\x17\n\x07param_a\x18\x02\x20\x01(\x04R\x06param\
    A\x12\x17\n\x07param_d\x18\x03\x20\x01(\x04R\x06paramD\x12\x17\n\x07para\
    m_m\x18\x04\x20\x01(\x04R\x06paramM\"f\n,CMsgGC_Client2GCEconPreviewData\
    BlockResponse\x126\n\x08iteminfo\x18\x01\x20\x01(\x0b2\x1a.CEconItemPrev\
    iewDataBlockR\x08iteminfo\"\xc4\x06\n\x16CSOTFLadderPlayerStats\x12#\n\n\
    account_id\x18\x01\x20\x01(\rR\taccountIdB\x04\x80\xa6\x1d\x01\x12%\n\
    \x0bmatch_group\x18\x02\x20\x01(\x05R\nmatchGroupB\x04\x80\xa6\x1d\x01\
    \x12!\n\tseason_id\x18\x03\x20\x01(\rR\x08seasonIdB\x04\x80\xa6\x1d\x01\
    \x12\x14\n\x05games\x18\t\x20\x01(\rR\x05games\x12\x14\n\x05score\x18\n\
    \x20\x01(\rR\x05score\x12\x14\n\x05kills\x18\x0b\x20\x01(\rR\x05kills\
    \x12\x16\n\x06deaths\x18\x0c\x20\x01(\rR\x06deaths\x12\x16\n\x06damage\
    \x18\r\x20\x01(\rR\x06damage\x12\x18\n\x07healing\x18\x0e\x20\x01(\rR\
    \x07healing\x12\x18\n\x07support\x18\x0f\x20\x01(\rR\x07support\x12!\n\
    \x0cscore_bronze\x18\x10\x20\x01(\rR\x0bscoreBronze\x12!\n\x0cscore_silv\
    er\x18\x11\x20\x01(\rR\x0bscoreSilver\x12\x1d\n\nscore_gold\x18\x12\x20\
    \x01(\rR\tscoreGold\x12!\n\x0ckills_bronze\x18\x13\x20\x01(\rR\x0bkillsB\
    ronze\x12!\n\x0ckills_silver\x18\x14\x20\x01(\rR\x0bkillsSilver\x12\x1d\
    \n\nkills_gold\x18\x15\x20\x01(\rR\tkillsGold\x12#\n\rdamage_bronze\x18\
    \x16\x20\x01(\rR\x0cdamageBronze\x12#\n\rdamage_silver\x18\x17\x20\x01(\
    \rR\x0cdamageSilver\x12\x1f\n\x0bdamage_gold\x18\x18\x20\x01(\rR\ndamage\
    Gold\x12%\n\x0ehealing_bronze\x18\x19\x20\x01(\rR\rhealingBronze\x12%\n\
    \x0ehealing_silver\x18\x1a\x20\x01(\rR\rhealingSilver\x12!\n\x0chealing_\
    gold\x18\x1b\x20\x01(\rR\x0bhealingGold\x12%\n\x0esupport_bronze\x18\x1c\
    \x20\x01(\rR\rsupportBronze\x12%\n\x0esupport_silver\x18\x1d\x20\x01(\rR\
    \rsupportSilver\x12!\n\x0csupport_gold\x18\x1e\x20\x01(\rR\x0bsupportGol\
    d\"\xd8\x01\n\x0fCSOTFRatingData\x12#\n\naccount_id\x18\x01\x20\x01(\rR\
    \taccountIdB\x04\x80\xa6\x1d\x01\x12%\n\x0brating_type\x18\x02\x20\x01(\
    \x05R\nratingTypeB\x04\x80\xa6\x1d\x01\x12%\n\x0erating_primary\x18\x03\
    \x20\x01(\rR\rratingPrimary\x12)\n\x10rating_secondary\x18\x04\x20\x01(\
    \rR\x0fratingSecondary\x12'\n\x0frating_tertiary\x18\x05\x20\x01(\rR\x0e\
    ratingTertiary\"\xb6\x01\n\x1eCMsgGC_TFVoteKickPlayerRequest\x12\x1b\n\t\
    target_id\x18\x02\x20\x01(\x04R\x08targetId\x12\x19\n\x08voter_id\x18\
    \x03\x20\x01(\x04R\x07voterId\x12A\n\x06reason\x18\x04\x20\x01(\x0e2\x11\
    .TFVoteKickReason:\x16TFVoteKickReason_OtherR\x06reason\x12\x19\n\x08mat\
    ch_id\x18\x05\x20\x01(\x04R\x07matchId\"\x8c\x01\n$CMsgGC_VoteKickPlayer\
    RequestResponse\x12\x18\n\x07allowed\x18\x01\x20\x01(\x08R\x07allowed\
    \x12#\n\rvoter_inhibit\x18\x03\x20\x01(\x08R\x0cvoterInhibit\x12%\n\x0et\
    arget_inhibit\x18\x04\x20\x01(\x08R\rtargetInhibit\"$\n\"CMsgGC_DailyCom\
    petitiveStatsRollup\"\x93\x04\n+CMsgGC_DailyCompetitiveStatsRollup_Respo\
    nse\x12X\n\x08rankdata\x18\x01\x20\x03(\x0b2<.CMsgGC_DailyCompetitiveSta\
    tsRollup_Response.RankBucketEntryR\x08rankdata\x1a\x89\x03\n\x0fRankBuck\
    etEntry\x12\x12\n\x04rank\x18\x01\x20\x01(\rR\x04rank\x12\x18\n\x07recor\
    ds\x18\x02\x20\x01(\rR\x07records\x12\x1b\n\tavg_score\x18\x03\x20\x01(\
    \rR\x08avgScore\x12\x1f\n\x0bstdev_score\x18\x04\x20\x01(\rR\nstdevScore\
    \x12\x1b\n\tavg_kills\x18\x05\x20\x01(\rR\x08avgKills\x12\x1f\n\x0bstdev\
    _kills\x18\x06\x20\x01(\rR\nstdevKills\x12\x1d\n\navg_damage\x18\x07\x20\
    \x01(\rR\tavgDamage\x12!\n\x0cstdev_damage\x18\x08\x20\x01(\rR\x0bstdevD\
    amage\x12\x1f\n\x0bavg_healing\x18\t\x20\x01(\rR\navgHealing\x12#\n\rstd\
    ev_healing\x18\n\x20\x01(\rR\x0cstdevHealing\x12\x1f\n\x0bavg_support\
    \x18\x0b\x20\x01(\rR\navgSupport\x12#\n\rstdev_support\x18\x0c\x20\x01(\
    \rR\x0cstdevSupport\"\x92\x02\n\x13CMsgGC_ReportPlayer\x12*\n\x11account\
    _id_target\x18\x01\x20\x01(\rR\x0faccountIdTarget\x12E\n\x06reason\x18\
    \x02\x20\x01(\x0e2\x1c.CMsgGC_ReportPlayer.EReason:\x0fkReason_INVALIDR\
    \x06reason\"\x87\x01\n\x07EReason\x12\x13\n\x0fkReason_INVALID\x10\0\x12\
    \x14\n\x10kReason_CHEATING\x10\x01\x12\x10\n\x0ckReason_IDLE\x10\x02\x12\
    \x16\n\x12kReason_HARASSMENT\x10\x03\x12\x14\n\x10kReason_GRIEFING\x10\
    \x04\x12\x11\n\rkReason_COUNT\x10\x05\"\xd8\x06\n\x1bCSOTFMatchResultPla\
    yerStats\x12\x1f\n\x08match_id\x18\x01\x20\x01(\x04R\x07matchIdB\x04\x80\
    \xa6\x1d\x01\x12#\n\naccount_id\x18\x02\x20\x01(\rR\taccountIdB\x04\x80\
    \xa6\x1d\x01\x12%\n\x0bmatch_group\x18\x03\x20\x01(\x05R\nmatchGroupB\
    \x04\x80\xa6\x1d\x01\x12\x18\n\x07endtime\x18\x04\x20\x01(\rR\x07endtime\
    \x12\x1b\n\tseason_id\x18\x05\x20\x01(\rR\x08seasonId\x12\x16\n\x06statu\
    s\x18\x06\x20\x01(\rR\x06status\x12*\n\x11original_party_id\x18\x07\x20\
    \x01(\rR\x0foriginalPartyId\x12\x12\n\x04team\x18\x08\x20\x01(\rR\x04tea\
    m\x12\x14\n\x05score\x18\t\x20\x01(\rR\x05score\x12\x12\n\x04ping\x18\n\
    \x20\x01(\rR\x04ping\x12\x14\n\x05flags\x18\x0b\x20\x01(\rR\x05flags\x12\
    %\n\x0edisplay_rating\x18\x0c\x20\x01(\rR\rdisplayRating\x122\n\x15displ\
    ay_rating_change\x18\r\x20\x01(\x05R\x13displayRatingChange\x12\x12\n\
    \x04rank\x18\x0e\x20\x01(\rR\x04rank\x12%\n\x0eclasses_played\x18\x0f\
    \x20\x01(\rR\rclassesPlayed\x12\x14\n\x05kills\x18\x10\x20\x01(\rR\x05ki\
    lls\x12\x16\n\x06deaths\x18\x11\x20\x01(\rR\x06deaths\x12\x16\n\x06damag\
    e\x18\x12\x20\x01(\rR\x06damage\x12\x18\n\x07healing\x18\x13\x20\x01(\rR\
    \x07healing\x12\x18\n\x07support\x18\x14\x20\x01(\rR\x07support\x12\x1f\
    \n\x0bscore_medal\x18\x15\x20\x01(\rR\nscoreMedal\x12\x1f\n\x0bkills_med\
    al\x18\x16\x20\x01(\rR\nkillsMedal\x12!\n\x0cdamage_medal\x18\x17\x20\
    \x01(\rR\x0bdamageMedal\x12#\n\rhealing_medal\x18\x18\x20\x01(\rR\x0chea\
    lingMedal\x12#\n\rsupport_medal\x18\x19\x20\x01(\rR\x0csupportMedal\x12\
    \x1b\n\tmap_index\x18\x1a\x20\x01(\rR\x08mapIndex\x12!\n\x0cwinning_team\
    \x18\x1b\x20\x01(\rR\x0bwinningTeam\"\x1e\n\x1cCMsgGCRequestMatchMakerSt\
    ats\"S\n\x1aCMsgGCDataCenterPopulation\x12\x12\n\x04name\x18\x01\x20\x01\
    (\tR\x04name\x12!\n\x0chealth_ratio\x18\x02\x20\x01(\x02R\x0bhealthRatio\
    \"y\n$CMsgGCMatchGroupDataCenterPopulation\x12Q\n\x16data_center_populat\
    ion\x18\x01\x20\x03(\x0b2\x1b.CMsgGCDataCenterPopulationR\x14dataCenterP\
    opulation\"\xae\x01\n\x1dCMsgGCMatchMakerStatsResponse\x12\x1b\n\tmap_co\
    unt\x18\x01\x20\x03(\rR\x08mapCount\x12p\n!matchgroup_data_center_popula\
    tion\x18\x02\x20\x03(\x0b2%.CMsgGCMatchGroupDataCenterPopulationR\x1emat\
    chgroupDataCenterPopulation\"b\n\x16CMsgGCMatchHistoryLoad\x12H\n\x0bmat\
    ch_group\x18\x01\x20\x01(\x0e2\x0e.ETFMatchGroup:\x17k_eTFMatchGroup_Inv\
    alidR\nmatchGroup\"\xaf\x02\n\x1bCMsgGCDataCenterPing_Update\x12B\n\x08p\
    ingdata\x18\x01\x20\x03(\x0b2&.CMsgGCDataCenterPing_Update.PingEntryR\
    \x08pingdata\x1a\x81\x01\n\tPingEntry\x12\x12\n\x04name\x18\x01\x20\x01(\
    \tR\x04name\x12\x12\n\x04ping\x18\x02\x20\x01(\rR\x04ping\x12L\n\x0bping\
    _status\x18\x03\x20\x01(\x0e2#.CMsgGCDataCenterPing_Update.Status:\x06No\
    rmalR\npingStatus\"H\n\x06Status\x12\x0b\n\x07Invalid\x10\0\x12\n\n\x06N\
    ormal\x10\x01\x12\x0f\n\x0bUnreachable\x10\x02\x12\x14\n\x10FallbackToDC\
    Ping\x10\x03\"8\n\x1aCMsgGC_KickPlayerFromLobby\x12\x1a\n\x08targetID\
    \x18\x01\x20\x01(\x04R\x08targetID\"\x82\x01\n\x13CMsgGCSurveyRequest\
    \x12P\n\rquestion_type\x18\x01\x20\x01(\x0e2\x13.SurveyQuestionType:\x16\
    QUESTION_MATCH_QUALITYR\x0cquestionType\x12\x19\n\x08match_id\x18\x02\
    \x20\x01(\x04R\x07matchId\"\x9f\x01\n\x14CMsgGCSurveyResponse\x12P\n\rqu\
    estion_type\x18\x01\x20\x01(\x0e2\x13.SurveyQuestionType:\x16QUESTION_MA\
    TCH_QUALITYR\x0cquestionType\x12\x19\n\x08match_id\x18\x02\x20\x01(\x04R\
    \x07matchId\x12\x1a\n\x08response\x18\x03\x20\x01(\x05R\x08response\"\
    \xea\x02\n\x0fCSOQuestMapNode\x12#\n\naccount_id\x18\x01\x20\x01(\rR\tac\
    countIdB\x04\x80\xa6\x1d\x01\x12\x20\n\x08defindex\x18\x03\x20\x01(\rR\
    \x08defindexB\x04\x80\xa6\x1d\x01\x12\x17\n\x07node_id\x18\x04\x20\x01(\
    \rR\x06nodeId\x12)\n\rstar_0_earned\x18\x06\x20\x01(\x08:\x05falseR\x0bs\
    tar0Earned\x12)\n\rstar_1_earned\x18\x07\x20\x01(\x08:\x05falseR\x0bstar\
    1Earned\x12)\n\rstar_2_earned\x18\x08\x20\x01(\x08:\x05falseR\x0bstar2Ea\
    rned\x12(\n\x0cloot_claimed\x18\t\x20\x01(\x08:\x05falseR\x0blootClaimed\
    \x12/\n\x12selected_quest_def\x18\n\x20\x01(\r:\x010R\x10selectedQuestDe\
    f\x12\x1b\n\tmap_cycle\x18\x0b\x20\x01(\rR\x08mapCycle\"\xab\x02\n\x08CS\
    OQuest\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x1f\n\
    \x08quest_id\x18\x02\x20\x01(\x04R\x07questIdB\x04\x80\xa6\x1d\x01\x12\
    \x1a\n\x08defindex\x18\x03\x20\x01(\rR\x08defindex\x12\x1d\n\x06active\
    \x18\x04\x20\x01(\x08:\x05falseR\x06active\x12\x19\n\x08points_0\x18\x05\
    \x20\x01(\rR\x07points0\x12\x19\n\x08points_1\x18\x06\x20\x01(\rR\x07poi\
    nts1\x12\x19\n\x08points_2\x18\x07\x20\x01(\rR\x07points2\x126\n\x18ques\
    t_map_node_source_id\x18\x08\x20\x01(\rR\x14questMapNodeSourceId\x12\x1b\
    \n\tmap_cycle\x18\t\x20\x01(\rR\x08mapCycle\"\xb0\x01\n\x19CSOQuestMapRe\
    wardPurchase\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\
    \x20\n\x08defindex\x18\x02\x20\x01(\rR\x08defindexB\x04\x80\xa6\x1d\x01\
    \x12\x14\n\x05count\x18\x03\x20\x01(\rR\x05count\x12\x1b\n\tmap_cycle\
    \x18\x04\x20\x01(\rR\x08mapCycle\x12\x1f\n\x0bpurchase_id\x18\x05\x20\
    \x01(\rR\npurchaseId\"0\n\x13CMsgGCQuestIdentify\x12\x19\n\x08quest_id\
    \x18\x01\x20\x01(\x04R\x07questId\"<\n\x12CMsgGCQuestDevGive\x12&\n\x0fq\
    uest_def_index\x18\x01\x20\x01(\rR\rquestDefIndex\"<\n\x15CMsgGCQuestNod\
    eTurnIn\x12#\n\rnode_defindex\x18\x01\x20\x01(\rR\x0cnodeDefindex\"f\n\
    \x18CMsgGCQuestMapUnlockNode\x12#\n\rnode_defindex\x18\x01\x20\x01(\rR\
    \x0cnodeDefindex\x12%\n\x0equest_defindex\x18\x02\x20\x01(\rR\rquestDefi\
    ndex\"\x84\x01\n\x1dCMsgGCNewMatchForLobbyRequest\x12(\n\x10current_matc\
    h_id\x18\x01\x20\x01(\x04R\x0ecurrentMatchId\x12\x1e\n\x0bnext_map_id\
    \x18\x02\x20\x01(\rR\tnextMapId\x12\x19\n\x08lobby_id\x18\x03\x20\x01(\
    \x04R\x07lobbyId\":\n\x1eCMsgGCNewMatchForLobbyResponse\x12\x18\n\x07suc\
    cess\x18\x01\x20\x01(\x08R\x07success\"\x82\x02\n#CMsgGCChangeMatchPlaye\
    rTeamsRequest\x12\x19\n\x08match_id\x18\x01\x20\x01(\x04R\x07matchId\x12\
    \x19\n\x08lobby_id\x18\x02\x20\x01(\x04R\x07lobbyId\x12C\n\x06member\x18\
    \x03\x20\x03(\x0b2+.CMsgGCChangeMatchPlayerTeamsRequest.MemberR\x06membe\
    r\x1a`\n\x06Member\x12\x1b\n\tmember_id\x18\x01\x20\x01(\x04R\x08memberI\
    d\x129\n\x08new_team\x18\x02\x20\x01(\x0e2\x0b.TF_GC_TEAM:\x11TF_GC_TEAM\
    _NOTEAMR\x07newTeam\"@\n$CMsgGCChangeMatchPlayerTeamsResponse\x12\x18\n\
    \x07success\x18\x01\x20\x01(\x08R\x07success\"W\n\x19CMsgGCQuestComplete\
    _Debug\x12\x19\n\x08quest_id\x18\x01\x20\x01(\x04R\x07questId\x12\x1f\n\
    \x0bpoints_type\x18\x02\x20\x01(\rR\npointsType\"\x9c\x01\n\x14CMsgGCQue\
    stMap_Debug\x12'\n\x0freset_operation\x18\x01\x20\x01(\rR\x0eresetOperat\
    ion\x12\x1f\n\x0bgive_credit\x18\x02\x20\x01(\rR\ngiveCredit\x12:\n\x0bu\
    nlock_node\x18\x03\x20\x01(\x0b2\x19.CMsgGCQuestMapUnlockNodeR\nunlockNo\
    de\"N\n\x1cCMsgGCQuestMapPurchaseReward\x12.\n\x13store_item_defindex\
    \x18\x01\x20\x01(\rR\x11storeItemDefindex\"6\n\x13CMsgGCQuestResponse\
    \x12\x1f\n\x07success\x18\x01\x20\x01(\x08:\x05falseR\x07success\":\n\"C\
    MsgGCSetDisablePartyQuestProgress\x12\x14\n\x05state\x18\x01\x20\x01(\
    \x08R\x05state\"\xa6\x02\n\x17CMsgQuestProgressReport\x12\x19\n\x08quest\
    _id\x18\x01\x20\x01(\x04R\x07questId\x12\"\n\rstar_0_earned\x18\x02\x20\
    \x01(\x08R\x0bstar0Earned\x12\"\n\rstar_1_earned\x18\x03\x20\x01(\x08R\
    \x0bstar1Earned\x12\"\n\rstar_2_earned\x18\x04\x20\x01(\x08R\x0bstar2Ear\
    ned\x12!\n\x0citems_earned\x18\x05\x20\x03(\x04R\x0bitemsEarned\x122\n\
    \x15reward_credits_earned\x18\x06\x20\x01(\rR\x13rewardCreditsEarned\x12\
    -\n\x12contract_completed\x18\x07\x20\x01(\x08R\x11contractCompleted\"[\
    \n\x13CMsgConsumePaintkit\x12\x1b\n\tsource_id\x18\x01\x20\x01(\x06R\x08\
    sourceId\x12'\n\x0ftarget_defindex\x18\x02\x20\x01(\rR\x0etargetDefindex\
    \"{\n\x13CMsgPainkitDevGrant\x12+\n\x11paintkit_defindex\x18\x01\x20\x01\
    (\rR\x10paintkitDefindex\x12\x12\n\x04wear\x18\x02\x20\x01(\x02R\x04wear\
    \x12#\n\ritem_defindex\x18\x03\x20\x01(\rR\x0citemDefindex\"\xc6\x01\n\
    \x13GCQuestStrangeEvent\x12(\n\x10owner_account_id\x18\x01\x20\x01(\rR\
    \x0eownerAccountId\x12*\n\x11scorer_account_id\x18\x02\x20\x01(\rR\x0fsc\
    orerAccountId\x12\x19\n\x08quest_id\x18\x03\x20\x01(\x04R\x07questId\x12\
    (\n\x10strange_event_id\x18\x04\x20\x01(\rR\x0estrangeEventId\x12\x14\n\
    \x05score\x18\x05\x20\x01(\rR\x05score\"<\n\rCMsgSDRTicket\x12+\n\x11ser\
    ialized_ticket\x18\x01\x20\x01(\x0cR\x10serializedTicket*\x823\n\x08ETFG\
    CMsg\x12\x1a\n\x15k_EMsgGCReportWarKill\x10\x89'\x12\"\n\x1dk_EMsgGCKick\
    Player_DEPRECATED\x10\x9c'\x12'\n\"k_EMsgGCStartedTraining_DEPRECATED\
    \x10\x9d'\x12.\n)k_EMsgGCFreeTrial_ChooseMostHelpfulFriend\x10\x9e'\x12\
    \x1e\n\x19k_EMsgGCRequestTF2Friends\x10\x9f'\x12&\n!k_EMsgGCRequestTF2Fr\
    iendsResponse\x10\xa0'\x12&\n!k_EMsgGCReplay_SubmitContestEntry\x10\xa2'\
    \x12.\n)k_EMsgGCReplay_SubmitContestEntryResponse\x10\xa3'\x12\x1a\n\x15\
    k_EMsgGCSaxxy_Awarded\x10\xa5'\x12'\n\"k_EMsgGCFreeTrial_ThankedBySomeon\
    e\x10\xa4'\x12%\n\x20k_EMsgGCFreeTrial_ThankedSomeone\x10\xa6'\x12)\n$k_\
    EMsgGCFreeTrial_ConvertedToPremium\x10\xa7'\x128\n3k_EMsgGCMeetThePyroSi\
    lliness_BananaCraft_DEPRECATED\x10\xa8'\x126\n1k_EMsgGCMVMARG_HighFiveSu\
    ccessResponse_DEPRECATED\x10\xa9'\x12/\n*k_EMsgGCMVMARG_HighFiveOnClient\
    _DEPRECATED\x10\xaa'\x12\"\n\x1dk_EMsgGCCoaching_AddToCoaches\x10\xd0(\
    \x12*\n%k_EMsgGCCoaching_AddToCoachesResponse\x10\xd1(\x12'\n\"k_EMsgGCC\
    oaching_RemoveFromCoaches\x10\xd2(\x12/\n*k_EMsgGCCoaching_RemoveFromCoa\
    chesResponse\x10\xd3(\x12\x1f\n\x1ak_EMsgGCCoaching_FindCoach\x10\xd4(\
    \x12'\n\"k_EMsgGCCoaching_FindCoachResponse\x10\xd5(\x12\x1e\n\x19k_EMsg\
    GCCoaching_AskCoach\x10\xd6(\x12&\n!k_EMsgGCCoaching_AskCoachResponse\
    \x10\xd7(\x12#\n\x1ek_EMsgGCCoaching_CoachJoinGame\x10\xd8(\x12\"\n\x1dk\
    _EMsgGCCoaching_CoachJoining\x10\xd9(\x12!\n\x1ck_EMsgGCCoaching_CoachJo\
    ined\x10\xda(\x12&\n!k_EMsgGCCoaching_LikeCurrentCoach\x10\xdb(\x12(\n#k\
    _EMsgGCCoaching_RemoveCurrentCoach\x10\xdc(\x12'\n\"k_EMsgGCCoaching_Alr\
    eadyRatedCoach\x10\xdd(\x12\x1a\n\x15k_EMsgGC_Duel_Request\x10\xfc*\x12\
    \x1b\n\x16k_EMsgGC_Duel_Response\x10\xfd*\x12\x1a\n\x15k_EMsgGC_Duel_Res\
    ults\x10\xfe*\x12\x19\n\x14k_EMsgGC_Duel_Status\x10\xff*\x12/\n*k_EMsgGC\
    _Halloween_ReservedItem_DEPRECATED\x10\xe0+\x12,\n'k_EMsgGC_Halloween_Gr\
    antItem_DEPRECATED\x10\xe1+\x124\n/k_EMsgGC_Halloween_GrantItemResponse_\
    DEPRECATED\x10\xe4+\x126\n1k_EMsgGC_Halloween_Cheat_QueryResponse_DEPREC\
    ATED\x10\xe5+\x12.\n)k_EMsgGC_Halloween_ItemClaimed_DEPRECATED\x10\xe6+\
    \x12$\n\x1fk_EMsgGC_Halloween_ReservedItem\x10\xe7+\x12!\n\x1ck_EMsgGC_H\
    alloween_GrantItem\x10\xe8+\x12)\n$k_EMsgGC_Halloween_GrantItemResponse\
    \x10\xe9+\x128\n3k_EMsgGC_Halloween_Cheat_QueryResponse_DEPRECATED_2\x10\
    \xea+\x120\n+k_EMsgGC_Halloween_ItemClaimed_DEPRECATED_2\x10\xeb+\x12'\n\
    \"k_EMsgGC_Halloween_ServerBossEvent\x10\xec+\x12$\n\x1fk_EMsgGC_Hallowe\
    en_Merasmus2012\x10\xed+\x12/\n*k_EMsgGC_Halloween_UpdateMerasmusLootLev\
    el\x10\xee+\x12\"\n\x1dk_EMsgGC_GameServer_LevelInfo\x10\xc4,\x12&\n!k_E\
    MsgGC_GameServer_AuthChallenge\x10\xc5,\x12.\n)k_EMsgGC_GameServer_AuthC\
    hallengeResponse\x10\xc6,\x12'\n\"k_EMsgGC_GameServer_CreateIdentity\x10\
    \xc7,\x12/\n*k_EMsgGC_GameServer_CreateIdentityResponse\x10\xc8,\x12\x1d\
    \n\x18k_EMsgGC_GameServer_List\x10\xc9,\x12%\n\x20k_EMsgGC_GameServer_Li\
    stResponse\x10\xca,\x12#\n\x1ek_EMsgGC_GameServer_AuthResult\x10\xcb,\
    \x12&\n!k_EMsgGC_GameServer_ResetIdentity\x10\xcc,\x12.\n)k_EMsgGC_GameS\
    erver_ResetIdentityResponse\x10\xcd,\x12.\n)k_EMsgGC_Client_UseServerMod\
    ificationItem\x10\xce,\x127\n2k_EMsgGC_Client_UseServerModificationItem_\
    Response\x10\xcf,\x122\n-k_EMsgGC_GameServer_UseServerModificationItem\
    \x10\xd0,\x12;\n6k_EMsgGC_GameServer_UseServerModificationItem_Response\
    \x10\xd1,\x126\n1k_EMsgGC_GameServer_ServerModificationItemExpired\x10\
    \xd2,\x12.\n)k_EMsgGC_GameServer_ModificationItemState\x10\xd3,\x12\"\n\
    \x1dk_EMsgGC_GameServer_AckPolicy\x10\xd4,\x12*\n%k_EMsgGC_GameServer_Ac\
    kPolicyResponse\x10\xd5,\x12\x1d\n\x18k_EMsgGC_QP_ScoreServers\x10\xa8-\
    \x12%\n\x20k_EMsgGC_QP_ScoreServersResponse\x10\xa9-\x12\x1e\n\x19k_EMsg\
    GC_QP_PlayerJoining\x10\xaa-\x124\n/k_EMsgGC_PickupItemEligibility_Query\
    _DEPRECATED\x10\xf0.\x126\n1k_EMsgGC_PickupItemEligibility_Query_DEPRECA\
    TED_2\x10\xf1.\x124\n/k_EMsgGC_IncrementKillCountAttribute_DEPRECATED\
    \x10\xd4/\x123\n.k_EMsgGC_IncrementKillCountResponse_DEPRECATED\x10\xd5/\
    \x12\x1f\n\x1ak_EMsgGCAbandonCurrentGame\x10\xdb0\x12\x1d\n\x18k_EMsgFor\
    ceSOCacheResend\x10\xdd0\x12#\n\x1ek_EMsgGCRequestChatChannelList\x10\
    \xf40\x12+\n&k_EMsgGCRequestChatChannelListResponse\x10\xf50\x12\x14\n\
    \x0fk_EMsgGCReadyUp\x10\xfe0\x12'\n\"k_EMsgGCKickedFromMatchmakingQueue\
    \x10\xff0\x12\x1b\n\x16k_EMsgGCLeaverDetected\x10\x801\x12#\n\x1ek_EMsgG\
    CLeaverDetectedResponse\x10\x8f1\x12\x1c\n\x17k_EMsgGCExitMatchmaking\
    \x10\x911\x12\x20\n\x1bk_EMsgGCMatchmakingProgress\x10\x951\x12\x1b\n\
    \x16k_EMsgGCMvMVictoryInfo\x10\x961\x12(\n#k_EMsgGCGameServerMatchmaking\
    Status\x10\x971\x12\x17\n\x12k_EMsgGCMvMVictory\x10\x991\x12\x1c\n\x17k_\
    EMsgGCMvMVictoryReply\x10\x9a1\x12#\n\x1ek_EMsgGCGameServerKickingLobby\
    \x10\x9b1\x12+\n&k_EMsgGCLeaveGameAndPrepareToJoinParty\x10\x9c1\x12!\n\
    \x1ck_EMsgGC_UpdatePeriodicEvent\x10\x802\x12.\n)k_EMsgGC_DuckLeaderboar\
    d_IndividualUpdate\x10\x812\x122\n-k_EMsgGC_Client2GCEconPreviewDataBloc\
    kRequest\x10\x822\x123\n.k_EMsgGC_Client2GCEconPreviewDataBlockResponse\
    \x10\x832\x12)\n$k_EMsgGC_ClientVerificationChallenge\x10\xe42\x121\n,k_\
    EMsgGC_ClientVerificationChallengeResponse\x10\xe52\x12/\n*k_EMsgGC_Clie\
    ntVerificationVerboseResponse\x10\xe62\x12(\n#k_EMsgGC_ClientSetItemSlot\
    Attribute\x10\xe72\x12\"\n\x1dk_EMsgGC_War_IndividualUpdate\x10\xe92\x12\
    \x19\n\x14k_EMsgGC_War_JoinWar\x10\xea2\x12$\n\x1fk_EMsgGC_War_RequestGl\
    obalStats\x10\xeb2\x12%\n\x20k_EMsgGC_War_GlobalStatsResponse\x10\xec2\
    \x12*\n%k_EMsgGC_WorldItemPlacement_Attribute\x10\xee2\x12'\n\"k_EMsgGC_\
    WorldItemPlacement_Update\x10\xef2\x12\x1a\n\x15k_EMsgGC_Match_Result\
    \x10\xf02\x12\"\n\x1dk_EMsgGCVoteKickPlayerRequest\x10\xf12\x12*\n%k_EMs\
    gGCVoteKickPlayerRequestResponse\x10\xf22\x12)\n$k_EMsgGC_DailyCompetiti\
    veStatsRollup\x10\xf42\x122\n-k_EMsgGC_DailyCompetitiveStatsRollup_Respo\
    nse\x10\xf52\x12\"\n\x1dk_EMsgGC_WorldStatusBroadcast\x10\xf62\x12\x1a\n\
    \x15k_EMsgGC_ReportPlayer\x10\xf72\x12\"\n\x1dk_EMsgGC_Match_ResultRespo\
    nse\x10\xf82\x12+\n&k_EMsgGCGameServerKickingLobbyResponse\x10\xf92\x12\
    \x1c\n\x17k_EMsgGCPlayerLeftMatch\x10\xfa2\x12$\n\x1fk_EMsgGCPlayerLeftM\
    atchResponse\x10\xfb2\x12#\n\x1ek_EMsgGCRequestMatchMakerStats\x10\xfc2\
    \x12$\n\x1fk_EMsgGCMatchMakerStatsResponse\x10\xfd2\x12\x1d\n\x18k_EMsgG\
    CMatchHistoryLoad\x10\xfe2\x12\x1b\n\x16k_EMsgGC_AcknowledgeXP\x10\xff2\
    \x12\"\n\x1dk_EMsgGCDataCenterPing_Update\x10\x803\x12%\n\x20k_EMsgGC_No\
    tificationAcknowledge\x10\x813\x12*\n%k_EMsgGC_NotificationAcknowledgeRe\
    ply\x10\x823\x12!\n\x1ck_EMsgGC_KickPlayerFromLobby\x10\x833\x12#\n\x1ek\
    _EMsgGC_SurveyQuestionRequest\x10\x863\x12$\n\x1fk_EMsgGC_SurveyQuestion\
    Response\x10\x873\x12\x1a\n\x15k_EMsgGC_TFClientInit\x10\x883\x12%\n\x20\
    k_EMsgGC_NewMatchForLobbyRequest\x10\x893\x12&\n!k_EMsgGC_NewMatchForLob\
    byResponse\x10\x8a3\x12+\n&k_EMsgGC_ChangeMatchPlayerTeamsRequest\x10\
    \x8b3\x12,\n'k_EMsgGC_ChangeMatchPlayerTeamsResponse\x10\x8c3\x12\x1b\n\
    \x16k_EMsgGC_QuestIdentify\x10\x8d3\x12\x1a\n\x15k_EMsgGC_QuestDevGive\
    \x10\x8e3\x12\x20\n\x1bk_EMsgGCQuestComplete_Debug\x10\x903\x12\x1b\n\
    \x16k_EMsgGC_QuestMapDebug\x10\x913\x12\x20\n\x1bk_EMsgGC_QuestMapUnlock\
    Node\x10\x933\x12$\n\x1fk_EMsgGC_QuestMapPurchaseReward\x10\x953\x12*\n%\
    k_EMsgGC_SetDisablePartyQuestProgress\x10\x963\x12\x20\n\x1bk_EMsgGCQues\
    tProgressReport\x10\x993\x12\x1d\n\x18k_EMsgGCParty_SetOptions\x10\x9a3\
    \x12%\n\x20k_EMsgGCParty_SetOptionsResponse\x10\x9b3\x12\x20\n\x1bk_EMsg\
    GCParty_QueueForMatch\x10\x9c3\x12(\n#k_EMsgGCParty_QueueForMatchRespons\
    e\x10\x9d3\x12\"\n\x1dk_EMsgGCParty_RemoveFromQueue\x10\x9e3\x12*\n%k_EM\
    sgGCParty_RemoveFromQueueResponse\x10\x9f3\x12\x1f\n\x1ak_EMsgGCParty_In\
    vitePlayer\x10\xa03\x12$\n\x1fk_EMsgGCParty_RequestJoinPlayer\x10\xa13\
    \x12\x1b\n\x16k_EMsgGCParty_SendChat\x10\xa23\x12\x1a\n\x15k_EMsgGCParty\
    _ChatMsg\x10\xa33\x12\x1c\n\x17k_EMsgGCQuestNodeTurnIn\x10\xa43\x12\x1c\
    \n\x17k_EMsgGCConsumePaintKit\x10\xa53\x12\x1e\n\x19k_EMsgGC_Painkit_Dev\
    Grant\x10\xa63\x12\"\n\x1dk_EMsgGCParty_QueueForStandby\x10\xa73\x12*\n%\
    k_EMsgGCParty_QueueForStandbyResponse\x10\xa83\x12)\n$k_EMsgGCParty_Remo\
    veFromStandbyQueue\x10\xa93\x121\n,k_EMsgGCParty_RemoveFromStandbyQueueR\
    esponse\x10\xaa3\x12%\n\x20k_EMsgGCParty_ClearPendingPlayer\x10\xab3\x12\
    -\n(k_EMsgGCParty_ClearPendingPlayerResponse\x10\xac3\x12)\n$k_EMsgGCPar\
    ty_ClearOtherPartyRequest\x10\xad3\x121\n,k_EMsgGCParty_ClearOtherPartyR\
    equestResponse\x10\xae3\x12\"\n\x1dk_EMsgGCParty_PromoteToLeader\x10\xaf\
    3\x12\x1d\n\x18k_EMsgGCParty_KickMember\x10\xb03\x12\x1e\n\x19k_EMsgGCQu\
    estStrangeEvent\x10\xb13\x12\x1f\n\x1ak_EMsgGC_AcceptLobbyInvite\x10\xb2\
    3\x12$\n\x1fk_EMsgGC_AcceptLobbyInviteReply\x10\xb33\x12\x17\n\x12k_EMsg\
    GC_SDRTicket\x10\xb43\x12\"\n\x1dk_EMsgGC_ProcessMatchVoteKick\x10\xb53\
    \x12*\n%k_EMsgGC_ProcessMatchVoteKickResponse\x10\xb63\x12\x1d\n\x18k_EM\
    sgGCDev_GrantWarKill\x10\x91N*H\n\x1bEServerModificationItemType\x12)\n%\
    kGameServerModificationItem_Halloween\x10\x01*\x9b\x02\n\x13ETFSyncedMMM\
    enuStep\x12*\n\x1dk_eTFSyncedMMMenuStep_Invalid\x10\xff\xff\xff\xff\xff\
    \xff\xff\xff\xff\x01\x12\x1e\n\x1ak_eTFSyncedMMMenuStep_None\x10\0\x12*\
    \n&k_eTFSyncedMMMenuStep_Configuring_Mode\x10\x01\x12,\n(k_eTFSyncedMMMe\
    nuStep_MvM_Selecting_Mode\x10\x02\x12,\n(k_eTFSyncedMMMenuStep_MvM_Selec\
    ting_Tour\x10\x03\x120\n,k_eTFSyncedMMMenuStep_MvM_Selecting_Missions\
    \x10\x04*\x91\x06\n\rETFMatchGroup\x12$\n\x17k_eTFMatchGroup_Invalid\x10\
    \xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12\x20\n\x1ck_eTFMatchGroup_Mv\
    M_Practice\x10\0\x12\x1e\n\x1ak_eTFMatchGroup_MvM_MannUp\x10\x01\x12\x19\
    \n\x15k_eTFMatchGroup_First\x10\0\x12\x1f\n\x1bk_eTFMatchGroup_MvM_Defau\
    lt\x10\0\x12\x1d\n\x19k_eTFMatchGroup_MvM_First\x10\0\x12\x1c\n\x18k_eTF\
    MatchGroup_MvM_Last\x10\x01\x12\x1e\n\x1ak_eTFMatchGroup_Ladder_6v6\x10\
    \x02\x12\x1e\n\x1ak_eTFMatchGroup_Ladder_9v9\x10\x03\x12\x20\n\x1ck_eTFM\
    atchGroup_Ladder_12v12\x10\x04\x12\"\n\x1ek_eTFMatchGroup_Ladder_Default\
    \x10\x02\x12\x20\n\x1ck_eTFMatchGroup_Ladder_First\x10\x02\x12\x1f\n\x1b\
    k_eTFMatchGroup_Ladder_Last\x10\x04\x12\x1e\n\x1ak_eTFMatchGroup_Casual_\
    6v6\x10\x05\x12\x1e\n\x1ak_eTFMatchGroup_Casual_9v9\x10\x06\x12\x20\n\
    \x1ck_eTFMatchGroup_Casual_12v12\x10\x07\x12\"\n\x1ek_eTFMatchGroup_Casu\
    al_Default\x10\x07\x12\x20\n\x1ck_eTFMatchGroup_Casual_First\x10\x05\x12\
    \x1f\n\x1bk_eTFMatchGroup_Casual_Last\x10\x07\x12%\n!k_eTFMatchGroup_Eve\
    nt_Placeholder\x10\x08\x12!\n\x1dk_eTFMatchGroup_Event_Default\x10\x08\
    \x12\x1f\n\x1bk_eTFMatchGroup_Event_First\x10\x08\x12\x1e\n\x1ak_eTFMatc\
    hGroup_Event_Last\x10\x08\x1a\x02\x10\x01*\xc1\x02\n\x10ETFPartyChatType\
    \x12\x1e\n\x1ak_eTFPartyChatType_Invalid\x10\0\x12!\n\x1dk_eTFPartyChatT\
    ype_MemberChat\x10\x01\x12,\n'k_eTFPartyChatType_Synthetic_MemberJoin\
    \x10\xe8\x07\x12-\n(k_eTFPartyChatType_Synthetic_MemberLeave\x10\xe9\x07\
    \x12,\n'k_eTFPartyChatType_Synthetic_SendFailed\x10\xea\x07\x12.\n)k_eTF\
    PartyChatType_Synthetic_MemberOnline\x10\xeb\x07\x12/\n*k_eTFPartyChatTy\
    pe_Synthetic_MemberOffline\x10\xec\x07*\x81\x02\n\x0fTF_GC_GameState\x12\
    \x1e\n\x1aTF_GC_GAMESTATE_STATE_INIT\x10\0\x12,\n(TF_GC_GAMESTATE_WAIT_F\
    OR_PLAYERS_TO_LOAD\x10\x01\x12!\n\x1dTF_GC_GAMESTATE_STRATEGY_TIME\x10\
    \x03\x12$\n\x20TF_GC_GAMESTATE_GAME_IN_PROGRESS\x10\x05\x12\x1d\n\x19TF_\
    GC_GAMESTATE_POST_GAME\x10\x06\x12\x1e\n\x1aTF_GC_GAMESTATE_DISCONNECT\
    \x10\x07\x12\x18\n\x14TF_GC_GAMESTATE_LAST\x10\x08*\xa8\x01\n\nTF_GC_TEA\
    M\x12\x18\n\x14TF_GC_TEAM_DEFENDERS\x10\0\x12\x17\n\x13TF_GC_TEAM_INVADE\
    RS\x10\x01\x12\x1a\n\x16TF_GC_TEAM_BROADCASTER\x10\x02\x12\x18\n\x14TF_G\
    C_TEAM_SPECTATOR\x10\x03\x12\x1a\n\x16TF_GC_TEAM_PLAYER_POOL\x10\x04\x12\
    \x15\n\x11TF_GC_TEAM_NOTEAM\x10\x05*\xfa\x01\n\x12TFMatchLeaveReason\x12\
    \"\n\x1eTFMatchLeaveReason_UNSPECIFIED\x10\0\x12\x20\n\x1cTFMatchLeaveRe\
    ason_VOTE_KICK\x10\x01\x12\x1b\n\x17TFMatchLeaveReason_IDLE\x10\x02\x12!\
    \n\x1dTFMatchLeaveReason_ADMIN_KICK\x10\x03\x12\x1b\n\x17TFMatchLeaveRea\
    son_AWOL\x10\x04\x12\x1e\n\x1aTFMatchLeaveReason_NO_SHOW\x10\x05\x12!\n\
    \x1dTFMatchLeaveReason_GC_REMOVED\x10\x06*\x87\x01\n\x10TFVoteKickReason\
    \x12\x1a\n\x16TFVoteKickReason_Other\x10\0\x12\x1d\n\x19TFVoteKickReason\
    _Cheating\x10\x01\x12\x19\n\x15TFVoteKickReason_Idle\x10\x02\x12\x1d\n\
    \x19TFVoteKickReason_Scamming\x10\x03*\xf3\x01\n\x16ServerMatchmakingSta\
    te\x12\"\n\x1eServerMatchmakingState_INVALID\x10\0\x12,\n(ServerMatchmak\
    ingState_NOT_PARTICIPATING\x10\x01\x12\x20\n\x1cServerMatchmakingState_E\
    MPTY\x10\x02\x12<\n8ServerMatchmakingState_ACTIVE_MATCH_REQUESTING_LATE_\
    JOIN\x10\x03\x12'\n#ServerMatchmakingState_ACTIVE_MATCH\x10\x04*\x9c\x01\
    \n\x12SurveyQuestionType\x12\x1a\n\x16QUESTION_MATCH_QUALITY\x10\0\x12\
    \x18\n\x14QUESTION_MAP_QUALITY\x10\x01\x12\x19\n\x15QUESTION_COMP_INQUIR\
    Y\x10\x02\x12\x1b\n\x17QUESTION_CASUAL_INQUIRY\x10\x03\x12\x18\n\x14QUES\
    TION_RANDOM_CRIT\x10\x04B\x05H\x01\x80\x01\0J\xe0\xb6\x04\n\x07\x12\x05\
    \0\0\xd7\x0c\x01\n\t\n\x02\x03\0\x12\x03\0\0\x1d\n\t\n\x02\x03\x01\x12\
    \x03\x01\0\x1f\n\x08\n\x01\x08\x12\x03\x03\0\x1c\n\t\n\x02\x08\t\x12\x03\
    \x03\0\x1c\n\x08\n\x01\x08\x12\x03\x04\0#\n\t\n\x02\x08\x10\x12\x03\x04\
    \0#\n\x0b\n\x02\x05\0\x12\x05\x06\0\xac\x01\x01\n\n\n\x03\x05\0\x01\x12\
    \x03\x06\x05\r\n\x0b\n\x04\x05\0\x02\0\x12\x03\x07\x08%\n\x0c\n\x05\x05\
    \0\x02\0\x01\x12\x03\x07\x08\x1d\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\x07\
    \x20$\n\x0b\n\x04\x05\0\x02\x01\x12\x03\x08\x08-\n\x0c\n\x05\x05\0\x02\
    \x01\x01\x12\x03\x08\x08%\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\x08(,\n\
    \x0b\n\x04\x05\0\x02\x02\x12\x03\t\x082\n\x0c\n\x05\x05\0\x02\x02\x01\
    \x12\x03\t\x08*\n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03\t-1\n\x0b\n\x04\
    \x05\0\x02\x03\x12\x03\n\x089\n\x0c\n\x05\x05\0\x02\x03\x01\x12\x03\n\
    \x081\n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03\n48\n\x0b\n\x04\x05\0\x02\
    \x04\x12\x03\x0b\x08)\n\x0c\n\x05\x05\0\x02\x04\x01\x12\x03\x0b\x08!\n\
    \x0c\n\x05\x05\0\x02\x04\x02\x12\x03\x0b$(\n\x0b\n\x04\x05\0\x02\x05\x12\
    \x03\x0c\x081\n\x0c\n\x05\x05\0\x02\x05\x01\x12\x03\x0c\x08)\n\x0c\n\x05\
    \x05\0\x02\x05\x02\x12\x03\x0c,0\n\x0b\n\x04\x05\0\x02\x06\x12\x03\r\x08\
    1\n\x0c\n\x05\x05\0\x02\x06\x01\x12\x03\r\x08)\n\x0c\n\x05\x05\0\x02\x06\
    \x02\x12\x03\r,0\n\x0b\n\x04\x05\0\x02\x07\x12\x03\x0e\x089\n\x0c\n\x05\
    \x05\0\x02\x07\x01\x12\x03\x0e\x081\n\x0c\n\x05\x05\0\x02\x07\x02\x12\
    \x03\x0e48\n\x0b\n\x04\x05\0\x02\x08\x12\x03\x0f\x08%\n\x0c\n\x05\x05\0\
    \x02\x08\x01\x12\x03\x0f\x08\x1d\n\x0c\n\x05\x05\0\x02\x08\x02\x12\x03\
    \x0f\x20$\n\x0b\n\x04\x05\0\x02\t\x12\x03\x10\x082\n\x0c\n\x05\x05\0\x02\
    \t\x01\x12\x03\x10\x08*\n\x0c\n\x05\x05\0\x02\t\x02\x12\x03\x10-1\n\x0b\
    \n\x04\x05\0\x02\n\x12\x03\x11\x080\n\x0c\n\x05\x05\0\x02\n\x01\x12\x03\
    \x11\x08(\n\x0c\n\x05\x05\0\x02\n\x02\x12\x03\x11+/\n\x0b\n\x04\x05\0\
    \x02\x0b\x12\x03\x12\x084\n\x0c\n\x05\x05\0\x02\x0b\x01\x12\x03\x12\x08,\
    \n\x0c\n\x05\x05\0\x02\x0b\x02\x12\x03\x12/3\n\x0b\n\x04\x05\0\x02\x0c\
    \x12\x03\x13\x08C\n\x0c\n\x05\x05\0\x02\x0c\x01\x12\x03\x13\x08;\n\x0c\n\
    \x05\x05\0\x02\x0c\x02\x12\x03\x13>B\n\x0b\n\x04\x05\0\x02\r\x12\x03\x14\
    \x08A\n\x0c\n\x05\x05\0\x02\r\x01\x12\x03\x14\x089\n\x0c\n\x05\x05\0\x02\
    \r\x02\x12\x03\x14<@\n\x0b\n\x04\x05\0\x02\x0e\x12\x03\x15\x08:\n\x0c\n\
    \x05\x05\0\x02\x0e\x01\x12\x03\x15\x082\n\x0c\n\x05\x05\0\x02\x0e\x02\
    \x12\x03\x1559\n\x0b\n\x04\x05\0\x02\x0f\x12\x03\x16\x08-\n\x0c\n\x05\
    \x05\0\x02\x0f\x01\x12\x03\x16\x08%\n\x0c\n\x05\x05\0\x02\x0f\x02\x12\
    \x03\x16(,\n\x0b\n\x04\x05\0\x02\x10\x12\x03\x17\x085\n\x0c\n\x05\x05\0\
    \x02\x10\x01\x12\x03\x17\x08-\n\x0c\n\x05\x05\0\x02\x10\x02\x12\x03\x170\
    4\n\x0b\n\x04\x05\0\x02\x11\x12\x03\x18\x082\n\x0c\n\x05\x05\0\x02\x11\
    \x01\x12\x03\x18\x08*\n\x0c\n\x05\x05\0\x02\x11\x02\x12\x03\x18-1\n\x0b\
    \n\x04\x05\0\x02\x12\x12\x03\x19\x08:\n\x0c\n\x05\x05\0\x02\x12\x01\x12\
    \x03\x19\x082\n\x0c\n\x05\x05\0\x02\x12\x02\x12\x03\x1959\n\x0b\n\x04\
    \x05\0\x02\x13\x12\x03\x1a\x08*\n\x0c\n\x05\x05\0\x02\x13\x01\x12\x03\
    \x1a\x08\"\n\x0c\n\x05\x05\0\x02\x13\x02\x12\x03\x1a%)\n\x0b\n\x04\x05\0\
    \x02\x14\x12\x03\x1b\x082\n\x0c\n\x05\x05\0\x02\x14\x01\x12\x03\x1b\x08*\
    \n\x0c\n\x05\x05\0\x02\x14\x02\x12\x03\x1b-1\n\x0b\n\x04\x05\0\x02\x15\
    \x12\x03\x1c\x08)\n\x0c\n\x05\x05\0\x02\x15\x01\x12\x03\x1c\x08!\n\x0c\n\
    \x05\x05\0\x02\x15\x02\x12\x03\x1c$(\n\x0b\n\x04\x05\0\x02\x16\x12\x03\
    \x1d\x081\n\x0c\n\x05\x05\0\x02\x16\x01\x12\x03\x1d\x08)\n\x0c\n\x05\x05\
    \0\x02\x16\x02\x12\x03\x1d,0\n\x0b\n\x04\x05\0\x02\x17\x12\x03\x1e\x08.\
    \n\x0c\n\x05\x05\0\x02\x17\x01\x12\x03\x1e\x08&\n\x0c\n\x05\x05\0\x02\
    \x17\x02\x12\x03\x1e)-\n\x0b\n\x04\x05\0\x02\x18\x12\x03\x1f\x08-\n\x0c\
    \n\x05\x05\0\x02\x18\x01\x12\x03\x1f\x08%\n\x0c\n\x05\x05\0\x02\x18\x02\
    \x12\x03\x1f(,\n\x0b\n\x04\x05\0\x02\x19\x12\x03\x20\x08,\n\x0c\n\x05\
    \x05\0\x02\x19\x01\x12\x03\x20\x08$\n\x0c\n\x05\x05\0\x02\x19\x02\x12\
    \x03\x20'+\n\x0b\n\x04\x05\0\x02\x1a\x12\x03!\x081\n\x0c\n\x05\x05\0\x02\
    \x1a\x01\x12\x03!\x08)\n\x0c\n\x05\x05\0\x02\x1a\x02\x12\x03!,0\n\x0b\n\
    \x04\x05\0\x02\x1b\x12\x03\"\x083\n\x0c\n\x05\x05\0\x02\x1b\x01\x12\x03\
    \"\x08+\n\x0c\n\x05\x05\0\x02\x1b\x02\x12\x03\".2\n\x0b\n\x04\x05\0\x02\
    \x1c\x12\x03#\x082\n\x0c\n\x05\x05\0\x02\x1c\x01\x12\x03#\x08*\n\x0c\n\
    \x05\x05\0\x02\x1c\x02\x12\x03#-1\n\x0b\n\x04\x05\0\x02\x1d\x12\x03$\x08\
    %\n\x0c\n\x05\x05\0\x02\x1d\x01\x12\x03$\x08\x1d\n\x0c\n\x05\x05\0\x02\
    \x1d\x02\x12\x03$\x20$\n\x0b\n\x04\x05\0\x02\x1e\x12\x03%\x08&\n\x0c\n\
    \x05\x05\0\x02\x1e\x01\x12\x03%\x08\x1e\n\x0c\n\x05\x05\0\x02\x1e\x02\
    \x12\x03%!%\n\x0b\n\x04\x05\0\x02\x1f\x12\x03&\x08%\n\x0c\n\x05\x05\0\
    \x02\x1f\x01\x12\x03&\x08\x1d\n\x0c\n\x05\x05\0\x02\x1f\x02\x12\x03&\x20\
    $\n\x0b\n\x04\x05\0\x02\x20\x12\x03'\x08$\n\x0c\n\x05\x05\0\x02\x20\x01\
    \x12\x03'\x08\x1c\n\x0c\n\x05\x05\0\x02\x20\x02\x12\x03'\x1f#\n\x0b\n\
    \x04\x05\0\x02!\x12\x03(\x08:\n\x0c\n\x05\x05\0\x02!\x01\x12\x03(\x082\n\
    \x0c\n\x05\x05\0\x02!\x02\x12\x03(59\n\x0b\n\x04\x05\0\x02\"\x12\x03)\
    \x087\n\x0c\n\x05\x05\0\x02\"\x01\x12\x03)\x08/\n\x0c\n\x05\x05\0\x02\"\
    \x02\x12\x03)26\n\x0b\n\x04\x05\0\x02#\x12\x03*\x08?\n\x0c\n\x05\x05\0\
    \x02#\x01\x12\x03*\x087\n\x0c\n\x05\x05\0\x02#\x02\x12\x03*:>\n\x0b\n\
    \x04\x05\0\x02$\x12\x03+\x08A\n\x0c\n\x05\x05\0\x02$\x01\x12\x03+\x089\n\
    \x0c\n\x05\x05\0\x02$\x02\x12\x03+<@\n\x0b\n\x04\x05\0\x02%\x12\x03,\x08\
    9\n\x0c\n\x05\x05\0\x02%\x01\x12\x03,\x081\n\x0c\n\x05\x05\0\x02%\x02\
    \x12\x03,48\n\x0b\n\x04\x05\0\x02&\x12\x03-\x08/\n\x0c\n\x05\x05\0\x02&\
    \x01\x12\x03-\x08'\n\x0c\n\x05\x05\0\x02&\x02\x12\x03-*.\n\x0b\n\x04\x05\
    \0\x02'\x12\x03.\x08,\n\x0c\n\x05\x05\0\x02'\x01\x12\x03.\x08$\n\x0c\n\
    \x05\x05\0\x02'\x02\x12\x03.'+\n\x0b\n\x04\x05\0\x02(\x12\x03/\x084\n\
    \x0c\n\x05\x05\0\x02(\x01\x12\x03/\x08,\n\x0c\n\x05\x05\0\x02(\x02\x12\
    \x03//3\n\x0b\n\x04\x05\0\x02)\x12\x030\x08C\n\x0c\n\x05\x05\0\x02)\x01\
    \x12\x030\x08;\n\x0c\n\x05\x05\0\x02)\x02\x12\x030>B\n\x0b\n\x04\x05\0\
    \x02*\x12\x031\x08;\n\x0c\n\x05\x05\0\x02*\x01\x12\x031\x083\n\x0c\n\x05\
    \x05\0\x02*\x02\x12\x0316:\n\x0b\n\x04\x05\0\x02+\x12\x032\x082\n\x0c\n\
    \x05\x05\0\x02+\x01\x12\x032\x08*\n\x0c\n\x05\x05\0\x02+\x02\x12\x032-1\
    \n\x0b\n\x04\x05\0\x02,\x12\x033\x08/\n\x0c\n\x05\x05\0\x02,\x01\x12\x03\
    3\x08'\n\x0c\n\x05\x05\0\x02,\x02\x12\x033*.\n\x0b\n\x04\x05\0\x02-\x12\
    \x034\x08:\n\x0c\n\x05\x05\0\x02-\x01\x12\x034\x082\n\x0c\n\x05\x05\0\
    \x02-\x02\x12\x03459\n\x0b\n\x04\x05\0\x02.\x12\x035\x08-\n\x0c\n\x05\
    \x05\0\x02.\x01\x12\x035\x08%\n\x0c\n\x05\x05\0\x02.\x02\x12\x035(,\n\
    \x0b\n\x04\x05\0\x02/\x12\x036\x081\n\x0c\n\x05\x05\0\x02/\x01\x12\x036\
    \x08)\n\x0c\n\x05\x05\0\x02/\x02\x12\x036,0\n\x0b\n\x04\x05\0\x020\x12\
    \x037\x089\n\x0c\n\x05\x05\0\x020\x01\x12\x037\x081\n\x0c\n\x05\x05\0\
    \x020\x02\x12\x03748\n\x0b\n\x04\x05\0\x021\x12\x038\x082\n\x0c\n\x05\
    \x05\0\x021\x01\x12\x038\x08*\n\x0c\n\x05\x05\0\x021\x02\x12\x038-1\n\
    \x0b\n\x04\x05\0\x022\x12\x039\x08:\n\x0c\n\x05\x05\0\x022\x01\x12\x039\
    \x082\n\x0c\n\x05\x05\0\x022\x02\x12\x03959\n\x0b\n\x04\x05\0\x023\x12\
    \x03:\x08(\n\x0c\n\x05\x05\0\x023\x01\x12\x03:\x08\x20\n\x0c\n\x05\x05\0\
    \x023\x02\x12\x03:#'\n\x0b\n\x04\x05\0\x024\x12\x03;\x080\n\x0c\n\x05\
    \x05\0\x024\x01\x12\x03;\x08(\n\x0c\n\x05\x05\0\x024\x02\x12\x03;+/\n\
    \x0b\n\x04\x05\0\x025\x12\x03<\x08.\n\x0c\n\x05\x05\0\x025\x01\x12\x03<\
    \x08&\n\x0c\n\x05\x05\0\x025\x02\x12\x03<)-\n\x0b\n\x04\x05\0\x026\x12\
    \x03=\x081\n\x0c\n\x05\x05\0\x026\x01\x12\x03=\x08)\n\x0c\n\x05\x05\0\
    \x026\x02\x12\x03=,0\n\x0b\n\x04\x05\0\x027\x12\x03>\x089\n\x0c\n\x05\
    \x05\0\x027\x01\x12\x03>\x081\n\x0c\n\x05\x05\0\x027\x02\x12\x03>48\n\
    \x0b\n\x04\x05\0\x028\x12\x03?\x089\n\x0c\n\x05\x05\0\x028\x01\x12\x03?\
    \x081\n\x0c\n\x05\x05\0\x028\x02\x12\x03?48\n\x0b\n\x04\x05\0\x029\x12\
    \x03@\x08B\n\x0c\n\x05\x05\0\x029\x01\x12\x03@\x08:\n\x0c\n\x05\x05\0\
    \x029\x02\x12\x03@=A\n\x0b\n\x04\x05\0\x02:\x12\x03A\x08=\n\x0c\n\x05\
    \x05\0\x02:\x01\x12\x03A\x085\n\x0c\n\x05\x05\0\x02:\x02\x12\x03A8<\n\
    \x0b\n\x04\x05\0\x02;\x12\x03B\x08F\n\x0c\n\x05\x05\0\x02;\x01\x12\x03B\
    \x08>\n\x0c\n\x05\x05\0\x02;\x02\x12\x03BAE\n\x0b\n\x04\x05\0\x02<\x12\
    \x03C\x08A\n\x0c\n\x05\x05\0\x02<\x01\x12\x03C\x089\n\x0c\n\x05\x05\0\
    \x02<\x02\x12\x03C<@\n\x0b\n\x04\x05\0\x02=\x12\x03D\x089\n\x0c\n\x05\
    \x05\0\x02=\x01\x12\x03D\x081\n\x0c\n\x05\x05\0\x02=\x02\x12\x03D48\n\
    \x0b\n\x04\x05\0\x02>\x12\x03E\x08-\n\x0c\n\x05\x05\0\x02>\x01\x12\x03E\
    \x08%\n\x0c\n\x05\x05\0\x02>\x02\x12\x03E(,\n\x0b\n\x04\x05\0\x02?\x12\
    \x03F\x085\n\x0c\n\x05\x05\0\x02?\x01\x12\x03F\x08-\n\x0c\n\x05\x05\0\
    \x02?\x02\x12\x03F04\n\x0b\n\x04\x05\0\x02@\x12\x03G\x08(\n\x0c\n\x05\
    \x05\0\x02@\x01\x12\x03G\x08\x20\n\x0c\n\x05\x05\0\x02@\x02\x12\x03G#'\n\
    \x0b\n\x04\x05\0\x02A\x12\x03H\x080\n\x0c\n\x05\x05\0\x02A\x01\x12\x03H\
    \x08(\n\x0c\n\x05\x05\0\x02A\x02\x12\x03H+/\n\x0b\n\x04\x05\0\x02B\x12\
    \x03I\x08)\n\x0c\n\x05\x05\0\x02B\x01\x12\x03I\x08!\n\x0c\n\x05\x05\0\
    \x02B\x02\x12\x03I$(\n\x0b\n\x04\x05\0\x02C\x12\x03J\x08?\n\x0c\n\x05\
    \x05\0\x02C\x01\x12\x03J\x087\n\x0c\n\x05\x05\0\x02C\x02\x12\x03J:>\n\
    \x0b\n\x04\x05\0\x02D\x12\x03K\x08A\n\x0c\n\x05\x05\0\x02D\x01\x12\x03K\
    \x089\n\x0c\n\x05\x05\0\x02D\x02\x12\x03K<@\n\x0b\n\x04\x05\0\x02E\x12\
    \x03L\x08?\n\x0c\n\x05\x05\0\x02E\x01\x12\x03L\x087\n\x0c\n\x05\x05\0\
    \x02E\x02\x12\x03L:>\n\x0b\n\x04\x05\0\x02F\x12\x03M\x08>\n\x0c\n\x05\
    \x05\0\x02F\x01\x12\x03M\x086\n\x0c\n\x05\x05\0\x02F\x02\x12\x03M9=\n\
    \x0b\n\x04\x05\0\x02G\x12\x03N\x08*\n\x0c\n\x05\x05\0\x02G\x01\x12\x03N\
    \x08\"\n\x0c\n\x05\x05\0\x02G\x02\x12\x03N%)\n\x0b\n\x04\x05\0\x02H\x12\
    \x03O\x08(\n\x0c\n\x05\x05\0\x02H\x01\x12\x03O\x08\x20\n\x0c\n\x05\x05\0\
    \x02H\x02\x12\x03O#'\n\x0b\n\x04\x05\0\x02I\x12\x03P\x08.\n\x0c\n\x05\
    \x05\0\x02I\x01\x12\x03P\x08&\n\x0c\n\x05\x05\0\x02I\x02\x12\x03P)-\n\
    \x0b\n\x04\x05\0\x02J\x12\x03Q\x086\n\x0c\n\x05\x05\0\x02J\x01\x12\x03Q\
    \x08.\n\x0c\n\x05\x05\0\x02J\x02\x12\x03Q15\n\x0b\n\x04\x05\0\x02K\x12\
    \x03R\x08\x1f\n\x0c\n\x05\x05\0\x02K\x01\x12\x03R\x08\x17\n\x0c\n\x05\
    \x05\0\x02K\x02\x12\x03R\x1a\x1e\n\x0b\n\x04\x05\0\x02L\x12\x03S\x082\n\
    \x0c\n\x05\x05\0\x02L\x01\x12\x03S\x08*\n\x0c\n\x05\x05\0\x02L\x02\x12\
    \x03S-1\n\x0b\n\x04\x05\0\x02M\x12\x03T\x08&\n\x0c\n\x05\x05\0\x02M\x01\
    \x12\x03T\x08\x1e\n\x0c\n\x05\x05\0\x02M\x02\x12\x03T!%\n\x0b\n\x04\x05\
    \0\x02N\x12\x03U\x08.\n\x0c\n\x05\x05\0\x02N\x01\x12\x03U\x08&\n\x0c\n\
    \x05\x05\0\x02N\x02\x12\x03U)-\n\x0b\n\x04\x05\0\x02O\x12\x03V\x08'\n\
    \x0c\n\x05\x05\0\x02O\x01\x12\x03V\x08\x1f\n\x0c\n\x05\x05\0\x02O\x02\
    \x12\x03V\"&\n\x0b\n\x04\x05\0\x02P\x12\x03W\x08+\n\x0c\n\x05\x05\0\x02P\
    \x01\x12\x03W\x08#\n\x0c\n\x05\x05\0\x02P\x02\x12\x03W&*\n\x0b\n\x04\x05\
    \0\x02Q\x12\x03X\x08&\n\x0c\n\x05\x05\0\x02Q\x01\x12\x03X\x08\x1e\n\x0c\
    \n\x05\x05\0\x02Q\x02\x12\x03X!%\n\x0b\n\x04\x05\0\x02R\x12\x03Y\x083\n\
    \x0c\n\x05\x05\0\x02R\x01\x12\x03Y\x08+\n\x0c\n\x05\x05\0\x02R\x02\x12\
    \x03Y.2\n\x0b\n\x04\x05\0\x02S\x12\x03Z\x08\"\n\x0c\n\x05\x05\0\x02S\x01\
    \x12\x03Z\x08\x1a\n\x0c\n\x05\x05\0\x02S\x02\x12\x03Z\x1d!\n\x0b\n\x04\
    \x05\0\x02T\x12\x03[\x08'\n\x0c\n\x05\x05\0\x02T\x01\x12\x03[\x08\x1f\n\
    \x0c\n\x05\x05\0\x02T\x02\x12\x03[\"&\n\x0b\n\x04\x05\0\x02U\x12\x03\\\
    \x08.\n\x0c\n\x05\x05\0\x02U\x01\x12\x03\\\x08&\n\x0c\n\x05\x05\0\x02U\
    \x02\x12\x03\\)-\n\x0b\n\x04\x05\0\x02V\x12\x03]\x086\n\x0c\n\x05\x05\0\
    \x02V\x01\x12\x03]\x08.\n\x0c\n\x05\x05\0\x02V\x02\x12\x03]15\n\x0b\n\
    \x04\x05\0\x02W\x12\x03^\x08,\n\x0c\n\x05\x05\0\x02W\x01\x12\x03^\x08$\n\
    \x0c\n\x05\x05\0\x02W\x02\x12\x03^'+\n\x0b\n\x04\x05\0\x02X\x12\x03_\x08\
    9\n\x0c\n\x05\x05\0\x02X\x01\x12\x03_\x081\n\x0c\n\x05\x05\0\x02X\x02\
    \x12\x03_48\n\x0b\n\x04\x05\0\x02Y\x12\x03`\x08=\n\x0c\n\x05\x05\0\x02Y\
    \x01\x12\x03`\x085\n\x0c\n\x05\x05\0\x02Y\x02\x12\x03`8<\n\x0b\n\x04\x05\
    \0\x02Z\x12\x03a\x08>\n\x0c\n\x05\x05\0\x02Z\x01\x12\x03a\x086\n\x0c\n\
    \x05\x05\0\x02Z\x02\x12\x03a9=\n\x0b\n\x04\x05\0\x02[\x12\x03b\x084\n\
    \x0c\n\x05\x05\0\x02[\x01\x12\x03b\x08,\n\x0c\n\x05\x05\0\x02[\x02\x12\
    \x03b/3\n\x0b\n\x04\x05\0\x02\\\x12\x03c\x08<\n\x0c\n\x05\x05\0\x02\\\
    \x01\x12\x03c\x084\n\x0c\n\x05\x05\0\x02\\\x02\x12\x03c7;\n\x0b\n\x04\
    \x05\0\x02]\x12\x03d\x08:\n\x0c\n\x05\x05\0\x02]\x01\x12\x03d\x082\n\x0c\
    \n\x05\x05\0\x02]\x02\x12\x03d59\n\x0b\n\x04\x05\0\x02^\x12\x03e\x083\n\
    \x0c\n\x05\x05\0\x02^\x01\x12\x03e\x08+\n\x0c\n\x05\x05\0\x02^\x02\x12\
    \x03e.2\n\x0b\n\x04\x05\0\x02_\x12\x03f\x08-\n\x0c\n\x05\x05\0\x02_\x01\
    \x12\x03f\x08%\n\x0c\n\x05\x05\0\x02_\x02\x12\x03f(,\n\x0b\n\x04\x05\0\
    \x02`\x12\x03g\x08$\n\x0c\n\x05\x05\0\x02`\x01\x12\x03g\x08\x1c\n\x0c\n\
    \x05\x05\0\x02`\x02\x12\x03g\x1f#\n\x0b\n\x04\x05\0\x02a\x12\x03h\x08/\n\
    \x0c\n\x05\x05\0\x02a\x01\x12\x03h\x08'\n\x0c\n\x05\x05\0\x02a\x02\x12\
    \x03h*.\n\x0b\n\x04\x05\0\x02b\x12\x03i\x080\n\x0c\n\x05\x05\0\x02b\x01\
    \x12\x03i\x08(\n\x0c\n\x05\x05\0\x02b\x02\x12\x03i+/\n\x0b\n\x04\x05\0\
    \x02c\x12\x03j\x085\n\x0c\n\x05\x05\0\x02c\x01\x12\x03j\x08-\n\x0c\n\x05\
    \x05\0\x02c\x02\x12\x03j04\n\x0b\n\x04\x05\0\x02d\x12\x03k\x082\n\x0c\n\
    \x05\x05\0\x02d\x01\x12\x03k\x08*\n\x0c\n\x05\x05\0\x02d\x02\x12\x03k-1\
    \n\x0b\n\x04\x05\0\x02e\x12\x03l\x08%\n\x0c\n\x05\x05\0\x02e\x01\x12\x03\
    l\x08\x1d\n\x0c\n\x05\x05\0\x02e\x02\x12\x03l\x20$\n\x0b\n\x04\x05\0\x02\
    f\x12\x03m\x08-\n\x0c\n\x05\x05\0\x02f\x01\x12\x03m\x08%\n\x0c\n\x05\x05\
    \0\x02f\x02\x12\x03m(,\n\x0b\n\x04\x05\0\x02g\x12\x03n\x085\n\x0c\n\x05\
    \x05\0\x02g\x01\x12\x03n\x08-\n\x0c\n\x05\x05\0\x02g\x02\x12\x03n04\n\
    \x0b\n\x04\x05\0\x02h\x12\x03o\x084\n\x0c\n\x05\x05\0\x02h\x01\x12\x03o\
    \x08,\n\x0c\n\x05\x05\0\x02h\x02\x12\x03o/3\n\x0b\n\x04\x05\0\x02i\x12\
    \x03p\x08=\n\x0c\n\x05\x05\0\x02i\x01\x12\x03p\x085\n\x0c\n\x05\x05\0\
    \x02i\x02\x12\x03p8<\n\x0b\n\x04\x05\0\x02j\x12\x03q\x08-\n\x0c\n\x05\
    \x05\0\x02j\x01\x12\x03q\x08%\n\x0c\n\x05\x05\0\x02j\x02\x12\x03q(,\n\
    \x0b\n\x04\x05\0\x02k\x12\x03r\x08%\n\x0c\n\x05\x05\0\x02k\x01\x12\x03r\
    \x08\x1d\n\x0c\n\x05\x05\0\x02k\x02\x12\x03r\x20$\n\x0b\n\x04\x05\0\x02l\
    \x12\x03s\x08-\n\x0c\n\x05\x05\0\x02l\x01\x12\x03s\x08%\n\x0c\n\x05\x05\
    \0\x02l\x02\x12\x03s(,\n\x0b\n\x04\x05\0\x02m\x12\x03t\x086\n\x0c\n\x05\
    \x05\0\x02m\x01\x12\x03t\x08.\n\x0c\n\x05\x05\0\x02m\x02\x12\x03t15\n\
    \x0b\n\x04\x05\0\x02n\x12\x03u\x08'\n\x0c\n\x05\x05\0\x02n\x01\x12\x03u\
    \x08\x1f\n\x0c\n\x05\x05\0\x02n\x02\x12\x03u\"&\n\x0b\n\x04\x05\0\x02o\
    \x12\x03v\x08/\n\x0c\n\x05\x05\0\x02o\x01\x12\x03v\x08'\n\x0c\n\x05\x05\
    \0\x02o\x02\x12\x03v*.\n\x0b\n\x04\x05\0\x02p\x12\x03w\x08.\n\x0c\n\x05\
    \x05\0\x02p\x01\x12\x03w\x08&\n\x0c\n\x05\x05\0\x02p\x02\x12\x03w)-\n\
    \x0b\n\x04\x05\0\x02q\x12\x03x\x08/\n\x0c\n\x05\x05\0\x02q\x01\x12\x03x\
    \x08'\n\x0c\n\x05\x05\0\x02q\x02\x12\x03x*.\n\x0b\n\x04\x05\0\x02r\x12\
    \x03y\x08(\n\x0c\n\x05\x05\0\x02r\x01\x12\x03y\x08\x20\n\x0c\n\x05\x05\0\
    \x02r\x02\x12\x03y#'\n\x0b\n\x04\x05\0\x02s\x12\x03z\x08&\n\x0c\n\x05\
    \x05\0\x02s\x01\x12\x03z\x08\x1e\n\x0c\n\x05\x05\0\x02s\x02\x12\x03z!%\n\
    \x0b\n\x04\x05\0\x02t\x12\x03{\x08-\n\x0c\n\x05\x05\0\x02t\x01\x12\x03{\
    \x08%\n\x0c\n\x05\x05\0\x02t\x02\x12\x03{(,\n\x0b\n\x04\x05\0\x02u\x12\
    \x03|\x080\n\x0c\n\x05\x05\0\x02u\x01\x12\x03|\x08(\n\x0c\n\x05\x05\0\
    \x02u\x02\x12\x03|+/\n\x0b\n\x04\x05\0\x02v\x12\x03}\x085\n\x0c\n\x05\
    \x05\0\x02v\x01\x12\x03}\x08-\n\x0c\n\x05\x05\0\x02v\x02\x12\x03}04\n\
    \x0b\n\x04\x05\0\x02w\x12\x03~\x08,\n\x0c\n\x05\x05\0\x02w\x01\x12\x03~\
    \x08$\n\x0c\n\x05\x05\0\x02w\x02\x12\x03~'+\n\x0b\n\x04\x05\0\x02x\x12\
    \x03\x7f\x08.\n\x0c\n\x05\x05\0\x02x\x01\x12\x03\x7f\x08&\n\x0c\n\x05\
    \x05\0\x02x\x02\x12\x03\x7f)-\n\x0c\n\x04\x05\0\x02y\x12\x04\x80\x01\x08\
    /\n\r\n\x05\x05\0\x02y\x01\x12\x04\x80\x01\x08'\n\r\n\x05\x05\0\x02y\x02\
    \x12\x04\x80\x01*.\n\x0c\n\x04\x05\0\x02z\x12\x04\x81\x01\x08%\n\r\n\x05\
    \x05\0\x02z\x01\x12\x04\x81\x01\x08\x1d\n\r\n\x05\x05\0\x02z\x02\x12\x04\
    \x81\x01\x20$\n\x0c\n\x04\x05\0\x02{\x12\x04\x82\x01\x080\n\r\n\x05\x05\
    \0\x02{\x01\x12\x04\x82\x01\x08(\n\r\n\x05\x05\0\x02{\x02\x12\x04\x82\
    \x01+/\n\x0c\n\x04\x05\0\x02|\x12\x04\x83\x01\x081\n\r\n\x05\x05\0\x02|\
    \x01\x12\x04\x83\x01\x08)\n\r\n\x05\x05\0\x02|\x02\x12\x04\x83\x01,0\n\
    \x0c\n\x04\x05\0\x02}\x12\x04\x84\x01\x086\n\r\n\x05\x05\0\x02}\x01\x12\
    \x04\x84\x01\x08.\n\r\n\x05\x05\0\x02}\x02\x12\x04\x84\x0115\n\x0c\n\x04\
    \x05\0\x02~\x12\x04\x85\x01\x087\n\r\n\x05\x05\0\x02~\x01\x12\x04\x85\
    \x01\x08/\n\r\n\x05\x05\0\x02~\x02\x12\x04\x85\x0126\n\x0c\n\x04\x05\0\
    \x02\x7f\x12\x04\x86\x01\x08&\n\r\n\x05\x05\0\x02\x7f\x01\x12\x04\x86\
    \x01\x08\x1e\n\r\n\x05\x05\0\x02\x7f\x02\x12\x04\x86\x01!%\n\r\n\x05\x05\
    \0\x02\x80\x01\x12\x04\x87\x01\x08%\n\x0e\n\x06\x05\0\x02\x80\x01\x01\
    \x12\x04\x87\x01\x08\x1d\n\x0e\n\x06\x05\0\x02\x80\x01\x02\x12\x04\x87\
    \x01\x20$\n\r\n\x05\x05\0\x02\x81\x01\x12\x04\x88\x01\x08+\n\x0e\n\x06\
    \x05\0\x02\x81\x01\x01\x12\x04\x88\x01\x08#\n\x0e\n\x06\x05\0\x02\x81\
    \x01\x02\x12\x04\x88\x01&*\n\r\n\x05\x05\0\x02\x82\x01\x12\x04\x89\x01\
    \x08&\n\x0e\n\x06\x05\0\x02\x82\x01\x01\x12\x04\x89\x01\x08\x1e\n\x0e\n\
    \x06\x05\0\x02\x82\x01\x02\x12\x04\x89\x01!%\n\r\n\x05\x05\0\x02\x83\x01\
    \x12\x04\x8a\x01\x08+\n\x0e\n\x06\x05\0\x02\x83\x01\x01\x12\x04\x8a\x01\
    \x08#\n\x0e\n\x06\x05\0\x02\x83\x01\x02\x12\x04\x8a\x01&*\n\r\n\x05\x05\
    \0\x02\x84\x01\x12\x04\x8b\x01\x08/\n\x0e\n\x06\x05\0\x02\x84\x01\x01\
    \x12\x04\x8b\x01\x08'\n\x0e\n\x06\x05\0\x02\x84\x01\x02\x12\x04\x8b\x01*\
    .\n\r\n\x05\x05\0\x02\x85\x01\x12\x04\x8c\x01\x085\n\x0e\n\x06\x05\0\x02\
    \x85\x01\x01\x12\x04\x8c\x01\x08-\n\x0e\n\x06\x05\0\x02\x85\x01\x02\x12\
    \x04\x8c\x0104\n\r\n\x05\x05\0\x02\x86\x01\x12\x04\x8d\x01\x08+\n\x0e\n\
    \x06\x05\0\x02\x86\x01\x01\x12\x04\x8d\x01\x08#\n\x0e\n\x06\x05\0\x02\
    \x86\x01\x02\x12\x04\x8d\x01&*\n\r\n\x05\x05\0\x02\x87\x01\x12\x04\x8e\
    \x01\x08(\n\x0e\n\x06\x05\0\x02\x87\x01\x01\x12\x04\x8e\x01\x08\x20\n\
    \x0e\n\x06\x05\0\x02\x87\x01\x02\x12\x04\x8e\x01#'\n\r\n\x05\x05\0\x02\
    \x88\x01\x12\x04\x8f\x01\x080\n\x0e\n\x06\x05\0\x02\x88\x01\x01\x12\x04\
    \x8f\x01\x08(\n\x0e\n\x06\x05\0\x02\x88\x01\x02\x12\x04\x8f\x01+/\n\r\n\
    \x05\x05\0\x02\x89\x01\x12\x04\x90\x01\x08+\n\x0e\n\x06\x05\0\x02\x89\
    \x01\x01\x12\x04\x90\x01\x08#\n\x0e\n\x06\x05\0\x02\x89\x01\x02\x12\x04\
    \x90\x01&*\n\r\n\x05\x05\0\x02\x8a\x01\x12\x04\x91\x01\x083\n\x0e\n\x06\
    \x05\0\x02\x8a\x01\x01\x12\x04\x91\x01\x08+\n\x0e\n\x06\x05\0\x02\x8a\
    \x01\x02\x12\x04\x91\x01.2\n\r\n\x05\x05\0\x02\x8b\x01\x12\x04\x92\x01\
    \x08-\n\x0e\n\x06\x05\0\x02\x8b\x01\x01\x12\x04\x92\x01\x08%\n\x0e\n\x06\
    \x05\0\x02\x8b\x01\x02\x12\x04\x92\x01(,\n\r\n\x05\x05\0\x02\x8c\x01\x12\
    \x04\x93\x01\x085\n\x0e\n\x06\x05\0\x02\x8c\x01\x01\x12\x04\x93\x01\x08-\
    \n\x0e\n\x06\x05\0\x02\x8c\x01\x02\x12\x04\x93\x0104\n\r\n\x05\x05\0\x02\
    \x8d\x01\x12\x04\x94\x01\x08*\n\x0e\n\x06\x05\0\x02\x8d\x01\x01\x12\x04\
    \x94\x01\x08\"\n\x0e\n\x06\x05\0\x02\x8d\x01\x02\x12\x04\x94\x01%)\n\r\n\
    \x05\x05\0\x02\x8e\x01\x12\x04\x95\x01\x08/\n\x0e\n\x06\x05\0\x02\x8e\
    \x01\x01\x12\x04\x95\x01\x08'\n\x0e\n\x06\x05\0\x02\x8e\x01\x02\x12\x04\
    \x95\x01*.\n\r\n\x05\x05\0\x02\x8f\x01\x12\x04\x96\x01\x08&\n\x0e\n\x06\
    \x05\0\x02\x8f\x01\x01\x12\x04\x96\x01\x08\x1e\n\x0e\n\x06\x05\0\x02\x8f\
    \x01\x02\x12\x04\x96\x01!%\n\r\n\x05\x05\0\x02\x90\x01\x12\x04\x97\x01\
    \x08%\n\x0e\n\x06\x05\0\x02\x90\x01\x01\x12\x04\x97\x01\x08\x1d\n\x0e\n\
    \x06\x05\0\x02\x90\x01\x02\x12\x04\x97\x01\x20$\n\r\n\x05\x05\0\x02\x91\
    \x01\x12\x04\x98\x01\x08'\n\x0e\n\x06\x05\0\x02\x91\x01\x01\x12\x04\x98\
    \x01\x08\x1f\n\x0e\n\x06\x05\0\x02\x91\x01\x02\x12\x04\x98\x01\"&\n\r\n\
    \x05\x05\0\x02\x92\x01\x12\x04\x99\x01\x08'\n\x0e\n\x06\x05\0\x02\x92\
    \x01\x01\x12\x04\x99\x01\x08\x1f\n\x0e\n\x06\x05\0\x02\x92\x01\x02\x12\
    \x04\x99\x01\"&\n\r\n\x05\x05\0\x02\x93\x01\x12\x04\x9a\x01\x08)\n\x0e\n\
    \x06\x05\0\x02\x93\x01\x01\x12\x04\x9a\x01\x08!\n\x0e\n\x06\x05\0\x02\
    \x93\x01\x02\x12\x04\x9a\x01$(\n\r\n\x05\x05\0\x02\x94\x01\x12\x04\x9b\
    \x01\x08-\n\x0e\n\x06\x05\0\x02\x94\x01\x01\x12\x04\x9b\x01\x08%\n\x0e\n\
    \x06\x05\0\x02\x94\x01\x02\x12\x04\x9b\x01(,\n\r\n\x05\x05\0\x02\x95\x01\
    \x12\x04\x9c\x01\x085\n\x0e\n\x06\x05\0\x02\x95\x01\x01\x12\x04\x9c\x01\
    \x08-\n\x0e\n\x06\x05\0\x02\x95\x01\x02\x12\x04\x9c\x0104\n\r\n\x05\x05\
    \0\x02\x96\x01\x12\x04\x9d\x01\x084\n\x0e\n\x06\x05\0\x02\x96\x01\x01\
    \x12\x04\x9d\x01\x08,\n\x0e\n\x06\x05\0\x02\x96\x01\x02\x12\x04\x9d\x01/\
    3\n\r\n\x05\x05\0\x02\x97\x01\x12\x04\x9e\x01\x08<\n\x0e\n\x06\x05\0\x02\
    \x97\x01\x01\x12\x04\x9e\x01\x084\n\x0e\n\x06\x05\0\x02\x97\x01\x02\x12\
    \x04\x9e\x017;\n\r\n\x05\x05\0\x02\x98\x01\x12\x04\x9f\x01\x080\n\x0e\n\
    \x06\x05\0\x02\x98\x01\x01\x12\x04\x9f\x01\x08(\n\x0e\n\x06\x05\0\x02\
    \x98\x01\x02\x12\x04\x9f\x01+/\n\r\n\x05\x05\0\x02\x99\x01\x12\x04\xa0\
    \x01\x088\n\x0e\n\x06\x05\0\x02\x99\x01\x01\x12\x04\xa0\x01\x080\n\x0e\n\
    \x06\x05\0\x02\x99\x01\x02\x12\x04\xa0\x0137\n\r\n\x05\x05\0\x02\x9a\x01\
    \x12\x04\xa1\x01\x084\n\x0e\n\x06\x05\0\x02\x9a\x01\x01\x12\x04\xa1\x01\
    \x08,\n\x0e\n\x06\x05\0\x02\x9a\x01\x02\x12\x04\xa1\x01/3\n\r\n\x05\x05\
    \0\x02\x9b\x01\x12\x04\xa2\x01\x08<\n\x0e\n\x06\x05\0\x02\x9b\x01\x01\
    \x12\x04\xa2\x01\x084\n\x0e\n\x06\x05\0\x02\x9b\x01\x02\x12\x04\xa2\x017\
    ;\n\r\n\x05\x05\0\x02\x9c\x01\x12\x04\xa3\x01\x08-\n\x0e\n\x06\x05\0\x02\
    \x9c\x01\x01\x12\x04\xa3\x01\x08%\n\x0e\n\x06\x05\0\x02\x9c\x01\x02\x12\
    \x04\xa3\x01(,\n\r\n\x05\x05\0\x02\x9d\x01\x12\x04\xa4\x01\x08(\n\x0e\n\
    \x06\x05\0\x02\x9d\x01\x01\x12\x04\xa4\x01\x08\x20\n\x0e\n\x06\x05\0\x02\
    \x9d\x01\x02\x12\x04\xa4\x01#'\n\r\n\x05\x05\0\x02\x9e\x01\x12\x04\xa5\
    \x01\x08)\n\x0e\n\x06\x05\0\x02\x9e\x01\x01\x12\x04\xa5\x01\x08!\n\x0e\n\
    \x06\x05\0\x02\x9e\x01\x02\x12\x04\xa5\x01$(\n\r\n\x05\x05\0\x02\x9f\x01\
    \x12\x04\xa6\x01\x08*\n\x0e\n\x06\x05\0\x02\x9f\x01\x01\x12\x04\xa6\x01\
    \x08\"\n\x0e\n\x06\x05\0\x02\x9f\x01\x02\x12\x04\xa6\x01%)\n\r\n\x05\x05\
    \0\x02\xa0\x01\x12\x04\xa7\x01\x08/\n\x0e\n\x06\x05\0\x02\xa0\x01\x01\
    \x12\x04\xa7\x01\x08'\n\x0e\n\x06\x05\0\x02\xa0\x01\x02\x12\x04\xa7\x01*\
    .\n\r\n\x05\x05\0\x02\xa1\x01\x12\x04\xa8\x01\x08\"\n\x0e\n\x06\x05\0\
    \x02\xa1\x01\x01\x12\x04\xa8\x01\x08\x1a\n\x0e\n\x06\x05\0\x02\xa1\x01\
    \x02\x12\x04\xa8\x01\x1d!\n\r\n\x05\x05\0\x02\xa2\x01\x12\x04\xa9\x01\
    \x08-\n\x0e\n\x06\x05\0\x02\xa2\x01\x01\x12\x04\xa9\x01\x08%\n\x0e\n\x06\
    \x05\0\x02\xa2\x01\x02\x12\x04\xa9\x01(,\n\r\n\x05\x05\0\x02\xa3\x01\x12\
    \x04\xaa\x01\x085\n\x0e\n\x06\x05\0\x02\xa3\x01\x01\x12\x04\xaa\x01\x08-\
    \n\x0e\n\x06\x05\0\x02\xa3\x01\x02\x12\x04\xaa\x0104\n\r\n\x05\x05\0\x02\
    \xa4\x01\x12\x04\xab\x01\x08)\n\x0e\n\x06\x05\0\x02\xa4\x01\x01\x12\x04\
    \xab\x01\x08\x20\n\x0e\n\x06\x05\0\x02\xa4\x01\x02\x12\x04\xab\x01#(\n\
    \x0c\n\x02\x05\x01\x12\x06\xae\x01\0\xb0\x01\x01\n\x0b\n\x03\x05\x01\x01\
    \x12\x04\xae\x01\x05\x20\n\x0c\n\x04\x05\x01\x02\0\x12\x04\xaf\x01\x082\
    \n\r\n\x05\x05\x01\x02\0\x01\x12\x04\xaf\x01\x08-\n\r\n\x05\x05\x01\x02\
    \0\x02\x12\x04\xaf\x0101\n\x0c\n\x02\x05\x02\x12\x06\xb2\x01\0\xb9\x01\
    \x01\n\x0b\n\x03\x05\x02\x01\x12\x04\xb2\x01\x05\x18\n\x0c\n\x04\x05\x02\
    \x02\0\x12\x04\xb3\x01\x08+\n\r\n\x05\x05\x02\x02\0\x01\x12\x04\xb3\x01\
    \x08%\n\r\n\x05\x05\x02\x02\0\x02\x12\x04\xb3\x01(*\n\x0c\n\x04\x05\x02\
    \x02\x01\x12\x04\xb4\x01\x08'\n\r\n\x05\x05\x02\x02\x01\x01\x12\x04\xb4\
    \x01\x08\"\n\r\n\x05\x05\x02\x02\x01\x02\x12\x04\xb4\x01%&\n\x0c\n\x04\
    \x05\x02\x02\x02\x12\x04\xb5\x01\x083\n\r\n\x05\x05\x02\x02\x02\x01\x12\
    \x04\xb5\x01\x08.\n\r\n\x05\x05\x02\x02\x02\x02\x12\x04\xb5\x0112\n\x0c\
    \n\x04\x05\x02\x02\x03\x12\x04\xb6\x01\x085\n\r\n\x05\x05\x02\x02\x03\
    \x01\x12\x04\xb6\x01\x080\n\r\n\x05\x05\x02\x02\x03\x02\x12\x04\xb6\x013\
    4\n\x0c\n\x04\x05\x02\x02\x04\x12\x04\xb7\x01\x085\n\r\n\x05\x05\x02\x02\
    \x04\x01\x12\x04\xb7\x01\x080\n\r\n\x05\x05\x02\x02\x04\x02\x12\x04\xb7\
    \x0134\n\x0c\n\x04\x05\x02\x02\x05\x12\x04\xb8\x01\x089\n\r\n\x05\x05\
    \x02\x02\x05\x01\x12\x04\xb8\x01\x084\n\r\n\x05\x05\x02\x02\x05\x02\x12\
    \x04\xb8\x0178\n\x0c\n\x02\x05\x03\x12\x06\xbb\x01\0\xd4\x01\x01\n\x0b\n\
    \x03\x05\x03\x01\x12\x04\xbb\x01\x05\x12\n\x0b\n\x03\x05\x03\x03\x12\x04\
    \xbc\x01\x08\"\n\x0c\n\x04\x05\x03\x03\x02\x12\x04\xbc\x01\x08\"\n\x0c\n\
    \x04\x05\x03\x02\0\x12\x04\xbd\x01\x08%\n\r\n\x05\x05\x03\x02\0\x01\x12\
    \x04\xbd\x01\x08\x1f\n\r\n\x05\x05\x03\x02\0\x02\x12\x04\xbd\x01\"$\n\
    \x0c\n\x04\x05\x03\x02\x01\x12\x04\xbe\x01\x08)\n\r\n\x05\x05\x03\x02\
    \x01\x01\x12\x04\xbe\x01\x08$\n\r\n\x05\x05\x03\x02\x01\x02\x12\x04\xbe\
    \x01'(\n\x0c\n\x04\x05\x03\x02\x02\x12\x04\xbf\x01\x08'\n\r\n\x05\x05\
    \x03\x02\x02\x01\x12\x04\xbf\x01\x08\"\n\r\n\x05\x05\x03\x02\x02\x02\x12\
    \x04\xbf\x01%&\n\x0c\n\x04\x05\x03\x02\x03\x12\x04\xc0\x01\x08\"\n\r\n\
    \x05\x05\x03\x02\x03\x01\x12\x04\xc0\x01\x08\x1d\n\r\n\x05\x05\x03\x02\
    \x03\x02\x12\x04\xc0\x01\x20!\n\x0c\n\x04\x05\x03\x02\x04\x12\x04\xc1\
    \x01\x08(\n\r\n\x05\x05\x03\x02\x04\x01\x12\x04\xc1\x01\x08#\n\r\n\x05\
    \x05\x03\x02\x04\x02\x12\x04\xc1\x01&'\n\x0c\n\x04\x05\x03\x02\x05\x12\
    \x04\xc2\x01\x08&\n\r\n\x05\x05\x03\x02\x05\x01\x12\x04\xc2\x01\x08!\n\r\
    \n\x05\x05\x03\x02\x05\x02\x12\x04\xc2\x01$%\n\x0c\n\x04\x05\x03\x02\x06\
    \x12\x04\xc3\x01\x08%\n\r\n\x05\x05\x03\x02\x06\x01\x12\x04\xc3\x01\x08\
    \x20\n\r\n\x05\x05\x03\x02\x06\x02\x12\x04\xc3\x01#$\n\x0c\n\x04\x05\x03\
    \x02\x07\x12\x04\xc4\x01\x08'\n\r\n\x05\x05\x03\x02\x07\x01\x12\x04\xc4\
    \x01\x08\"\n\r\n\x05\x05\x03\x02\x07\x02\x12\x04\xc4\x01%&\n\x0c\n\x04\
    \x05\x03\x02\x08\x12\x04\xc5\x01\x08'\n\r\n\x05\x05\x03\x02\x08\x01\x12\
    \x04\xc5\x01\x08\"\n\r\n\x05\x05\x03\x02\x08\x02\x12\x04\xc5\x01%&\n\x0c\
    \n\x04\x05\x03\x02\t\x12\x04\xc6\x01\x08)\n\r\n\x05\x05\x03\x02\t\x01\
    \x12\x04\xc6\x01\x08$\n\r\n\x05\x05\x03\x02\t\x02\x12\x04\xc6\x01'(\n\
    \x0c\n\x04\x05\x03\x02\n\x12\x04\xc7\x01\x08+\n\r\n\x05\x05\x03\x02\n\
    \x01\x12\x04\xc7\x01\x08&\n\r\n\x05\x05\x03\x02\n\x02\x12\x04\xc7\x01)*\
    \n\x0c\n\x04\x05\x03\x02\x0b\x12\x04\xc8\x01\x08)\n\r\n\x05\x05\x03\x02\
    \x0b\x01\x12\x04\xc8\x01\x08$\n\r\n\x05\x05\x03\x02\x0b\x02\x12\x04\xc8\
    \x01'(\n\x0c\n\x04\x05\x03\x02\x0c\x12\x04\xc9\x01\x08(\n\r\n\x05\x05\
    \x03\x02\x0c\x01\x12\x04\xc9\x01\x08#\n\r\n\x05\x05\x03\x02\x0c\x02\x12\
    \x04\xc9\x01&'\n\x0c\n\x04\x05\x03\x02\r\x12\x04\xca\x01\x08'\n\r\n\x05\
    \x05\x03\x02\r\x01\x12\x04\xca\x01\x08\"\n\r\n\x05\x05\x03\x02\r\x02\x12\
    \x04\xca\x01%&\n\x0c\n\x04\x05\x03\x02\x0e\x12\x04\xcb\x01\x08'\n\r\n\
    \x05\x05\x03\x02\x0e\x01\x12\x04\xcb\x01\x08\"\n\r\n\x05\x05\x03\x02\x0e\
    \x02\x12\x04\xcb\x01%&\n\x0c\n\x04\x05\x03\x02\x0f\x12\x04\xcc\x01\x08)\
    \n\r\n\x05\x05\x03\x02\x0f\x01\x12\x04\xcc\x01\x08$\n\r\n\x05\x05\x03\
    \x02\x0f\x02\x12\x04\xcc\x01'(\n\x0c\n\x04\x05\x03\x02\x10\x12\x04\xcd\
    \x01\x08+\n\r\n\x05\x05\x03\x02\x10\x01\x12\x04\xcd\x01\x08&\n\r\n\x05\
    \x05\x03\x02\x10\x02\x12\x04\xcd\x01)*\n\x0c\n\x04\x05\x03\x02\x11\x12\
    \x04\xce\x01\x08)\n\r\n\x05\x05\x03\x02\x11\x01\x12\x04\xce\x01\x08$\n\r\
    \n\x05\x05\x03\x02\x11\x02\x12\x04\xce\x01'(\n\x0c\n\x04\x05\x03\x02\x12\
    \x12\x04\xcf\x01\x08(\n\r\n\x05\x05\x03\x02\x12\x01\x12\x04\xcf\x01\x08#\
    \n\r\n\x05\x05\x03\x02\x12\x02\x12\x04\xcf\x01&'\n\x0c\n\x04\x05\x03\x02\
    \x13\x12\x04\xd0\x01\x08.\n\r\n\x05\x05\x03\x02\x13\x01\x12\x04\xd0\x01\
    \x08)\n\r\n\x05\x05\x03\x02\x13\x02\x12\x04\xd0\x01,-\n\x0c\n\x04\x05\
    \x03\x02\x14\x12\x04\xd1\x01\x08*\n\r\n\x05\x05\x03\x02\x14\x01\x12\x04\
    \xd1\x01\x08%\n\r\n\x05\x05\x03\x02\x14\x02\x12\x04\xd1\x01()\n\x0c\n\
    \x04\x05\x03\x02\x15\x12\x04\xd2\x01\x08(\n\r\n\x05\x05\x03\x02\x15\x01\
    \x12\x04\xd2\x01\x08#\n\r\n\x05\x05\x03\x02\x15\x02\x12\x04\xd2\x01&'\n\
    \x0c\n\x04\x05\x03\x02\x16\x12\x04\xd3\x01\x08'\n\r\n\x05\x05\x03\x02\
    \x16\x01\x12\x04\xd3\x01\x08\"\n\r\n\x05\x05\x03\x02\x16\x02\x12\x04\xd3\
    \x01%&\n\x0c\n\x02\x05\x04\x12\x06\xd6\x01\0\xde\x01\x01\n\x0b\n\x03\x05\
    \x04\x01\x12\x04\xd6\x01\x05\x15\n\x0c\n\x04\x05\x04\x02\0\x12\x04\xd7\
    \x01\x08'\n\r\n\x05\x05\x04\x02\0\x01\x12\x04\xd7\x01\x08\"\n\r\n\x05\
    \x05\x04\x02\0\x02\x12\x04\xd7\x01%&\n\x0c\n\x04\x05\x04\x02\x01\x12\x04\
    \xd8\x01\x08*\n\r\n\x05\x05\x04\x02\x01\x01\x12\x04\xd8\x01\x08%\n\r\n\
    \x05\x05\x04\x02\x01\x02\x12\x04\xd8\x01()\n\x0c\n\x04\x05\x04\x02\x02\
    \x12\x04\xd9\x01\x087\n\r\n\x05\x05\x04\x02\x02\x01\x12\x04\xd9\x01\x08/\
    \n\r\n\x05\x05\x04\x02\x02\x02\x12\x04\xd9\x0126\n\x0c\n\x04\x05\x04\x02\
    \x03\x12\x04\xda\x01\x088\n\r\n\x05\x05\x04\x02\x03\x01\x12\x04\xda\x01\
    \x080\n\r\n\x05\x05\x04\x02\x03\x02\x12\x04\xda\x0137\n\x0c\n\x04\x05\
    \x04\x02\x04\x12\x04\xdb\x01\x087\n\r\n\x05\x05\x04\x02\x04\x01\x12\x04\
    \xdb\x01\x08/\n\r\n\x05\x05\x04\x02\x04\x02\x12\x04\xdb\x0126\n\x0c\n\
    \x04\x05\x04\x02\x05\x12\x04\xdc\x01\x089\n\r\n\x05\x05\x04\x02\x05\x01\
    \x12\x04\xdc\x01\x081\n\r\n\x05\x05\x04\x02\x05\x02\x12\x04\xdc\x0148\n\
    \x0c\n\x04\x05\x04\x02\x06\x12\x04\xdd\x01\x08:\n\r\n\x05\x05\x04\x02\
    \x06\x01\x12\x04\xdd\x01\x082\n\r\n\x05\x05\x04\x02\x06\x02\x12\x04\xdd\
    \x0159\n\x0c\n\x02\x05\x05\x12\x06\xe0\x01\0\xe8\x01\x01\n\x0b\n\x03\x05\
    \x05\x01\x12\x04\xe0\x01\x05\x14\n\x0c\n\x04\x05\x05\x02\0\x12\x04\xe1\
    \x01\x08'\n\r\n\x05\x05\x05\x02\0\x01\x12\x04\xe1\x01\x08\"\n\r\n\x05\
    \x05\x05\x02\0\x02\x12\x04\xe1\x01%&\n\x0c\n\x04\x05\x05\x02\x01\x12\x04\
    \xe2\x01\x085\n\r\n\x05\x05\x05\x02\x01\x01\x12\x04\xe2\x01\x080\n\r\n\
    \x05\x05\x05\x02\x01\x02\x12\x04\xe2\x0134\n\x0c\n\x04\x05\x05\x02\x02\
    \x12\x04\xe3\x01\x08*\n\r\n\x05\x05\x05\x02\x02\x01\x12\x04\xe3\x01\x08%\
    \n\r\n\x05\x05\x05\x02\x02\x02\x12\x04\xe3\x01()\n\x0c\n\x04\x05\x05\x02\
    \x03\x12\x04\xe4\x01\x08-\n\r\n\x05\x05\x05\x02\x03\x01\x12\x04\xe4\x01\
    \x08(\n\r\n\x05\x05\x05\x02\x03\x02\x12\x04\xe4\x01+,\n\x0c\n\x04\x05\
    \x05\x02\x04\x12\x04\xe5\x01\x08&\n\r\n\x05\x05\x05\x02\x04\x01\x12\x04\
    \xe5\x01\x08!\n\r\n\x05\x05\x05\x02\x04\x02\x12\x04\xe5\x01$%\n\x0c\n\
    \x04\x05\x05\x02\x05\x12\x04\xe6\x01\x08'\n\r\n\x05\x05\x05\x02\x05\x01\
    \x12\x04\xe6\x01\x08\"\n\r\n\x05\x05\x05\x02\x05\x02\x12\x04\xe6\x01%&\n\
    \x0c\n\x04\x05\x05\x02\x06\x12\x04\xe7\x01\x08!\n\r\n\x05\x05\x05\x02\
    \x06\x01\x12\x04\xe7\x01\x08\x1c\n\r\n\x05\x05\x05\x02\x06\x02\x12\x04\
    \xe7\x01\x1f\x20\n\x0c\n\x02\x05\x06\x12\x06\xea\x01\0\xf1\x01\x01\n\x0b\
    \n\x03\x05\x06\x01\x12\x04\xea\x01\x05\x0f\n\x0c\n\x04\x05\x06\x02\0\x12\
    \x04\xeb\x01\x08!\n\r\n\x05\x05\x06\x02\0\x01\x12\x04\xeb\x01\x08\x1c\n\
    \r\n\x05\x05\x06\x02\0\x02\x12\x04\xeb\x01\x1f\x20\n\x0c\n\x04\x05\x06\
    \x02\x01\x12\x04\xec\x01\x08\x20\n\r\n\x05\x05\x06\x02\x01\x01\x12\x04\
    \xec\x01\x08\x1b\n\r\n\x05\x05\x06\x02\x01\x02\x12\x04\xec\x01\x1e\x1f\n\
    \x0c\n\x04\x05\x06\x02\x02\x12\x04\xed\x01\x08#\n\r\n\x05\x05\x06\x02\
    \x02\x01\x12\x04\xed\x01\x08\x1e\n\r\n\x05\x05\x06\x02\x02\x02\x12\x04\
    \xed\x01!\"\n\x0c\n\x04\x05\x06\x02\x03\x12\x04\xee\x01\x08!\n\r\n\x05\
    \x05\x06\x02\x03\x01\x12\x04\xee\x01\x08\x1c\n\r\n\x05\x05\x06\x02\x03\
    \x02\x12\x04\xee\x01\x1f\x20\n\x0c\n\x04\x05\x06\x02\x04\x12\x04\xef\x01\
    \x08#\n\r\n\x05\x05\x06\x02\x04\x01\x12\x04\xef\x01\x08\x1e\n\r\n\x05\
    \x05\x06\x02\x04\x02\x12\x04\xef\x01!\"\n\x0c\n\x04\x05\x06\x02\x05\x12\
    \x04\xf0\x01\x08\x1e\n\r\n\x05\x05\x06\x02\x05\x01\x12\x04\xf0\x01\x08\
    \x19\n\r\n\x05\x05\x06\x02\x05\x02\x12\x04\xf0\x01\x1c\x1d\n\x0c\n\x02\
    \x05\x07\x12\x06\xf3\x01\0\xfb\x01\x01\n\x0b\n\x03\x05\x07\x01\x12\x04\
    \xf3\x01\x05\x17\n\x0c\n\x04\x05\x07\x02\0\x12\x04\xf4\x01\x08+\n\r\n\
    \x05\x05\x07\x02\0\x01\x12\x04\xf4\x01\x08&\n\r\n\x05\x05\x07\x02\0\x02\
    \x12\x04\xf4\x01)*\n\x0c\n\x04\x05\x07\x02\x01\x12\x04\xf5\x01\x08)\n\r\
    \n\x05\x05\x07\x02\x01\x01\x12\x04\xf5\x01\x08$\n\r\n\x05\x05\x07\x02\
    \x01\x02\x12\x04\xf5\x01'(\n\x0c\n\x04\x05\x07\x02\x02\x12\x04\xf6\x01\
    \x08$\n\r\n\x05\x05\x07\x02\x02\x01\x12\x04\xf6\x01\x08\x1f\n\r\n\x05\
    \x05\x07\x02\x02\x02\x12\x04\xf6\x01\"#\n\x0c\n\x04\x05\x07\x02\x03\x12\
    \x04\xf7\x01\x08*\n\r\n\x05\x05\x07\x02\x03\x01\x12\x04\xf7\x01\x08%\n\r\
    \n\x05\x05\x07\x02\x03\x02\x12\x04\xf7\x01()\n\x0c\n\x04\x05\x07\x02\x04\
    \x12\x04\xf8\x01\x08$\n\r\n\x05\x05\x07\x02\x04\x01\x12\x04\xf8\x01\x08\
    \x1f\n\r\n\x05\x05\x07\x02\x04\x02\x12\x04\xf8\x01\"#\n\x0c\n\x04\x05\
    \x07\x02\x05\x12\x04\xf9\x01\x08'\n\r\n\x05\x05\x07\x02\x05\x01\x12\x04\
    \xf9\x01\x08\"\n\r\n\x05\x05\x07\x02\x05\x02\x12\x04\xf9\x01%&\n\x0c\n\
    \x04\x05\x07\x02\x06\x12\x04\xfa\x01\x08*\n\r\n\x05\x05\x07\x02\x06\x01\
    \x12\x04\xfa\x01\x08%\n\r\n\x05\x05\x07\x02\x06\x02\x12\x04\xfa\x01()\n\
    \x0c\n\x02\x05\x08\x12\x06\xfd\x01\0\x82\x02\x01\n\x0b\n\x03\x05\x08\x01\
    \x12\x04\xfd\x01\x05\x15\n\x0c\n\x04\x05\x08\x02\0\x12\x04\xfe\x01\x08#\
    \n\r\n\x05\x05\x08\x02\0\x01\x12\x04\xfe\x01\x08\x1e\n\r\n\x05\x05\x08\
    \x02\0\x02\x12\x04\xfe\x01!\"\n\x0c\n\x04\x05\x08\x02\x01\x12\x04\xff\
    \x01\x08&\n\r\n\x05\x05\x08\x02\x01\x01\x12\x04\xff\x01\x08!\n\r\n\x05\
    \x05\x08\x02\x01\x02\x12\x04\xff\x01$%\n\x0c\n\x04\x05\x08\x02\x02\x12\
    \x04\x80\x02\x08\"\n\r\n\x05\x05\x08\x02\x02\x01\x12\x04\x80\x02\x08\x1d\
    \n\r\n\x05\x05\x08\x02\x02\x02\x12\x04\x80\x02\x20!\n\x0c\n\x04\x05\x08\
    \x02\x03\x12\x04\x81\x02\x08&\n\r\n\x05\x05\x08\x02\x03\x01\x12\x04\x81\
    \x02\x08!\n\r\n\x05\x05\x08\x02\x03\x02\x12\x04\x81\x02$%\n\x0c\n\x02\
    \x05\t\x12\x06\x84\x02\0\x8a\x02\x01\n\x0b\n\x03\x05\t\x01\x12\x04\x84\
    \x02\x05\x1b\n\x0c\n\x04\x05\t\x02\0\x12\x04\x85\x02\x08+\n\r\n\x05\x05\
    \t\x02\0\x01\x12\x04\x85\x02\x08&\n\r\n\x05\x05\t\x02\0\x02\x12\x04\x85\
    \x02)*\n\x0c\n\x04\x05\t\x02\x01\x12\x04\x86\x02\x085\n\r\n\x05\x05\t\
    \x02\x01\x01\x12\x04\x86\x02\x080\n\r\n\x05\x05\t\x02\x01\x02\x12\x04\
    \x86\x0234\n\x0c\n\x04\x05\t\x02\x02\x12\x04\x87\x02\x08)\n\r\n\x05\x05\
    \t\x02\x02\x01\x12\x04\x87\x02\x08$\n\r\n\x05\x05\t\x02\x02\x02\x12\x04\
    \x87\x02'(\n\x0c\n\x04\x05\t\x02\x03\x12\x04\x88\x02\x08E\n\r\n\x05\x05\
    \t\x02\x03\x01\x12\x04\x88\x02\x08@\n\r\n\x05\x05\t\x02\x03\x02\x12\x04\
    \x88\x02CD\n\x0c\n\x04\x05\t\x02\x04\x12\x04\x89\x02\x080\n\r\n\x05\x05\
    \t\x02\x04\x01\x12\x04\x89\x02\x08+\n\r\n\x05\x05\t\x02\x04\x02\x12\x04\
    \x89\x02./\n\x0c\n\x02\x05\n\x12\x06\x8c\x02\0\x92\x02\x01\n\x0b\n\x03\
    \x05\n\x01\x12\x04\x8c\x02\x05\x17\n\x0c\n\x04\x05\n\x02\0\x12\x04\x8d\
    \x02\x08#\n\r\n\x05\x05\n\x02\0\x01\x12\x04\x8d\x02\x08\x1e\n\r\n\x05\
    \x05\n\x02\0\x02\x12\x04\x8d\x02!\"\n\x0c\n\x04\x05\n\x02\x01\x12\x04\
    \x8e\x02\x08!\n\r\n\x05\x05\n\x02\x01\x01\x12\x04\x8e\x02\x08\x1c\n\r\n\
    \x05\x05\n\x02\x01\x02\x12\x04\x8e\x02\x1f\x20\n\x0c\n\x04\x05\n\x02\x02\
    \x12\x04\x8f\x02\x08\"\n\r\n\x05\x05\n\x02\x02\x01\x12\x04\x8f\x02\x08\
    \x1d\n\r\n\x05\x05\n\x02\x02\x02\x12\x04\x8f\x02\x20!\n\x0c\n\x04\x05\n\
    \x02\x03\x12\x04\x90\x02\x08$\n\r\n\x05\x05\n\x02\x03\x01\x12\x04\x90\
    \x02\x08\x1f\n\r\n\x05\x05\n\x02\x03\x02\x12\x04\x90\x02\"#\n\x0c\n\x04\
    \x05\n\x02\x04\x12\x04\x91\x02\x08!\n\r\n\x05\x05\n\x02\x04\x01\x12\x04\
    \x91\x02\x08\x1c\n\r\n\x05\x05\n\x02\x04\x02\x12\x04\x91\x02\x1f\x20\n\
    \x0c\n\x02\x04\0\x12\x06\x94\x02\0\x98\x02\x01\n\x0b\n\x03\x04\0\x01\x12\
    \x04\x94\x02\x08#\n\x0c\n\x04\x04\0\x02\0\x12\x04\x95\x02\x08)\n\r\n\x05\
    \x04\0\x02\0\x04\x12\x04\x95\x02\x08\x10\n\r\n\x05\x04\0\x02\0\x05\x12\
    \x04\x95\x02\x11\x16\n\r\n\x05\x04\0\x02\0\x01\x12\x04\x95\x02\x17$\n\r\
    \n\x05\x04\0\x02\0\x03\x12\x04\x95\x02'(\n\x0c\n\x04\x04\0\x02\x01\x12\
    \x04\x96\x02\x08\"\n\r\n\x05\x04\0\x02\x01\x04\x12\x04\x96\x02\x08\x10\n\
    \r\n\x05\x04\0\x02\x01\x05\x12\x04\x96\x02\x11\x15\n\r\n\x05\x04\0\x02\
    \x01\x01\x12\x04\x96\x02\x16\x1d\n\r\n\x05\x04\0\x02\x01\x03\x12\x04\x96\
    \x02\x20!\n\x0c\n\x04\x04\0\x02\x02\x12\x04\x97\x02\x08&\n\r\n\x05\x04\0\
    \x02\x02\x04\x12\x04\x97\x02\x08\x10\n\r\n\x05\x04\0\x02\x02\x05\x12\x04\
    \x97\x02\x11\x17\n\r\n\x05\x04\0\x02\x02\x01\x12\x04\x97\x02\x18!\n\r\n\
    \x05\x04\0\x02\x02\x03\x12\x04\x97\x02$%\n\x0c\n\x02\x04\x01\x12\x06\x9a\
    \x02\0\x9d\x02\x01\n\x0b\n\x03\x04\x01\x01\x12\x04\x9a\x02\x08\x1c\n\x0c\
    \n\x04\x04\x01\x02\0\x12\x04\x9b\x02\x08+\n\r\n\x05\x04\x01\x02\0\x04\
    \x12\x04\x9b\x02\x08\x10\n\r\n\x05\x04\x01\x02\0\x05\x12\x04\x9b\x02\x11\
    \x16\n\r\n\x05\x04\x01\x02\0\x01\x12\x04\x9b\x02\x17&\n\r\n\x05\x04\x01\
    \x02\0\x03\x12\x04\x9b\x02)*\n\x0c\n\x04\x04\x01\x02\x01\x12\x04\x9c\x02\
    \x08&\n\r\n\x05\x04\x01\x02\x01\x04\x12\x04\x9c\x02\x08\x10\n\r\n\x05\
    \x04\x01\x02\x01\x05\x12\x04\x9c\x02\x11\x17\n\r\n\x05\x04\x01\x02\x01\
    \x01\x12\x04\x9c\x02\x18!\n\r\n\x05\x04\x01\x02\x01\x03\x12\x04\x9c\x02$\
    %\n\x0c\n\x02\x04\x02\x12\x06\x9f\x02\0\xa3\x02\x01\n\x0b\n\x03\x04\x02\
    \x01\x12\x04\x9f\x02\x08%\n\x0c\n\x04\x04\x02\x02\0\x12\x04\xa0\x02\x08+\
    \n\r\n\x05\x04\x02\x02\0\x04\x12\x04\xa0\x02\x08\x10\n\r\n\x05\x04\x02\
    \x02\0\x05\x12\x04\xa0\x02\x11\x17\n\r\n\x05\x04\x02\x02\0\x01\x12\x04\
    \xa0\x02\x18&\n\r\n\x05\x04\x02\x02\0\x03\x12\x04\xa0\x02)*\n\x0c\n\x04\
    \x04\x02\x02\x01\x12\x04\xa1\x02\x08*\n\r\n\x05\x04\x02\x02\x01\x04\x12\
    \x04\xa1\x02\x08\x10\n\r\n\x05\x04\x02\x02\x01\x05\x12\x04\xa1\x02\x11\
    \x15\n\r\n\x05\x04\x02\x02\x01\x01\x12\x04\xa1\x02\x16%\n\r\n\x05\x04\
    \x02\x02\x01\x03\x12\x04\xa1\x02()\n\x0c\n\x04\x04\x02\x02\x02\x12\x04\
    \xa2\x02\x08&\n\r\n\x05\x04\x02\x02\x02\x04\x12\x04\xa2\x02\x08\x10\n\r\
    \n\x05\x04\x02\x02\x02\x05\x12\x04\xa2\x02\x11\x17\n\r\n\x05\x04\x02\x02\
    \x02\x01\x12\x04\xa2\x02\x18!\n\r\n\x05\x04\x02\x02\x02\x03\x12\x04\xa2\
    \x02$%\n\x0c\n\x02\x04\x03\x12\x06\xa5\x02\0\xab\x02\x01\n\x0b\n\x03\x04\
    \x03\x01\x12\x04\xa5\x02\x08\x19\n\x0c\n\x04\x04\x03\x02\0\x12\x04\xa6\
    \x02\x08J\n\r\n\x05\x04\x03\x02\0\x04\x12\x04\xa6\x02\x08\x10\n\r\n\x05\
    \x04\x03\x02\0\x05\x12\x04\xa6\x02\x11\x15\n\r\n\x05\x04\x03\x02\0\x01\
    \x12\x04\xa6\x02\x163\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\xa6\x0267\n\r\
    \n\x05\x04\x03\x02\0\x08\x12\x04\xa6\x028I\n\r\n\x05\x04\x03\x02\0\x07\
    \x12\x04\xa6\x02CH\n\x0c\n\x04\x04\x03\x02\x01\x12\x04\xa7\x02\x08Z\n\r\
    \n\x05\x04\x03\x02\x01\x04\x12\x04\xa7\x02\x08\x10\n\r\n\x05\x04\x03\x02\
    \x01\x06\x12\x04\xa7\x02\x11\x1f\n\r\n\x05\x04\x03\x02\x01\x01\x12\x04\
    \xa7\x02\x201\n\r\n\x05\x04\x03\x02\x01\x03\x12\x04\xa7\x0245\n\r\n\x05\
    \x04\x03\x02\x01\x08\x12\x04\xa7\x026Y\n\r\n\x05\x04\x03\x02\x01\x07\x12\
    \x04\xa7\x02AX\n\x0c\n\x04\x04\x03\x02\x02\x12\x04\xa8\x02\x08=\n\r\n\
    \x05\x04\x03\x02\x02\x04\x12\x04\xa8\x02\x08\x10\n\r\n\x05\x04\x03\x02\
    \x02\x05\x12\x04\xa8\x02\x11\x18\n\r\n\x05\x04\x03\x02\x02\x01\x12\x04\
    \xa8\x02\x19*\n\r\n\x05\x04\x03\x02\x02\x03\x12\x04\xa8\x02-.\n\r\n\x05\
    \x04\x03\x02\x02\x08\x12\x04\xa8\x02/<\n\r\n\x05\x04\x03\x02\x02\x07\x12\
    \x04\xa8\x02:;\n\x0c\n\x04\x04\x03\x02\x03\x12\x04\xa9\x02\x082\n\r\n\
    \x05\x04\x03\x02\x03\x04\x12\x04\xa9\x02\x08\x10\n\r\n\x05\x04\x03\x02\
    \x03\x05\x12\x04\xa9\x02\x11\x17\n\r\n\x05\x04\x03\x02\x03\x01\x12\x04\
    \xa9\x02\x18-\n\r\n\x05\x04\x03\x02\x03\x03\x12\x04\xa9\x0201\n\x0c\n\
    \x04\x04\x03\x02\x04\x12\x04\xaa\x02\x08:\n\r\n\x05\x04\x03\x02\x04\x04\
    \x12\x04\xaa\x02\x08\x10\n\r\n\x05\x04\x03\x02\x04\x06\x12\x04\xaa\x02\
    \x11\x1f\n\r\n\x05\x04\x03\x02\x04\x01\x12\x04\xaa\x02\x205\n\r\n\x05\
    \x04\x03\x02\x04\x03\x12\x04\xaa\x0289\n\x0c\n\x02\x04\x04\x12\x06\xad\
    \x02\0\xb4\x02\x01\n\x0b\n\x03\x04\x04\x01\x12\x04\xad\x02\x08\x18\n\x0c\
    \n\x04\x04\x04\x02\0\x12\x04\xae\x02\x08<\n\r\n\x05\x04\x04\x02\0\x04\
    \x12\x04\xae\x02\x08\x10\n\r\n\x05\x04\x04\x02\0\x05\x12\x04\xae\x02\x11\
    \x17\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\xae\x02\x18\"\n\r\n\x05\x04\x04\
    \x02\0\x03\x12\x04\xae\x02%&\n\r\n\x05\x04\x04\x02\0\x08\x12\x04\xae\x02\
    ';\n\x10\n\x08\x04\x04\x02\0\x08\xe0\xd4\x03\x12\x04\xae\x02(:\n\x0c\n\
    \x04\x04\x04\x02\x01\x12\x04\xaf\x02\x08&\n\r\n\x05\x04\x04\x02\x01\x04\
    \x12\x04\xaf\x02\x08\x10\n\r\n\x05\x04\x04\x02\x01\x05\x12\x04\xaf\x02\
    \x11\x17\n\r\n\x05\x04\x04\x02\x01\x01\x12\x04\xaf\x02\x18!\n\r\n\x05\
    \x04\x04\x02\x01\x03\x12\x04\xaf\x02$%\n\x0c\n\x04\x04\x04\x02\x02\x12\
    \x04\xb0\x02\x08(\n\r\n\x05\x04\x04\x02\x02\x04\x12\x04\xb0\x02\x08\x10\
    \n\r\n\x05\x04\x04\x02\x02\x05\x12\x04\xb0\x02\x11\x17\n\r\n\x05\x04\x04\
    \x02\x02\x01\x12\x04\xb0\x02\x18#\n\r\n\x05\x04\x04\x02\x02\x03\x12\x04\
    \xb0\x02&'\n\x0c\n\x04\x04\x04\x02\x03\x12\x04\xb1\x02\x081\n\r\n\x05\
    \x04\x04\x02\x03\x04\x12\x04\xb1\x02\x08\x10\n\r\n\x05\x04\x04\x02\x03\
    \x05\x12\x04\xb1\x02\x11\x17\n\r\n\x05\x04\x04\x02\x03\x01\x12\x04\xb1\
    \x02\x18,\n\r\n\x05\x04\x04\x02\x03\x03\x12\x04\xb1\x02/0\n\x0c\n\x04\
    \x04\x04\x02\x04\x12\x04\xb2\x02\x080\n\r\n\x05\x04\x04\x02\x04\x04\x12\
    \x04\xb2\x02\x08\x10\n\r\n\x05\x04\x04\x02\x04\x05\x12\x04\xb2\x02\x11\
    \x17\n\r\n\x05\x04\x04\x02\x04\x01\x12\x04\xb2\x02\x18+\n\r\n\x05\x04\
    \x04\x02\x04\x03\x12\x04\xb2\x02./\n\x0c\n\x04\x04\x04\x02\x05\x12\x04\
    \xb3\x02\x08-\n\r\n\x05\x04\x04\x02\x05\x04\x12\x04\xb3\x02\x08\x10\n\r\
    \n\x05\x04\x04\x02\x05\x05\x12\x04\xb3\x02\x11\x17\n\r\n\x05\x04\x04\x02\
    \x05\x01\x12\x04\xb3\x02\x18(\n\r\n\x05\x04\x04\x02\x05\x03\x12\x04\xb3\
    \x02+,\n\x0c\n\x02\x04\x05\x12\x06\xb6\x02\0\xba\x02\x01\n\x0b\n\x03\x04\
    \x05\x01\x12\x04\xb6\x02\x08\x1c\n\x0c\n\x04\x04\x05\x02\0\x12\x04\xb7\
    \x02\x08<\n\r\n\x05\x04\x05\x02\0\x04\x12\x04\xb7\x02\x08\x10\n\r\n\x05\
    \x04\x05\x02\0\x05\x12\x04\xb7\x02\x11\x17\n\r\n\x05\x04\x05\x02\0\x01\
    \x12\x04\xb7\x02\x18\"\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\xb7\x02%&\n\r\
    \n\x05\x04\x05\x02\0\x08\x12\x04\xb7\x02';\n\x10\n\x08\x04\x05\x02\0\x08\
    \xe0\xd4\x03\x12\x04\xb7\x02(:\n\x0c\n\x04\x04\x05\x02\x01\x12\x04\xb8\
    \x02\x08;\n\r\n\x05\x04\x05\x02\x01\x04\x12\x04\xb8\x02\x08\x10\n\r\n\
    \x05\x04\x05\x02\x01\x05\x12\x04\xb8\x02\x11\x17\n\r\n\x05\x04\x05\x02\
    \x01\x01\x12\x04\xb8\x02\x18!\n\r\n\x05\x04\x05\x02\x01\x03\x12\x04\xb8\
    \x02$%\n\r\n\x05\x04\x05\x02\x01\x08\x12\x04\xb8\x02&:\n\x10\n\x08\x04\
    \x05\x02\x01\x08\xe0\xd4\x03\x12\x04\xb8\x02'9\n\x0c\n\x04\x04\x05\x02\
    \x02\x12\x04\xb9\x02\x08/\n\r\n\x05\x04\x05\x02\x02\x04\x12\x04\xb9\x02\
    \x08\x10\n\r\n\x05\x04\x05\x02\x02\x05\x12\x04\xb9\x02\x11\x17\n\r\n\x05\
    \x04\x05\x02\x02\x01\x12\x04\xb9\x02\x18*\n\r\n\x05\x04\x05\x02\x02\x03\
    \x12\x04\xb9\x02-.\n\x0c\n\x02\x04\x06\x12\x06\xbc\x02\0\xbe\x02\x01\n\
    \x0b\n\x03\x04\x06\x01\x12\x04\xbc\x02\x08.\n\x0c\n\x04\x04\x06\x02\0\
    \x12\x04\xbd\x02\x08.\n\r\n\x05\x04\x06\x02\0\x04\x12\x04\xbd\x02\x08\
    \x10\n\r\n\x05\x04\x06\x02\0\x05\x12\x04\xbd\x02\x11\x17\n\r\n\x05\x04\
    \x06\x02\0\x01\x12\x04\xbd\x02\x18)\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\
    \xbd\x02,-\n\x0c\n\x02\x04\x07\x12\x06\xc0\x02\0\xc2\x02\x01\n\x0b\n\x03\
    \x04\x07\x01\x12\x04\xc0\x02\x08\x1f\n\x0c\n\x04\x04\x07\x02\0\x12\x04\
    \xc1\x02\x08(\n\r\n\x05\x04\x07\x02\0\x04\x12\x04\xc1\x02\x08\x10\n\r\n\
    \x05\x04\x07\x02\0\x05\x12\x04\xc1\x02\x11\x17\n\r\n\x05\x04\x07\x02\0\
    \x01\x12\x04\xc1\x02\x18#\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\xc1\x02&'\
    \n\x0c\n\x02\x04\x08\x12\x06\xc4\x02\0\xc6\x02\x01\n\x0b\n\x03\x04\x08\
    \x01\x12\x04\xc4\x02\x08'\n\x0c\n\x04\x04\x08\x02\0\x12\x04\xc5\x02\x08(\
    \n\r\n\x05\x04\x08\x02\0\x04\x12\x04\xc5\x02\x08\x10\n\r\n\x05\x04\x08\
    \x02\0\x05\x12\x04\xc5\x02\x11\x17\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\
    \xc5\x02\x18#\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\xc5\x02&'\n\x0c\n\x02\
    \x04\t\x12\x06\xc8\x02\0\xca\x02\x01\n\x0b\n\x03\x04\t\x01\x12\x04\xc8\
    \x02\x08\x17\n\x0c\n\x04\x04\t\x02\0\x12\x04\xc9\x02\x081\n\r\n\x05\x04\
    \t\x02\0\x04\x12\x04\xc9\x02\x08\x10\n\r\n\x05\x04\t\x02\0\x05\x12\x04\
    \xc9\x02\x11\x17\n\r\n\x05\x04\t\x02\0\x01\x12\x04\xc9\x02\x18,\n\r\n\
    \x05\x04\t\x02\0\x03\x12\x04\xc9\x02/0\n\x0c\n\x02\x04\n\x12\x06\xcc\x02\
    \0\xce\x02\x01\n\x0b\n\x03\x04\n\x01\x12\x04\xcc\x02\x08\x1e\n\x0c\n\x04\
    \x04\n\x02\0\x12\x04\xcd\x02\x08-\n\r\n\x05\x04\n\x02\0\x04\x12\x04\xcd\
    \x02\x08\x10\n\r\n\x05\x04\n\x02\0\x05\x12\x04\xcd\x02\x11\x17\n\r\n\x05\
    \x04\n\x02\0\x01\x12\x04\xcd\x02\x18(\n\r\n\x05\x04\n\x02\0\x03\x12\x04\
    \xcd\x02+,\n\x0c\n\x02\x04\x0b\x12\x06\xd0\x02\0\xd1\x02\x01\n\x0b\n\x03\
    \x04\x0b\x01\x12\x04\xd0\x02\x08\x1c\n\x0c\n\x02\x04\x0c\x12\x06\xd3\x02\
    \0\xd4\x02\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\xd3\x02\x08)\n\x0c\n\x02\
    \x04\r\x12\x06\xd6\x02\0\xd9\x02\x01\n\x0b\n\x03\x04\r\x01\x12\x04\xd6\
    \x02\x08\x18\n\x0c\n\x04\x04\r\x02\0\x12\x04\xd7\x02\x08%\n\r\n\x05\x04\
    \r\x02\0\x04\x12\x04\xd7\x02\x08\x10\n\r\n\x05\x04\r\x02\0\x05\x12\x04\
    \xd7\x02\x11\x17\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xd7\x02\x18\x20\n\r\n\
    \x05\x04\r\x02\0\x03\x12\x04\xd7\x02#$\n\x0c\n\x04\x04\r\x02\x01\x12\x04\
    \xd8\x02\x08)\n\r\n\x05\x04\r\x02\x01\x04\x12\x04\xd8\x02\x08\x10\n\r\n\
    \x05\x04\r\x02\x01\x05\x12\x04\xd8\x02\x11\x17\n\r\n\x05\x04\r\x02\x01\
    \x01\x12\x04\xd8\x02\x18$\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\xd8\x02'(\
    \n\x0c\n\x02\x04\x0e\x12\x06\xdb\x02\0\xde\x02\x01\n\x0b\n\x03\x04\x0e\
    \x01\x12\x04\xdb\x02\x08$\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\xdc\x02\x08(\
    \n\r\n\x05\x04\x0e\x02\0\x04\x12\x04\xdc\x02\x08\x10\n\r\n\x05\x04\x0e\
    \x02\0\x05\x12\x04\xdc\x02\x11\x17\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\
    \xdc\x02\x18#\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xdc\x02&'\n\x0c\n\x04\
    \x04\x0e\x02\x01\x12\x04\xdd\x02\x08%\n\r\n\x05\x04\x0e\x02\x01\x04\x12\
    \x04\xdd\x02\x08\x10\n\r\n\x05\x04\x0e\x02\x01\x05\x12\x04\xdd\x02\x11\
    \x17\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\xdd\x02\x18\x20\n\r\n\x05\x04\
    \x0e\x02\x01\x03\x12\x04\xdd\x02#$\n\x0c\n\x02\x04\x0f\x12\x06\xe0\x02\0\
    \xe2\x02\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\xe0\x02\x08,\n\x0c\n\x04\
    \x04\x0f\x02\0\x12\x04\xe1\x02\x08\"\n\r\n\x05\x04\x0f\x02\0\x04\x12\x04\
    \xe1\x02\x08\x10\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\xe1\x02\x11\x15\n\r\
    \n\x05\x04\x0f\x02\0\x01\x12\x04\xe1\x02\x16\x1d\n\r\n\x05\x04\x0f\x02\0\
    \x03\x12\x04\xe1\x02\x20!\n\x0c\n\x02\x04\x10\x12\x06\xe4\x02\0\xe9\x02\
    \x01\n\x0b\n\x03\x04\x10\x01\x12\x04\xe4\x02\x08\x20\n\x0c\n\x04\x04\x10\
    \x02\0\x12\x04\xe5\x02\x08'\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\xe5\x02\
    \x08\x10\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\xe5\x02\x11\x18\n\r\n\x05\
    \x04\x10\x02\0\x01\x12\x04\xe5\x02\x19\"\n\r\n\x05\x04\x10\x02\0\x03\x12\
    \x04\xe5\x02%&\n\x0c\n\x04\x04\x10\x02\x01\x12\x04\xe6\x02\x08/\n\r\n\
    \x05\x04\x10\x02\x01\x04\x12\x04\xe6\x02\x08\x10\n\r\n\x05\x04\x10\x02\
    \x01\x05\x12\x04\xe6\x02\x11\x17\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\
    \xe6\x02\x18*\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xe6\x02-.\n\x0c\n\
    \x04\x04\x10\x02\x02\x12\x04\xe7\x02\x08,\n\r\n\x05\x04\x10\x02\x02\x04\
    \x12\x04\xe7\x02\x08\x10\n\r\n\x05\x04\x10\x02\x02\x05\x12\x04\xe7\x02\
    \x11\x17\n\r\n\x05\x04\x10\x02\x02\x01\x12\x04\xe7\x02\x18'\n\r\n\x05\
    \x04\x10\x02\x02\x03\x12\x04\xe7\x02*+\n\x0c\n\x04\x04\x10\x02\x03\x12\
    \x04\xe8\x02\x08/\n\r\n\x05\x04\x10\x02\x03\x04\x12\x04\xe8\x02\x08\x10\
    \n\r\n\x05\x04\x10\x02\x03\x05\x12\x04\xe8\x02\x11\x17\n\r\n\x05\x04\x10\
    \x02\x03\x01\x12\x04\xe8\x02\x18*\n\r\n\x05\x04\x10\x02\x03\x03\x12\x04\
    \xe8\x02-.\n\x0c\n\x02\x04\x11\x12\x06\xeb\x02\0\xec\x02\x01\n\x0b\n\x03\
    \x04\x11\x01\x12\x04\xeb\x02\x08#\n\x0c\n\x02\x04\x12\x12\x06\xee\x02\0\
    \xef\x02\x01\n\x0b\n\x03\x04\x12\x01\x12\x04\xee\x02\x08(\n\x0c\n\x02\
    \x04\x13\x12\x06\xf1\x02\0\xf3\x02\x01\n\x0b\n\x03\x04\x13\x01\x12\x04\
    \xf1\x02\x08\x20\n\x0c\n\x04\x04\x13\x02\0\x12\x04\xf2\x02\x087\n\r\n\
    \x05\x04\x13\x02\0\x04\x12\x04\xf2\x02\x08\x10\n\r\n\x05\x04\x13\x02\0\
    \x05\x12\x04\xf2\x02\x11\x17\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\xf2\x02\
    \x182\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xf2\x0256\n\x0c\n\x02\x04\x14\
    \x12\x06\xf5\x02\0\xf9\x02\x01\n\x0b\n\x03\x04\x14\x01\x12\x04\xf5\x02\
    \x08(\n\x0c\n\x04\x04\x14\x02\0\x12\x04\xf6\x02\x08&\n\r\n\x05\x04\x14\
    \x02\0\x04\x12\x04\xf6\x02\x08\x10\n\r\n\x05\x04\x14\x02\0\x05\x12\x04\
    \xf6\x02\x11\x15\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xf6\x02\x16!\n\r\n\
    \x05\x04\x14\x02\0\x03\x12\x04\xf6\x02$%\n\x0c\n\x04\x04\x14\x02\x01\x12\
    \x04\xf7\x02\x08&\n\r\n\x05\x04\x14\x02\x01\x04\x12\x04\xf7\x02\x08\x10\
    \n\r\n\x05\x04\x14\x02\x01\x05\x12\x04\xf7\x02\x11\x17\n\r\n\x05\x04\x14\
    \x02\x01\x01\x12\x04\xf7\x02\x18!\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\
    \xf7\x02$%\n\x0c\n\x04\x04\x14\x02\x02\x12\x04\xf8\x02\x08'\n\r\n\x05\
    \x04\x14\x02\x02\x04\x12\x04\xf8\x02\x08\x10\n\r\n\x05\x04\x14\x02\x02\
    \x05\x12\x04\xf8\x02\x11\x17\n\r\n\x05\x04\x14\x02\x02\x01\x12\x04\xf8\
    \x02\x18\"\n\r\n\x05\x04\x14\x02\x02\x03\x12\x04\xf8\x02%&\n\x0c\n\x02\
    \x04\x15\x12\x06\xfb\x02\0\xfe\x02\x01\n\x0b\n\x03\x04\x15\x01\x12\x04\
    \xfb\x02\x08\x1f\n\x0c\n\x04\x04\x15\x02\0\x12\x04\xfc\x02\x08/\n\r\n\
    \x05\x04\x15\x02\0\x04\x12\x04\xfc\x02\x08\x10\n\r\n\x05\x04\x15\x02\0\
    \x05\x12\x04\xfc\x02\x11\x17\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\xfc\x02\
    \x18*\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xfc\x02-.\n\x0c\n\x04\x04\x15\
    \x02\x01\x12\x04\xfd\x02\x08,\n\r\n\x05\x04\x15\x02\x01\x04\x12\x04\xfd\
    \x02\x08\x10\n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\xfd\x02\x11\x15\n\r\n\
    \x05\x04\x15\x02\x01\x01\x12\x04\xfd\x02\x16'\n\r\n\x05\x04\x15\x02\x01\
    \x03\x12\x04\xfd\x02*+\n\x0c\n\x02\x04\x16\x12\x06\x80\x03\0\x82\x03\x01\
    \n\x0b\n\x03\x04\x16\x01\x12\x04\x80\x03\x08'\n\x0c\n\x04\x04\x16\x02\0\
    \x12\x04\x81\x03\x085\n\r\n\x05\x04\x16\x02\0\x04\x12\x04\x81\x03\x08\
    \x10\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\x81\x03\x11\x15\n\r\n\x05\x04\
    \x16\x02\0\x01\x12\x04\x81\x03\x160\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\
    \x81\x0334\n\x0c\n\x02\x04\x17\x12\x06\x84\x03\0\x89\x03\x01\n\x0b\n\x03\
    \x04\x17\x01\x12\x04\x84\x03\x08$\n\x0c\n\x04\x04\x17\x02\0\x12\x04\x85\
    \x03\x08$\n\r\n\x05\x04\x17\x02\0\x04\x12\x04\x85\x03\x08\x10\n\r\n\x05\
    \x04\x17\x02\0\x05\x12\x04\x85\x03\x11\x15\n\r\n\x05\x04\x17\x02\0\x01\
    \x12\x04\x85\x03\x16\x1f\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\x85\x03\"#\
    \n\x0c\n\x04\x04\x17\x02\x01\x12\x04\x86\x03\x08+\n\r\n\x05\x04\x17\x02\
    \x01\x04\x12\x04\x86\x03\x08\x10\n\r\n\x05\x04\x17\x02\x01\x05\x12\x04\
    \x86\x03\x11\x17\n\r\n\x05\x04\x17\x02\x01\x01\x12\x04\x86\x03\x18&\n\r\
    \n\x05\x04\x17\x02\x01\x03\x12\x04\x86\x03)*\n\x0c\n\x04\x04\x17\x02\x02\
    \x12\x04\x87\x03\x08(\n\r\n\x05\x04\x17\x02\x02\x04\x12\x04\x87\x03\x08\
    \x10\n\r\n\x05\x04\x17\x02\x02\x05\x12\x04\x87\x03\x11\x17\n\r\n\x05\x04\
    \x17\x02\x02\x01\x12\x04\x87\x03\x18#\n\r\n\x05\x04\x17\x02\x02\x03\x12\
    \x04\x87\x03&'\n\x0c\n\x04\x04\x17\x02\x03\x12\x04\x88\x03\x08/\n\r\n\
    \x05\x04\x17\x02\x03\x04\x12\x04\x88\x03\x08\x10\n\r\n\x05\x04\x17\x02\
    \x03\x05\x12\x04\x88\x03\x11\x17\n\r\n\x05\x04\x17\x02\x03\x01\x12\x04\
    \x88\x03\x18*\n\r\n\x05\x04\x17\x02\x03\x03\x12\x04\x88\x03-.\n\x0c\n\
    \x02\x04\x18\x12\x06\x8b\x03\0\x8e\x03\x01\n\x0b\n\x03\x04\x18\x01\x12\
    \x04\x8b\x03\x08#\n\x0c\n\x04\x04\x18\x02\0\x12\x04\x8c\x03\x08-\n\r\n\
    \x05\x04\x18\x02\0\x04\x12\x04\x8c\x03\x08\x10\n\r\n\x05\x04\x18\x02\0\
    \x05\x12\x04\x8c\x03\x11\x17\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\x8c\x03\
    \x18(\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\x8c\x03+,\n\x0c\n\x04\x04\x18\
    \x02\x01\x12\x04\x8d\x03\x08/\n\r\n\x05\x04\x18\x02\x01\x04\x12\x04\x8d\
    \x03\x08\x10\n\r\n\x05\x04\x18\x02\x01\x05\x12\x04\x8d\x03\x11\x17\n\r\n\
    \x05\x04\x18\x02\x01\x01\x12\x04\x8d\x03\x18*\n\r\n\x05\x04\x18\x02\x01\
    \x03\x12\x04\x8d\x03-.\n\x0c\n\x02\x04\x19\x12\x06\x90\x03\0\x92\x03\x01\
    \n\x0b\n\x03\x04\x19\x01\x12\x04\x90\x03\x08\"\n\x0c\n\x04\x04\x19\x02\0\
    \x12\x04\x91\x03\x08-\n\r\n\x05\x04\x19\x02\0\x04\x12\x04\x91\x03\x08\
    \x10\n\r\n\x05\x04\x19\x02\0\x05\x12\x04\x91\x03\x11\x17\n\r\n\x05\x04\
    \x19\x02\0\x01\x12\x04\x91\x03\x18(\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\
    \x91\x03+,\n\x0c\n\x02\x04\x1a\x12\x06\x94\x03\0\x96\x03\x01\n\x0b\n\x03\
    \x04\x1a\x01\x12\x04\x94\x03\x08'\n\x0c\n\x04\x04\x1a\x02\0\x12\x04\x95\
    \x03\x08%\n\r\n\x05\x04\x1a\x02\0\x04\x12\x04\x95\x03\x08\x10\n\r\n\x05\
    \x04\x1a\x02\0\x05\x12\x04\x95\x03\x11\x15\n\r\n\x05\x04\x1a\x02\0\x01\
    \x12\x04\x95\x03\x16\x20\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\x95\x03#$\n\
    \x0c\n\x02\x04\x1b\x12\x06\x98\x03\0\x9a\x03\x01\n\x0b\n\x03\x04\x1b\x01\
    \x12\x04\x98\x03\x08)\n\x0c\n\x04\x04\x1b\x02\0\x12\x04\x99\x03\x08-\n\r\
    \n\x05\x04\x1b\x02\0\x04\x12\x04\x99\x03\x08\x10\n\r\n\x05\x04\x1b\x02\0\
    \x05\x12\x04\x99\x03\x11\x17\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\x99\x03\
    \x18(\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\x99\x03+,\n\x0c\n\x02\x04\x1c\
    \x12\x06\x9c\x03\0\xa7\x03\x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\x9c\x03\
    \x08$\n\x0e\n\x04\x04\x1c\x03\0\x12\x06\x9d\x03\x08\xa4\x03\t\n\r\n\x05\
    \x04\x1c\x03\0\x01\x12\x04\x9d\x03\x10\x1a\n\x0e\n\x06\x04\x1c\x03\0\x02\
    \0\x12\x04\x9e\x03\x103\n\x0f\n\x07\x04\x1c\x03\0\x02\0\x04\x12\x04\x9e\
    \x03\x10\x18\n\x0f\n\x07\x04\x1c\x03\0\x02\0\x05\x12\x04\x9e\x03\x19\x1f\
    \n\x0f\n\x07\x04\x1c\x03\0\x02\0\x01\x12\x04\x9e\x03\x20.\n\x0f\n\x07\
    \x04\x1c\x03\0\x02\0\x03\x12\x04\x9e\x0312\n\x0e\n\x06\x04\x1c\x03\0\x02\
    \x01\x12\x04\x9f\x03\x100\n\x0f\n\x07\x04\x1c\x03\0\x02\x01\x04\x12\x04\
    \x9f\x03\x10\x18\n\x0f\n\x07\x04\x1c\x03\0\x02\x01\x05\x12\x04\x9f\x03\
    \x19\x1f\n\x0f\n\x07\x04\x1c\x03\0\x02\x01\x01\x12\x04\x9f\x03\x20+\n\
    \x0f\n\x07\x04\x1c\x03\0\x02\x01\x03\x12\x04\x9f\x03./\n\x0e\n\x06\x04\
    \x1c\x03\0\x02\x02\x12\x04\xa0\x03\x10.\n\x0f\n\x07\x04\x1c\x03\0\x02\
    \x02\x04\x12\x04\xa0\x03\x10\x18\n\x0f\n\x07\x04\x1c\x03\0\x02\x02\x05\
    \x12\x04\xa0\x03\x19\x1f\n\x0f\n\x07\x04\x1c\x03\0\x02\x02\x01\x12\x04\
    \xa0\x03\x20)\n\x0f\n\x07\x04\x1c\x03\0\x02\x02\x03\x12\x04\xa0\x03,-\n\
    \x0e\n\x06\x04\x1c\x03\0\x02\x03\x12\x04\xa1\x03\x10-\n\x0f\n\x07\x04\
    \x1c\x03\0\x02\x03\x04\x12\x04\xa1\x03\x10\x18\n\x0f\n\x07\x04\x1c\x03\0\
    \x02\x03\x05\x12\x04\xa1\x03\x19\x1f\n\x0f\n\x07\x04\x1c\x03\0\x02\x03\
    \x01\x12\x04\xa1\x03\x20(\n\x0f\n\x07\x04\x1c\x03\0\x02\x03\x03\x12\x04\
    \xa1\x03+,\n\x0e\n\x06\x04\x1c\x03\0\x02\x04\x12\x04\xa2\x03\x10.\n\x0f\
    \n\x07\x04\x1c\x03\0\x02\x04\x04\x12\x04\xa2\x03\x10\x18\n\x0f\n\x07\x04\
    \x1c\x03\0\x02\x04\x05\x12\x04\xa2\x03\x19\x1f\n\x0f\n\x07\x04\x1c\x03\0\
    \x02\x04\x01\x12\x04\xa2\x03\x20)\n\x0f\n\x07\x04\x1c\x03\0\x02\x04\x03\
    \x12\x04\xa2\x03,-\n\x0e\n\x06\x04\x1c\x03\0\x02\x05\x12\x04\xa3\x03\x10\
    .\n\x0f\n\x07\x04\x1c\x03\0\x02\x05\x04\x12\x04\xa3\x03\x10\x18\n\x0f\n\
    \x07\x04\x1c\x03\0\x02\x05\x05\x12\x04\xa3\x03\x19\x1e\n\x0f\n\x07\x04\
    \x1c\x03\0\x02\x05\x01\x12\x04\xa3\x03\x1f)\n\x0f\n\x07\x04\x1c\x03\0\
    \x02\x05\x03\x12\x04\xa3\x03,-\n\x0c\n\x04\x04\x1c\x02\0\x12\x04\xa6\x03\
    \x08F\n\r\n\x05\x04\x1c\x02\0\x04\x12\x04\xa6\x03\x08\x10\n\r\n\x05\x04\
    \x1c\x02\0\x06\x12\x04\xa6\x03\x119\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\
    \xa6\x03:A\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xa6\x03DE\n\x0c\n\x02\x04\
    \x1d\x12\x06\xa9\x03\0\xb3\x03\x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\xa9\
    \x03\x08,\n\x0e\n\x04\x04\x1d\x03\0\x12\x06\xaa\x03\x08\xb0\x03\t\n\r\n\
    \x05\x04\x1d\x03\0\x01\x12\x04\xaa\x03\x10\x1a\n\x0e\n\x06\x04\x1d\x03\0\
    \x02\0\x12\x04\xab\x03\x103\n\x0f\n\x07\x04\x1d\x03\0\x02\0\x04\x12\x04\
    \xab\x03\x10\x18\n\x0f\n\x07\x04\x1d\x03\0\x02\0\x05\x12\x04\xab\x03\x19\
    \x1f\n\x0f\n\x07\x04\x1d\x03\0\x02\0\x01\x12\x04\xab\x03\x20.\n\x0f\n\
    \x07\x04\x1d\x03\0\x02\0\x03\x12\x04\xab\x0312\n\x0e\n\x06\x04\x1d\x03\0\
    \x02\x01\x12\x04\xac\x03\x100\n\x0f\n\x07\x04\x1d\x03\0\x02\x01\x04\x12\
    \x04\xac\x03\x10\x18\n\x0f\n\x07\x04\x1d\x03\0\x02\x01\x05\x12\x04\xac\
    \x03\x19\x1f\n\x0f\n\x07\x04\x1d\x03\0\x02\x01\x01\x12\x04\xac\x03\x20+\
    \n\x0f\n\x07\x04\x1d\x03\0\x02\x01\x03\x12\x04\xac\x03./\n\x0e\n\x06\x04\
    \x1d\x03\0\x02\x02\x12\x04\xad\x03\x10/\n\x0f\n\x07\x04\x1d\x03\0\x02\
    \x02\x04\x12\x04\xad\x03\x10\x18\n\x0f\n\x07\x04\x1d\x03\0\x02\x02\x05\
    \x12\x04\xad\x03\x19\x1e\n\x0f\n\x07\x04\x1d\x03\0\x02\x02\x01\x12\x04\
    \xad\x03\x1f*\n\x0f\n\x07\x04\x1d\x03\0\x02\x02\x03\x12\x04\xad\x03-.\n\
    \x0e\n\x06\x04\x1d\x03\0\x02\x03\x12\x04\xae\x03\x10-\n\x0f\n\x07\x04\
    \x1d\x03\0\x02\x03\x04\x12\x04\xae\x03\x10\x18\n\x0f\n\x07\x04\x1d\x03\0\
    \x02\x03\x05\x12\x04\xae\x03\x19\x1f\n\x0f\n\x07\x04\x1d\x03\0\x02\x03\
    \x01\x12\x04\xae\x03\x20(\n\x0f\n\x07\x04\x1d\x03\0\x02\x03\x03\x12\x04\
    \xae\x03+,\n\x0e\n\x06\x04\x1d\x03\0\x02\x04\x12\x04\xaf\x03\x102\n\x0f\
    \n\x07\x04\x1d\x03\0\x02\x04\x04\x12\x04\xaf\x03\x10\x18\n\x0f\n\x07\x04\
    \x1d\x03\0\x02\x04\x05\x12\x04\xaf\x03\x19\x1f\n\x0f\n\x07\x04\x1d\x03\0\
    \x02\x04\x01\x12\x04\xaf\x03\x20-\n\x0f\n\x07\x04\x1d\x03\0\x02\x04\x03\
    \x12\x04\xaf\x0301\n\x0c\n\x04\x04\x1d\x02\0\x12\x04\xb2\x03\x08N\n\r\n\
    \x05\x04\x1d\x02\0\x04\x12\x04\xb2\x03\x08\x10\n\r\n\x05\x04\x1d\x02\0\
    \x06\x12\x04\xb2\x03\x11A\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\xb2\x03BI\
    \n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\xb2\x03LM\n\x0c\n\x02\x04\x1e\x12\
    \x06\xb5\x03\0\xb7\x03\x01\n\x0b\n\x03\x04\x1e\x01\x12\x04\xb5\x03\x08%\
    \n\x0c\n\x04\x04\x1e\x02\0\x12\x04\xb6\x03\x08'\n\r\n\x05\x04\x1e\x02\0\
    \x04\x12\x04\xb6\x03\x08\x10\n\r\n\x05\x04\x1e\x02\0\x05\x12\x04\xb6\x03\
    \x11\x17\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\xb6\x03\x18\"\n\r\n\x05\x04\
    \x1e\x02\0\x03\x12\x04\xb6\x03%&\n\x0c\n\x02\x04\x1f\x12\x06\xb9\x03\0\
    \xbc\x03\x01\n\x0b\n\x03\x04\x1f\x01\x12\x04\xb9\x03\x08#\n\x0c\n\x04\
    \x04\x1f\x02\0\x12\x04\xba\x03\x08'\n\r\n\x05\x04\x1f\x02\0\x04\x12\x04\
    \xba\x03\x08\x10\n\r\n\x05\x04\x1f\x02\0\x05\x12\x04\xba\x03\x11\x15\n\r\
    \n\x05\x04\x1f\x02\0\x01\x12\x04\xba\x03\x16\"\n\r\n\x05\x04\x1f\x02\0\
    \x03\x12\x04\xba\x03%&\n\x0c\n\x04\x04\x1f\x02\x01\x12\x04\xbb\x03\x08'\
    \n\r\n\x05\x04\x1f\x02\x01\x04\x12\x04\xbb\x03\x08\x10\n\r\n\x05\x04\x1f\
    \x02\x01\x05\x12\x04\xbb\x03\x11\x17\n\r\n\x05\x04\x1f\x02\x01\x01\x12\
    \x04\xbb\x03\x18\"\n\r\n\x05\x04\x1f\x02\x01\x03\x12\x04\xbb\x03%&\n\x0c\
    \n\x02\x04\x20\x12\x06\xbe\x03\0\xc0\x03\x01\n\x0b\n\x03\x04\x20\x01\x12\
    \x04\xbe\x03\x08'\n\x0c\n\x04\x04\x20\x02\0\x12\x04\xbf\x03\x08-\n\r\n\
    \x05\x04\x20\x02\0\x04\x12\x04\xbf\x03\x08\x10\n\r\n\x05\x04\x20\x02\0\
    \x05\x12\x04\xbf\x03\x11\x17\n\r\n\x05\x04\x20\x02\0\x01\x12\x04\xbf\x03\
    \x18(\n\r\n\x05\x04\x20\x02\0\x03\x12\x04\xbf\x03+,\n\x0c\n\x02\x04!\x12\
    \x06\xc2\x03\0\xc8\x03\x01\n\x0b\n\x03\x04!\x01\x12\x04\xc2\x03\x08$\n\
    \x0c\n\x04\x04!\x02\0\x12\x04\xc3\x03\x08(\n\r\n\x05\x04!\x02\0\x04\x12\
    \x04\xc3\x03\x08\x10\n\r\n\x05\x04!\x02\0\x05\x12\x04\xc3\x03\x11\x15\n\
    \r\n\x05\x04!\x02\0\x01\x12\x04\xc3\x03\x16#\n\r\n\x05\x04!\x02\0\x03\
    \x12\x04\xc3\x03&'\n\x0c\n\x04\x04!\x02\x01\x12\x04\xc4\x03\x080\n\r\n\
    \x05\x04!\x02\x01\x04\x12\x04\xc4\x03\x08\x10\n\r\n\x05\x04!\x02\x01\x05\
    \x12\x04\xc4\x03\x11\x16\n\r\n\x05\x04!\x02\x01\x01\x12\x04\xc4\x03\x17+\
    \n\r\n\x05\x04!\x02\x01\x03\x12\x04\xc4\x03./\n\x0c\n\x04\x04!\x02\x02\
    \x12\x04\xc5\x03\x086\n\r\n\x05\x04!\x02\x02\x04\x12\x04\xc5\x03\x08\x10\
    \n\r\n\x05\x04!\x02\x02\x05\x12\x04\xc5\x03\x11\x16\n\r\n\x05\x04!\x02\
    \x02\x01\x12\x04\xc5\x03\x171\n\r\n\x05\x04!\x02\x02\x03\x12\x04\xc5\x03\
    45\n\x0c\n\x04\x04!\x02\x03\x12\x04\xc6\x03\x08*\n\r\n\x05\x04!\x02\x03\
    \x04\x12\x04\xc6\x03\x08\x10\n\r\n\x05\x04!\x02\x03\x05\x12\x04\xc6\x03\
    \x11\x15\n\r\n\x05\x04!\x02\x03\x01\x12\x04\xc6\x03\x16%\n\r\n\x05\x04!\
    \x02\x03\x03\x12\x04\xc6\x03()\n\x0c\n\x04\x04!\x02\x04\x12\x04\xc7\x03\
    \x08$\n\r\n\x05\x04!\x02\x04\x04\x12\x04\xc7\x03\x08\x10\n\r\n\x05\x04!\
    \x02\x04\x05\x12\x04\xc7\x03\x11\x17\n\r\n\x05\x04!\x02\x04\x01\x12\x04\
    \xc7\x03\x18\x1f\n\r\n\x05\x04!\x02\x04\x03\x12\x04\xc7\x03\"#\n\x0c\n\
    \x02\x04\"\x12\x06\xca\x03\0\xcd\x03\x01\n\x0b\n\x03\x04\"\x01\x12\x04\
    \xca\x03\x08/\n\x0c\n\x04\x04\"\x02\0\x12\x04\xcb\x03\x083\n\r\n\x05\x04\
    \"\x02\0\x04\x12\x04\xcb\x03\x08\x10\n\r\n\x05\x04\"\x02\0\x05\x12\x04\
    \xcb\x03\x11\x17\n\r\n\x05\x04\"\x02\0\x01\x12\x04\xcb\x03\x18.\n\r\n\
    \x05\x04\"\x02\0\x03\x12\x04\xcb\x0312\n\x0c\n\x04\x04\"\x02\x01\x12\x04\
    \xcc\x03\x083\n\r\n\x05\x04\"\x02\x01\x04\x12\x04\xcc\x03\x08\x10\n\r\n\
    \x05\x04\"\x02\x01\x05\x12\x04\xcc\x03\x11\x16\n\r\n\x05\x04\"\x02\x01\
    \x01\x12\x04\xcc\x03\x17.\n\r\n\x05\x04\"\x02\x01\x03\x12\x04\xcc\x0312\
    \n\x0c\n\x02\x04#\x12\x06\xcf\x03\0\xd1\x03\x01\n\x0b\n\x03\x04#\x01\x12\
    \x04\xcf\x03\x08(\n\x0c\n\x04\x04#\x02\0\x12\x04\xd0\x03\x08'\n\r\n\x05\
    \x04#\x02\0\x04\x12\x04\xd0\x03\x08\x10\n\r\n\x05\x04#\x02\0\x05\x12\x04\
    \xd0\x03\x11\x17\n\r\n\x05\x04#\x02\0\x01\x12\x04\xd0\x03\x18\"\n\r\n\
    \x05\x04#\x02\0\x03\x12\x04\xd0\x03%&\n\x0c\n\x02\x04$\x12\x06\xd3\x03\0\
    \xdf\x03\x01\n\x0b\n\x03\x04$\x01\x12\x04\xd3\x03\x080\n\x0e\n\x04\x04$\
    \x04\0\x12\x06\xd4\x03\x08\xd9\x03\t\n\r\n\x05\x04$\x04\0\x01\x12\x04\
    \xd4\x03\r\x14\n\x0e\n\x06\x04$\x04\0\x02\0\x12\x04\xd5\x03\x10+\n\x0f\n\
    \x07\x04$\x04\0\x02\0\x01\x12\x04\xd5\x03\x10&\n\x0f\n\x07\x04$\x04\0\
    \x02\0\x02\x12\x04\xd5\x03)*\n\x0e\n\x06\x04$\x04\0\x02\x01\x12\x04\xd6\
    \x03\x10%\n\x0f\n\x07\x04$\x04\0\x02\x01\x01\x12\x04\xd6\x03\x10\x1f\n\
    \x0f\n\x07\x04$\x04\0\x02\x01\x02\x12\x04\xd6\x03\"$\n\x0e\n\x06\x04$\
    \x04\0\x02\x02\x12\x04\xd7\x03\x10%\n\x0f\n\x07\x04$\x04\0\x02\x02\x01\
    \x12\x04\xd7\x03\x10\x1f\n\x0f\n\x07\x04$\x04\0\x02\x02\x02\x12\x04\xd7\
    \x03\"$\n\x0e\n\x06\x04$\x04\0\x02\x03\x12\x04\xd8\x03\x10$\n\x0f\n\x07\
    \x04$\x04\0\x02\x03\x01\x12\x04\xd8\x03\x10\x1f\n\x0f\n\x07\x04$\x04\0\
    \x02\x03\x02\x12\x04\xd8\x03\"#\n\x0c\n\x04\x04$\x02\0\x12\x04\xdb\x03\
    \x08*\n\r\n\x05\x04$\x02\0\x04\x12\x04\xdb\x03\x08\x10\n\r\n\x05\x04$\
    \x02\0\x05\x12\x04\xdb\x03\x11\x15\n\r\n\x05\x04$\x02\0\x01\x12\x04\xdb\
    \x03\x16%\n\r\n\x05\x04$\x02\0\x03\x12\x04\xdb\x03()\n\x0c\n\x04\x04$\
    \x02\x01\x12\x04\xdc\x03\x083\n\r\n\x05\x04$\x02\x01\x04\x12\x04\xdc\x03\
    \x08\x10\n\r\n\x05\x04$\x02\x01\x05\x12\x04\xdc\x03\x11\x17\n\r\n\x05\
    \x04$\x02\x01\x01\x12\x04\xdc\x03\x18.\n\r\n\x05\x04$\x02\x01\x03\x12\
    \x04\xdc\x0312\n\x0c\n\x04\x04$\x02\x02\x12\x04\xdd\x03\x087\n\r\n\x05\
    \x04$\x02\x02\x04\x12\x04\xdd\x03\x08\x10\n\r\n\x05\x04$\x02\x02\x05\x12\
    \x04\xdd\x03\x11\x17\n\r\n\x05\x04$\x02\x02\x01\x12\x04\xdd\x03\x182\n\r\
    \n\x05\x04$\x02\x02\x03\x12\x04\xdd\x0356\n\x0c\n\x04\x04$\x02\x03\x12\
    \x04\xde\x03\x08q\n\r\n\x05\x04$\x02\x03\x04\x12\x04\xde\x03\x08\x10\n\r\
    \n\x05\x04$\x02\x03\x06\x12\x04\xde\x03\x11B\n\r\n\x05\x04$\x02\x03\x01\
    \x12\x04\xde\x03CI\n\r\n\x05\x04$\x02\x03\x03\x12\x04\xde\x03LM\n\r\n\
    \x05\x04$\x02\x03\x08\x12\x04\xde\x03Np\n\r\n\x05\x04$\x02\x03\x07\x12\
    \x04\xde\x03Yo\n\x0c\n\x02\x04%\x12\x06\xe1\x03\0\xe3\x03\x01\n\x0b\n\
    \x03\x04%\x01\x12\x04\xe1\x03\x08\x1e\n\x0c\n\x04\x04%\x02\0\x12\x04\xe2\
    \x03\x08'\n\r\n\x05\x04%\x02\0\x04\x12\x04\xe2\x03\x08\x10\n\r\n\x05\x04\
    %\x02\0\x05\x12\x04\xe2\x03\x11\x17\n\r\n\x05\x04%\x02\0\x01\x12\x04\xe2\
    \x03\x18\"\n\r\n\x05\x04%\x02\0\x03\x12\x04\xe2\x03%&\n\x0c\n\x02\x04&\
    \x12\x06\xe5\x03\0\xee\x03\x01\n\x0b\n\x03\x04&\x01\x12\x04\xe5\x03\x08&\
    \n\x0e\n\x04\x04&\x03\0\x12\x06\xe6\x03\x08\xeb\x03\t\n\r\n\x05\x04&\x03\
    \0\x01\x12\x04\xe6\x03\x10\"\n\x0e\n\x06\x04&\x03\0\x02\0\x12\x04\xe7\
    \x03\x10;\n\x0f\n\x07\x04&\x03\0\x02\0\x04\x12\x04\xe7\x03\x10\x18\n\x0f\
    \n\x07\x04&\x03\0\x02\0\x05\x12\x04\xe7\x03\x19\x1f\n\x0f\n\x07\x04&\x03\
    \0\x02\0\x01\x12\x04\xe7\x03\x206\n\x0f\n\x07\x04&\x03\0\x02\0\x03\x12\
    \x04\xe7\x039:\n\x0e\n\x06\x04&\x03\0\x02\x01\x12\x04\xe8\x03\x10?\n\x0f\
    \n\x07\x04&\x03\0\x02\x01\x04\x12\x04\xe8\x03\x10\x18\n\x0f\n\x07\x04&\
    \x03\0\x02\x01\x05\x12\x04\xe8\x03\x19\x1f\n\x0f\n\x07\x04&\x03\0\x02\
    \x01\x01\x12\x04\xe8\x03\x20:\n\x0f\n\x07\x04&\x03\0\x02\x01\x03\x12\x04\
    \xe8\x03=>\n\x0e\n\x06\x04&\x03\0\x02\x02\x12\x04\xe9\x03\x108\n\x0f\n\
    \x07\x04&\x03\0\x02\x02\x04\x12\x04\xe9\x03\x10\x18\n\x0f\n\x07\x04&\x03\
    \0\x02\x02\x05\x12\x04\xe9\x03\x19\x1e\n\x0f\n\x07\x04&\x03\0\x02\x02\
    \x01\x12\x04\xe9\x03\x1f3\n\x0f\n\x07\x04&\x03\0\x02\x02\x03\x12\x04\xe9\
    \x0367\n\x0e\n\x06\x04&\x03\0\x02\x03\x12\x04\xea\x03\x10>\n\x0f\n\x07\
    \x04&\x03\0\x02\x03\x04\x12\x04\xea\x03\x10\x18\n\x0f\n\x07\x04&\x03\0\
    \x02\x03\x05\x12\x04\xea\x03\x19\x1e\n\x0f\n\x07\x04&\x03\0\x02\x03\x01\
    \x12\x04\xea\x03\x1f9\n\x0f\n\x07\x04&\x03\0\x02\x03\x03\x12\x04\xea\x03\
    <=\n\x0c\n\x04\x04&\x02\0\x12\x04\xed\x03\x08[\n\r\n\x05\x04&\x02\0\x04\
    \x12\x04\xed\x03\x08\x10\n\r\n\x05\x04&\x02\0\x06\x12\x04\xed\x03\x11C\n\
    \r\n\x05\x04&\x02\0\x01\x12\x04\xed\x03DV\n\r\n\x05\x04&\x02\0\x03\x12\
    \x04\xed\x03YZ\n\x0c\n\x02\x04'\x12\x06\xf0\x03\0\xf2\x03\x01\n\x0b\n\
    \x03\x04'\x01\x12\x04\xf0\x03\x08'\n\x0c\n\x04\x04'\x02\0\x12\x04\xf1\
    \x03\x083\n\r\n\x05\x04'\x02\0\x04\x12\x04\xf1\x03\x08\x10\n\r\n\x05\x04\
    '\x02\0\x05\x12\x04\xf1\x03\x11\x17\n\r\n\x05\x04'\x02\0\x01\x12\x04\xf1\
    \x03\x18.\n\r\n\x05\x04'\x02\0\x03\x12\x04\xf1\x0312\n\x0c\n\x02\x04(\
    \x12\x06\xf4\x03\0\xf8\x03\x01\n\x0b\n\x03\x04(\x01\x12\x04\xf4\x03\x08/\
    \n\x0c\n\x04\x04(\x02\0\x12\x04\xf5\x03\x08;\n\r\n\x05\x04(\x02\0\x04\
    \x12\x04\xf5\x03\x08\x10\n\r\n\x05\x04(\x02\0\x05\x12\x04\xf5\x03\x11\
    \x15\n\r\n\x05\x04(\x02\0\x01\x12\x04\xf5\x03\x166\n\r\n\x05\x04(\x02\0\
    \x03\x12\x04\xf5\x039:\n\x0c\n\x04\x04(\x02\x01\x12\x04\xf6\x03\x083\n\r\
    \n\x05\x04(\x02\x01\x04\x12\x04\xf6\x03\x08\x10\n\r\n\x05\x04(\x02\x01\
    \x05\x12\x04\xf6\x03\x11\x17\n\r\n\x05\x04(\x02\x01\x01\x12\x04\xf6\x03\
    \x18.\n\r\n\x05\x04(\x02\x01\x03\x12\x04\xf6\x0312\n\x0c\n\x04\x04(\x02\
    \x02\x12\x04\xf7\x03\x087\n\r\n\x05\x04(\x02\x02\x04\x12\x04\xf7\x03\x08\
    \x10\n\r\n\x05\x04(\x02\x02\x05\x12\x04\xf7\x03\x11\x17\n\r\n\x05\x04(\
    \x02\x02\x01\x12\x04\xf7\x03\x182\n\r\n\x05\x04(\x02\x02\x03\x12\x04\xf7\
    \x0356\n\x0c\n\x02\x04)\x12\x06\xfa\x03\0\xfb\x03\x01\n\x0b\n\x03\x04)\
    \x01\x12\x04\xfa\x03\x08#\n\x0c\n\x02\x04*\x12\x06\xfd\x03\0\x80\x04\x01\
    \n\x0b\n\x03\x04*\x01\x12\x04\xfd\x03\x08+\n\x0c\n\x04\x04*\x02\0\x12\
    \x04\xfe\x03\x08#\n\r\n\x05\x04*\x02\0\x04\x12\x04\xfe\x03\x08\x10\n\r\n\
    \x05\x04*\x02\0\x05\x12\x04\xfe\x03\x11\x17\n\r\n\x05\x04*\x02\0\x01\x12\
    \x04\xfe\x03\x18\x1e\n\r\n\x05\x04*\x02\0\x03\x12\x04\xfe\x03!\"\n\x0c\n\
    \x04\x04*\x02\x01\x12\x04\xff\x03\x08$\n\r\n\x05\x04*\x02\x01\x04\x12\
    \x04\xff\x03\x08\x10\n\r\n\x05\x04*\x02\x01\x05\x12\x04\xff\x03\x11\x17\
    \n\r\n\x05\x04*\x02\x01\x01\x12\x04\xff\x03\x18\x1f\n\r\n\x05\x04*\x02\
    \x01\x03\x12\x04\xff\x03\"#\n\x0c\n\x02\x04+\x12\x06\x82\x04\0\x84\x04\
    \x01\n\x0b\n\x03\x04+\x01\x12\x04\x82\x04\x08/\n\x0c\n\x04\x04+\x02\0\
    \x12\x04\x83\x04\x08$\n\r\n\x05\x04+\x02\0\x04\x12\x04\x83\x04\x08\x10\n\
    \r\n\x05\x04+\x02\0\x05\x12\x04\x83\x04\x11\x17\n\r\n\x05\x04+\x02\0\x01\
    \x12\x04\x83\x04\x18\x1f\n\r\n\x05\x04+\x02\0\x03\x12\x04\x83\x04\"#\n\
    \x0c\n\x02\x04,\x12\x06\x86\x04\0\x90\x04\x01\n\x0b\n\x03\x04,\x01\x12\
    \x04\x86\x04\x088\n\x0e\n\x04\x04,\x04\0\x12\x06\x87\x04\x08\x8d\x04\t\n\
    \r\n\x05\x04,\x04\0\x01\x12\x04\x87\x04\r,\n\x0e\n\x06\x04,\x04\0\x02\0\
    \x12\x04\x88\x04\x10A\n\x0f\n\x07\x04,\x04\0\x02\0\x01\x12\x04\x88\x04\
    \x10<\n\x0f\n\x07\x04,\x04\0\x02\0\x02\x12\x04\x88\x04?@\n\x0e\n\x06\x04\
    ,\x04\0\x02\x01\x12\x04\x89\x04\x10M\n\x0f\n\x07\x04,\x04\0\x02\x01\x01\
    \x12\x04\x89\x04\x10H\n\x0f\n\x07\x04,\x04\0\x02\x01\x02\x12\x04\x89\x04\
    KL\n\x0e\n\x06\x04,\x04\0\x02\x02\x12\x04\x8a\x04\x10A\n\x0f\n\x07\x04,\
    \x04\0\x02\x02\x01\x12\x04\x8a\x04\x10<\n\x0f\n\x07\x04,\x04\0\x02\x02\
    \x02\x12\x04\x8a\x04?@\n\x0e\n\x06\x04,\x04\0\x02\x03\x12\x04\x8b\x04\
    \x10B\n\x0f\n\x07\x04,\x04\0\x02\x03\x01\x12\x04\x8b\x04\x10=\n\x0f\n\
    \x07\x04,\x04\0\x02\x03\x02\x12\x04\x8b\x04@A\n\x0e\n\x06\x04,\x04\0\x02\
    \x04\x12\x04\x8c\x04\x10G\n\x0f\n\x07\x04,\x04\0\x02\x04\x01\x12\x04\x8c\
    \x04\x10B\n\x0f\n\x07\x04,\x04\0\x02\x04\x02\x12\x04\x8c\x04EF\n\r\n\x04\
    \x04,\x02\0\x12\x05\x8f\x04\x08\xae\x01\n\r\n\x05\x04,\x02\0\x04\x12\x04\
    \x8f\x04\x08\x10\n\r\n\x05\x04,\x02\0\x06\x12\x04\x8f\x04\x11b\n\r\n\x05\
    \x04,\x02\0\x01\x12\x04\x8f\x04cp\n\r\n\x05\x04,\x02\0\x03\x12\x04\x8f\
    \x04st\n\x0e\n\x05\x04,\x02\0\x08\x12\x05\x8f\x04u\xad\x01\n\x0f\n\x05\
    \x04,\x02\0\x07\x12\x06\x8f\x04\x80\x01\xac\x01\n\x0c\n\x02\x04-\x12\x06\
    \x92\x04\0\x94\x04\x01\n\x0b\n\x03\x04-\x01\x12\x04\x92\x04\x083\n\x0c\n\
    \x04\x04-\x02\0\x12\x04\x93\x04\x08v\n\r\n\x05\x04-\x02\0\x04\x12\x04\
    \x93\x04\x08\x10\n\r\n\x05\x04-\x02\0\x06\x12\x04\x93\x04\x11-\n\r\n\x05\
    \x04-\x02\0\x01\x12\x04\x93\x04.?\n\r\n\x05\x04-\x02\0\x03\x12\x04\x93\
    \x04BC\n\r\n\x05\x04-\x02\0\x08\x12\x04\x93\x04Du\n\r\n\x05\x04-\x02\0\
    \x07\x12\x04\x93\x04Ot\n\x0c\n\x02\x04.\x12\x06\x96\x04\0\x9f\x04\x01\n\
    \x0b\n\x03\x04.\x01\x12\x04\x96\x04\x08<\n\x0e\n\x04\x04.\x04\0\x12\x06\
    \x97\x04\x08\x9b\x04\t\n\r\n\x05\x04.\x04\0\x01\x12\x04\x97\x04\r2\n\x0e\
    \n\x06\x04.\x04\0\x02\0\x12\x04\x98\x04\x10C\n\x0f\n\x07\x04.\x04\0\x02\
    \0\x01\x12\x04\x98\x04\x10>\n\x0f\n\x07\x04.\x04\0\x02\0\x02\x12\x04\x98\
    \x04AB\n\x0e\n\x06\x04.\x04\0\x02\x01\x12\x04\x99\x04\x10G\n\x0f\n\x07\
    \x04.\x04\0\x02\x01\x01\x12\x04\x99\x04\x10B\n\x0f\n\x07\x04.\x04\0\x02\
    \x01\x02\x12\x04\x99\x04EF\n\x0e\n\x06\x04.\x04\0\x02\x02\x12\x04\x9a\
    \x04\x10E\n\x0f\n\x07\x04.\x04\0\x02\x02\x01\x12\x04\x9a\x04\x10@\n\x0f\
    \n\x07\x04.\x04\0\x02\x02\x02\x12\x04\x9a\x04CD\n\x0c\n\x04\x04.\x02\0\
    \x12\x04\x9d\x04\x08v\n\r\n\x05\x04.\x02\0\x04\x12\x04\x9d\x04\x08\x10\n\
    \r\n\x05\x04.\x02\0\x06\x12\x04\x9d\x04\x11-\n\r\n\x05\x04.\x02\0\x01\
    \x12\x04\x9d\x04.?\n\r\n\x05\x04.\x02\0\x03\x12\x04\x9d\x04BC\n\r\n\x05\
    \x04.\x02\0\x08\x12\x04\x9d\x04Du\n\r\n\x05\x04.\x02\0\x07\x12\x04\x9d\
    \x04Ot\n\r\n\x04\x04.\x02\x01\x12\x05\x9e\x04\x08\xc1\x01\n\r\n\x05\x04.\
    \x02\x01\x04\x12\x04\x9e\x04\x08\x10\n\r\n\x05\x04.\x02\x01\x06\x12\x04\
    \x9e\x04\x11l\n\x0e\n\x05\x04.\x02\x01\x01\x12\x05\x9e\x04m\x81\x01\n\
    \x0f\n\x05\x04.\x02\x01\x03\x12\x06\x9e\x04\x84\x01\x85\x01\n\x0f\n\x05\
    \x04.\x02\x01\x08\x12\x06\x9e\x04\x86\x01\xc0\x01\n\x0f\n\x05\x04.\x02\
    \x01\x07\x12\x06\x9e\x04\x91\x01\xbf\x01\n\x0c\n\x02\x04/\x12\x06\xa1\
    \x04\0\xa3\x04\x01\n\x0b\n\x03\x04/\x01\x12\x04\xa1\x04\x087\n\x0c\n\x04\
    \x04/\x02\0\x12\x04\xa2\x04\x08v\n\r\n\x05\x04/\x02\0\x04\x12\x04\xa2\
    \x04\x08\x10\n\r\n\x05\x04/\x02\0\x06\x12\x04\xa2\x04\x11-\n\r\n\x05\x04\
    /\x02\0\x01\x12\x04\xa2\x04.?\n\r\n\x05\x04/\x02\0\x03\x12\x04\xa2\x04BC\
    \n\r\n\x05\x04/\x02\0\x08\x12\x04\xa2\x04Du\n\r\n\x05\x04/\x02\0\x07\x12\
    \x04\xa2\x04Ot\n\x0c\n\x02\x040\x12\x06\xa5\x04\0\xa8\x04\x01\n\x0b\n\
    \x03\x040\x01\x12\x04\xa5\x04\x080\n\x0c\n\x04\x040\x02\0\x12\x04\xa6\
    \x04\x08v\n\r\n\x05\x040\x02\0\x04\x12\x04\xa6\x04\x08\x10\n\r\n\x05\x04\
    0\x02\0\x06\x12\x04\xa6\x04\x11-\n\r\n\x05\x040\x02\0\x01\x12\x04\xa6\
    \x04.?\n\r\n\x05\x040\x02\0\x03\x12\x04\xa6\x04BC\n\r\n\x05\x040\x02\0\
    \x08\x12\x04\xa6\x04Du\n\r\n\x05\x040\x02\0\x07\x12\x04\xa6\x04Ot\n\x0c\
    \n\x04\x040\x02\x01\x12\x04\xa7\x04\x08!\n\r\n\x05\x040\x02\x01\x04\x12\
    \x04\xa7\x04\x08\x10\n\r\n\x05\x040\x02\x01\x05\x12\x04\xa7\x04\x11\x15\
    \n\r\n\x05\x040\x02\x01\x01\x12\x04\xa7\x04\x16\x1c\n\r\n\x05\x040\x02\
    \x01\x03\x12\x04\xa7\x04\x1f\x20\n\x0c\n\x02\x041\x12\x06\xaa\x04\0\xaf\
    \x04\x01\n\x0b\n\x03\x041\x01\x12\x04\xaa\x04\x08%\n\x0c\n\x04\x041\x02\
    \0\x12\x04\xab\x04\x08\x1d\n\r\n\x05\x041\x02\0\x04\x12\x04\xab\x04\x08\
    \x10\n\r\n\x05\x041\x02\0\x05\x12\x04\xab\x04\x11\x16\n\r\n\x05\x041\x02\
    \0\x01\x12\x04\xab\x04\x17\x18\n\r\n\x05\x041\x02\0\x03\x12\x04\xab\x04\
    \x1b\x1c\n\x0c\n\x04\x041\x02\x01\x12\x04\xac\x04\x08\x1d\n\r\n\x05\x041\
    \x02\x01\x04\x12\x04\xac\x04\x08\x10\n\r\n\x05\x041\x02\x01\x05\x12\x04\
    \xac\x04\x11\x16\n\r\n\x05\x041\x02\x01\x01\x12\x04\xac\x04\x17\x18\n\r\
    \n\x05\x041\x02\x01\x03\x12\x04\xac\x04\x1b\x1c\n\x0c\n\x04\x041\x02\x02\
    \x12\x04\xad\x04\x08\x1d\n\r\n\x05\x041\x02\x02\x04\x12\x04\xad\x04\x08\
    \x10\n\r\n\x05\x041\x02\x02\x05\x12\x04\xad\x04\x11\x16\n\r\n\x05\x041\
    \x02\x02\x01\x12\x04\xad\x04\x17\x18\n\r\n\x05\x041\x02\x02\x03\x12\x04\
    \xad\x04\x1b\x1c\n\x0c\n\x04\x041\x02\x03\x12\x04\xae\x04\x08,\n\r\n\x05\
    \x041\x02\x03\x04\x12\x04\xae\x04\x08\x10\n\r\n\x05\x041\x02\x03\x05\x12\
    \x04\xae\x04\x11\x17\n\r\n\x05\x041\x02\x03\x01\x12\x04\xae\x04\x18'\n\r\
    \n\x05\x041\x02\x03\x03\x12\x04\xae\x04*+\n\x0c\n\x02\x042\x12\x06\xb1\
    \x04\0\xb5\x04\x01\n\x0b\n\x03\x042\x01\x12\x04\xb1\x04\x08\"\n\x0c\n\
    \x04\x042\x02\0\x12\x04\xb2\x04\x081\n\r\n\x05\x042\x02\0\x04\x12\x04\
    \xb2\x04\x08\x10\n\r\n\x05\x042\x02\0\x05\x12\x04\xb2\x04\x11\x17\n\r\n\
    \x05\x042\x02\0\x01\x12\x04\xb2\x04\x18,\n\r\n\x05\x042\x02\0\x03\x12\
    \x04\xb2\x04/0\n\x0c\n\x04\x042\x02\x01\x12\x04\xb3\x04\x08%\n\r\n\x05\
    \x042\x02\x01\x04\x12\x04\xb3\x04\x08\x10\n\r\n\x05\x042\x02\x01\x05\x12\
    \x04\xb3\x04\x11\x17\n\r\n\x05\x042\x02\x01\x01\x12\x04\xb3\x04\x18\x20\
    \n\r\n\x05\x042\x02\x01\x03\x12\x04\xb3\x04#$\n\x0c\n\x04\x042\x02\x02\
    \x12\x04\xb4\x04\x08\"\n\r\n\x05\x042\x02\x02\x04\x12\x04\xb4\x04\x08\
    \x10\n\r\n\x05\x042\x02\x02\x05\x12\x04\xb4\x04\x11\x15\n\r\n\x05\x042\
    \x02\x02\x01\x12\x04\xb4\x04\x16\x1d\n\r\n\x05\x042\x02\x02\x03\x12\x04\
    \xb4\x04\x20!\n\x0c\n\x02\x043\x12\x06\xb7\x04\0\xb9\x04\x01\n\x0b\n\x03\
    \x043\x01\x12\x04\xb7\x04\x08*\n\x0c\n\x04\x043\x02\0\x12\x04\xb8\x04\
    \x081\n\r\n\x05\x043\x02\0\x04\x12\x04\xb8\x04\x08\x10\n\r\n\x05\x043\
    \x02\0\x05\x12\x04\xb8\x04\x11\x17\n\r\n\x05\x043\x02\0\x01\x12\x04\xb8\
    \x04\x18,\n\r\n\x05\x043\x02\0\x03\x12\x04\xb8\x04/0\n\x0c\n\x02\x044\
    \x12\x06\xbb\x04\0\xbc\x04\x01\n\x0b\n\x03\x044\x01\x12\x04\xbb\x04\x08$\
    \n\x0c\n\x02\x045\x12\x06\xbe\x04\0\xc1\x04\x01\n\x0b\n\x03\x045\x01\x12\
    \x04\xbe\x04\x08*\n\x0c\n\x04\x045\x02\0\x12\x04\xbf\x04\x08'\n\r\n\x05\
    \x045\x02\0\x04\x12\x04\xbf\x04\x08\x10\n\r\n\x05\x045\x02\0\x05\x12\x04\
    \xbf\x04\x11\x17\n\r\n\x05\x045\x02\0\x01\x12\x04\xbf\x04\x18\"\n\r\n\
    \x05\x045\x02\0\x03\x12\x04\xbf\x04%&\n\x0c\n\x04\x045\x02\x01\x12\x04\
    \xc0\x04\x08(\n\r\n\x05\x045\x02\x01\x04\x12\x04\xc0\x04\x08\x10\n\r\n\
    \x05\x045\x02\x01\x05\x12\x04\xc0\x04\x11\x17\n\r\n\x05\x045\x02\x01\x01\
    \x12\x04\xc0\x04\x18#\n\r\n\x05\x045\x02\x01\x03\x12\x04\xc0\x04&'\n\x0c\
    \n\x02\x046\x12\x06\xc3\x04\0\xc7\x04\x01\n\x0b\n\x03\x046\x01\x12\x04\
    \xc3\x04\x082\n\x0c\n\x04\x046\x02\0\x12\x04\xc4\x04\x08'\n\r\n\x05\x046\
    \x02\0\x04\x12\x04\xc4\x04\x08\x10\n\r\n\x05\x046\x02\0\x05\x12\x04\xc4\
    \x04\x11\x17\n\r\n\x05\x046\x02\0\x01\x12\x04\xc4\x04\x18\"\n\r\n\x05\
    \x046\x02\0\x03\x12\x04\xc4\x04%&\n\x0c\n\x04\x046\x02\x01\x12\x04\xc5\
    \x04\x08'\n\r\n\x05\x046\x02\x01\x04\x12\x04\xc5\x04\x08\x10\n\r\n\x05\
    \x046\x02\x01\x05\x12\x04\xc5\x04\x11\x15\n\r\n\x05\x046\x02\x01\x01\x12\
    \x04\xc5\x04\x16\"\n\r\n\x05\x046\x02\x01\x03\x12\x04\xc5\x04%&\n\x0c\n\
    \x04\x046\x02\x02\x12\x04\xc6\x04\x08%\n\r\n\x05\x046\x02\x02\x04\x12\
    \x04\xc6\x04\x08\x10\n\r\n\x05\x046\x02\x02\x05\x12\x04\xc6\x04\x11\x17\
    \n\r\n\x05\x046\x02\x02\x01\x12\x04\xc6\x04\x18\x20\n\r\n\x05\x046\x02\
    \x02\x03\x12\x04\xc6\x04#$\n\x0c\n\x02\x047\x12\x06\xc9\x04\0\xde\x04\
    \x01\n\x0b\n\x03\x047\x01\x12\x04\xc9\x04\x08\x18\n\x0e\n\x04\x047\x03\0\
    \x12\x06\xca\x04\x08\xd0\x04\t\n\r\n\x05\x047\x03\0\x01\x12\x04\xca\x04\
    \x10\x18\n\x0e\n\x06\x047\x03\0\x02\0\x12\x04\xcb\x04\x10.\n\x0f\n\x07\
    \x047\x03\0\x02\0\x04\x12\x04\xcb\x04\x10\x18\n\x0f\n\x07\x047\x03\0\x02\
    \0\x05\x12\x04\xcb\x04\x19\x20\n\x0f\n\x07\x047\x03\0\x02\0\x01\x12\x04\
    \xcb\x04!)\n\x0f\n\x07\x047\x03\0\x02\0\x03\x12\x04\xcb\x04,-\n\x0e\n\
    \x06\x047\x03\0\x02\x01\x12\x04\xcc\x04\x10b\n\x0f\n\x07\x047\x03\0\x02\
    \x01\x04\x12\x04\xcc\x04\x10\x18\n\x0f\n\x07\x047\x03\0\x02\x01\x06\x12\
    \x04\xcc\x04\x19'\n\x0f\n\x07\x047\x03\0\x02\x01\x01\x12\x04\xcc\x04(9\n\
    \x0f\n\x07\x047\x03\0\x02\x01\x03\x12\x04\xcc\x04<=\n\x0f\n\x07\x047\x03\
    \0\x02\x01\x08\x12\x04\xcc\x04>a\n\x0f\n\x07\x047\x03\0\x02\x01\x07\x12\
    \x04\xcc\x04I`\n\x0e\n\x06\x047\x03\0\x02\x02\x12\x04\xcd\x04\x105\n\x0f\
    \n\x07\x047\x03\0\x02\x02\x04\x12\x04\xcd\x04\x10\x18\n\x0f\n\x07\x047\
    \x03\0\x02\x02\x05\x12\x04\xcd\x04\x19\x1d\n\x0f\n\x07\x047\x03\0\x02\
    \x02\x01\x12\x04\xcd\x04\x1e0\n\x0f\n\x07\x047\x03\0\x02\x02\x03\x12\x04\
    \xcd\x0434\n\x0e\n\x06\x047\x03\0\x02\x03\x12\x04\xce\x04\x10)\n\x0f\n\
    \x07\x047\x03\0\x02\x03\x04\x12\x04\xce\x04\x10\x18\n\x0f\n\x07\x047\x03\
    \0\x02\x03\x05\x12\x04\xce\x04\x19\x1d\n\x0f\n\x07\x047\x03\0\x02\x03\
    \x01\x12\x04\xce\x04\x1e$\n\x0f\n\x07\x047\x03\0\x02\x03\x03\x12\x04\xce\
    \x04'(\n\x0e\n\x06\x047\x03\0\x02\x04\x12\x04\xcf\x04\x103\n\x0f\n\x07\
    \x047\x03\0\x02\x04\x04\x12\x04\xcf\x04\x10\x18\n\x0f\n\x07\x047\x03\0\
    \x02\x04\x05\x12\x04\xcf\x04\x19\x1f\n\x0f\n\x07\x047\x03\0\x02\x04\x01\
    \x12\x04\xcf\x04\x20.\n\x0f\n\x07\x047\x03\0\x02\x04\x03\x12\x04\xcf\x04\
    12\n\x0c\n\x04\x047\x02\0\x12\x04\xd2\x04\x08&\n\r\n\x05\x047\x02\0\x04\
    \x12\x04\xd2\x04\x08\x10\n\r\n\x05\x047\x02\0\x05\x12\x04\xd2\x04\x11\
    \x15\n\r\n\x05\x047\x02\0\x01\x12\x04\xd2\x04\x16!\n\r\n\x05\x047\x02\0\
    \x03\x12\x04\xd2\x04$%\n\x0c\n\x04\x047\x02\x01\x12\x04\xd3\x04\x08/\n\r\
    \n\x05\x047\x02\x01\x04\x12\x04\xd3\x04\x08\x10\n\r\n\x05\x047\x02\x01\
    \x05\x12\x04\xd3\x04\x11\x17\n\r\n\x05\x047\x02\x01\x01\x12\x04\xd3\x04\
    \x18*\n\r\n\x05\x047\x02\x01\x03\x12\x04\xd3\x04-.\n\x0c\n\x04\x047\x02\
    \x02\x12\x04\xd4\x04\x08(\n\r\n\x05\x047\x02\x02\x04\x12\x04\xd4\x04\x08\
    \x10\n\r\n\x05\x047\x02\x02\x05\x12\x04\xd4\x04\x11\x17\n\r\n\x05\x047\
    \x02\x02\x01\x12\x04\xd4\x04\x18#\n\r\n\x05\x047\x02\x02\x03\x12\x04\xd4\
    \x04&'\n\x0c\n\x04\x047\x02\x03\x12\x04\xd5\x04\x08-\n\r\n\x05\x047\x02\
    \x03\x04\x12\x04\xd5\x04\x08\x10\n\r\n\x05\x047\x02\x03\x05\x12\x04\xd5\
    \x04\x11\x15\n\r\n\x05\x047\x02\x03\x01\x12\x04\xd5\x04\x16(\n\r\n\x05\
    \x047\x02\x03\x03\x12\x04\xd5\x04+,\n\x0c\n\x04\x047\x02\x04\x12\x04\xd6\
    \x04\x08(\n\r\n\x05\x047\x02\x04\x04\x12\x04\xd6\x04\x08\x10\n\r\n\x05\
    \x047\x02\x04\x05\x12\x04\xd6\x04\x11\x17\n\r\n\x05\x047\x02\x04\x01\x12\
    \x04\xd6\x04\x18\"\n\r\n\x05\x047\x02\x04\x03\x12\x04\xd6\x04%'\n\x0c\n\
    \x04\x047\x02\x05\x12\x04\xd7\x04\x08F\n\r\n\x05\x047\x02\x05\x04\x12\
    \x04\xd7\x04\x08\x10\n\r\n\x05\x047\x02\x05\x06\x12\x04\xd7\x04\x110\n\r\
    \n\x05\x047\x02\x05\x01\x12\x04\xd7\x041@\n\r\n\x05\x047\x02\x05\x03\x12\
    \x04\xd7\x04CE\n\x0c\n\x04\x047\x02\x06\x12\x04\xd8\x04\x08:\n\r\n\x05\
    \x047\x02\x06\x04\x12\x04\xd8\x04\x08\x10\n\r\n\x05\x047\x02\x06\x06\x12\
    \x04\xd8\x04\x11+\n\r\n\x05\x047\x02\x06\x01\x12\x04\xd8\x04,4\n\r\n\x05\
    \x047\x02\x06\x03\x12\x04\xd8\x0479\n\x0c\n\x04\x047\x02\x07\x12\x04\xd9\
    \x04\x08)\n\r\n\x05\x047\x02\x07\x04\x12\x04\xd9\x04\x08\x10\n\r\n\x05\
    \x047\x02\x07\x05\x12\x04\xd9\x04\x11\x15\n\r\n\x05\x047\x02\x07\x01\x12\
    \x04\xd9\x04\x16#\n\r\n\x05\x047\x02\x07\x03\x12\x04\xd9\x04&(\n\x0c\n\
    \x04\x047\x02\x08\x12\x04\xda\x04\x08)\n\r\n\x05\x047\x02\x08\x04\x12\
    \x04\xda\x04\x08\x10\n\r\n\x05\x047\x02\x08\x05\x12\x04\xda\x04\x11\x15\
    \n\r\n\x05\x047\x02\x08\x01\x12\x04\xda\x04\x16#\n\r\n\x05\x047\x02\x08\
    \x03\x12\x04\xda\x04&(\n\x0c\n\x04\x047\x02\t\x12\x04\xdb\x04\x08/\n\r\n\
    \x05\x047\x02\t\x04\x12\x04\xdb\x04\x08\x10\n\r\n\x05\x047\x02\t\x05\x12\
    \x04\xdb\x04\x11\x15\n\r\n\x05\x047\x02\t\x01\x12\x04\xdb\x04\x16)\n\r\n\
    \x05\x047\x02\t\x03\x12\x04\xdb\x04,.\n\x0c\n\x04\x047\x02\n\x12\x04\xdc\
    \x04\x08/\n\r\n\x05\x047\x02\n\x04\x12\x04\xdc\x04\x08\x10\n\r\n\x05\x04\
    7\x02\n\x05\x12\x04\xdc\x04\x11\x15\n\r\n\x05\x047\x02\n\x01\x12\x04\xdc\
    \x04\x16)\n\r\n\x05\x047\x02\n\x03\x12\x04\xdc\x04,.\n\x0c\n\x04\x047\
    \x02\x0b\x12\x04\xdd\x04\x08)\n\r\n\x05\x047\x02\x0b\x04\x12\x04\xdd\x04\
    \x08\x10\n\r\n\x05\x047\x02\x0b\x05\x12\x04\xdd\x04\x11\x15\n\r\n\x05\
    \x047\x02\x0b\x01\x12\x04\xdd\x04\x16#\n\r\n\x05\x047\x02\x0b\x03\x12\
    \x04\xdd\x04&(\n\x0c\n\x02\x048\x12\x06\xe0\x04\0\xe9\x04\x01\n\x0b\n\
    \x03\x048\x01\x12\x04\xe0\x04\x08\x1c\n\x0e\n\x04\x048\x04\0\x12\x06\xe1\
    \x04\x08\xe4\x04\t\n\r\n\x05\x048\x04\0\x01\x12\x04\xe1\x04\r\x12\n\x0e\
    \n\x06\x048\x04\0\x02\0\x12\x04\xe2\x04\x10\x1c\n\x0f\n\x07\x048\x04\0\
    \x02\0\x01\x12\x04\xe2\x04\x10\x17\n\x0f\n\x07\x048\x04\0\x02\0\x02\x12\
    \x04\xe2\x04\x1a\x1b\n\x0e\n\x06\x048\x04\0\x02\x01\x12\x04\xe3\x04\x10$\
    \n\x0f\n\x07\x048\x04\0\x02\x01\x01\x12\x04\xe3\x04\x10\x1f\n\x0f\n\x07\
    \x048\x04\0\x02\x01\x02\x12\x04\xe3\x04\"#\n\x0c\n\x04\x048\x02\0\x12\
    \x04\xe6\x04\x08%\n\r\n\x05\x048\x02\0\x04\x12\x04\xe6\x04\x08\x10\n\r\n\
    \x05\x048\x02\0\x05\x12\x04\xe6\x04\x11\x18\n\r\n\x05\x048\x02\0\x01\x12\
    \x04\xe6\x04\x19\x20\n\r\n\x05\x048\x02\0\x03\x12\x04\xe6\x04#$\n\x0c\n\
    \x04\x048\x02\x01\x12\x04\xe7\x04\x08J\n\r\n\x05\x048\x02\x01\x04\x12\
    \x04\xe7\x04\x08\x10\n\r\n\x05\x048\x02\x01\x06\x12\x04\xe7\x04\x11,\n\r\
    \n\x05\x048\x02\x01\x01\x12\x04\xe7\x04-1\n\r\n\x05\x048\x02\x01\x03\x12\
    \x04\xe7\x0445\n\r\n\x05\x048\x02\x01\x08\x12\x04\xe7\x046I\n\r\n\x05\
    \x048\x02\x01\x07\x12\x04\xe7\x04AH\n\x0c\n\x04\x048\x02\x02\x12\x04\xe8\
    \x04\x08%\n\r\n\x05\x048\x02\x02\x04\x12\x04\xe8\x04\x08\x10\n\r\n\x05\
    \x048\x02\x02\x05\x12\x04\xe8\x04\x11\x18\n\r\n\x05\x048\x02\x02\x01\x12\
    \x04\xe8\x04\x19\x20\n\r\n\x05\x048\x02\x02\x03\x12\x04\xe8\x04#$\n\x0c\
    \n\x02\x049\x12\x06\xeb\x04\0\xee\x04\x01\n\x0b\n\x03\x049\x01\x12\x04\
    \xeb\x04\x08\x19\n\x0c\n\x04\x049\x02\0\x12\x04\xec\x04\x08[\n\r\n\x05\
    \x049\x02\0\x04\x12\x04\xec\x04\x08\x10\n\r\n\x05\x049\x02\0\x06\x12\x04\
    \xec\x04\x11%\n\r\n\x05\x049\x02\0\x01\x12\x04\xec\x04&/\n\r\n\x05\x049\
    \x02\0\x03\x12\x04\xec\x0423\n\r\n\x05\x049\x02\0\x08\x12\x04\xec\x044Z\
    \n\r\n\x05\x049\x02\0\x07\x12\x04\xec\x04?Y\n\x0c\n\x04\x049\x02\x01\x12\
    \x04\xed\x04\x08T\n\r\n\x05\x049\x02\x01\x04\x12\x04\xed\x04\x08\x10\n\r\
    \n\x05\x049\x02\x01\x06\x12\x04\xed\x04\x11\x1f\n\r\n\x05\x049\x02\x01\
    \x01\x12\x04\xed\x04\x20+\n\r\n\x05\x049\x02\x01\x03\x12\x04\xed\x04./\n\
    \r\n\x05\x049\x02\x01\x08\x12\x04\xed\x040S\n\r\n\x05\x049\x02\x01\x07\
    \x12\x04\xed\x04;R\n\x0c\n\x02\x04:\x12\x06\xf0\x04\0\xf7\x04\x01\n\x0b\
    \n\x03\x04:\x01\x12\x04\xf0\x04\x08\"\n\x0c\n\x04\x04:\x02\0\x12\x04\xf1\
    \x04\x08'\n\r\n\x05\x04:\x02\0\x04\x12\x04\xf1\x04\x08\x10\n\r\n\x05\x04\
    :\x02\0\x05\x12\x04\xf1\x04\x11\x15\n\r\n\x05\x04:\x02\0\x01\x12\x04\xf1\
    \x04\x16\"\n\r\n\x05\x04:\x02\0\x03\x12\x04\xf1\x04%&\n\x0c\n\x04\x04:\
    \x02\x01\x12\x04\xf2\x04\x08A\n\r\n\x05\x04:\x02\x01\x04\x12\x04\xf2\x04\
    \x08\x10\n\r\n\x05\x04:\x02\x01\x05\x12\x04\xf2\x04\x11\x17\n\r\n\x05\
    \x04:\x02\x01\x01\x12\x04\xf2\x04\x18-\n\r\n\x05\x04:\x02\x01\x03\x12\
    \x04\xf2\x0402\n\r\n\x05\x04:\x02\x01\x08\x12\x04\xf2\x043@\n\r\n\x05\
    \x04:\x02\x01\x07\x12\x04\xf2\x04>?\n\x0c\n\x04\x04:\x02\x02\x12\x04\xf3\
    \x04\x08-\n\r\n\x05\x04:\x02\x02\x04\x12\x04\xf3\x04\x08\x10\n\r\n\x05\
    \x04:\x02\x02\x05\x12\x04\xf3\x04\x11\x17\n\r\n\x05\x04:\x02\x02\x01\x12\
    \x04\xf3\x04\x18'\n\r\n\x05\x04:\x02\x02\x03\x12\x04\xf3\x04*,\n\x0c\n\
    \x04\x04:\x02\x03\x12\x04\xf4\x04\x081\n\r\n\x05\x04:\x02\x03\x04\x12\
    \x04\xf4\x04\x08\x10\n\r\n\x05\x04:\x02\x03\x05\x12\x04\xf4\x04\x11\x17\
    \n\r\n\x05\x04:\x02\x03\x01\x12\x04\xf4\x04\x18+\n\r\n\x05\x04:\x02\x03\
    \x03\x12\x04\xf4\x04.0\n\x0c\n\x04\x04:\x02\x04\x12\x04\xf5\x04\x083\n\r\
    \n\x05\x04:\x02\x04\x04\x12\x04\xf5\x04\x08\x10\n\r\n\x05\x04:\x02\x04\
    \x05\x12\x04\xf5\x04\x11\x17\n\r\n\x05\x04:\x02\x04\x01\x12\x04\xf5\x04\
    \x18-\n\r\n\x05\x04:\x02\x04\x03\x12\x04\xf5\x0402\n\x0c\n\x04\x04:\x02\
    \x05\x12\x04\xf6\x04\x08>\n\r\n\x05\x04:\x02\x05\x04\x12\x04\xf6\x04\x08\
    \x10\n\r\n\x05\x04:\x02\x05\x06\x12\x04\xf6\x04\x11(\n\r\n\x05\x04:\x02\
    \x05\x01\x12\x04\xf6\x04)8\n\r\n\x05\x04:\x02\x05\x03\x12\x04\xf6\x04;=\
    \n\x0c\n\x02\x04;\x12\x06\xf9\x04\0\xfb\x04\x01\n\x0b\n\x03\x04;\x01\x12\
    \x04\xf9\x04\x08\x1e\n\x0c\n\x04\x04;\x02\0\x12\x04\xfa\x04\x080\n\r\n\
    \x05\x04;\x02\0\x04\x12\x04\xfa\x04\x08\x10\n\r\n\x05\x04;\x02\0\x05\x12\
    \x04\xfa\x04\x11\x18\n\r\n\x05\x04;\x02\0\x01\x12\x04\xfa\x04\x19+\n\r\n\
    \x05\x04;\x02\0\x03\x12\x04\xfa\x04./\n\x0c\n\x02\x04<\x12\x06\xfd\x04\0\
    \xff\x04\x01\n\x0b\n\x03\x04<\x01\x12\x04\xfd\x04\x08&\n\x0c\n\x04\x04<\
    \x02\0\x12\x04\xfe\x04\x08,\n\r\n\x05\x04<\x02\0\x04\x12\x04\xfe\x04\x08\
    \x10\n\r\n\x05\x04<\x02\0\x05\x12\x04\xfe\x04\x11\x15\n\r\n\x05\x04<\x02\
    \0\x01\x12\x04\xfe\x04\x16'\n\r\n\x05\x04<\x02\0\x03\x12\x04\xfe\x04*+\n\
    \x0c\n\x02\x04=\x12\x06\x81\x05\0\x86\x05\x01\n\x0b\n\x03\x04=\x01\x12\
    \x04\x81\x05\x08\x17\n\x0c\n\x04\x04=\x02\0\x12\x04\x82\x05\x08-\n\r\n\
    \x05\x04=\x02\0\x04\x12\x04\x82\x05\x08\x10\n\r\n\x05\x04=\x02\0\x05\x12\
    \x04\x82\x05\x11\x15\n\r\n\x05\x04=\x02\0\x01\x12\x04\x82\x05\x16(\n\r\n\
    \x05\x04=\x02\0\x03\x12\x04\x82\x05+,\n\x0c\n\x04\x04=\x02\x01\x12\x04\
    \x83\x05\x08@\n\r\n\x05\x04=\x02\x01\x04\x12\x04\x83\x05\x08\x10\n\r\n\
    \x05\x04=\x02\x01\x06\x12\x04\x83\x05\x11,\n\r\n\x05\x04=\x02\x01\x01\
    \x12\x04\x83\x05-;\n\r\n\x05\x04=\x02\x01\x03\x12\x04\x83\x05>?\n\x0c\n\
    \x04\x04=\x02\x02\x12\x04\x84\x05\x08E\n\r\n\x05\x04=\x02\x02\x04\x12\
    \x04\x84\x05\x08\x10\n\r\n\x05\x04=\x02\x02\x06\x12\x04\x84\x05\x110\n\r\
    \n\x05\x04=\x02\x02\x01\x12\x04\x84\x051@\n\r\n\x05\x04=\x02\x02\x03\x12\
    \x04\x84\x05CD\n\x0c\n\x04\x04=\x02\x03\x12\x04\x85\x05\x087\n\r\n\x05\
    \x04=\x02\x03\x04\x12\x04\x85\x05\x08\x10\n\r\n\x05\x04=\x02\x03\x06\x12\
    \x04\x85\x05\x11#\n\r\n\x05\x04=\x02\x03\x01\x12\x04\x85\x05$2\n\r\n\x05\
    \x04=\x02\x03\x03\x12\x04\x85\x0556\n\x0c\n\x02\x04>\x12\x06\x88\x05\0\
    \x8b\x05\x01\n\x0b\n\x03\x04>\x01\x12\x04\x88\x05\x08\x1b\n\x0c\n\x04\
    \x04>\x02\0\x12\x04\x89\x05\x08&\n\r\n\x05\x04>\x02\0\x04\x12\x04\x89\
    \x05\x08\x10\n\r\n\x05\x04>\x02\0\x05\x12\x04\x89\x05\x11\x18\n\r\n\x05\
    \x04>\x02\0\x01\x12\x04\x89\x05\x19!\n\r\n\x05\x04>\x02\0\x03\x12\x04\
    \x89\x05$%\n\x0c\n\x04\x04>\x02\x01\x12\x04\x8a\x05\x08.\n\r\n\x05\x04>\
    \x02\x01\x04\x12\x04\x8a\x05\x08\x10\n\r\n\x05\x04>\x02\x01\x06\x12\x04\
    \x8a\x05\x11!\n\r\n\x05\x04>\x02\x01\x01\x12\x04\x8a\x05\")\n\r\n\x05\
    \x04>\x02\x01\x03\x12\x04\x8a\x05,-\n\x0c\n\x02\x04?\x12\x06\x8d\x05\0\
    \x8e\x05\x01\n\x0b\n\x03\x04?\x01\x12\x04\x8d\x05\x08#\n\x0c\n\x02\x04@\
    \x12\x06\x90\x05\0\x94\x05\x01\n\x0b\n\x03\x04@\x01\x12\x04\x90\x05\x08\
    \x1e\n\x0c\n\x04\x04@\x02\0\x12\x04\x91\x05\x08&\n\r\n\x05\x04@\x02\0\
    \x04\x12\x04\x91\x05\x08\x10\n\r\n\x05\x04@\x02\0\x05\x12\x04\x91\x05\
    \x11\x18\n\r\n\x05\x04@\x02\0\x01\x12\x04\x91\x05\x19!\n\r\n\x05\x04@\
    \x02\0\x03\x12\x04\x91\x05$%\n\x0c\n\x04\x04@\x02\x01\x12\x04\x92\x05\
    \x084\n\r\n\x05\x04@\x02\x01\x04\x12\x04\x92\x05\x08\x10\n\r\n\x05\x04@\
    \x02\x01\x06\x12\x04\x92\x05\x11!\n\r\n\x05\x04@\x02\x01\x01\x12\x04\x92\
    \x05\"/\n\r\n\x05\x04@\x02\x01\x03\x12\x04\x92\x0523\n\x0c\n\x04\x04@\
    \x02\x02\x12\x04\x93\x05\x08T\n\r\n\x05\x04@\x02\x02\x04\x12\x04\x93\x05\
    \x08\x10\n\r\n\x05\x04@\x02\x02\x06\x12\x04\x93\x05\x11\x1f\n\r\n\x05\
    \x04@\x02\x02\x01\x12\x04\x93\x05\x20+\n\r\n\x05\x04@\x02\x02\x03\x12\
    \x04\x93\x05./\n\r\n\x05\x04@\x02\x02\x08\x12\x04\x93\x050S\n\r\n\x05\
    \x04@\x02\x02\x07\x12\x04\x93\x05;R\n\x0c\n\x02\x04A\x12\x06\x96\x05\0\
    \x97\x05\x01\n\x0b\n\x03\x04A\x01\x12\x04\x96\x05\x08&\n\x0c\n\x02\x04B\
    \x12\x06\x99\x05\0\x9c\x05\x01\n\x0b\n\x03\x04B\x01\x12\x04\x99\x05\x08\
    \x20\n\x0c\n\x04\x04B\x02\0\x12\x04\x9a\x05\x08&\n\r\n\x05\x04B\x02\0\
    \x04\x12\x04\x9a\x05\x08\x10\n\r\n\x05\x04B\x02\0\x05\x12\x04\x9a\x05\
    \x11\x18\n\r\n\x05\x04B\x02\0\x01\x12\x04\x9a\x05\x19!\n\r\n\x05\x04B\
    \x02\0\x03\x12\x04\x9a\x05$%\n\x0c\n\x04\x04B\x02\x01\x12\x04\x9b\x05\
    \x08,\n\r\n\x05\x04B\x02\x01\x04\x12\x04\x9b\x05\x08\x10\n\r\n\x05\x04B\
    \x02\x01\x05\x12\x04\x9b\x05\x11\x18\n\r\n\x05\x04B\x02\x01\x01\x12\x04\
    \x9b\x05\x19'\n\r\n\x05\x04B\x02\x01\x03\x12\x04\x9b\x05*+\n\x0c\n\x02\
    \x04C\x12\x06\x9e\x05\0\x9f\x05\x01\n\x0b\n\x03\x04C\x01\x12\x04\x9e\x05\
    \x08(\n\x0c\n\x02\x04D\x12\x06\xa1\x05\0\xa4\x05\x01\n\x0b\n\x03\x04D\
    \x01\x12\x04\xa1\x05\x08\x20\n\x0c\n\x04\x04D\x02\0\x12\x04\xa2\x05\x08&\
    \n\r\n\x05\x04D\x02\0\x04\x12\x04\xa2\x05\x08\x10\n\r\n\x05\x04D\x02\0\
    \x05\x12\x04\xa2\x05\x11\x18\n\r\n\x05\x04D\x02\0\x01\x12\x04\xa2\x05\
    \x19!\n\r\n\x05\x04D\x02\0\x03\x12\x04\xa2\x05$%\n\x0c\n\x04\x04D\x02\
    \x01\x12\x04\xa3\x05\x08T\n\r\n\x05\x04D\x02\x01\x04\x12\x04\xa3\x05\x08\
    \x10\n\r\n\x05\x04D\x02\x01\x06\x12\x04\xa3\x05\x11\x1f\n\r\n\x05\x04D\
    \x02\x01\x01\x12\x04\xa3\x05\x20+\n\r\n\x05\x04D\x02\x01\x03\x12\x04\xa3\
    \x05./\n\r\n\x05\x04D\x02\x01\x08\x12\x04\xa3\x050S\n\r\n\x05\x04D\x02\
    \x01\x07\x12\x04\xa3\x05;R\n\x0c\n\x02\x04E\x12\x06\xa6\x05\0\xa7\x05\
    \x01\n\x0b\n\x03\x04E\x01\x12\x04\xa6\x05\x08(\n\x0c\n\x02\x04F\x12\x06\
    \xa9\x05\0\xab\x05\x01\n\x0b\n\x03\x04F\x01\x12\x04\xa9\x05\x08'\n\x0c\n\
    \x04\x04F\x02\0\x12\x04\xaa\x05\x08&\n\r\n\x05\x04F\x02\0\x04\x12\x04\
    \xaa\x05\x08\x10\n\r\n\x05\x04F\x02\0\x05\x12\x04\xaa\x05\x11\x18\n\r\n\
    \x05\x04F\x02\0\x01\x12\x04\xaa\x05\x19!\n\r\n\x05\x04F\x02\0\x03\x12\
    \x04\xaa\x05$%\n\x0c\n\x02\x04G\x12\x06\xad\x05\0\xae\x05\x01\n\x0b\n\
    \x03\x04G\x01\x12\x04\xad\x05\x08/\n\x0c\n\x02\x04H\x12\x06\xb0\x05\0\
    \xb4\x05\x01\n\x0b\n\x03\x04H\x01\x12\x04\xb0\x05\x08\x1d\n\x0c\n\x04\
    \x04H\x02\0\x12\x04\xb1\x05\x08&\n\r\n\x05\x04H\x02\0\x04\x12\x04\xb1\
    \x05\x08\x10\n\r\n\x05\x04H\x02\0\x05\x12\x04\xb1\x05\x11\x18\n\r\n\x05\
    \x04H\x02\0\x01\x12\x04\xb1\x05\x19!\n\r\n\x05\x04H\x02\0\x03\x12\x04\
    \xb1\x05$%\n\x0c\n\x04\x04H\x02\x01\x12\x04\xb2\x05\x08'\n\r\n\x05\x04H\
    \x02\x01\x04\x12\x04\xb2\x05\x08\x10\n\r\n\x05\x04H\x02\x01\x05\x12\x04\
    \xb2\x05\x11\x18\n\r\n\x05\x04H\x02\x01\x01\x12\x04\xb2\x05\x19\"\n\r\n\
    \x05\x04H\x02\x01\x03\x12\x04\xb2\x05%&\n\x0c\n\x04\x04H\x02\x02\x12\x04\
    \xb3\x05\x084\n\r\n\x05\x04H\x02\x02\x04\x12\x04\xb3\x05\x08\x10\n\r\n\
    \x05\x04H\x02\x02\x05\x12\x04\xb3\x05\x11\x15\n\r\n\x05\x04H\x02\x02\x01\
    \x12\x04\xb3\x05\x16/\n\r\n\x05\x04H\x02\x02\x03\x12\x04\xb3\x0523\n\x0c\
    \n\x02\x04I\x12\x06\xb6\x05\0\xbb\x05\x01\n\x0b\n\x03\x04I\x01\x12\x04\
    \xb6\x05\x08\"\n\x0c\n\x04\x04I\x02\0\x12\x04\xb7\x05\x08.\n\r\n\x05\x04\
    I\x02\0\x04\x12\x04\xb7\x05\x08\x10\n\r\n\x05\x04I\x02\0\x05\x12\x04\xb7\
    \x05\x11\x18\n\r\n\x05\x04I\x02\0\x01\x12\x04\xb7\x05\x19)\n\r\n\x05\x04\
    I\x02\0\x03\x12\x04\xb7\x05,-\n\x0c\n\x04\x04I\x02\x01\x12\x04\xb8\x05\
    \x08,\n\r\n\x05\x04I\x02\x01\x04\x12\x04\xb8\x05\x08\x10\n\r\n\x05\x04I\
    \x02\x01\x05\x12\x04\xb8\x05\x11\x18\n\r\n\x05\x04I\x02\x01\x01\x12\x04\
    \xb8\x05\x19'\n\r\n\x05\x04I\x02\x01\x03\x12\x04\xb8\x05*+\n\x0c\n\x04\
    \x04I\x02\x02\x12\x04\xb9\x05\x08+\n\r\n\x05\x04I\x02\x02\x04\x12\x04\
    \xb9\x05\x08\x10\n\r\n\x05\x04I\x02\x02\x05\x12\x04\xb9\x05\x11\x18\n\r\
    \n\x05\x04I\x02\x02\x01\x12\x04\xb9\x05\x19&\n\r\n\x05\x04I\x02\x02\x03\
    \x12\x04\xb9\x05)*\n\x0c\n\x04\x04I\x02\x03\x12\x04\xba\x05\x08+\n\r\n\
    \x05\x04I\x02\x03\x04\x12\x04\xba\x05\x08\x10\n\r\n\x05\x04I\x02\x03\x05\
    \x12\x04\xba\x05\x11\x15\n\r\n\x05\x04I\x02\x03\x01\x12\x04\xba\x05\x16&\
    \n\r\n\x05\x04I\x02\x03\x03\x12\x04\xba\x05)*\n\x0c\n\x02\x04J\x12\x06\
    \xbd\x05\0\xc0\x05\x01\n\x0b\n\x03\x04J\x01\x12\x04\xbd\x05\x08#\n\x0c\n\
    \x04\x04J\x02\0\x12\x04\xbe\x05\x08&\n\r\n\x05\x04J\x02\0\x04\x12\x04\
    \xbe\x05\x08\x10\n\r\n\x05\x04J\x02\0\x05\x12\x04\xbe\x05\x11\x18\n\r\n\
    \x05\x04J\x02\0\x01\x12\x04\xbe\x05\x19!\n\r\n\x05\x04J\x02\0\x03\x12\
    \x04\xbe\x05$%\n\x0c\n\x04\x04J\x02\x01\x12\x04\xbf\x05\x08/\n\r\n\x05\
    \x04J\x02\x01\x04\x12\x04\xbf\x05\x08\x10\n\r\n\x05\x04J\x02\x01\x05\x12\
    \x04\xbf\x05\x11\x18\n\r\n\x05\x04J\x02\x01\x01\x12\x04\xbf\x05\x19*\n\r\
    \n\x05\x04J\x02\x01\x03\x12\x04\xbf\x05-.\n\x0c\n\x02\x04K\x12\x06\xc2\
    \x05\0\xc3\x05\x01\n\x0b\n\x03\x04K\x01\x12\x04\xc2\x05\x08+\n\x0c\n\x02\
    \x04L\x12\x06\xc5\x05\0\xc7\x05\x01\n\x0b\n\x03\x04L\x01\x12\x04\xc5\x05\
    \x08'\n\x0c\n\x04\x04L\x02\0\x12\x04\xc6\x05\x08,\n\r\n\x05\x04L\x02\0\
    \x04\x12\x04\xc6\x05\x08\x10\n\r\n\x05\x04L\x02\0\x05\x12\x04\xc6\x05\
    \x11\x18\n\r\n\x05\x04L\x02\0\x01\x12\x04\xc6\x05\x19'\n\r\n\x05\x04L\
    \x02\0\x03\x12\x04\xc6\x05*+\n\x0c\n\x02\x04M\x12\x06\xc9\x05\0\xca\x05\
    \x01\n\x0b\n\x03\x04M\x01\x12\x04\xc9\x05\x08/\n\x0c\n\x02\x04N\x12\x06\
    \xcc\x05\0\xcf\x05\x01\n\x0b\n\x03\x04N\x01\x12\x04\xcc\x05\x08\x20\n\
    \x0c\n\x04\x04N\x02\0\x12\x04\xcd\x05\x08&\n\r\n\x05\x04N\x02\0\x04\x12\
    \x04\xcd\x05\x08\x10\n\r\n\x05\x04N\x02\0\x05\x12\x04\xcd\x05\x11\x18\n\
    \r\n\x05\x04N\x02\0\x01\x12\x04\xcd\x05\x19!\n\r\n\x05\x04N\x02\0\x03\
    \x12\x04\xcd\x05$%\n\x0c\n\x04\x04N\x02\x01\x12\x04\xce\x05\x08+\n\r\n\
    \x05\x04N\x02\x01\x04\x12\x04\xce\x05\x08\x10\n\r\n\x05\x04N\x02\x01\x05\
    \x12\x04\xce\x05\x11\x18\n\r\n\x05\x04N\x02\x01\x01\x12\x04\xce\x05\x19&\
    \n\r\n\x05\x04N\x02\x01\x03\x12\x04\xce\x05)*\n\x0c\n\x02\x04O\x12\x06\
    \xd1\x05\0\xd4\x05\x01\n\x0b\n\x03\x04O\x01\x12\x04\xd1\x05\x08\x1b\n\
    \x0c\n\x04\x04O\x02\0\x12\x04\xd2\x05\x08&\n\r\n\x05\x04O\x02\0\x04\x12\
    \x04\xd2\x05\x08\x10\n\r\n\x05\x04O\x02\0\x05\x12\x04\xd2\x05\x11\x18\n\
    \r\n\x05\x04O\x02\0\x01\x12\x04\xd2\x05\x19!\n\r\n\x05\x04O\x02\0\x03\
    \x12\x04\xd2\x05$%\n\x0c\n\x04\x04O\x02\x01\x12\x04\xd3\x05\x08'\n\r\n\
    \x05\x04O\x02\x01\x04\x12\x04\xd3\x05\x08\x10\n\r\n\x05\x04O\x02\x01\x05\
    \x12\x04\xd3\x05\x11\x18\n\r\n\x05\x04O\x02\x01\x01\x12\x04\xd3\x05\x19\
    \"\n\r\n\x05\x04O\x02\x01\x03\x12\x04\xd3\x05%&\n\x0c\n\x02\x04P\x12\x06\
    \xd6\x05\0\xd9\x05\x01\n\x0b\n\x03\x04P\x01\x12\x04\xd6\x05\x08\x19\n\
    \x0c\n\x04\x04P\x02\0\x12\x04\xd7\x05\x08&\n\r\n\x05\x04P\x02\0\x04\x12\
    \x04\xd7\x05\x08\x10\n\r\n\x05\x04P\x02\0\x05\x12\x04\xd7\x05\x11\x18\n\
    \r\n\x05\x04P\x02\0\x01\x12\x04\xd7\x05\x19!\n\r\n\x05\x04P\x02\0\x03\
    \x12\x04\xd7\x05$%\n\x0c\n\x04\x04P\x02\x01\x12\x04\xd8\x05\x08\x20\n\r\
    \n\x05\x04P\x02\x01\x04\x12\x04\xd8\x05\x08\x10\n\r\n\x05\x04P\x02\x01\
    \x05\x12\x04\xd8\x05\x11\x17\n\r\n\x05\x04P\x02\x01\x01\x12\x04\xd8\x05\
    \x18\x1b\n\r\n\x05\x04P\x02\x01\x03\x12\x04\xd8\x05\x1e\x1f\n\x0c\n\x02\
    \x04Q\x12\x06\xdb\x05\0\xdf\x05\x01\n\x0b\n\x03\x04Q\x01\x12\x04\xdb\x05\
    \x08\x18\n\x0c\n\x04\x04Q\x02\0\x12\x04\xdc\x05\x08S\n\r\n\x05\x04Q\x02\
    \0\x04\x12\x04\xdc\x05\x08\x10\n\r\n\x05\x04Q\x02\0\x06\x12\x04\xdc\x05\
    \x11\"\n\r\n\x05\x04Q\x02\0\x01\x12\x04\xdc\x05#'\n\r\n\x05\x04Q\x02\0\
    \x03\x12\x04\xdc\x05*+\n\r\n\x05\x04Q\x02\0\x08\x12\x04\xdc\x05,R\n\r\n\
    \x05\x04Q\x02\0\x07\x12\x04\xdc\x057Q\n\x0c\n\x04\x04Q\x02\x01\x12\x04\
    \xdd\x05\x08&\n\r\n\x05\x04Q\x02\x01\x04\x12\x04\xdd\x05\x08\x10\n\r\n\
    \x05\x04Q\x02\x01\x05\x12\x04\xdd\x05\x11\x18\n\r\n\x05\x04Q\x02\x01\x01\
    \x12\x04\xdd\x05\x19!\n\r\n\x05\x04Q\x02\x01\x03\x12\x04\xdd\x05$%\n\x0c\
    \n\x04\x04Q\x02\x02\x12\x04\xde\x05\x08\x20\n\r\n\x05\x04Q\x02\x02\x04\
    \x12\x04\xde\x05\x08\x10\n\r\n\x05\x04Q\x02\x02\x05\x12\x04\xde\x05\x11\
    \x17\n\r\n\x05\x04Q\x02\x02\x01\x12\x04\xde\x05\x18\x1b\n\r\n\x05\x04Q\
    \x02\x02\x03\x12\x04\xde\x05\x1e\x1f\n\x0c\n\x02\x04R\x12\x06\xe1\x05\0\
    \xf5\x05\x01\n\x0b\n\x03\x04R\x01\x12\x04\xe1\x05\x08\x12\n\x0e\n\x04\
    \x04R\x03\0\x12\x06\xe2\x05\x08\xe5\x05\t\n\r\n\x05\x04R\x03\0\x01\x12\
    \x04\xe2\x05\x10\x1a\n\x0e\n\x06\x04R\x03\0\x02\0\x12\x04\xe3\x05\x10\\\
    \n\x0f\n\x07\x04R\x03\0\x02\0\x04\x12\x04\xe3\x05\x10\x18\n\x0f\n\x07\
    \x04R\x03\0\x02\0\x06\x12\x04\xe3\x05\x19'\n\x0f\n\x07\x04R\x03\0\x02\0\
    \x01\x12\x04\xe3\x05(3\n\x0f\n\x07\x04R\x03\0\x02\0\x03\x12\x04\xe3\x056\
    7\n\x0f\n\x07\x04R\x03\0\x02\0\x08\x12\x04\xe3\x058[\n\x0f\n\x07\x04R\
    \x03\0\x02\0\x07\x12\x04\xe3\x05CZ\n\x0e\n\x06\x04R\x03\0\x02\x01\x12\
    \x04\xe4\x05\x101\n\x0f\n\x07\x04R\x03\0\x02\x01\x04\x12\x04\xe4\x05\x10\
    \x18\n\x0f\n\x07\x04R\x03\0\x02\x01\x05\x12\x04\xe4\x05\x19\x20\n\x0f\n\
    \x07\x04R\x03\0\x02\x01\x01\x12\x04\xe4\x05!,\n\x0f\n\x07\x04R\x03\0\x02\
    \x01\x03\x12\x04\xe4\x05/0\n\x0c\n\x04\x04R\x02\0\x12\x04\xe7\x05\x08:\n\
    \r\n\x05\x04R\x02\0\x04\x12\x04\xe7\x05\x08\x10\n\r\n\x05\x04R\x02\0\x05\
    \x12\x04\xe7\x05\x11\x17\n\r\n\x05\x04R\x02\0\x01\x12\x04\xe7\x05\x18\
    \x20\n\r\n\x05\x04R\x02\0\x03\x12\x04\xe7\x05#$\n\r\n\x05\x04R\x02\0\x08\
    \x12\x04\xe7\x05%9\n\x10\n\x08\x04R\x02\0\x08\xe0\xd4\x03\x12\x04\xe7\
    \x05&8\n\x0c\n\x04\x04R\x02\x01\x12\x04\xe8\x05\x08'\n\r\n\x05\x04R\x02\
    \x01\x04\x12\x04\xe8\x05\x08\x10\n\r\n\x05\x04R\x02\x01\x05\x12\x04\xe8\
    \x05\x11\x18\n\r\n\x05\x04R\x02\x01\x01\x12\x04\xe8\x05\x19\"\n\r\n\x05\
    \x04R\x02\x01\x03\x12\x04\xe8\x05%&\n\x0c\n\x04\x04R\x02\x02\x12\x04\xe9\
    \x05\x08(\n\r\n\x05\x04R\x02\x02\x04\x12\x04\xe9\x05\x08\x10\n\r\n\x05\
    \x04R\x02\x02\x05\x12\x04\xe9\x05\x11\x18\n\r\n\x05\x04R\x02\x02\x01\x12\
    \x04\xe9\x05\x19#\n\r\n\x05\x04R\x02\x02\x03\x12\x04\xe9\x05&'\n\x0c\n\
    \x04\x04R\x02\x03\x12\x04\xea\x05\x080\n\r\n\x05\x04R\x02\x03\x04\x12\
    \x04\xea\x05\x08\x10\n\r\n\x05\x04R\x02\x03\x06\x12\x04\xea\x05\x11\"\n\
    \r\n\x05\x04R\x02\x03\x01\x12\x04\xea\x05#*\n\r\n\x05\x04R\x02\x03\x03\
    \x12\x04\xea\x05-/\n\x0c\n\x04\x04R\x02\x04\x12\x04\xeb\x05\x081\n\r\n\
    \x05\x04R\x02\x04\x04\x12\x04\xeb\x05\x08\x10\n\r\n\x05\x04R\x02\x04\x05\
    \x12\x04\xeb\x05\x11\x17\n\r\n\x05\x04R\x02\x04\x01\x12\x04\xeb\x05\x18+\
    \n\r\n\x05\x04R\x02\x04\x03\x12\x04\xeb\x05.0\n\x0c\n\x04\x04R\x02\x05\
    \x12\x04\xec\x05\x08f\n\r\n\x05\x04R\x02\x05\x04\x12\x04\xec\x05\x08\x10\
    \n\r\n\x05\x04R\x02\x05\x06\x12\x04\xec\x05\x11\x1f\n\r\n\x05\x04R\x02\
    \x05\x01\x12\x04\xec\x05\x20<\n\r\n\x05\x04R\x02\x05\x03\x12\x04\xec\x05\
    ?A\n\r\n\x05\x04R\x02\x05\x08\x12\x04\xec\x05Be\n\r\n\x05\x04R\x02\x05\
    \x07\x12\x04\xec\x05Md\n\x0c\n\x04\x04R\x02\x06\x12\x04\xed\x05\x08@\n\r\
    \n\x05\x04R\x02\x06\x04\x12\x04\xed\x05\x08\x10\n\r\n\x05\x04R\x02\x06\
    \x06\x12\x04\xed\x05\x11'\n\r\n\x05\x04R\x02\x06\x01\x12\x04\xed\x05(:\n\
    \r\n\x05\x04R\x02\x06\x03\x12\x04\xed\x05=?\n\x0c\n\x04\x04R\x02\x07\x12\
    \x04\xee\x05\x08A\n\r\n\x05\x04R\x02\x07\x04\x12\x04\xee\x05\x08\x10\n\r\
    \n\x05\x04R\x02\x07\x06\x12\x04\xee\x05\x11,\n\r\n\x05\x04R\x02\x07\x01\
    \x12\x04\xee\x05-;\n\r\n\x05\x04R\x02\x07\x03\x12\x04\xee\x05>@\n\x0c\n\
    \x04\x04R\x02\x08\x12\x04\xef\x05\x080\n\r\n\x05\x04R\x02\x08\x04\x12\
    \x04\xef\x05\x08\x10\n\r\n\x05\x04R\x02\x08\x05\x12\x04\xef\x05\x11\x17\
    \n\r\n\x05\x04R\x02\x08\x01\x12\x04\xef\x05\x18*\n\r\n\x05\x04R\x02\x08\
    \x03\x12\x04\xef\x05-/\n\x0c\n\x04\x04R\x02\t\x12\x04\xf0\x05\x086\n\r\n\
    \x05\x04R\x02\t\x04\x12\x04\xf0\x05\x08\x10\n\r\n\x05\x04R\x02\t\x05\x12\
    \x04\xf0\x05\x11\x17\n\r\n\x05\x04R\x02\t\x01\x12\x04\xf0\x05\x180\n\r\n\
    \x05\x04R\x02\t\x03\x12\x04\xf0\x0535\n\x0c\n\x04\x04R\x02\n\x12\x04\xf1\
    \x05\x080\n\r\n\x05\x04R\x02\n\x04\x12\x04\xf1\x05\x08\x10\n\r\n\x05\x04\
    R\x02\n\x05\x12\x04\xf1\x05\x11\x17\n\r\n\x05\x04R\x02\n\x01\x12\x04\xf1\
    \x05\x18*\n\r\n\x05\x04R\x02\n\x03\x12\x04\xf1\x05-/\n\x0c\n\x04\x04R\
    \x02\x0b\x12\x04\xf2\x05\x086\n\r\n\x05\x04R\x02\x0b\x04\x12\x04\xf2\x05\
    \x08\x10\n\r\n\x05\x04R\x02\x0b\x05\x12\x04\xf2\x05\x11\x17\n\r\n\x05\
    \x04R\x02\x0b\x01\x12\x04\xf2\x05\x180\n\r\n\x05\x04R\x02\x0b\x03\x12\
    \x04\xf2\x0535\n\x0c\n\x04\x04R\x02\x0c\x12\x04\xf3\x05\x089\n\r\n\x05\
    \x04R\x02\x0c\x04\x12\x04\xf3\x05\x08\x10\n\r\n\x05\x04R\x02\x0c\x06\x12\
    \x04\xf3\x05\x11#\n\r\n\x05\x04R\x02\x0c\x01\x12\x04\xf3\x05$3\n\r\n\x05\
    \x04R\x02\x0c\x03\x12\x04\xf3\x0568\n\x0c\n\x04\x04R\x02\r\x12\x04\xf4\
    \x05\x08<\n\r\n\x05\x04R\x02\r\x04\x12\x04\xf4\x05\x08\x10\n\r\n\x05\x04\
    R\x02\r\x06\x12\x04\xf4\x05\x11&\n\r\n\x05\x04R\x02\r\x01\x12\x04\xf4\
    \x05'6\n\r\n\x05\x04R\x02\r\x03\x12\x04\xf4\x059;\n\x0c\n\x02\x04S\x12\
    \x06\xf7\x05\0\x85\x06\x01\n\x0b\n\x03\x04S\x01\x12\x04\xf7\x05\x08\x18\
    \n\x0e\n\x04\x04S\x03\0\x12\x06\xf8\x05\x08\xfa\x05\t\n\r\n\x05\x04S\x03\
    \0\x01\x12\x04\xf8\x05\x10\x1b\n\x0e\n\x06\x04S\x03\0\x02\0\x12\x04\xf9\
    \x05\x10-\n\x0f\n\x07\x04S\x03\0\x02\0\x04\x12\x04\xf9\x05\x10\x18\n\x0f\
    \n\x07\x04S\x03\0\x02\0\x05\x12\x04\xf9\x05\x19\x20\n\x0f\n\x07\x04S\x03\
    \0\x02\0\x01\x12\x04\xf9\x05!(\n\x0f\n\x07\x04S\x03\0\x02\0\x03\x12\x04\
    \xf9\x05+,\n\x0e\n\x04\x04S\x04\0\x12\x06\xfc\x05\x08\xff\x05\t\n\r\n\
    \x05\x04S\x04\0\x01\x12\x04\xfc\x05\r\x11\n\x0e\n\x06\x04S\x04\0\x02\0\
    \x12\x04\xfd\x05\x10#\n\x0f\n\x07\x04S\x04\0\x02\0\x01\x12\x04\xfd\x05\
    \x10\x1e\n\x0f\n\x07\x04S\x04\0\x02\0\x02\x12\x04\xfd\x05!\"\n\x0e\n\x06\
    \x04S\x04\0\x02\x01\x12\x04\xfe\x05\x10)\n\x0f\n\x07\x04S\x04\0\x02\x01\
    \x01\x12\x04\xfe\x05\x10$\n\x0f\n\x07\x04S\x04\0\x02\x01\x02\x12\x04\xfe\
    \x05'(\n\x0c\n\x04\x04S\x02\0\x12\x04\x81\x06\x08:\n\r\n\x05\x04S\x02\0\
    \x04\x12\x04\x81\x06\x08\x10\n\r\n\x05\x04S\x02\0\x05\x12\x04\x81\x06\
    \x11\x17\n\r\n\x05\x04S\x02\0\x01\x12\x04\x81\x06\x18\x20\n\r\n\x05\x04S\
    \x02\0\x03\x12\x04\x81\x06#$\n\r\n\x05\x04S\x02\0\x08\x12\x04\x81\x06%9\
    \n\x10\n\x08\x04S\x02\0\x08\xe0\xd4\x03\x12\x04\x81\x06&8\n\x0c\n\x04\
    \x04S\x02\x01\x12\x04\x82\x06\x08%\n\r\n\x05\x04S\x02\x01\x04\x12\x04\
    \x82\x06\x08\x10\n\r\n\x05\x04S\x02\x01\x05\x12\x04\x82\x06\x11\x18\n\r\
    \n\x05\x04S\x02\x01\x01\x12\x04\x82\x06\x19\x20\n\r\n\x05\x04S\x02\x01\
    \x03\x12\x04\x82\x06#$\n\x0c\n\x04\x04S\x02\x02\x12\x04\x83\x06\x08;\n\r\
    \n\x05\x04S\x02\x02\x04\x12\x04\x83\x06\x08\x10\n\r\n\x05\x04S\x02\x02\
    \x06\x12\x04\x83\x06\x11.\n\r\n\x05\x04S\x02\x02\x01\x12\x04\x83\x06/6\n\
    \r\n\x05\x04S\x02\x02\x03\x12\x04\x83\x069:\n\x0c\n\x04\x04S\x02\x03\x12\
    \x04\x84\x06\x08L\n\r\n\x05\x04S\x02\x03\x04\x12\x04\x84\x06\x08\x10\n\r\
    \n\x05\x04S\x02\x03\x06\x12\x04\x84\x06\x11'\n\r\n\x05\x04S\x02\x03\x01\
    \x12\x04\x84\x06(,\n\r\n\x05\x04S\x02\x03\x03\x12\x04\x84\x06/0\n\r\n\
    \x05\x04S\x02\x03\x08\x12\x04\x84\x061K\n\r\n\x05\x04S\x02\x03\x07\x12\
    \x04\x84\x06<J\n\x0c\n\x02\x04T\x12\x06\x87\x06\0\xa4\x06\x01\n\x0b\n\
    \x03\x04T\x01\x12\x04\x87\x06\x08\x1b\n\x0e\n\x04\x04T\x04\0\x12\x06\x88\
    \x06\x08\x8e\x06\t\n\r\n\x05\x04T\x04\0\x01\x12\x04\x88\x06\r\x19\n\x0e\
    \n\x06\x04T\x04\0\x02\0\x12\x04\x89\x06\x10\x1c\n\x0f\n\x07\x04T\x04\0\
    \x02\0\x01\x12\x04\x89\x06\x10\x17\n\x0f\n\x07\x04T\x04\0\x02\0\x02\x12\
    \x04\x89\x06\x1a\x1b\n\x0e\n\x06\x04T\x04\0\x02\x01\x12\x04\x8a\x06\x10(\
    \n\x0f\n\x07\x04T\x04\0\x02\x01\x01\x12\x04\x8a\x06\x10#\n\x0f\n\x07\x04\
    T\x04\0\x02\x01\x02\x12\x04\x8a\x06&'\n\x0e\n\x06\x04T\x04\0\x02\x02\x12\
    \x04\x8b\x06\x10\x1d\n\x0f\n\x07\x04T\x04\0\x02\x02\x01\x12\x04\x8b\x06\
    \x10\x18\n\x0f\n\x07\x04T\x04\0\x02\x02\x02\x12\x04\x8b\x06\x1b\x1c\n\
    \x0e\n\x06\x04T\x04\0\x02\x03\x12\x04\x8c\x06\x10\x1e\n\x0f\n\x07\x04T\
    \x04\0\x02\x03\x01\x12\x04\x8c\x06\x10\x19\n\x0f\n\x07\x04T\x04\0\x02\
    \x03\x02\x12\x04\x8c\x06\x1c\x1d\n\x0e\n\x06\x04T\x04\0\x02\x04\x12\x04\
    \x8d\x06\x10!\n\x0f\n\x07\x04T\x04\0\x02\x04\x01\x12\x04\x8d\x06\x10\x1c\
    \n\x0f\n\x07\x04T\x04\0\x02\x04\x02\x12\x04\x8d\x06\x1f\x20\n\x0e\n\x04\
    \x04T\x04\x01\x12\x06\x90\x06\x08\x95\x06\t\n\r\n\x05\x04T\x04\x01\x01\
    \x12\x04\x90\x06\r\x11\n\x0e\n\x06\x04T\x04\x01\x02\0\x12\x04\x91\x06\
    \x10#\n\x0f\n\x07\x04T\x04\x01\x02\0\x01\x12\x04\x91\x06\x10\x1e\n\x0f\n\
    \x07\x04T\x04\x01\x02\0\x02\x12\x04\x91\x06!\"\n\x0e\n\x06\x04T\x04\x01\
    \x02\x01\x12\x04\x92\x06\x10!\n\x0f\n\x07\x04T\x04\x01\x02\x01\x01\x12\
    \x04\x92\x06\x10\x1c\n\x0f\n\x07\x04T\x04\x01\x02\x01\x02\x12\x04\x92\
    \x06\x1f\x20\n\x0e\n\x06\x04T\x04\x01\x02\x02\x12\x04\x93\x06\x10#\n\x0f\
    \n\x07\x04T\x04\x01\x02\x02\x01\x12\x04\x93\x06\x10\x1e\n\x0f\n\x07\x04T\
    \x04\x01\x02\x02\x02\x12\x04\x93\x06!\"\n\x0e\n\x06\x04T\x04\x01\x02\x03\
    \x12\x04\x94\x06\x10%\n\x0f\n\x07\x04T\x04\x01\x02\x03\x01\x12\x04\x94\
    \x06\x10\x20\n\x0f\n\x07\x04T\x04\x01\x02\x03\x02\x12\x04\x94\x06#$\n\
    \x0c\n\x04\x04T\x02\0\x12\x04\x97\x06\x085\n\r\n\x05\x04T\x02\0\x04\x12\
    \x04\x97\x06\x08\x10\n\r\n\x05\x04T\x02\0\x05\x12\x04\x97\x06\x11\x18\n\
    \r\n\x05\x04T\x02\0\x01\x12\x04\x97\x06\x19\x1b\n\r\n\x05\x04T\x02\0\x03\
    \x12\x04\x97\x06\x1e\x1f\n\r\n\x05\x04T\x02\0\x08\x12\x04\x97\x06\x204\n\
    \x10\n\x08\x04T\x02\0\x08\xe0\xd4\x03\x12\x04\x97\x06!3\n\x0c\n\x04\x04T\
    \x02\x01\x12\x04\x98\x06\x08G\n\r\n\x05\x04T\x02\x01\x04\x12\x04\x98\x06\
    \x08\x10\n\r\n\x05\x04T\x02\x01\x06\x12\x04\x98\x06\x11\x1c\n\r\n\x05\
    \x04T\x02\x01\x01\x12\x04\x98\x06\x1d!\n\r\n\x05\x04T\x02\x01\x03\x12\
    \x04\x98\x06$%\n\r\n\x05\x04T\x02\x01\x08\x12\x04\x98\x06&F\n\r\n\x05\
    \x04T\x02\x01\x07\x12\x04\x98\x061E\n\x0c\n\x04\x04T\x02\x02\x12\x04\x99\
    \x06\x08Z\n\r\n\x05\x04T\x02\x02\x04\x12\x04\x99\x06\x08\x10\n\r\n\x05\
    \x04T\x02\x02\x06\x12\x04\x99\x06\x112\n\r\n\x05\x04T\x02\x02\x01\x12\
    \x04\x99\x063@\n\r\n\x05\x04T\x02\x02\x03\x12\x04\x99\x06CE\n\r\n\x05\
    \x04T\x02\x02\x08\x12\x04\x99\x06FY\n\r\n\x05\x04T\x02\x02\x07\x12\x04\
    \x99\x06QX\n\x0c\n\x04\x04T\x02\x03\x12\x04\x9a\x06\x08!\n\r\n\x05\x04T\
    \x02\x03\x04\x12\x04\x9a\x06\x08\x10\n\r\n\x05\x04T\x02\x03\x05\x12\x04\
    \x9a\x06\x11\x17\n\r\n\x05\x04T\x02\x03\x01\x12\x04\x9a\x06\x18\x1c\n\r\
    \n\x05\x04T\x02\x03\x03\x12\x04\x9a\x06\x1f\x20\n\x0c\n\x04\x04T\x02\x04\
    \x12\x04\x9b\x06\x08/\n\r\n\x05\x04T\x02\x04\x04\x12\x04\x9b\x06\x08\x10\
    \n\r\n\x05\x04T\x02\x04\x05\x12\x04\x9b\x06\x11\x17\n\r\n\x05\x04T\x02\
    \x04\x01\x12\x04\x9b\x06\x18)\n\r\n\x05\x04T\x02\x04\x03\x12\x04\x9b\x06\
    ,.\n\x0c\n\x04\x04T\x02\x05\x12\x04\x9c\x06\x08)\n\r\n\x05\x04T\x02\x05\
    \x04\x12\x04\x9c\x06\x08\x10\n\r\n\x05\x04T\x02\x05\x05\x12\x04\x9c\x06\
    \x11\x15\n\r\n\x05\x04T\x02\x05\x01\x12\x04\x9c\x06\x16#\n\r\n\x05\x04T\
    \x02\x05\x03\x12\x04\x9c\x06&(\n\x0c\n\x04\x04T\x02\x06\x12\x04\x9d\x06\
    \x08)\n\r\n\x05\x04T\x02\x06\x04\x12\x04\x9d\x06\x08\x10\n\r\n\x05\x04T\
    \x02\x06\x05\x12\x04\x9d\x06\x11\x17\n\r\n\x05\x04T\x02\x06\x01\x12\x04\
    \x9d\x06\x18#\n\r\n\x05\x04T\x02\x06\x03\x12\x04\x9d\x06&(\n\x0c\n\x04\
    \x04T\x02\x07\x12\x04\x9e\x06\x08/\n\r\n\x05\x04T\x02\x07\x04\x12\x04\
    \x9e\x06\x08\x10\n\r\n\x05\x04T\x02\x07\x05\x12\x04\x9e\x06\x11\x17\n\r\
    \n\x05\x04T\x02\x07\x01\x12\x04\x9e\x06\x18)\n\r\n\x05\x04T\x02\x07\x03\
    \x12\x04\x9e\x06,.\n\x0c\n\x04\x04T\x02\x08\x12\x04\x9f\x06\x08P\n\r\n\
    \x05\x04T\x02\x08\x04\x12\x04\x9f\x06\x08\x10\n\r\n\x05\x04T\x02\x08\x06\
    \x12\x04\x9f\x06\x11*\n\r\n\x05\x04T\x02\x08\x01\x12\x04\x9f\x06+/\n\r\n\
    \x05\x04T\x02\x08\x03\x12\x04\x9f\x0624\n\r\n\x05\x04T\x02\x08\x08\x12\
    \x04\x9f\x065O\n\r\n\x05\x04T\x02\x08\x07\x12\x04\x9f\x06@N\n\x0c\n\x04\
    \x04T\x02\t\x12\x04\xa0\x06\x08/\n\r\n\x05\x04T\x02\t\x04\x12\x04\xa0\
    \x06\x08\x10\n\r\n\x05\x04T\x02\t\x05\x12\x04\xa0\x06\x11\x17\n\r\n\x05\
    \x04T\x02\t\x01\x12\x04\xa0\x06\x18)\n\r\n\x05\x04T\x02\t\x03\x12\x04\
    \xa0\x06,.\n\x0c\n\x04\x04T\x02\n\x12\x04\xa1\x06\x084\n\r\n\x05\x04T\
    \x02\n\x04\x12\x04\xa1\x06\x08\x10\n\r\n\x05\x04T\x02\n\x05\x12\x04\xa1\
    \x06\x11\x17\n\r\n\x05\x04T\x02\n\x01\x12\x04\xa1\x06\x18.\n\r\n\x05\x04\
    T\x02\n\x03\x12\x04\xa1\x0613\n\x0c\n\x04\x04T\x02\x0b\x12\x04\xa2\x06\
    \x08\"\n\r\n\x05\x04T\x02\x0b\x04\x12\x04\xa2\x06\x08\x10\n\r\n\x05\x04T\
    \x02\x0b\x05\x12\x04\xa2\x06\x11\x17\n\r\n\x05\x04T\x02\x0b\x01\x12\x04\
    \xa2\x06\x18\x1c\n\r\n\x05\x04T\x02\x0b\x03\x12\x04\xa2\x06\x1f!\n\x0c\n\
    \x04\x04T\x02\x0c\x12\x04\xa3\x06\x08+\n\r\n\x05\x04T\x02\x0c\x04\x12\
    \x04\xa3\x06\x08\x10\n\r\n\x05\x04T\x02\x0c\x05\x12\x04\xa3\x06\x11\x15\
    \n\r\n\x05\x04T\x02\x0c\x01\x12\x04\xa3\x06\x16%\n\r\n\x05\x04T\x02\x0c\
    \x03\x12\x04\xa3\x06(*\n\x0c\n\x02\x04U\x12\x06\xa6\x06\0\xa9\x06\x01\n\
    \x0b\n\x03\x04U\x01\x12\x04\xa6\x06\x08\x1b\n\x0c\n\x04\x04U\x02\0\x12\
    \x04\xa7\x06\x08;\n\r\n\x05\x04U\x02\0\x04\x12\x04\xa7\x06\x08\x10\n\r\n\
    \x05\x04U\x02\0\x05\x12\x04\xa7\x06\x11\x18\n\r\n\x05\x04U\x02\0\x01\x12\
    \x04\xa7\x06\x19!\n\r\n\x05\x04U\x02\0\x03\x12\x04\xa7\x06$%\n\r\n\x05\
    \x04U\x02\0\x08\x12\x04\xa7\x06&:\n\x10\n\x08\x04U\x02\0\x08\xe0\xd4\x03\
    \x12\x04\xa7\x06'9\n\x0c\n\x04\x04U\x02\x01\x12\x04\xa8\x06\x08T\n\r\n\
    \x05\x04U\x02\x01\x04\x12\x04\xa8\x06\x08\x10\n\r\n\x05\x04U\x02\x01\x06\
    \x12\x04\xa8\x06\x11\x1f\n\r\n\x05\x04U\x02\x01\x01\x12\x04\xa8\x06\x20+\
    \n\r\n\x05\x04U\x02\x01\x03\x12\x04\xa8\x06./\n\r\n\x05\x04U\x02\x01\x08\
    \x12\x04\xa8\x060S\n\r\n\x05\x04U\x02\x01\x07\x12\x04\xa8\x06;R\n\x0c\n\
    \x02\x04V\x12\x06\xab\x06\0\xcc\x06\x01\n\x0b\n\x03\x04V\x01\x12\x04\xab\
    \x06\x08\x1c\n\x0e\n\x04\x04V\x04\0\x12\x06\xac\x06\x08\xb0\x06\t\n\r\n\
    \x05\x04V\x04\0\x01\x12\x04\xac\x06\r\x12\n\x0e\n\x06\x04V\x04\0\x02\0\
    \x12\x04\xad\x06\x10\x1c\n\x0f\n\x07\x04V\x04\0\x02\0\x01\x12\x04\xad\
    \x06\x10\x17\n\x0f\n\x07\x04V\x04\0\x02\0\x02\x12\x04\xad\x06\x1a\x1b\n\
    \x0e\n\x06\x04V\x04\0\x02\x01\x12\x04\xae\x06\x10\x20\n\x0f\n\x07\x04V\
    \x04\0\x02\x01\x01\x12\x04\xae\x06\x10\x1b\n\x0f\n\x07\x04V\x04\0\x02\
    \x01\x02\x12\x04\xae\x06\x1e\x1f\n\x0e\n\x06\x04V\x04\0\x02\x02\x12\x04\
    \xaf\x06\x10\x18\n\x0f\n\x07\x04V\x04\0\x02\x02\x01\x12\x04\xaf\x06\x10\
    \x13\n\x0f\n\x07\x04V\x04\0\x02\x02\x02\x12\x04\xaf\x06\x16\x17\n\x0e\n\
    \x04\x04V\x04\x01\x12\x06\xb2\x06\x08\xb6\x06\t\n\r\n\x05\x04V\x04\x01\
    \x01\x12\x04\xb2\x06\r\x15\n\x0e\n\x06\x04V\x04\x01\x02\0\x12\x04\xb3\
    \x06\x10\x19\n\x0f\n\x07\x04V\x04\x01\x02\0\x01\x12\x04\xb3\x06\x10\x14\
    \n\x0f\n\x07\x04V\x04\x01\x02\0\x02\x12\x04\xb3\x06\x17\x18\n\x0e\n\x06\
    \x04V\x04\x01\x02\x01\x12\x04\xb4\x06\x10&\n\x0f\n\x07\x04V\x04\x01\x02\
    \x01\x01\x12\x04\xb4\x06\x10!\n\x0f\n\x07\x04V\x04\x01\x02\x01\x02\x12\
    \x04\xb4\x06$%\n\x0e\n\x06\x04V\x04\x01\x02\x02\x12\x04\xb5\x06\x10'\n\
    \x0f\n\x07\x04V\x04\x01\x02\x02\x01\x12\x04\xb5\x06\x10\"\n\x0f\n\x07\
    \x04V\x04\x01\x02\x02\x02\x12\x04\xb5\x06%&\n\x0c\n\x04\x04V\x02\0\x12\
    \x04\xb8\x06\x08:\n\r\n\x05\x04V\x02\0\x04\x12\x04\xb8\x06\x08\x10\n\r\n\
    \x05\x04V\x02\0\x05\x12\x04\xb8\x06\x11\x17\n\r\n\x05\x04V\x02\0\x01\x12\
    \x04\xb8\x06\x18\x20\n\r\n\x05\x04V\x02\0\x03\x12\x04\xb8\x06#$\n\r\n\
    \x05\x04V\x02\0\x08\x12\x04\xb8\x06%9\n\x10\n\x08\x04V\x02\0\x08\xe0\xd4\
    \x03\x12\x04\xb8\x06&8\n\x0c\n\x04\x04V\x02\x01\x12\x04\xb9\x06\x082\n\r\
    \n\x05\x04V\x02\x01\x04\x12\x04\xb9\x06\x08\x10\n\r\n\x05\x04V\x02\x01\
    \x06\x12\x04\xb9\x06\x11%\n\r\n\x05\x04V\x02\x01\x01\x12\x04\xb9\x06&-\n\
    \r\n\x05\x04V\x02\x01\x03\x12\x04\xb9\x0601\n\x0c\n\x04\x04V\x02\x02\x12\
    \x04\xba\x06\x085\n\r\n\x05\x04V\x02\x02\x04\x12\x04\xba\x06\x08\x10\n\r\
    \n\x05\x04V\x02\x02\x05\x12\x04\xba\x06\x11\x18\n\r\n\x05\x04V\x02\x02\
    \x01\x12\x04\xba\x06\x19\"\n\r\n\x05\x04V\x02\x02\x03\x12\x04\xba\x06%&\
    \n\r\n\x05\x04V\x02\x02\x08\x12\x04\xba\x06'4\n\r\n\x05\x04V\x02\x02\x07\
    \x12\x04\xba\x0623\n\x0c\n\x04\x04V\x02\x03\x12\x04\xbb\x06\x08K\n\r\n\
    \x05\x04V\x02\x03\x04\x12\x04\xbb\x06\x08\x10\n\r\n\x05\x04V\x02\x03\x06\
    \x12\x04\xbb\x06\x11,\n\r\n\x05\x04V\x02\x03\x01\x12\x04\xbb\x06-2\n\r\n\
    \x05\x04V\x02\x03\x03\x12\x04\xbb\x0656\n\r\n\x05\x04V\x02\x03\x08\x12\
    \x04\xbb\x067J\n\r\n\x05\x04V\x02\x03\x07\x12\x04\xbb\x06BI\n\x0c\n\x04\
    \x04V\x02\x04\x12\x04\xbc\x06\x08$\n\r\n\x05\x04V\x02\x04\x04\x12\x04\
    \xbc\x06\x08\x10\n\r\n\x05\x04V\x02\x04\x05\x12\x04\xbc\x06\x11\x17\n\r\
    \n\x05\x04V\x02\x04\x01\x12\x04\xbc\x06\x18\x1f\n\r\n\x05\x04V\x02\x04\
    \x03\x12\x04\xbc\x06\"#\n\x0c\n\x04\x04V\x02\x05\x12\x04\xbd\x06\x08Y\n\
    \r\n\x05\x04V\x02\x05\x04\x12\x04\xbd\x06\x08\x10\n\r\n\x05\x04V\x02\x05\
    \x06\x12\x04\xbd\x06\x11!\n\r\n\x05\x04V\x02\x05\x01\x12\x04\xbd\x06\",\
    \n\r\n\x05\x04V\x02\x05\x03\x12\x04\xbd\x06/1\n\r\n\x05\x04V\x02\x05\x08\
    \x12\x04\xbd\x062X\n\r\n\x05\x04V\x02\x05\x07\x12\x04\xbd\x06=W\n\x0c\n\
    \x04\x04V\x02\x06\x12\x04\xbe\x06\x087\n\r\n\x05\x04V\x02\x06\x04\x12\
    \x04\xbe\x06\x08\x10\n\r\n\x05\x04V\x02\x06\x05\x12\x04\xbe\x06\x11\x17\
    \n\r\n\x05\x04V\x02\x06\x01\x12\x04\xbe\x06\x181\n\r\n\x05\x04V\x02\x06\
    \x03\x12\x04\xbe\x0646\n\x0c\n\x04\x04V\x02\x07\x12\x04\xbf\x06\x08.\n\r\
    \n\x05\x04V\x02\x07\x04\x12\x04\xbf\x06\x08\x10\n\r\n\x05\x04V\x02\x07\
    \x05\x12\x04\xbf\x06\x11\x17\n\r\n\x05\x04V\x02\x07\x01\x12\x04\xbf\x06\
    \x18(\n\r\n\x05\x04V\x02\x07\x03\x12\x04\xbf\x06+-\n\x0c\n\x04\x04V\x02\
    \x08\x12\x04\xc0\x06\x08&\n\r\n\x05\x04V\x02\x08\x04\x12\x04\xc0\x06\x08\
    \x10\n\r\n\x05\x04V\x02\x08\x05\x12\x04\xc0\x06\x11\x17\n\r\n\x05\x04V\
    \x02\x08\x01\x12\x04\xc0\x06\x18\x20\n\r\n\x05\x04V\x02\x08\x03\x12\x04\
    \xc0\x06#%\n\x0c\n\x04\x04V\x02\t\x12\x04\xc1\x06\x08*\n\r\n\x05\x04V\
    \x02\t\x04\x12\x04\xc1\x06\x08\x10\n\r\n\x05\x04V\x02\t\x05\x12\x04\xc1\
    \x06\x11\x17\n\r\n\x05\x04V\x02\t\x01\x12\x04\xc1\x06\x18$\n\r\n\x05\x04\
    V\x02\t\x03\x12\x04\xc1\x06')\n\x0c\n\x04\x04V\x02\n\x12\x04\xc2\x06\x08\
    )\n\r\n\x05\x04V\x02\n\x04\x12\x04\xc2\x06\x08\x10\n\r\n\x05\x04V\x02\n\
    \x05\x12\x04\xc2\x06\x11\x17\n\r\n\x05\x04V\x02\n\x01\x12\x04\xc2\x06\
    \x18#\n\r\n\x05\x04V\x02\n\x03\x12\x04\xc2\x06&(\n\x0c\n\x04\x04V\x02\
    \x0b\x12\x04\xc3\x06\x084\n\r\n\x05\x04V\x02\x0b\x04\x12\x04\xc3\x06\x08\
    \x10\n\r\n\x05\x04V\x02\x0b\x05\x12\x04\xc3\x06\x11\x17\n\r\n\x05\x04V\
    \x02\x0b\x01\x12\x04\xc3\x06\x18\x20\n\r\n\x05\x04V\x02\x0b\x03\x12\x04\
    \xc3\x06#%\n\r\n\x05\x04V\x02\x0b\x08\x12\x04\xc3\x06&3\n\r\n\x05\x04V\
    \x02\x0b\x07\x12\x04\xc3\x0612\n\x0c\n\x04\x04V\x02\x0c\x12\x04\xc4\x06\
    \x08)\n\r\n\x05\x04V\x02\x0c\x04\x12\x04\xc4\x06\x08\x10\n\r\n\x05\x04V\
    \x02\x0c\x05\x12\x04\xc4\x06\x11\x17\n\r\n\x05\x04V\x02\x0c\x01\x12\x04\
    \xc4\x06\x18#\n\r\n\x05\x04V\x02\x0c\x03\x12\x04\xc4\x06&(\n\x0c\n\x04\
    \x04V\x02\r\x12\x04\xc5\x06\x08#\n\r\n\x05\x04V\x02\r\x04\x12\x04\xc5\
    \x06\x08\x10\n\r\n\x05\x04V\x02\r\x05\x12\x04\xc5\x06\x11\x17\n\r\n\x05\
    \x04V\x02\r\x01\x12\x04\xc5\x06\x18\x1d\n\r\n\x05\x04V\x02\r\x03\x12\x04\
    \xc5\x06\x20\"\n\x0c\n\x04\x04V\x02\x0e\x12\x04\xc6\x06\x08.\n\r\n\x05\
    \x04V\x02\x0e\x04\x12\x04\xc6\x06\x08\x10\n\r\n\x05\x04V\x02\x0e\x05\x12\
    \x04\xc6\x06\x11\x15\n\r\n\x05\x04V\x02\x0e\x01\x12\x04\xc6\x06\x16(\n\r\
    \n\x05\x04V\x02\x0e\x03\x12\x04\xc6\x06+-\n\x0c\n\x04\x04V\x02\x0f\x12\
    \x04\xc7\x06\x08.\n\r\n\x05\x04V\x02\x0f\x04\x12\x04\xc7\x06\x08\x10\n\r\
    \n\x05\x04V\x02\x0f\x05\x12\x04\xc7\x06\x11\x17\n\r\n\x05\x04V\x02\x0f\
    \x01\x12\x04\xc7\x06\x18(\n\r\n\x05\x04V\x02\x0f\x03\x12\x04\xc7\x06+-\n\
    \x0c\n\x04\x04V\x02\x10\x12\x04\xc8\x06\x08S\n\r\n\x05\x04V\x02\x10\x04\
    \x12\x04\xc8\x06\x08\x10\n\r\n\x05\x04V\x02\x10\x06\x12\x04\xc8\x06\x11/\
    \n\r\n\x05\x04V\x02\x10\x01\x12\x04\xc8\x060<\n\r\n\x05\x04V\x02\x10\x03\
    \x12\x04\xc8\x06?A\n\r\n\x05\x04V\x02\x10\x08\x12\x04\xc8\x06BR\n\r\n\
    \x05\x04V\x02\x10\x07\x12\x04\xc8\x06MQ\n\x0c\n\x04\x04V\x02\x11\x12\x04\
    \xc9\x06\x080\n\r\n\x05\x04V\x02\x11\x04\x12\x04\xc9\x06\x08\x10\n\r\n\
    \x05\x04V\x02\x11\x05\x12\x04\xc9\x06\x11\x17\n\r\n\x05\x04V\x02\x11\x01\
    \x12\x04\xc9\x06\x18*\n\r\n\x05\x04V\x02\x11\x03\x12\x04\xc9\x06-/\n\x0c\
    \n\x04\x04V\x02\x12\x12\x04\xca\x06\x08.\n\r\n\x05\x04V\x02\x12\x04\x12\
    \x04\xca\x06\x08\x10\n\r\n\x05\x04V\x02\x12\x05\x12\x04\xca\x06\x11\x17\
    \n\r\n\x05\x04V\x02\x12\x01\x12\x04\xca\x06\x18(\n\r\n\x05\x04V\x02\x12\
    \x03\x12\x04\xca\x06+-\n\x0c\n\x04\x04V\x02\x13\x12\x04\xcb\x06\x08;\n\r\
    \n\x05\x04V\x02\x13\x04\x12\x04\xcb\x06\x08\x10\n\r\n\x05\x04V\x02\x13\
    \x06\x12\x04\xcb\x06\x11%\n\r\n\x05\x04V\x02\x13\x01\x12\x04\xcb\x06&5\n\
    \r\n\x05\x04V\x02\x13\x03\x12\x04\xcb\x068:\n\x0c\n\x02\x04W\x12\x06\xce\
    \x06\0\xd2\x06\x01\n\x0b\n\x03\x04W\x01\x12\x04\xce\x06\x08\x1b\n\x0c\n\
    \x04\x04W\x02\0\x12\x04\xcf\x06\x08+\n\r\n\x05\x04W\x02\0\x04\x12\x04\
    \xcf\x06\x08\x10\n\r\n\x05\x04W\x02\0\x05\x12\x04\xcf\x06\x11\x15\n\r\n\
    \x05\x04W\x02\0\x01\x12\x04\xcf\x06\x16&\n\r\n\x05\x04W\x02\0\x03\x12\
    \x04\xcf\x06)*\n\x0c\n\x04\x04W\x02\x01\x12\x04\xd0\x06\x08%\n\r\n\x05\
    \x04W\x02\x01\x04\x12\x04\xd0\x06\x08\x10\n\r\n\x05\x04W\x02\x01\x05\x12\
    \x04\xd0\x06\x11\x17\n\r\n\x05\x04W\x02\x01\x01\x12\x04\xd0\x06\x18\x20\
    \n\r\n\x05\x04W\x02\x01\x03\x12\x04\xd0\x06#$\n\x0c\n\x04\x04W\x02\x02\
    \x12\x04\xd1\x06\x08%\n\r\n\x05\x04W\x02\x02\x04\x12\x04\xd1\x06\x08\x10\
    \n\r\n\x05\x04W\x02\x02\x05\x12\x04\xd1\x06\x11\x17\n\r\n\x05\x04W\x02\
    \x02\x01\x12\x04\xd1\x06\x18\x20\n\r\n\x05\x04W\x02\x02\x03\x12\x04\xd1\
    \x06#$\n\x0c\n\x02\x04X\x12\x06\xd4\x06\0\xd8\x06\x01\n\x0b\n\x03\x04X\
    \x01\x12\x04\xd4\x06\x08\x1d\n\x0c\n\x04\x04X\x02\0\x12\x04\xd5\x06\x08-\
    \n\r\n\x05\x04X\x02\0\x04\x12\x04\xd5\x06\x08\x10\n\r\n\x05\x04X\x02\0\
    \x05\x12\x04\xd5\x06\x11\x17\n\r\n\x05\x04X\x02\0\x01\x12\x04\xd5\x06\
    \x18(\n\r\n\x05\x04X\x02\0\x03\x12\x04\xd5\x06+,\n\x0c\n\x04\x04X\x02\
    \x01\x12\x04\xd6\x06\x080\n\r\n\x05\x04X\x02\x01\x04\x12\x04\xd6\x06\x08\
    \x10\n\r\n\x05\x04X\x02\x01\x05\x12\x04\xd6\x06\x11\x17\n\r\n\x05\x04X\
    \x02\x01\x01\x12\x04\xd6\x06\x18+\n\r\n\x05\x04X\x02\x01\x03\x12\x04\xd6\
    \x06./\n\x0c\n\x04\x04X\x02\x02\x12\x04\xd7\x06\x088\n\r\n\x05\x04X\x02\
    \x02\x04\x12\x04\xd7\x06\x08\x10\n\r\n\x05\x04X\x02\x02\x05\x12\x04\xd7\
    \x06\x11\x17\n\r\n\x05\x04X\x02\x02\x01\x12\x04\xd7\x06\x183\n\r\n\x05\
    \x04X\x02\x02\x03\x12\x04\xd7\x0667\n\x0c\n\x02\x04Y\x12\x06\xda\x06\0\
    \xdb\x06\x01\n\x0b\n\x03\x04Y\x01\x12\x04\xda\x06\x08\"\n\x0c\n\x02\x04Z\
    \x12\x06\xdd\x06\0\xde\x06\x01\n\x0b\n\x03\x04Z\x01\x12\x04\xdd\x06\x08)\
    \n\x0c\n\x02\x04[\x12\x06\xe0\x06\0\xe2\x06\x01\n\x0b\n\x03\x04[\x01\x12\
    \x04\xe0\x06\x08*\n\x0c\n\x04\x04[\x02\0\x12\x04\xe1\x06\x087\n\r\n\x05\
    \x04[\x02\0\x04\x12\x04\xe1\x06\x08\x10\n\r\n\x05\x04[\x02\0\x05\x12\x04\
    \xe1\x06\x11\x17\n\r\n\x05\x04[\x02\0\x01\x12\x04\xe1\x06\x182\n\r\n\x05\
    \x04[\x02\0\x03\x12\x04\xe1\x0656\n\x0c\n\x02\x04\\\x12\x06\xe4\x06\0\
    \xe5\x06\x01\n\x0b\n\x03\x04\\\x01\x12\x04\xe4\x06\x08&\n\x0c\n\x02\x04]\
    \x12\x06\xe7\x06\0\x90\x07\x01\n\x0b\n\x03\x04]\x01\x12\x04\xe7\x06\x08'\
    \n\x0e\n\x04\x04]\x03\0\x12\x06\xe8\x06\x08\xeb\x06\t\n\r\n\x05\x04]\x03\
    \0\x01\x12\x04\xe8\x06\x10\x16\n\x0e\n\x06\x04]\x03\0\x02\0\x12\x04\xe9\
    \x06\x10.\n\x0f\n\x07\x04]\x03\0\x02\0\x04\x12\x04\xe9\x06\x10\x18\n\x0f\
    \n\x07\x04]\x03\0\x02\0\x05\x12\x04\xe9\x06\x19\x20\n\x0f\n\x07\x04]\x03\
    \0\x02\0\x01\x12\x04\xe9\x06!)\n\x0f\n\x07\x04]\x03\0\x02\0\x03\x12\x04\
    \xe9\x06,-\n\x0e\n\x06\x04]\x03\0\x02\x01\x12\x04\xea\x06\x10s\n\x0f\n\
    \x07\x04]\x03\0\x02\x01\x04\x12\x04\xea\x06\x10\x18\n\x0f\n\x07\x04]\x03\
    \0\x02\x01\x06\x12\x04\xea\x06\x19L\n\x0f\n\x07\x04]\x03\0\x02\x01\x01\
    \x12\x04\xea\x06MZ\n\x0f\n\x07\x04]\x03\0\x02\x01\x03\x12\x04\xea\x06]^\
    \n\x0f\n\x07\x04]\x03\0\x02\x01\x08\x12\x04\xea\x06_r\n\x0f\n\x07\x04]\
    \x03\0\x02\x01\x07\x12\x04\xea\x06jq\n\x0e\n\x04\x04]\x04\0\x12\x06\xed\
    \x06\x08\xf1\x06\t\n\r\n\x05\x04]\x04\0\x01\x12\x04\xed\x06\r\x1f\n\x0e\
    \n\x06\x04]\x04\0\x02\0\x12\x04\xee\x06\x10\x1c\n\x0f\n\x07\x04]\x04\0\
    \x02\0\x01\x12\x04\xee\x06\x10\x17\n\x0f\n\x07\x04]\x04\0\x02\0\x02\x12\
    \x04\xee\x06\x1a\x1b\n\x0e\n\x06\x04]\x04\0\x02\x01\x12\x04\xef\x06\x10\
    \x1e\n\x0f\n\x07\x04]\x04\0\x02\x01\x01\x12\x04\xef\x06\x10\x19\n\x0f\n\
    \x07\x04]\x04\0\x02\x01\x02\x12\x04\xef\x06\x1c\x1d\n\x0e\n\x06\x04]\x04\
    \0\x02\x02\x12\x04\xf0\x06\x10\x1d\n\x0f\n\x07\x04]\x04\0\x02\x02\x01\
    \x12\x04\xf0\x06\x10\x18\n\x0f\n\x07\x04]\x04\0\x02\x02\x02\x12\x04\xf0\
    \x06\x1b\x1c\n\x0e\n\x04\x04]\x04\x01\x12\x06\xf3\x06\x08\xf8\x06\t\n\r\
    \n\x05\x04]\x04\x01\x01\x12\x04\xf3\x06\r\x12\n\x0e\n\x06\x04]\x04\x01\
    \x02\0\x12\x04\xf4\x06\x10\x19\n\x0f\n\x07\x04]\x04\x01\x02\0\x01\x12\
    \x04\xf4\x06\x10\x14\n\x0f\n\x07\x04]\x04\x01\x02\0\x02\x12\x04\xf4\x06\
    \x17\x18\n\x0e\n\x06\x04]\x04\x01\x02\x01\x12\x04\xf5\x06\x10\x1f\n\x0f\
    \n\x07\x04]\x04\x01\x02\x01\x01\x12\x04\xf5\x06\x10\x1a\n\x0f\n\x07\x04]\
    \x04\x01\x02\x01\x02\x12\x04\xf5\x06\x1d\x1e\n\x0e\n\x06\x04]\x04\x01\
    \x02\x02\x12\x04\xf6\x06\x10\x1e\n\x0f\n\x07\x04]\x04\x01\x02\x02\x01\
    \x12\x04\xf6\x06\x10\x19\n\x0f\n\x07\x04]\x04\x01\x02\x02\x02\x12\x04\
    \xf6\x06\x1c\x1d\n\x0e\n\x06\x04]\x04\x01\x02\x03\x12\x04\xf7\x06\x10'\n\
    \x0f\n\x07\x04]\x04\x01\x02\x03\x01\x12\x04\xf7\x06\x10\"\n\x0f\n\x07\
    \x04]\x04\x01\x02\x03\x02\x12\x04\xf7\x06%&\n\x0c\n\x04\x04]\x02\0\x12\
    \x04\xfa\x06\x08=\n\r\n\x05\x04]\x02\0\x04\x12\x04\xfa\x06\x08\x10\n\r\n\
    \x05\x04]\x02\0\x05\x12\x04\xfa\x06\x11\x17\n\r\n\x05\x04]\x02\0\x01\x12\
    \x04\xfa\x06\x18&\n\r\n\x05\x04]\x02\0\x03\x12\x04\xfa\x06)+\n\r\n\x05\
    \x04]\x02\0\x08\x12\x04\xfa\x06,<\n\r\n\x05\x04]\x02\0\x07\x12\x04\xfa\
    \x067;\n\x0c\n\x04\x04]\x02\x01\x12\x04\xfb\x06\x08j\n\r\n\x05\x04]\x02\
    \x01\x04\x12\x04\xfb\x06\x08\x10\n\r\n\x05\x04]\x02\x01\x06\x12\x04\xfb\
    \x06\x11(\n\r\n\x05\x04]\x02\x01\x01\x12\x04\xfb\x06):\n\r\n\x05\x04]\
    \x02\x01\x03\x12\x04\xfb\x06=>\n\r\n\x05\x04]\x02\x01\x08\x12\x04\xfb\
    \x06?i\n\r\n\x05\x04]\x02\x01\x07\x12\x04\xfb\x06Jh\n\x0c\n\x04\x04]\x02\
    \x02\x12\x04\xfc\x06\x08\x20\n\r\n\x05\x04]\x02\x02\x04\x12\x04\xfc\x06\
    \x08\x10\n\r\n\x05\x04]\x02\x02\x05\x12\x04\xfc\x06\x11\x17\n\r\n\x05\
    \x04]\x02\x02\x01\x12\x04\xfc\x06\x18\x1b\n\r\n\x05\x04]\x02\x02\x03\x12\
    \x04\xfc\x06\x1e\x1f\n\x0c\n\x04\x04]\x02\x03\x12\x04\xfd\x06\x08!\n\r\n\
    \x05\x04]\x02\x03\x04\x12\x04\xfd\x06\x08\x10\n\r\n\x05\x04]\x02\x03\x05\
    \x12\x04\xfd\x06\x11\x17\n\r\n\x05\x04]\x02\x03\x01\x12\x04\xfd\x06\x18\
    \x1c\n\r\n\x05\x04]\x02\x03\x03\x12\x04\xfd\x06\x1f\x20\n\x0c\n\x04\x04]\
    \x02\x04\x12\x04\xfe\x06\x08&\n\r\n\x05\x04]\x02\x04\x04\x12\x04\xfe\x06\
    \x08\x10\n\r\n\x05\x04]\x02\x04\x05\x12\x04\xfe\x06\x11\x17\n\r\n\x05\
    \x04]\x02\x04\x01\x12\x04\xfe\x06\x18!\n\r\n\x05\x04]\x02\x04\x03\x12\
    \x04\xfe\x06$%\n\x0c\n\x04\x04]\x02\x05\x12\x04\xff\x06\x08+\n\r\n\x05\
    \x04]\x02\x05\x04\x12\x04\xff\x06\x08\x10\n\r\n\x05\x04]\x02\x05\x05\x12\
    \x04\xff\x06\x11\x17\n\r\n\x05\x04]\x02\x05\x01\x12\x04\xff\x06\x18&\n\r\
    \n\x05\x04]\x02\x05\x03\x12\x04\xff\x06)*\n\x0c\n\x04\x04]\x02\x06\x12\
    \x04\x80\x07\x08(\n\r\n\x05\x04]\x02\x06\x04\x12\x04\x80\x07\x08\x10\n\r\
    \n\x05\x04]\x02\x06\x05\x12\x04\x80\x07\x11\x17\n\r\n\x05\x04]\x02\x06\
    \x01\x12\x04\x80\x07\x18#\n\r\n\x05\x04]\x02\x06\x03\x12\x04\x80\x07&'\n\
    \x0c\n\x04\x04]\x02\x07\x12\x04\x81\x07\x08'\n\r\n\x05\x04]\x02\x07\x04\
    \x12\x04\x81\x07\x08\x10\n\r\n\x05\x04]\x02\x07\x05\x12\x04\x81\x07\x11\
    \x17\n\r\n\x05\x04]\x02\x07\x01\x12\x04\x81\x07\x18\"\n\r\n\x05\x04]\x02\
    \x07\x03\x12\x04\x81\x07%&\n\x0c\n\x04\x04]\x02\x08\x12\x04\x82\x07\x08*\
    \n\r\n\x05\x04]\x02\x08\x04\x12\x04\x82\x07\x08\x10\n\r\n\x05\x04]\x02\
    \x08\x05\x12\x04\x82\x07\x11\x17\n\r\n\x05\x04]\x02\x08\x01\x12\x04\x82\
    \x07\x18%\n\r\n\x05\x04]\x02\x08\x03\x12\x04\x82\x07()\n\x0c\n\x04\x04]\
    \x02\t\x12\x04\x83\x07\x08+\n\r\n\x05\x04]\x02\t\x04\x12\x04\x83\x07\x08\
    \x10\n\r\n\x05\x04]\x02\t\x05\x12\x04\x83\x07\x11\x16\n\r\n\x05\x04]\x02\
    \t\x01\x12\x04\x83\x07\x17%\n\r\n\x05\x04]\x02\t\x03\x12\x04\x83\x07(*\n\
    \x0c\n\x04\x04]\x02\n\x12\x04\x84\x07\x08*\n\r\n\x05\x04]\x02\n\x04\x12\
    \x04\x84\x07\x08\x10\n\r\n\x05\x04]\x02\n\x05\x12\x04\x84\x07\x11\x15\n\
    \r\n\x05\x04]\x02\n\x01\x12\x04\x84\x07\x16$\n\r\n\x05\x04]\x02\n\x03\
    \x12\x04\x84\x07')\n\x0c\n\x04\x04]\x02\x0b\x12\x04\x85\x07\x08,\n\r\n\
    \x05\x04]\x02\x0b\x04\x12\x04\x85\x07\x08\x10\n\r\n\x05\x04]\x02\x0b\x05\
    \x12\x04\x85\x07\x11\x15\n\r\n\x05\x04]\x02\x0b\x01\x12\x04\x85\x07\x16&\
    \n\r\n\x05\x04]\x02\x0b\x03\x12\x04\x85\x07)+\n\x0c\n\x04\x04]\x02\x0c\
    \x12\x04\x86\x07\x08$\n\r\n\x05\x04]\x02\x0c\x04\x12\x04\x86\x07\x08\x10\
    \n\r\n\x05\x04]\x02\x0c\x05\x12\x04\x86\x07\x11\x17\n\r\n\x05\x04]\x02\
    \x0c\x01\x12\x04\x86\x07\x18\x1e\n\r\n\x05\x04]\x02\x0c\x03\x12\x04\x86\
    \x07!#\n\x0c\n\x04\x04]\x02\r\x12\x04\x87\x07\x08%\n\r\n\x05\x04]\x02\r\
    \x04\x12\x04\x87\x07\x08\x10\n\r\n\x05\x04]\x02\r\x05\x12\x04\x87\x07\
    \x11\x17\n\r\n\x05\x04]\x02\r\x01\x12\x04\x87\x07\x18\x1f\n\r\n\x05\x04]\
    \x02\r\x03\x12\x04\x87\x07\"$\n\x0c\n\x04\x04]\x02\x0e\x12\x04\x88\x07\
    \x08F\n\r\n\x05\x04]\x02\x0e\x04\x12\x04\x88\x07\x08\x10\n\r\n\x05\x04]\
    \x02\x0e\x06\x12\x04\x88\x07\x118\n\r\n\x05\x04]\x02\x0e\x01\x12\x04\x88\
    \x079@\n\r\n\x05\x04]\x02\x0e\x03\x12\x04\x88\x07CE\n\x0c\n\x04\x04]\x02\
    \x0f\x12\x04\x89\x07\x08Y\n\r\n\x05\x04]\x02\x0f\x04\x12\x04\x89\x07\x08\
    \x10\n\r\n\x05\x04]\x02\x0f\x06\x12\x04\x89\x07\x11!\n\r\n\x05\x04]\x02\
    \x0f\x01\x12\x04\x89\x07\",\n\r\n\x05\x04]\x02\x0f\x03\x12\x04\x89\x07/1\
    \n\r\n\x05\x04]\x02\x0f\x08\x12\x04\x89\x072X\n\r\n\x05\x04]\x02\x0f\x07\
    \x12\x04\x89\x07=W\n\x0c\n\x04\x04]\x02\x10\x12\x04\x8a\x07\x08T\n\r\n\
    \x05\x04]\x02\x10\x04\x12\x04\x8a\x07\x08\x10\n\r\n\x05\x04]\x02\x10\x06\
    \x12\x04\x8a\x07\x117\n\r\n\x05\x04]\x02\x10\x01\x12\x04\x8a\x078=\n\r\n\
    \x05\x04]\x02\x10\x03\x12\x04\x8a\x07@B\n\r\n\x05\x04]\x02\x10\x08\x12\
    \x04\x8a\x07CS\n\r\n\x05\x04]\x02\x10\x07\x12\x04\x8a\x07NR\n\x0c\n\x04\
    \x04]\x02\x11\x12\x04\x8b\x07\x08&\n\r\n\x05\x04]\x02\x11\x04\x12\x04\
    \x8b\x07\x08\x10\n\r\n\x05\x04]\x02\x11\x05\x12\x04\x8b\x07\x11\x17\n\r\
    \n\x05\x04]\x02\x11\x01\x12\x04\x8b\x07\x18\x20\n\r\n\x05\x04]\x02\x11\
    \x03\x12\x04\x8b\x07#%\n\x0c\n\x04\x04]\x02\x12\x12\x04\x8c\x07\x082\n\r\
    \n\x05\x04]\x02\x12\x04\x12\x04\x8c\x07\x08\x10\n\r\n\x05\x04]\x02\x12\
    \x05\x12\x04\x8c\x07\x11\x17\n\r\n\x05\x04]\x02\x12\x01\x12\x04\x8c\x07\
    \x18,\n\r\n\x05\x04]\x02\x12\x03\x12\x04\x8c\x07/1\n\x0c\n\x04\x04]\x02\
    \x13\x12\x04\x8d\x07\x081\n\r\n\x05\x04]\x02\x13\x04\x12\x04\x8d\x07\x08\
    \x10\n\r\n\x05\x04]\x02\x13\x05\x12\x04\x8d\x07\x11\x17\n\r\n\x05\x04]\
    \x02\x13\x01\x12\x04\x8d\x07\x18+\n\r\n\x05\x04]\x02\x13\x03\x12\x04\x8d\
    \x07.0\n\x0c\n\x04\x04]\x02\x14\x12\x04\x8e\x07\x088\n\r\n\x05\x04]\x02\
    \x14\x04\x12\x04\x8e\x07\x08\x10\n\r\n\x05\x04]\x02\x14\x05\x12\x04\x8e\
    \x07\x11\x17\n\r\n\x05\x04]\x02\x14\x01\x12\x04\x8e\x07\x18#\n\r\n\x05\
    \x04]\x02\x14\x03\x12\x04\x8e\x07&(\n\r\n\x05\x04]\x02\x14\x08\x12\x04\
    \x8e\x07)7\n\r\n\x05\x04]\x02\x14\x07\x12\x04\x8e\x0746\n\x0c\n\x04\x04]\
    \x02\x15\x12\x04\x8f\x07\x08.\n\r\n\x05\x04]\x02\x15\x04\x12\x04\x8f\x07\
    \x08\x10\n\r\n\x05\x04]\x02\x15\x05\x12\x04\x8f\x07\x11\x17\n\r\n\x05\
    \x04]\x02\x15\x01\x12\x04\x8f\x07\x18(\n\r\n\x05\x04]\x02\x15\x03\x12\
    \x04\x8f\x07+-\n\x0c\n\x02\x04^\x12\x06\x92\x07\0\xa3\x07\x01\n\x0b\n\
    \x03\x04^\x01\x12\x04\x92\x07\x08\x1f\n\x0c\n\x04\x04^\x02\0\x12\x04\x93\
    \x07\x08.\n\r\n\x05\x04^\x02\0\x04\x12\x04\x93\x07\x08\x10\n\r\n\x05\x04\
    ^\x02\0\x05\x12\x04\x93\x07\x11\x17\n\r\n\x05\x04^\x02\0\x01\x12\x04\x93\
    \x07\x18)\n\r\n\x05\x04^\x02\0\x03\x12\x04\x93\x07,-\n\x0c\n\x04\x04^\
    \x02\x01\x12\x04\x94\x07\x084\n\r\n\x05\x04^\x02\x01\x04\x12\x04\x94\x07\
    \x08\x10\n\r\n\x05\x04^\x02\x01\x05\x12\x04\x94\x07\x11\x17\n\r\n\x05\
    \x04^\x02\x01\x01\x12\x04\x94\x07\x18/\n\r\n\x05\x04^\x02\x01\x03\x12\
    \x04\x94\x0723\n\x0c\n\x04\x04^\x02\x02\x12\x04\x95\x07\x08+\n\r\n\x05\
    \x04^\x02\x02\x04\x12\x04\x95\x07\x08\x10\n\r\n\x05\x04^\x02\x02\x05\x12\
    \x04\x95\x07\x11\x17\n\r\n\x05\x04^\x02\x02\x01\x12\x04\x95\x07\x18&\n\r\
    \n\x05\x04^\x02\x02\x03\x12\x04\x95\x07)*\n\x0c\n\x04\x04^\x02\x03\x12\
    \x04\x96\x07\x08A\n\r\n\x05\x04^\x02\x03\x04\x12\x04\x96\x07\x08\x10\n\r\
    \n\x05\x04^\x02\x03\x05\x12\x04\x96\x07\x11\x17\n\r\n\x05\x04^\x02\x03\
    \x01\x12\x04\x96\x07\x18<\n\r\n\x05\x04^\x02\x03\x03\x12\x04\x96\x07?@\n\
    \x0c\n\x04\x04^\x02\x04\x12\x04\x97\x07\x08@\n\r\n\x05\x04^\x02\x04\x04\
    \x12\x04\x97\x07\x08\x10\n\r\n\x05\x04^\x02\x04\x05\x12\x04\x97\x07\x11\
    \x17\n\r\n\x05\x04^\x02\x04\x01\x12\x04\x97\x07\x18;\n\r\n\x05\x04^\x02\
    \x04\x03\x12\x04\x97\x07>?\n\x0c\n\x04\x04^\x02\x05\x12\x04\x98\x07\x08?\
    \n\r\n\x05\x04^\x02\x05\x04\x12\x04\x98\x07\x08\x10\n\r\n\x05\x04^\x02\
    \x05\x05\x12\x04\x98\x07\x11\x17\n\r\n\x05\x04^\x02\x05\x01\x12\x04\x98\
    \x07\x189\n\r\n\x05\x04^\x02\x05\x03\x12\x04\x98\x07<>\n\x0c\n\x04\x04^\
    \x02\x06\x12\x04\x99\x07\x08>\n\r\n\x05\x04^\x02\x06\x04\x12\x04\x99\x07\
    \x08\x10\n\r\n\x05\x04^\x02\x06\x05\x12\x04\x99\x07\x11\x17\n\r\n\x05\
    \x04^\x02\x06\x01\x12\x04\x99\x07\x188\n\r\n\x05\x04^\x02\x06\x03\x12\
    \x04\x99\x07;=\n\x0c\n\x04\x04^\x02\x07\x12\x04\x9a\x07\x08?\n\r\n\x05\
    \x04^\x02\x07\x04\x12\x04\x9a\x07\x08\x10\n\r\n\x05\x04^\x02\x07\x05\x12\
    \x04\x9a\x07\x11\x17\n\r\n\x05\x04^\x02\x07\x01\x12\x04\x9a\x07\x189\n\r\
    \n\x05\x04^\x02\x07\x03\x12\x04\x9a\x07<>\n\x0c\n\x04\x04^\x02\x08\x12\
    \x04\x9b\x07\x08>\n\r\n\x05\x04^\x02\x08\x04\x12\x04\x9b\x07\x08\x10\n\r\
    \n\x05\x04^\x02\x08\x05\x12\x04\x9b\x07\x11\x17\n\r\n\x05\x04^\x02\x08\
    \x01\x12\x04\x9b\x07\x188\n\r\n\x05\x04^\x02\x08\x03\x12\x04\x9b\x07;=\n\
    \x0c\n\x04\x04^\x02\t\x12\x04\x9c\x07\x08<\n\r\n\x05\x04^\x02\t\x04\x12\
    \x04\x9c\x07\x08\x10\n\r\n\x05\x04^\x02\t\x05\x12\x04\x9c\x07\x11\x17\n\
    \r\n\x05\x04^\x02\t\x01\x12\x04\x9c\x07\x186\n\r\n\x05\x04^\x02\t\x03\
    \x12\x04\x9c\x079;\n\x0c\n\x04\x04^\x02\n\x12\x04\x9d\x07\x08;\n\r\n\x05\
    \x04^\x02\n\x04\x12\x04\x9d\x07\x08\x10\n\r\n\x05\x04^\x02\n\x05\x12\x04\
    \x9d\x07\x11\x17\n\r\n\x05\x04^\x02\n\x01\x12\x04\x9d\x07\x185\n\r\n\x05\
    \x04^\x02\n\x03\x12\x04\x9d\x078:\n\x0c\n\x04\x04^\x02\x0b\x12\x04\x9e\
    \x07\x08B\n\r\n\x05\x04^\x02\x0b\x04\x12\x04\x9e\x07\x08\x10\n\r\n\x05\
    \x04^\x02\x0b\x05\x12\x04\x9e\x07\x11\x17\n\r\n\x05\x04^\x02\x0b\x01\x12\
    \x04\x9e\x07\x18<\n\r\n\x05\x04^\x02\x0b\x03\x12\x04\x9e\x07?A\n\x0c\n\
    \x04\x04^\x02\x0c\x12\x04\x9f\x07\x08A\n\r\n\x05\x04^\x02\x0c\x04\x12\
    \x04\x9f\x07\x08\x10\n\r\n\x05\x04^\x02\x0c\x05\x12\x04\x9f\x07\x11\x17\
    \n\r\n\x05\x04^\x02\x0c\x01\x12\x04\x9f\x07\x18;\n\r\n\x05\x04^\x02\x0c\
    \x03\x12\x04\x9f\x07>@\n\x0c\n\x04\x04^\x02\r\x12\x04\xa0\x07\x08?\n\r\n\
    \x05\x04^\x02\r\x04\x12\x04\xa0\x07\x08\x10\n\r\n\x05\x04^\x02\r\x05\x12\
    \x04\xa0\x07\x11\x17\n\r\n\x05\x04^\x02\r\x01\x12\x04\xa0\x07\x189\n\r\n\
    \x05\x04^\x02\r\x03\x12\x04\xa0\x07<>\n\x0c\n\x04\x04^\x02\x0e\x12\x04\
    \xa1\x07\x08>\n\r\n\x05\x04^\x02\x0e\x04\x12\x04\xa1\x07\x08\x10\n\r\n\
    \x05\x04^\x02\x0e\x05\x12\x04\xa1\x07\x11\x17\n\r\n\x05\x04^\x02\x0e\x01\
    \x12\x04\xa1\x07\x188\n\r\n\x05\x04^\x02\x0e\x03\x12\x04\xa1\x07;=\n\x0c\
    \n\x04\x04^\x02\x0f\x12\x04\xa2\x07\x08(\n\r\n\x05\x04^\x02\x0f\x04\x12\
    \x04\xa2\x07\x08\x10\n\r\n\x05\x04^\x02\x0f\x05\x12\x04\xa2\x07\x11\x17\
    \n\r\n\x05\x04^\x02\x0f\x01\x12\x04\xa2\x07\x18#\n\r\n\x05\x04^\x02\x0f\
    \x03\x12\x04\xa2\x07&'\n\x0c\n\x02\x04_\x12\x06\xa5\x07\0\xc3\x07\x01\n\
    \x0b\n\x03\x04_\x01\x12\x04\xa5\x07\x08\x1a\n\x0e\n\x04\x04_\x03\0\x12\
    \x06\xa6\x07\x08\xaa\x07\t\n\r\n\x05\x04_\x03\0\x01\x12\x04\xa6\x07\x10\
    \x14\n\x0e\n\x06\x04_\x03\0\x02\0\x12\x04\xa7\x07\x10^\n\x0f\n\x07\x04_\
    \x03\0\x02\0\x04\x12\x04\xa7\x07\x10\x18\n\x0f\n\x07\x04_\x03\0\x02\0\
    \x06\x12\x04\xa7\x07\x198\n\x0f\n\x07\x04_\x03\0\x02\0\x01\x12\x04\xa7\
    \x079E\n\x0f\n\x07\x04_\x03\0\x02\0\x03\x12\x04\xa7\x07HI\n\x0f\n\x07\
    \x04_\x03\0\x02\0\x08\x12\x04\xa7\x07J]\n\x0f\n\x07\x04_\x03\0\x02\0\x07\
    \x12\x04\xa7\x07U\\\n\x0e\n\x06\x04_\x03\0\x02\x01\x12\x04\xa8\x07\x10-\
    \n\x0f\n\x07\x04_\x03\0\x02\x01\x04\x12\x04\xa8\x07\x10\x18\n\x0f\n\x07\
    \x04_\x03\0\x02\x01\x05\x12\x04\xa8\x07\x19\x1e\n\x0f\n\x07\x04_\x03\0\
    \x02\x01\x01\x12\x04\xa8\x07\x1f(\n\x0f\n\x07\x04_\x03\0\x02\x01\x03\x12\
    \x04\xa8\x07+,\n\x0e\n\x06\x04_\x03\0\x02\x02\x12\x04\xa9\x07\x10D\n\x0f\
    \n\x07\x04_\x03\0\x02\x02\x04\x12\x04\xa9\x07\x10\x18\n\x0f\n\x07\x04_\
    \x03\0\x02\x02\x05\x12\x04\xa9\x07\x19\x20\n\x0f\n\x07\x04_\x03\0\x02\
    \x02\x01\x12\x04\xa9\x07!?\n\x0f\n\x07\x04_\x03\0\x02\x02\x03\x12\x04\
    \xa9\x07BC\n\x0e\n\x04\x04_\x03\x01\x12\x06\xac\x07\x08\xb6\x07\t\n\r\n\
    \x05\x04_\x03\x01\x01\x12\x04\xac\x07\x10\x16\n\x0e\n\x06\x04_\x03\x01\
    \x02\0\x12\x04\xad\x07\x10.\n\x0f\n\x07\x04_\x03\x01\x02\0\x04\x12\x04\
    \xad\x07\x10\x18\n\x0f\n\x07\x04_\x03\x01\x02\0\x05\x12\x04\xad\x07\x19\
    \x20\n\x0f\n\x07\x04_\x03\x01\x02\0\x01\x12\x04\xad\x07!)\n\x0f\n\x07\
    \x04_\x03\x01\x02\0\x03\x12\x04\xad\x07,-\n\x0e\n\x06\x04_\x03\x01\x02\
    \x01\x12\x04\xae\x07\x100\n\x0f\n\x07\x04_\x03\x01\x02\x01\x04\x12\x04\
    \xae\x07\x10\x18\n\x0f\n\x07\x04_\x03\x01\x02\x01\x05\x12\x04\xae\x07\
    \x19\x1d\n\x0f\n\x07\x04_\x03\x01\x02\x01\x01\x12\x04\xae\x07\x1e+\n\x0f\
    \n\x07\x04_\x03\x01\x02\x01\x03\x12\x04\xae\x07./\n\x0e\n\x06\x04_\x03\
    \x01\x02\x02\x12\x04\xaf\x07\x109\n\x0f\n\x07\x04_\x03\x01\x02\x02\x04\
    \x12\x04\xaf\x07\x10\x18\n\x0f\n\x07\x04_\x03\x01\x02\x02\x05\x12\x04\
    \xaf\x07\x19\x1d\n\x0f\n\x07\x04_\x03\x01\x02\x02\x01\x12\x04\xaf\x07\
    \x1e4\n\x0f\n\x07\x04_\x03\x01\x02\x02\x03\x12\x04\xaf\x0778\n\x0e\n\x06\
    \x04_\x03\x01\x02\x03\x12\x04\xb0\x07\x100\n\x0f\n\x07\x04_\x03\x01\x02\
    \x03\x04\x12\x04\xb0\x07\x10\x18\n\x0f\n\x07\x04_\x03\x01\x02\x03\x05\
    \x12\x04\xb0\x07\x19\x1d\n\x0f\n\x07\x04_\x03\x01\x02\x03\x01\x12\x04\
    \xb0\x07\x1e+\n\x0f\n\x07\x04_\x03\x01\x02\x03\x03\x12\x04\xb0\x07./\n\
    \x0e\n\x06\x04_\x03\x01\x02\x04\x12\x04\xb1\x07\x100\n\x0f\n\x07\x04_\
    \x03\x01\x02\x04\x04\x12\x04\xb1\x07\x10\x18\n\x0f\n\x07\x04_\x03\x01\
    \x02\x04\x05\x12\x04\xb1\x07\x19\x1f\n\x0f\n\x07\x04_\x03\x01\x02\x04\
    \x01\x12\x04\xb1\x07\x20+\n\x0f\n\x07\x04_\x03\x01\x02\x04\x03\x12\x04\
    \xb1\x07./\n\x0e\n\x06\x04_\x03\x01\x02\x05\x12\x04\xb2\x07\x108\n\x0f\n\
    \x07\x04_\x03\x01\x02\x05\x04\x12\x04\xb2\x07\x10\x18\n\x0f\n\x07\x04_\
    \x03\x01\x02\x05\x05\x12\x04\xb2\x07\x19\x1f\n\x0f\n\x07\x04_\x03\x01\
    \x02\x05\x01\x12\x04\xb2\x07\x203\n\x0f\n\x07\x04_\x03\x01\x02\x05\x03\
    \x12\x04\xb2\x0767\n\x0e\n\x06\x04_\x03\x01\x02\x06\x12\x04\xb3\x07\x10<\
    \n\x0f\n\x07\x04_\x03\x01\x02\x06\x04\x12\x04\xb3\x07\x10\x18\n\x0f\n\
    \x07\x04_\x03\x01\x02\x06\x06\x12\x04\xb3\x07\x191\n\x0f\n\x07\x04_\x03\
    \x01\x02\x06\x01\x12\x04\xb3\x0727\n\x0f\n\x07\x04_\x03\x01\x02\x06\x03\
    \x12\x04\xb3\x07:;\n\x0e\n\x06\x04_\x03\x01\x02\x07\x12\x04\xb4\x07\x102\
    \n\x0f\n\x07\x04_\x03\x01\x02\x07\x04\x12\x04\xb4\x07\x10\x18\n\x0f\n\
    \x07\x04_\x03\x01\x02\x07\x05\x12\x04\xb4\x07\x19\x1d\n\x0f\n\x07\x04_\
    \x03\x01\x02\x07\x01\x12\x04\xb4\x07\x1e-\n\x0f\n\x07\x04_\x03\x01\x02\
    \x07\x03\x12\x04\xb4\x0701\n\x0e\n\x06\x04_\x03\x01\x02\x08\x12\x04\xb5\
    \x07\x102\n\x0f\n\x07\x04_\x03\x01\x02\x08\x04\x12\x04\xb5\x07\x10\x18\n\
    \x0f\n\x07\x04_\x03\x01\x02\x08\x05\x12\x04\xb5\x07\x19\x1f\n\x0f\n\x07\
    \x04_\x03\x01\x02\x08\x01\x12\x04\xb5\x07\x20,\n\x0f\n\x07\x04_\x03\x01\
    \x02\x08\x03\x12\x04\xb5\x07/1\n\x0e\n\x04\x04_\x04\0\x12\x06\xb8\x07\
    \x08\xbe\x07\t\n\r\n\x05\x04_\x04\0\x01\x12\x04\xb8\x07\r\x18\n\x0e\n\
    \x06\x04_\x04\0\x02\0\x12\x04\xb9\x07\x10\x1c\n\x0f\n\x07\x04_\x04\0\x02\
    \0\x01\x12\x04\xb9\x07\x10\x17\n\x0f\n\x07\x04_\x04\0\x02\0\x02\x12\x04\
    \xb9\x07\x1a\x1b\n\x0e\n\x06\x04_\x04\0\x02\x01\x12\x04\xba\x07\x10\"\n\
    \x0f\n\x07\x04_\x04\0\x02\x01\x01\x12\x04\xba\x07\x10\x1d\n\x0f\n\x07\
    \x04_\x04\0\x02\x01\x02\x12\x04\xba\x07\x20!\n\x0e\n\x06\x04_\x04\0\x02\
    \x02\x12\x04\xbb\x07\x10\"\n\x0f\n\x07\x04_\x04\0\x02\x02\x01\x12\x04\
    \xbb\x07\x10\x1d\n\x0f\n\x07\x04_\x04\0\x02\x02\x02\x12\x04\xbb\x07\x20!\
    \n\x0e\n\x06\x04_\x04\0\x02\x03\x12\x04\xbc\x07\x10\x1c\n\x0f\n\x07\x04_\
    \x04\0\x02\x03\x01\x12\x04\xbc\x07\x10\x17\n\x0f\n\x07\x04_\x04\0\x02\
    \x03\x02\x12\x04\xbc\x07\x1a\x1b\n\x0e\n\x06\x04_\x04\0\x02\x04\x12\x04\
    \xbd\x07\x10\x20\n\x0f\n\x07\x04_\x04\0\x02\x04\x01\x12\x04\xbd\x07\x10\
    \x1b\n\x0f\n\x07\x04_\x04\0\x02\x04\x02\x12\x04\xbd\x07\x1e\x1f\n\x0c\n\
    \x04\x04_\x02\0\x12\x04\xc0\x07\x088\n\r\n\x05\x04_\x02\0\x04\x12\x04\
    \xc0\x07\x08\x10\n\r\n\x05\x04_\x02\0\x06\x12\x04\xc0\x07\x11+\n\r\n\x05\
    \x04_\x02\0\x01\x12\x04\xc0\x07,3\n\r\n\x05\x04_\x02\0\x03\x12\x04\xc0\
    \x0767\n\x0c\n\x04\x04_\x02\x01\x12\x04\xc1\x07\x08&\n\r\n\x05\x04_\x02\
    \x01\x04\x12\x04\xc1\x07\x08\x10\n\r\n\x05\x04_\x02\x01\x05\x12\x04\xc1\
    \x07\x11\x17\n\r\n\x05\x04_\x02\x01\x01\x12\x04\xc1\x07\x18!\n\r\n\x05\
    \x04_\x02\x01\x03\x12\x04\xc1\x07$%\n\x0c\n\x04\x04_\x02\x02\x12\x04\xc2\
    \x07\x08)\n\r\n\x05\x04_\x02\x02\x04\x12\x04\xc2\x07\x08\x10\n\r\n\x05\
    \x04_\x02\x02\x05\x12\x04\xc2\x07\x11\x17\n\r\n\x05\x04_\x02\x02\x01\x12\
    \x04\xc2\x07\x18$\n\r\n\x05\x04_\x02\x02\x03\x12\x04\xc2\x07'(\n\x0c\n\
    \x02\x04`\x12\x06\xc5\x07\0\xc9\x07\x01\n\x0b\n\x03\x04`\x01\x12\x04\xc5\
    \x07\x08\x1d\n\x0c\n\x04\x04`\x02\0\x12\x04\xc6\x07\x08*\n\r\n\x05\x04`\
    \x02\0\x04\x12\x04\xc6\x07\x08\x10\n\r\n\x05\x04`\x02\0\x05\x12\x04\xc6\
    \x07\x11\x17\n\r\n\x05\x04`\x02\0\x01\x12\x04\xc6\x07\x18%\n\r\n\x05\x04\
    `\x02\0\x03\x12\x04\xc6\x07()\n\x0c\n\x04\x04`\x02\x01\x12\x04\xc7\x07\
    \x08-\n\r\n\x05\x04`\x02\x01\x04\x12\x04\xc7\x07\x08\x10\n\r\n\x05\x04`\
    \x02\x01\x05\x12\x04\xc7\x07\x11\x17\n\r\n\x05\x04`\x02\x01\x01\x12\x04\
    \xc7\x07\x18(\n\r\n\x05\x04`\x02\x01\x03\x12\x04\xc7\x07+,\n\x0c\n\x04\
    \x04`\x02\x02\x12\x04\xc8\x07\x08,\n\r\n\x05\x04`\x02\x02\x04\x12\x04\
    \xc8\x07\x08\x10\n\r\n\x05\x04`\x02\x02\x05\x12\x04\xc8\x07\x11\x17\n\r\
    \n\x05\x04`\x02\x02\x01\x12\x04\xc8\x07\x18'\n\r\n\x05\x04`\x02\x02\x03\
    \x12\x04\xc8\x07*+\n\x0c\n\x02\x04a\x12\x06\xcb\x07\0\xd1\x07\x01\n\x0b\
    \n\x03\x04a\x01\x12\x04\xcb\x07\x08\x14\n\x0c\n\x04\x04a\x02\0\x12\x04\
    \xcc\x07\x08,\n\r\n\x05\x04a\x02\0\x04\x12\x04\xcc\x07\x08\x10\n\r\n\x05\
    \x04a\x02\0\x05\x12\x04\xcc\x07\x11\x16\n\r\n\x05\x04a\x02\0\x01\x12\x04\
    \xcc\x07\x17'\n\r\n\x05\x04a\x02\0\x03\x12\x04\xcc\x07*+\n\x0c\n\x04\x04\
    a\x02\x01\x12\x04\xcd\x07\x08*\n\r\n\x05\x04a\x02\x01\x04\x12\x04\xcd\
    \x07\x08\x10\n\r\n\x05\x04a\x02\x01\x05\x12\x04\xcd\x07\x11\x17\n\r\n\
    \x05\x04a\x02\x01\x01\x12\x04\xcd\x07\x18%\n\r\n\x05\x04a\x02\x01\x03\
    \x12\x04\xcd\x07()\n\x0c\n\x04\x04a\x02\x02\x12\x04\xce\x07\x08-\n\r\n\
    \x05\x04a\x02\x02\x04\x12\x04\xce\x07\x08\x10\n\r\n\x05\x04a\x02\x02\x05\
    \x12\x04\xce\x07\x11\x17\n\r\n\x05\x04a\x02\x02\x01\x12\x04\xce\x07\x18(\
    \n\r\n\x05\x04a\x02\x02\x03\x12\x04\xce\x07+,\n\x0c\n\x04\x04a\x02\x03\
    \x12\x04\xcf\x07\x08.\n\r\n\x05\x04a\x02\x03\x04\x12\x04\xcf\x07\x08\x10\
    \n\r\n\x05\x04a\x02\x03\x05\x12\x04\xcf\x07\x11\x17\n\r\n\x05\x04a\x02\
    \x03\x01\x12\x04\xcf\x07\x18)\n\r\n\x05\x04a\x02\x03\x03\x12\x04\xcf\x07\
    ,-\n\x0c\n\x04\x04a\x02\x04\x12\x04\xd0\x07\x08/\n\r\n\x05\x04a\x02\x04\
    \x04\x12\x04\xd0\x07\x08\x10\n\r\n\x05\x04a\x02\x04\x05\x12\x04\xd0\x07\
    \x11\x16\n\r\n\x05\x04a\x02\x04\x01\x12\x04\xd0\x07\x17*\n\r\n\x05\x04a\
    \x02\x04\x03\x12\x04\xd0\x07-.\n\x0c\n\x02\x04b\x12\x06\xd3\x07\0\xd7\
    \x07\x01\n\x0b\n\x03\x04b\x01\x12\x04\xd3\x07\x08\x16\n\x0c\n\x04\x04b\
    \x02\0\x12\x04\xd4\x07\x08-\n\r\n\x05\x04b\x02\0\x04\x12\x04\xd4\x07\x08\
    \x10\n\r\n\x05\x04b\x02\0\x05\x12\x04\xd4\x07\x11\x17\n\r\n\x05\x04b\x02\
    \0\x01\x12\x04\xd4\x07\x18(\n\r\n\x05\x04b\x02\0\x03\x12\x04\xd4\x07+,\n\
    \x0c\n\x04\x04b\x02\x01\x12\x04\xd5\x07\x08/\n\r\n\x05\x04b\x02\x01\x04\
    \x12\x04\xd5\x07\x08\x10\n\r\n\x05\x04b\x02\x01\x05\x12\x04\xd5\x07\x11\
    \x16\n\r\n\x05\x04b\x02\x01\x01\x12\x04\xd5\x07\x17*\n\r\n\x05\x04b\x02\
    \x01\x03\x12\x04\xd5\x07-.\n\x0c\n\x04\x04b\x02\x02\x12\x04\xd6\x07\x08*\
    \n\r\n\x05\x04b\x02\x02\x04\x12\x04\xd6\x07\x08\x10\n\r\n\x05\x04b\x02\
    \x02\x05\x12\x04\xd6\x07\x11\x17\n\r\n\x05\x04b\x02\x02\x01\x12\x04\xd6\
    \x07\x18%\n\r\n\x05\x04b\x02\x02\x03\x12\x04\xd6\x07()\n\x0c\n\x02\x04c\
    \x12\x06\xd9\x07\0\xe5\x07\x01\n\x0b\n\x03\x04c\x01\x12\x04\xd9\x07\x08\
    \x16\n\x0e\n\x04\x04c\x03\0\x12\x06\xda\x07\x08\xdd\x07\t\n\r\n\x05\x04c\
    \x03\0\x01\x12\x04\xda\x07\x10\x16\n\x0e\n\x06\x04c\x03\0\x02\0\x12\x04\
    \xdb\x07\x10.\n\x0f\n\x07\x04c\x03\0\x02\0\x04\x12\x04\xdb\x07\x10\x18\n\
    \x0f\n\x07\x04c\x03\0\x02\0\x05\x12\x04\xdb\x07\x19\x20\n\x0f\n\x07\x04c\
    \x03\0\x02\0\x01\x12\x04\xdb\x07!)\n\x0f\n\x07\x04c\x03\0\x02\0\x03\x12\
    \x04\xdb\x07,-\n\x0e\n\x06\x04c\x03\0\x02\x01\x12\x04\xdc\x07\x100\n\x0f\
    \n\x07\x04c\x03\0\x02\x01\x04\x12\x04\xdc\x07\x10\x18\n\x0f\n\x07\x04c\
    \x03\0\x02\x01\x05\x12\x04\xdc\x07\x19\x1d\n\x0f\n\x07\x04c\x03\0\x02\
    \x01\x01\x12\x04\xdc\x07\x1e+\n\x0f\n\x07\x04c\x03\0\x02\x01\x03\x12\x04\
    \xdc\x07./\n\x0c\n\x04\x04c\x02\0\x12\x04\xdf\x07\x081\n\r\n\x05\x04c\
    \x02\0\x04\x12\x04\xdf\x07\x08\x10\n\r\n\x05\x04c\x02\0\x05\x12\x04\xdf\
    \x07\x11\x17\n\r\n\x05\x04c\x02\0\x01\x12\x04\xdf\x07\x18,\n\r\n\x05\x04\
    c\x02\0\x03\x12\x04\xdf\x07/0\n\x0c\n\x04\x04c\x02\x01\x12\x04\xe0\x07\
    \x08-\n\r\n\x05\x04c\x02\x01\x04\x12\x04\xe0\x07\x08\x10\n\r\n\x05\x04c\
    \x02\x01\x05\x12\x04\xe0\x07\x11\x17\n\r\n\x05\x04c\x02\x01\x01\x12\x04\
    \xe0\x07\x18(\n\r\n\x05\x04c\x02\x01\x03\x12\x04\xe0\x07+,\n\x0c\n\x04\
    \x04c\x02\x02\x12\x04\xe1\x07\x08)\n\r\n\x05\x04c\x02\x02\x04\x12\x04\
    \xe1\x07\x08\x10\n\r\n\x05\x04c\x02\x02\x05\x12\x04\xe1\x07\x11\x17\n\r\
    \n\x05\x04c\x02\x02\x01\x12\x04\xe1\x07\x18$\n\r\n\x05\x04c\x02\x02\x03\
    \x12\x04\xe1\x07'(\n\x0c\n\x04\x04c\x02\x03\x12\x04\xe2\x07\x084\n\r\n\
    \x05\x04c\x02\x03\x04\x12\x04\xe2\x07\x08\x10\n\r\n\x05\x04c\x02\x03\x06\
    \x12\x04\xe2\x07\x11'\n\r\n\x05\x04c\x02\x03\x01\x12\x04\xe2\x07(/\n\r\n\
    \x05\x04c\x02\x03\x03\x12\x04\xe2\x0723\n\x0c\n\x04\x04c\x02\x04\x12\x04\
    \xe3\x07\x08%\n\r\n\x05\x04c\x02\x04\x04\x12\x04\xe3\x07\x08\x10\n\r\n\
    \x05\x04c\x02\x04\x05\x12\x04\xe3\x07\x11\x17\n\r\n\x05\x04c\x02\x04\x01\
    \x12\x04\xe3\x07\x18\x20\n\r\n\x05\x04c\x02\x04\x03\x12\x04\xe3\x07#$\n\
    \x0c\n\x04\x04c\x02\x05\x12\x04\xe4\x07\x08(\n\r\n\x05\x04c\x02\x05\x04\
    \x12\x04\xe4\x07\x08\x10\n\r\n\x05\x04c\x02\x05\x05\x12\x04\xe4\x07\x11\
    \x18\n\r\n\x05\x04c\x02\x05\x01\x12\x04\xe4\x07\x19#\n\r\n\x05\x04c\x02\
    \x05\x03\x12\x04\xe4\x07&'\n\x0c\n\x02\x04d\x12\x06\xe7\x07\0\xe8\x07\
    \x01\n\x0b\n\x03\x04d\x01\x12\x04\xe7\x07\x08!\n\x0c\n\x02\x04e\x12\x06\
    \xea\x07\0\xed\x07\x01\n\x0b\n\x03\x04e\x01\x12\x04\xea\x07\x08\"\n\x0c\
    \n\x04\x04e\x02\0\x12\x04\xeb\x07\x08%\n\r\n\x05\x04e\x02\0\x04\x12\x04\
    \xeb\x07\x08\x10\n\r\n\x05\x04e\x02\0\x05\x12\x04\xeb\x07\x11\x17\n\r\n\
    \x05\x04e\x02\0\x01\x12\x04\xeb\x07\x18\x20\n\r\n\x05\x04e\x02\0\x03\x12\
    \x04\xeb\x07#$\n\x0c\n\x04\x04e\x02\x01\x12\x04\xec\x07\x08%\n\r\n\x05\
    \x04e\x02\x01\x04\x12\x04\xec\x07\x08\x10\n\r\n\x05\x04e\x02\x01\x05\x12\
    \x04\xec\x07\x11\x17\n\r\n\x05\x04e\x02\x01\x01\x12\x04\xec\x07\x18\x20\
    \n\r\n\x05\x04e\x02\x01\x03\x12\x04\xec\x07#$\n\x0c\n\x02\x04f\x12\x06\
    \xef\x07\0\xf0\x07\x01\n\x0b\n\x03\x04f\x01\x12\x04\xef\x07\x08*\n\x0c\n\
    \x02\x04g\x12\x06\xf2\x07\0\xf4\x07\x01\n\x0b\n\x03\x04g\x01\x12\x04\xf2\
    \x07\x08*\n\x0c\n\x04\x04g\x02\0\x12\x04\xf3\x07\x08&\n\r\n\x05\x04g\x02\
    \0\x04\x12\x04\xf3\x07\x08\x10\n\r\n\x05\x04g\x02\0\x05\x12\x04\xf3\x07\
    \x11\x18\n\r\n\x05\x04g\x02\0\x01\x12\x04\xf3\x07\x19!\n\r\n\x05\x04g\
    \x02\0\x03\x12\x04\xf3\x07$%\n\x0c\n\x02\x04h\x12\x06\xf6\x07\0\xfd\x07\
    \x01\n\x0b\n\x03\x04h\x01\x12\x04\xf6\x07\x08\x1b\n\x0c\n\x04\x04h\x02\0\
    \x12\x04\xf7\x07\x08&\n\r\n\x05\x04h\x02\0\x04\x12\x04\xf7\x07\x08\x10\n\
    \r\n\x05\x04h\x02\0\x05\x12\x04\xf7\x07\x11\x18\n\r\n\x05\x04h\x02\0\x01\
    \x12\x04\xf7\x07\x19!\n\r\n\x05\x04h\x02\0\x03\x12\x04\xf7\x07$%\n\x0c\n\
    \x04\x04h\x02\x01\x12\x04\xf8\x07\x08a\n\r\n\x05\x04h\x02\x01\x04\x12\
    \x04\xf8\x07\x08\x10\n\r\n\x05\x04h\x02\x01\x06\x12\x04\xf8\x07\x11$\n\r\
    \n\x05\x04h\x02\x01\x01\x12\x04\xf8\x07%1\n\r\n\x05\x04h\x02\x01\x03\x12\
    \x04\xf8\x0745\n\r\n\x05\x04h\x02\x01\x08\x12\x04\xf8\x076`\n\r\n\x05\
    \x04h\x02\x01\x07\x12\x04\xf8\x07A_\n\x0c\n\x04\x04h\x02\x02\x12\x04\xf9\
    \x07\x08&\n\r\n\x05\x04h\x02\x02\x04\x12\x04\xf9\x07\x08\x10\n\r\n\x05\
    \x04h\x02\x02\x05\x12\x04\xf9\x07\x11\x15\n\r\n\x05\x04h\x02\x02\x01\x12\
    \x04\xf9\x07\x16!\n\r\n\x05\x04h\x02\x02\x03\x12\x04\xf9\x07$%\n\x0c\n\
    \x04\x04h\x02\x03\x12\x04\xfa\x07\x08%\n\r\n\x05\x04h\x02\x03\x04\x12\
    \x04\xfa\x07\x08\x10\n\r\n\x05\x04h\x02\x03\x05\x12\x04\xfa\x07\x11\x17\
    \n\r\n\x05\x04h\x02\x03\x01\x12\x04\xfa\x07\x18\x20\n\r\n\x05\x04h\x02\
    \x03\x03\x12\x04\xfa\x07#$\n\x0c\n\x04\x04h\x02\x04\x12\x04\xfb\x07\x08%\
    \n\r\n\x05\x04h\x02\x04\x04\x12\x04\xfb\x07\x08\x10\n\r\n\x05\x04h\x02\
    \x04\x05\x12\x04\xfb\x07\x11\x17\n\r\n\x05\x04h\x02\x04\x01\x12\x04\xfb\
    \x07\x18\x20\n\r\n\x05\x04h\x02\x04\x03\x12\x04\xfb\x07#$\n\x0c\n\x04\
    \x04h\x02\x05\x12\x04\xfc\x07\x082\n\r\n\x05\x04h\x02\x05\x04\x12\x04\
    \xfc\x07\x08\x10\n\r\n\x05\x04h\x02\x05\x06\x12\x04\xfc\x07\x11\x20\n\r\
    \n\x05\x04h\x02\x05\x01\x12\x04\xfc\x07!-\n\r\n\x05\x04h\x02\x05\x03\x12\
    \x04\xfc\x0701\n\x0c\n\x02\x04i\x12\x06\xff\x07\0\x80\x08\x01\n\x0b\n\
    \x03\x04i\x01\x12\x04\xff\x07\x08#\n\x0c\n\x02\x04j\x12\x06\x82\x08\0\
    \x8e\x08\x01\n\x0b\n\x03\x04j\x01\x12\x04\x82\x08\x08\x20\n\x0e\n\x04\
    \x04j\x03\0\x12\x06\x83\x08\x08\x86\x08\t\n\r\n\x05\x04j\x03\0\x01\x12\
    \x04\x83\x08\x10\x14\n\x0e\n\x06\x04j\x03\0\x02\0\x12\x04\x84\x08\x10.\n\
    \x0f\n\x07\x04j\x03\0\x02\0\x04\x12\x04\x84\x08\x10\x18\n\x0f\n\x07\x04j\
    \x03\0\x02\0\x05\x12\x04\x84\x08\x19\x20\n\x0f\n\x07\x04j\x03\0\x02\0\
    \x01\x12\x04\x84\x08!)\n\x0f\n\x07\x04j\x03\0\x02\0\x03\x12\x04\x84\x08,\
    -\n\x0e\n\x06\x04j\x03\0\x02\x01\x12\x04\x85\x08\x10+\n\x0f\n\x07\x04j\
    \x03\0\x02\x01\x04\x12\x04\x85\x08\x10\x18\n\x0f\n\x07\x04j\x03\0\x02\
    \x01\x05\x12\x04\x85\x08\x19\x1d\n\x0f\n\x07\x04j\x03\0\x02\x01\x01\x12\
    \x04\x85\x08\x1e&\n\x0f\n\x07\x04j\x03\0\x02\x01\x03\x12\x04\x85\x08)*\n\
    \x0c\n\x04\x04j\x02\0\x12\x04\x88\x08\x08&\n\r\n\x05\x04j\x02\0\x04\x12\
    \x04\x88\x08\x08\x10\n\r\n\x05\x04j\x02\0\x05\x12\x04\x88\x08\x11\x18\n\
    \r\n\x05\x04j\x02\0\x01\x12\x04\x88\x08\x19!\n\r\n\x05\x04j\x02\0\x03\
    \x12\x04\x88\x08$%\n\x0c\n\x04\x04j\x02\x01\x12\x04\x89\x08\x080\n\r\n\
    \x05\x04j\x02\x01\x04\x12\x04\x89\x08\x08\x10\n\r\n\x05\x04j\x02\x01\x05\
    \x12\x04\x89\x08\x11\x18\n\r\n\x05\x04j\x02\x01\x01\x12\x04\x89\x08\x19+\
    \n\r\n\x05\x04j\x02\x01\x03\x12\x04\x89\x08./\n\x0c\n\x04\x04j\x02\x02\
    \x12\x04\x8a\x08\x08-\n\r\n\x05\x04j\x02\x02\x04\x12\x04\x8a\x08\x08\x10\
    \n\r\n\x05\x04j\x02\x02\x05\x12\x04\x8a\x08\x11\x18\n\r\n\x05\x04j\x02\
    \x02\x01\x12\x04\x8a\x08\x19(\n\r\n\x05\x04j\x02\x02\x03\x12\x04\x8a\x08\
    +,\n\x0c\n\x04\x04j\x02\x03\x12\x04\x8b\x08\x08Q\n\r\n\x05\x04j\x02\x03\
    \x04\x12\x04\x8b\x08\x08\x10\n\r\n\x05\x04j\x02\x03\x06\x12\x04\x8b\x08\
    \x11\"\n\r\n\x05\x04j\x02\x03\x01\x12\x04\x8b\x08#)\n\r\n\x05\x04j\x02\
    \x03\x03\x12\x04\x8b\x08,-\n\r\n\x05\x04j\x02\x03\x08\x12\x04\x8b\x08.P\
    \n\r\n\x05\x04j\x02\x03\x07\x12\x04\x8b\x089O\n\x0c\n\x04\x04j\x02\x04\
    \x12\x04\x8c\x08\x08:\n\r\n\x05\x04j\x02\x04\x04\x12\x04\x8c\x08\x08\x10\
    \n\r\n\x05\x04j\x02\x04\x06\x12\x04\x8c\x08\x11/\n\r\n\x05\x04j\x02\x04\
    \x01\x12\x04\x8c\x0805\n\r\n\x05\x04j\x02\x04\x03\x12\x04\x8c\x0889\n\
    \x0c\n\x04\x04j\x02\x05\x12\x04\x8d\x08\x08'\n\r\n\x05\x04j\x02\x05\x04\
    \x12\x04\x8d\x08\x08\x10\n\r\n\x05\x04j\x02\x05\x05\x12\x04\x8d\x08\x11\
    \x15\n\r\n\x05\x04j\x02\x05\x01\x12\x04\x8d\x08\x16\"\n\r\n\x05\x04j\x02\
    \x05\x03\x12\x04\x8d\x08%&\n\x0c\n\x02\x04k\x12\x06\x90\x08\0\x92\x08\
    \x01\n\x0b\n\x03\x04k\x01\x12\x04\x90\x08\x08(\n\x0c\n\x04\x04k\x02\0\
    \x12\x04\x91\x08\x08\x1e\n\r\n\x05\x04k\x02\0\x04\x12\x04\x91\x08\x08\
    \x10\n\r\n\x05\x04k\x02\0\x05\x12\x04\x91\x08\x11\x15\n\r\n\x05\x04k\x02\
    \0\x01\x12\x04\x91\x08\x16\x19\n\r\n\x05\x04k\x02\0\x03\x12\x04\x91\x08\
    \x1c\x1d\n\x0c\n\x02\x04l\x12\x06\x94\x08\0\x95\x08\x01\n\x0b\n\x03\x04l\
    \x01\x12\x04\x94\x08\x085\n\x0c\n\x02\x04m\x12\x06\x97\x08\0\x9f\x08\x01\
    \n\x0b\n\x03\x04m\x01\x12\x04\x97\x08\x08%\n\x0c\n\x04\x04m\x02\0\x12\
    \x04\x98\x08\x08*\n\r\n\x05\x04m\x02\0\x04\x12\x04\x98\x08\x08\x10\n\r\n\
    \x05\x04m\x02\0\x05\x12\x04\x98\x08\x11\x17\n\r\n\x05\x04m\x02\0\x01\x12\
    \x04\x98\x08\x18%\n\r\n\x05\x04m\x02\0\x03\x12\x04\x98\x08()\n\x0c\n\x04\
    \x04m\x02\x01\x12\x04\x99\x08\x08&\n\r\n\x05\x04m\x02\x01\x04\x12\x04\
    \x99\x08\x08\x10\n\r\n\x05\x04m\x02\x01\x05\x12\x04\x99\x08\x11\x17\n\r\
    \n\x05\x04m\x02\x01\x01\x12\x04\x99\x08\x18!\n\r\n\x05\x04m\x02\x01\x03\
    \x12\x04\x99\x08$%\n\x0c\n\x04\x04m\x02\x02\x12\x04\x9a\x08\x08&\n\r\n\
    \x05\x04m\x02\x02\x04\x12\x04\x9a\x08\x08\x10\n\r\n\x05\x04m\x02\x02\x05\
    \x12\x04\x9a\x08\x11\x17\n\r\n\x05\x04m\x02\x02\x01\x12\x04\x9a\x08\x18!\
    \n\r\n\x05\x04m\x02\x02\x03\x12\x04\x9a\x08$%\n\x0c\n\x04\x04m\x02\x03\
    \x12\x04\x9b\x08\x08'\n\r\n\x05\x04m\x02\x03\x04\x12\x04\x9b\x08\x08\x10\
    \n\r\n\x05\x04m\x02\x03\x05\x12\x04\x9b\x08\x11\x17\n\r\n\x05\x04m\x02\
    \x03\x01\x12\x04\x9b\x08\x18\"\n\r\n\x05\x04m\x02\x03\x03\x12\x04\x9b\
    \x08%&\n\x0c\n\x04\x04m\x02\x04\x12\x04\x9c\x08\x08'\n\r\n\x05\x04m\x02\
    \x04\x04\x12\x04\x9c\x08\x08\x10\n\r\n\x05\x04m\x02\x04\x05\x12\x04\x9c\
    \x08\x11\x17\n\r\n\x05\x04m\x02\x04\x01\x12\x04\x9c\x08\x18\"\n\r\n\x05\
    \x04m\x02\x04\x03\x12\x04\x9c\x08%&\n\x0c\n\x04\x04m\x02\x05\x12\x04\x9d\
    \x08\x08-\n\r\n\x05\x04m\x02\x05\x04\x12\x04\x9d\x08\x08\x10\n\r\n\x05\
    \x04m\x02\x05\x05\x12\x04\x9d\x08\x11\x17\n\r\n\x05\x04m\x02\x05\x01\x12\
    \x04\x9d\x08\x18(\n\r\n\x05\x04m\x02\x05\x03\x12\x04\x9d\x08+,\n\x0c\n\
    \x04\x04m\x02\x06\x12\x04\x9e\x08\x08(\n\r\n\x05\x04m\x02\x06\x04\x12\
    \x04\x9e\x08\x08\x10\n\r\n\x05\x04m\x02\x06\x05\x12\x04\x9e\x08\x11\x16\
    \n\r\n\x05\x04m\x02\x06\x01\x12\x04\x9e\x08\x17#\n\r\n\x05\x04m\x02\x06\
    \x03\x12\x04\x9e\x08&'\n\x0c\n\x02\x04n\x12\x06\xa1\x08\0\xc0\x08\x01\n\
    \x0b\n\x03\x04n\x01\x12\x04\xa1\x08\x08\"\n\x0c\n\x04\x04n\x02\0\x12\x04\
    \xa2\x08\x08*\n\r\n\x05\x04n\x02\0\x04\x12\x04\xa2\x08\x08\x10\n\r\n\x05\
    \x04n\x02\0\x05\x12\x04\xa2\x08\x11\x17\n\r\n\x05\x04n\x02\0\x01\x12\x04\
    \xa2\x08\x18%\n\r\n\x05\x04n\x02\0\x03\x12\x04\xa2\x08()\n\x0c\n\x04\x04\
    n\x02\x01\x12\x04\xa3\x08\x08,\n\r\n\x05\x04n\x02\x01\x04\x12\x04\xa3\
    \x08\x08\x10\n\r\n\x05\x04n\x02\x01\x05\x12\x04\xa3\x08\x11\x18\n\r\n\
    \x05\x04n\x02\x01\x01\x12\x04\xa3\x08\x19'\n\r\n\x05\x04n\x02\x01\x03\
    \x12\x04\xa3\x08*+\n\x0c\n\x04\x04n\x02\x02\x12\x04\xa4\x08\x08*\n\r\n\
    \x05\x04n\x02\x02\x04\x12\x04\xa4\x08\x08\x10\n\r\n\x05\x04n\x02\x02\x05\
    \x12\x04\xa4\x08\x11\x15\n\r\n\x05\x04n\x02\x02\x01\x12\x04\xa4\x08\x16%\
    \n\r\n\x05\x04n\x02\x02\x03\x12\x04\xa4\x08()\n\x0c\n\x04\x04n\x02\x03\
    \x12\x04\xa5\x08\x08'\n\r\n\x05\x04n\x02\x03\x04\x12\x04\xa5\x08\x08\x10\
    \n\r\n\x05\x04n\x02\x03\x05\x12\x04\xa5\x08\x11\x17\n\r\n\x05\x04n\x02\
    \x03\x01\x12\x04\xa5\x08\x18\"\n\r\n\x05\x04n\x02\x03\x03\x12\x04\xa5\
    \x08%&\n\x0c\n\x04\x04n\x02\x04\x12\x04\xa6\x08\x08+\n\r\n\x05\x04n\x02\
    \x04\x04\x12\x04\xa6\x08\x08\x10\n\r\n\x05\x04n\x02\x04\x05\x12\x04\xa6\
    \x08\x11\x17\n\r\n\x05\x04n\x02\x04\x01\x12\x04\xa6\x08\x18&\n\r\n\x05\
    \x04n\x02\x04\x03\x12\x04\xa6\x08)*\n\x0c\n\x04\x04n\x02\x05\x12\x04\xa7\
    \x08\x08-\n\r\n\x05\x04n\x02\x05\x04\x12\x04\xa7\x08\x08\x10\n\r\n\x05\
    \x04n\x02\x05\x05\x12\x04\xa7\x08\x11\x17\n\r\n\x05\x04n\x02\x05\x01\x12\
    \x04\xa7\x08\x18(\n\r\n\x05\x04n\x02\x05\x03\x12\x04\xa7\x08+,\n\x0c\n\
    \x04\x04n\x02\x06\x12\x04\xa8\x08\x08&\n\r\n\x05\x04n\x02\x06\x04\x12\
    \x04\xa8\x08\x08\x10\n\r\n\x05\x04n\x02\x06\x05\x12\x04\xa8\x08\x11\x17\
    \n\r\n\x05\x04n\x02\x06\x01\x12\x04\xa8\x08\x18!\n\r\n\x05\x04n\x02\x06\
    \x03\x12\x04\xa8\x08$%\n\x0c\n\x04\x04n\x02\x07\x12\x04\xa9\x08\x08'\n\r\
    \n\x05\x04n\x02\x07\x04\x12\x04\xa9\x08\x08\x10\n\r\n\x05\x04n\x02\x07\
    \x05\x12\x04\xa9\x08\x11\x17\n\r\n\x05\x04n\x02\x07\x01\x12\x04\xa9\x08\
    \x18\"\n\r\n\x05\x04n\x02\x07\x03\x12\x04\xa9\x08%&\n\x0c\n\x04\x04n\x02\
    \x08\x12\x04\xaa\x08\x08(\n\r\n\x05\x04n\x02\x08\x04\x12\x04\xaa\x08\x08\
    \x10\n\r\n\x05\x04n\x02\x08\x05\x12\x04\xaa\x08\x11\x17\n\r\n\x05\x04n\
    \x02\x08\x01\x12\x04\xaa\x08\x18#\n\r\n\x05\x04n\x02\x08\x03\x12\x04\xaa\
    \x08&'\n\x0c\n\x04\x04n\x02\t\x12\x04\xab\x08\x08'\n\r\n\x05\x04n\x02\t\
    \x04\x12\x04\xab\x08\x08\x10\n\r\n\x05\x04n\x02\t\x05\x12\x04\xab\x08\
    \x11\x17\n\r\n\x05\x04n\x02\t\x01\x12\x04\xab\x08\x18!\n\r\n\x05\x04n\
    \x02\t\x03\x12\x04\xab\x08$&\n\x0c\n\x04\x04n\x02\n\x12\x04\xac\x08\x08,\
    \n\r\n\x05\x04n\x02\n\x04\x12\x04\xac\x08\x08\x10\n\r\n\x05\x04n\x02\n\
    \x05\x12\x04\xac\x08\x11\x17\n\r\n\x05\x04n\x02\n\x01\x12\x04\xac\x08\
    \x18&\n\r\n\x05\x04n\x02\n\x03\x12\x04\xac\x08)+\n\x0c\n\x04\x04n\x02\
    \x0b\x12\x04\xad\x08\x08,\n\r\n\x05\x04n\x02\x0b\x04\x12\x04\xad\x08\x08\
    \x10\n\r\n\x05\x04n\x02\x0b\x05\x12\x04\xad\x08\x11\x17\n\r\n\x05\x04n\
    \x02\x0b\x01\x12\x04\xad\x08\x18&\n\r\n\x05\x04n\x02\x0b\x03\x12\x04\xad\
    \x08)+\n\x0c\n\x04\x04n\x02\x0c\x12\x04\xae\x08\x08'\n\r\n\x05\x04n\x02\
    \x0c\x04\x12\x04\xae\x08\x08\x10\n\r\n\x05\x04n\x02\x0c\x05\x12\x04\xae\
    \x08\x11\x17\n\r\n\x05\x04n\x02\x0c\x01\x12\x04\xae\x08\x18!\n\r\n\x05\
    \x04n\x02\x0c\x03\x12\x04\xae\x08$&\n\x0c\n\x04\x04n\x02\r\x12\x04\xaf\
    \x08\x08(\n\r\n\x05\x04n\x02\r\x04\x12\x04\xaf\x08\x08\x10\n\r\n\x05\x04\
    n\x02\r\x05\x12\x04\xaf\x08\x11\x17\n\r\n\x05\x04n\x02\r\x01\x12\x04\xaf\
    \x08\x18\"\n\r\n\x05\x04n\x02\r\x03\x12\x04\xaf\x08%'\n\x0c\n\x04\x04n\
    \x02\x0e\x12\x04\xb0\x08\x08)\n\r\n\x05\x04n\x02\x0e\x04\x12\x04\xb0\x08\
    \x08\x10\n\r\n\x05\x04n\x02\x0e\x05\x12\x04\xb0\x08\x11\x17\n\r\n\x05\
    \x04n\x02\x0e\x01\x12\x04\xb0\x08\x18#\n\r\n\x05\x04n\x02\x0e\x03\x12\
    \x04\xb0\x08&(\n\x0c\n\x04\x04n\x02\x0f\x12\x04\xb1\x08\x08&\n\r\n\x05\
    \x04n\x02\x0f\x04\x12\x04\xb1\x08\x08\x10\n\r\n\x05\x04n\x02\x0f\x05\x12\
    \x04\xb1\x08\x11\x17\n\r\n\x05\x04n\x02\x0f\x01\x12\x04\xb1\x08\x18\x20\
    \n\r\n\x05\x04n\x02\x0f\x03\x12\x04\xb1\x08#%\n\x0c\n\x04\x04n\x02\x10\
    \x12\x04\xb2\x08\x08'\n\r\n\x05\x04n\x02\x10\x04\x12\x04\xb2\x08\x08\x10\
    \n\r\n\x05\x04n\x02\x10\x05\x12\x04\xb2\x08\x11\x17\n\r\n\x05\x04n\x02\
    \x10\x01\x12\x04\xb2\x08\x18!\n\r\n\x05\x04n\x02\x10\x03\x12\x04\xb2\x08\
    $&\n\x0c\n\x04\x04n\x02\x11\x12\x04\xb3\x08\x08'\n\r\n\x05\x04n\x02\x11\
    \x04\x12\x04\xb3\x08\x08\x10\n\r\n\x05\x04n\x02\x11\x05\x12\x04\xb3\x08\
    \x11\x17\n\r\n\x05\x04n\x02\x11\x01\x12\x04\xb3\x08\x18!\n\r\n\x05\x04n\
    \x02\x11\x03\x12\x04\xb3\x08$&\n\x0c\n\x04\x04n\x02\x12\x12\x04\xb4\x08\
    \x08&\n\r\n\x05\x04n\x02\x12\x04\x12\x04\xb4\x08\x08\x10\n\r\n\x05\x04n\
    \x02\x12\x05\x12\x04\xb4\x08\x11\x17\n\r\n\x05\x04n\x02\x12\x01\x12\x04\
    \xb4\x08\x18\x20\n\r\n\x05\x04n\x02\x12\x03\x12\x04\xb4\x08#%\n\x0c\n\
    \x04\x04n\x02\x13\x12\x04\xb5\x08\x08%\n\r\n\x05\x04n\x02\x13\x04\x12\
    \x04\xb5\x08\x08\x10\n\r\n\x05\x04n\x02\x13\x05\x12\x04\xb5\x08\x11\x17\
    \n\r\n\x05\x04n\x02\x13\x01\x12\x04\xb5\x08\x18\x1f\n\r\n\x05\x04n\x02\
    \x13\x03\x12\x04\xb5\x08\"$\n\x0c\n\x04\x04n\x02\x14\x12\x04\xb6\x08\x08\
    *\n\r\n\x05\x04n\x02\x14\x04\x12\x04\xb6\x08\x08\x10\n\r\n\x05\x04n\x02\
    \x14\x05\x12\x04\xb6\x08\x11\x17\n\r\n\x05\x04n\x02\x14\x01\x12\x04\xb6\
    \x08\x18$\n\r\n\x05\x04n\x02\x14\x03\x12\x04\xb6\x08')\n\x0c\n\x04\x04n\
    \x02\x15\x12\x04\xb7\x08\x08)\n\r\n\x05\x04n\x02\x15\x04\x12\x04\xb7\x08\
    \x08\x10\n\r\n\x05\x04n\x02\x15\x05\x12\x04\xb7\x08\x11\x17\n\r\n\x05\
    \x04n\x02\x15\x01\x12\x04\xb7\x08\x18#\n\r\n\x05\x04n\x02\x15\x03\x12\
    \x04\xb7\x08&(\n\x0c\n\x04\x04n\x02\x16\x12\x04\xb8\x08\x08*\n\r\n\x05\
    \x04n\x02\x16\x04\x12\x04\xb8\x08\x08\x10\n\r\n\x05\x04n\x02\x16\x05\x12\
    \x04\xb8\x08\x11\x17\n\r\n\x05\x04n\x02\x16\x01\x12\x04\xb8\x08\x18$\n\r\
    \n\x05\x04n\x02\x16\x03\x12\x04\xb8\x08')\n\x0c\n\x04\x04n\x02\x17\x12\
    \x04\xb9\x08\x08+\n\r\n\x05\x04n\x02\x17\x04\x12\x04\xb9\x08\x08\x10\n\r\
    \n\x05\x04n\x02\x17\x05\x12\x04\xb9\x08\x11\x17\n\r\n\x05\x04n\x02\x17\
    \x01\x12\x04\xb9\x08\x18%\n\r\n\x05\x04n\x02\x17\x03\x12\x04\xb9\x08(*\n\
    \x0c\n\x04\x04n\x02\x18\x12\x04\xba\x08\x08(\n\r\n\x05\x04n\x02\x18\x04\
    \x12\x04\xba\x08\x08\x10\n\r\n\x05\x04n\x02\x18\x05\x12\x04\xba\x08\x11\
    \x17\n\r\n\x05\x04n\x02\x18\x01\x12\x04\xba\x08\x18\"\n\r\n\x05\x04n\x02\
    \x18\x03\x12\x04\xba\x08%'\n\x0c\n\x04\x04n\x02\x19\x12\x04\xbb\x08\x08)\
    \n\r\n\x05\x04n\x02\x19\x04\x12\x04\xbb\x08\x08\x10\n\r\n\x05\x04n\x02\
    \x19\x05\x12\x04\xbb\x08\x11\x17\n\r\n\x05\x04n\x02\x19\x01\x12\x04\xbb\
    \x08\x18#\n\r\n\x05\x04n\x02\x19\x03\x12\x04\xbb\x08&(\n\x0c\n\x04\x04n\
    \x02\x1a\x12\x04\xbc\x08\x08)\n\r\n\x05\x04n\x02\x1a\x04\x12\x04\xbc\x08\
    \x08\x10\n\r\n\x05\x04n\x02\x1a\x05\x12\x04\xbc\x08\x11\x17\n\r\n\x05\
    \x04n\x02\x1a\x01\x12\x04\xbc\x08\x18#\n\r\n\x05\x04n\x02\x1a\x03\x12\
    \x04\xbc\x08&(\n\x0c\n\x04\x04n\x02\x1b\x12\x04\xbd\x08\x08(\n\r\n\x05\
    \x04n\x02\x1b\x04\x12\x04\xbd\x08\x08\x10\n\r\n\x05\x04n\x02\x1b\x05\x12\
    \x04\xbd\x08\x11\x17\n\r\n\x05\x04n\x02\x1b\x01\x12\x04\xbd\x08\x18\"\n\
    \r\n\x05\x04n\x02\x1b\x03\x12\x04\xbd\x08%'\n\x0c\n\x04\x04n\x02\x1c\x12\
    \x04\xbe\x08\x08'\n\r\n\x05\x04n\x02\x1c\x04\x12\x04\xbe\x08\x08\x10\n\r\
    \n\x05\x04n\x02\x1c\x05\x12\x04\xbe\x08\x11\x17\n\r\n\x05\x04n\x02\x1c\
    \x01\x12\x04\xbe\x08\x18!\n\r\n\x05\x04n\x02\x1c\x03\x12\x04\xbe\x08$&\n\
    \x0c\n\x04\x04n\x02\x1d\x12\x04\xbf\x08\x08,\n\r\n\x05\x04n\x02\x1d\x04\
    \x12\x04\xbf\x08\x08\x10\n\r\n\x05\x04n\x02\x1d\x05\x12\x04\xbf\x08\x11\
    \x17\n\r\n\x05\x04n\x02\x1d\x01\x12\x04\xbf\x08\x18&\n\r\n\x05\x04n\x02\
    \x1d\x03\x12\x04\xbf\x08)+\n\x0c\n\x02\x04o\x12\x06\xc2\x08\0\xc9\x08\
    \x01\n\x0b\n\x03\x04o\x01\x12\x04\xc2\x08\x08,\n\x0e\n\x04\x04o\x03\0\
    \x12\x06\xc3\x08\x08\xc5\x08\t\n\r\n\x05\x04o\x03\0\x01\x12\x04\xc3\x08\
    \x10\x16\n\x0e\n\x06\x04o\x03\0\x02\0\x12\x04\xc4\x08\x10.\n\x0f\n\x07\
    \x04o\x03\0\x02\0\x04\x12\x04\xc4\x08\x10\x18\n\x0f\n\x07\x04o\x03\0\x02\
    \0\x05\x12\x04\xc4\x08\x19\x20\n\x0f\n\x07\x04o\x03\0\x02\0\x01\x12\x04\
    \xc4\x08!)\n\x0f\n\x07\x04o\x03\0\x02\0\x03\x12\x04\xc4\x08,-\n\x0c\n\
    \x04\x04o\x02\0\x12\x04\xc7\x08\x08J\n\r\n\x05\x04o\x02\0\x04\x12\x04\
    \xc7\x08\x08\x10\n\r\n\x05\x04o\x02\0\x06\x12\x04\xc7\x08\x11=\n\r\n\x05\
    \x04o\x02\0\x01\x12\x04\xc7\x08>E\n\r\n\x05\x04o\x02\0\x03\x12\x04\xc7\
    \x08HI\n\x0c\n\x04\x04o\x02\x01\x12\x04\xc8\x08\x08+\n\r\n\x05\x04o\x02\
    \x01\x04\x12\x04\xc8\x08\x08\x10\n\r\n\x05\x04o\x02\x01\x05\x12\x04\xc8\
    \x08\x11\x17\n\r\n\x05\x04o\x02\x01\x01\x12\x04\xc8\x08\x18&\n\r\n\x05\
    \x04o\x02\x01\x03\x12\x04\xc8\x08)*\n\x0c\n\x02\x04p\x12\x06\xcb\x08\0\
    \xcd\x08\x01\n\x0b\n\x03\x04p\x01\x12\x04\xcb\x08\x08\x19\n\x0c\n\x04\
    \x04p\x02\0\x12\x04\xcc\x08\x08\"\n\r\n\x05\x04p\x02\0\x04\x12\x04\xcc\
    \x08\x08\x10\n\r\n\x05\x04p\x02\0\x05\x12\x04\xcc\x08\x11\x17\n\r\n\x05\
    \x04p\x02\0\x01\x12\x04\xcc\x08\x18\x1d\n\r\n\x05\x04p\x02\0\x03\x12\x04\
    \xcc\x08\x20!\n\x0c\n\x02\x04q\x12\x06\xcf\x08\0\xd6\x08\x01\n\x0b\n\x03\
    \x04q\x01\x12\x04\xcf\x08\x08)\n\x0c\n\x04\x04q\x02\0\x12\x04\xd0\x08\
    \x08&\n\r\n\x05\x04q\x02\0\x04\x12\x04\xd0\x08\x08\x10\n\r\n\x05\x04q\
    \x02\0\x05\x12\x04\xd0\x08\x11\x17\n\r\n\x05\x04q\x02\0\x01\x12\x04\xd0\
    \x08\x18!\n\r\n\x05\x04q\x02\0\x03\x12\x04\xd0\x08$%\n\x0c\n\x04\x04q\
    \x02\x01\x12\x04\xd1\x08\x08)\n\r\n\x05\x04q\x02\x01\x04\x12\x04\xd1\x08\
    \x08\x10\n\r\n\x05\x04q\x02\x01\x05\x12\x04\xd1\x08\x11\x17\n\r\n\x05\
    \x04q\x02\x01\x01\x12\x04\xd1\x08\x18$\n\r\n\x05\x04q\x02\x01\x03\x12\
    \x04\xd1\x08'(\n\x0c\n\x04\x04q\x02\x02\x12\x04\xd2\x08\x08,\n\r\n\x05\
    \x04q\x02\x02\x04\x12\x04\xd2\x08\x08\x10\n\r\n\x05\x04q\x02\x02\x05\x12\
    \x04\xd2\x08\x11\x17\n\r\n\x05\x04q\x02\x02\x01\x12\x04\xd2\x08\x18'\n\r\
    \n\x05\x04q\x02\x02\x03\x12\x04\xd2\x08*+\n\x0c\n\x04\x04q\x02\x03\x12\
    \x04\xd3\x08\x08.\n\r\n\x05\x04q\x02\x03\x04\x12\x04\xd3\x08\x08\x10\n\r\
    \n\x05\x04q\x02\x03\x05\x12\x04\xd3\x08\x11\x17\n\r\n\x05\x04q\x02\x03\
    \x01\x12\x04\xd3\x08\x18)\n\r\n\x05\x04q\x02\x03\x03\x12\x04\xd3\x08,-\n\
    \x0c\n\x04\x04q\x02\x04\x12\x04\xd4\x08\x08)\n\r\n\x05\x04q\x02\x04\x04\
    \x12\x04\xd4\x08\x08\x10\n\r\n\x05\x04q\x02\x04\x05\x12\x04\xd4\x08\x11\
    \x17\n\r\n\x05\x04q\x02\x04\x01\x12\x04\xd4\x08\x18$\n\r\n\x05\x04q\x02\
    \x04\x03\x12\x04\xd4\x08'(\n\x0c\n\x04\x04q\x02\x05\x12\x04\xd5\x08\x08*\
    \n\r\n\x05\x04q\x02\x05\x04\x12\x04\xd5\x08\x08\x10\n\r\n\x05\x04q\x02\
    \x05\x05\x12\x04\xd5\x08\x11\x17\n\r\n\x05\x04q\x02\x05\x01\x12\x04\xd5\
    \x08\x18%\n\r\n\x05\x04q\x02\x05\x03\x12\x04\xd5\x08()\n\x0c\n\x02\x04r\
    \x12\x06\xd8\x08\0\xe3\x08\x01\n\x0b\n\x03\x04r\x01\x12\x04\xd8\x08\x08I\
    \n\x0c\n\x04\x04r\x02\0\x12\x04\xd9\x08\x08&\n\r\n\x05\x04r\x02\0\x04\
    \x12\x04\xd9\x08\x08\x10\n\r\n\x05\x04r\x02\0\x05\x12\x04\xd9\x08\x11\
    \x17\n\r\n\x05\x04r\x02\0\x01\x12\x04\xd9\x08\x18!\n\r\n\x05\x04r\x02\0\
    \x03\x12\x04\xd9\x08$%\n\x0c\n\x04\x04r\x02\x01\x12\x04\xda\x08\x08%\n\r\
    \n\x05\x04r\x02\x01\x04\x12\x04\xda\x08\x08\x10\n\r\n\x05\x04r\x02\x01\
    \x05\x12\x04\xda\x08\x11\x17\n\r\n\x05\x04r\x02\x01\x01\x12\x04\xda\x08\
    \x18\x20\n\r\n\x05\x04r\x02\x01\x03\x12\x04\xda\x08#$\n\x0c\n\x04\x04r\
    \x02\x02\x12\x04\xdb\x08\x08)\n\r\n\x05\x04r\x02\x02\x04\x12\x04\xdb\x08\
    \x08\x10\n\r\n\x05\x04r\x02\x02\x05\x12\x04\xdb\x08\x11\x17\n\r\n\x05\
    \x04r\x02\x02\x01\x12\x04\xdb\x08\x18$\n\r\n\x05\x04r\x02\x02\x03\x12\
    \x04\xdb\x08'(\n\x0c\n\x04\x04r\x02\x03\x12\x04\xdc\x08\x08,\n\r\n\x05\
    \x04r\x02\x03\x04\x12\x04\xdc\x08\x08\x10\n\r\n\x05\x04r\x02\x03\x05\x12\
    \x04\xdc\x08\x11\x17\n\r\n\x05\x04r\x02\x03\x01\x12\x04\xdc\x08\x18'\n\r\
    \n\x05\x04r\x02\x03\x03\x12\x04\xdc\x08*+\n\x0c\n\x04\x04r\x02\x04\x12\
    \x04\xdd\x08\x08'\n\r\n\x05\x04r\x02\x04\x04\x12\x04\xdd\x08\x08\x10\n\r\
    \n\x05\x04r\x02\x04\x05\x12\x04\xdd\x08\x11\x17\n\r\n\x05\x04r\x02\x04\
    \x01\x12\x04\xdd\x08\x18\"\n\r\n\x05\x04r\x02\x04\x03\x12\x04\xdd\x08%&\
    \n\x0c\n\x04\x04r\x02\x05\x12\x04\xde\x08\x08.\n\r\n\x05\x04r\x02\x05\
    \x04\x12\x04\xde\x08\x08\x10\n\r\n\x05\x04r\x02\x05\x05\x12\x04\xde\x08\
    \x11\x17\n\r\n\x05\x04r\x02\x05\x01\x12\x04\xde\x08\x18)\n\r\n\x05\x04r\
    \x02\x05\x03\x12\x04\xde\x08,-\n\x0c\n\x04\x04r\x02\x06\x12\x04\xdf\x08\
    \x08)\n\r\n\x05\x04r\x02\x06\x04\x12\x04\xdf\x08\x08\x10\n\r\n\x05\x04r\
    \x02\x06\x05\x12\x04\xdf\x08\x11\x17\n\r\n\x05\x04r\x02\x06\x01\x12\x04\
    \xdf\x08\x18$\n\r\n\x05\x04r\x02\x06\x03\x12\x04\xdf\x08'(\n\x0c\n\x04\
    \x04r\x02\x07\x12\x04\xe0\x08\x08'\n\r\n\x05\x04r\x02\x07\x04\x12\x04\
    \xe0\x08\x08\x10\n\r\n\x05\x04r\x02\x07\x05\x12\x04\xe0\x08\x11\x17\n\r\
    \n\x05\x04r\x02\x07\x01\x12\x04\xe0\x08\x18\"\n\r\n\x05\x04r\x02\x07\x03\
    \x12\x04\xe0\x08%&\n\x0c\n\x04\x04r\x02\x08\x12\x04\xe1\x08\x08*\n\r\n\
    \x05\x04r\x02\x08\x04\x12\x04\xe1\x08\x08\x10\n\r\n\x05\x04r\x02\x08\x05\
    \x12\x04\xe1\x08\x11\x17\n\r\n\x05\x04r\x02\x08\x01\x12\x04\xe1\x08\x18%\
    \n\r\n\x05\x04r\x02\x08\x03\x12\x04\xe1\x08()\n\x0c\n\x04\x04r\x02\t\x12\
    \x04\xe2\x08\x08-\n\r\n\x05\x04r\x02\t\x04\x12\x04\xe2\x08\x08\x10\n\r\n\
    \x05\x04r\x02\t\x05\x12\x04\xe2\x08\x11\x17\n\r\n\x05\x04r\x02\t\x01\x12\
    \x04\xe2\x08\x18'\n\r\n\x05\x04r\x02\t\x03\x12\x04\xe2\x08*,\n\x0c\n\x02\
    \x04s\x12\x06\xe5\x08\0\xe7\x08\x01\n\x0b\n\x03\x04s\x01\x12\x04\xe5\x08\
    \x08#\n\x0c\n\x04\x04s\x02\0\x12\x04\xe6\x08\x08!\n\r\n\x05\x04s\x02\0\
    \x04\x12\x04\xe6\x08\x08\x10\n\r\n\x05\x04s\x02\0\x05\x12\x04\xe6\x08\
    \x11\x17\n\r\n\x05\x04s\x02\0\x01\x12\x04\xe6\x08\x18\x1c\n\r\n\x05\x04s\
    \x02\0\x03\x12\x04\xe6\x08\x1f\x20\n\x0c\n\x02\x04t\x12\x06\xe9\x08\0\
    \xed\x08\x01\n\x0b\n\x03\x04t\x01\x12\x04\xe9\x08\x08\x20\n\x0c\n\x04\
    \x04t\x02\0\x12\x04\xea\x08\x08$\n\r\n\x05\x04t\x02\0\x04\x12\x04\xea\
    \x08\x08\x10\n\r\n\x05\x04t\x02\0\x05\x12\x04\xea\x08\x11\x17\n\r\n\x05\
    \x04t\x02\0\x01\x12\x04\xea\x08\x18\x1f\n\r\n\x05\x04t\x02\0\x03\x12\x04\
    \xea\x08\"#\n\x0c\n\x04\x04t\x02\x01\x12\x04\xeb\x08\x082\n\r\n\x05\x04t\
    \x02\x01\x04\x12\x04\xeb\x08\x08\x10\n\r\n\x05\x04t\x02\x01\x05\x12\x04\
    \xeb\x08\x11\x17\n\r\n\x05\x04t\x02\x01\x01\x12\x04\xeb\x08\x18-\n\r\n\
    \x05\x04t\x02\x01\x03\x12\x04\xeb\x0801\n\x0c\n\x04\x04t\x02\x02\x12\x04\
    \xec\x08\x08'\n\r\n\x05\x04t\x02\x02\x04\x12\x04\xec\x08\x08\x10\n\r\n\
    \x05\x04t\x02\x02\x05\x12\x04\xec\x08\x11\x17\n\r\n\x05\x04t\x02\x02\x01\
    \x12\x04\xec\x08\x18\"\n\r\n\x05\x04t\x02\x02\x03\x12\x04\xec\x08%&\n\
    \x0c\n\x02\x04u\x12\x06\xef\x08\0\xf4\x08\x01\n\x0b\n\x03\x04u\x01\x12\
    \x04\xef\x08\x08\x12\n\x0c\n\x04\x04u\x02\0\x12\x04\xf0\x08\x08<\n\r\n\
    \x05\x04u\x02\0\x04\x12\x04\xf0\x08\x08\x10\n\r\n\x05\x04u\x02\0\x05\x12\
    \x04\xf0\x08\x11\x17\n\r\n\x05\x04u\x02\0\x01\x12\x04\xf0\x08\x18\"\n\r\
    \n\x05\x04u\x02\0\x03\x12\x04\xf0\x08%&\n\r\n\x05\x04u\x02\0\x08\x12\x04\
    \xf0\x08';\n\x10\n\x08\x04u\x02\0\x08\xe0\xd4\x03\x12\x04\xf0\x08(:\n\
    \x0c\n\x04\x04u\x02\x01\x12\x04\xf1\x08\x088\n\r\n\x05\x04u\x02\x01\x04\
    \x12\x04\xf1\x08\x08\x10\n\r\n\x05\x04u\x02\x01\x05\x12\x04\xf1\x08\x11\
    \x17\n\r\n\x05\x04u\x02\x01\x01\x12\x04\xf1\x08\x18\x1e\n\r\n\x05\x04u\
    \x02\x01\x03\x12\x04\xf1\x08!\"\n\r\n\x05\x04u\x02\x01\x08\x12\x04\xf1\
    \x08#7\n\x10\n\x08\x04u\x02\x01\x08\xe0\xd4\x03\x12\x04\xf1\x08$6\n\x0c\
    \n\x04\x04u\x02\x02\x12\x04\xf2\x08\x08(\n\r\n\x05\x04u\x02\x02\x04\x12\
    \x04\xf2\x08\x08\x10\n\r\n\x05\x04u\x02\x02\x05\x12\x04\xf2\x08\x11\x17\
    \n\r\n\x05\x04u\x02\x02\x01\x12\x04\xf2\x08\x18#\n\r\n\x05\x04u\x02\x02\
    \x03\x12\x04\xf2\x08&'\n\x0c\n\x04\x04u\x02\x03\x12\x04\xf3\x08\x08*\n\r\
    \n\x05\x04u\x02\x03\x04\x12\x04\xf3\x08\x08\x10\n\r\n\x05\x04u\x02\x03\
    \x05\x12\x04\xf3\x08\x11\x17\n\r\n\x05\x04u\x02\x03\x01\x12\x04\xf3\x08\
    \x18%\n\r\n\x05\x04u\x02\x03\x03\x12\x04\xf3\x08()\n\x0c\n\x02\x04v\x12\
    \x06\xf6\x08\0\xfa\x08\x01\n\x0b\n\x03\x04v\x01\x12\x04\xf6\x08\x08%\n\
    \x0c\n\x04\x04v\x02\0\x12\x04\xf7\x08\x08&\n\r\n\x05\x04v\x02\0\x04\x12\
    \x04\xf7\x08\x08\x10\n\r\n\x05\x04v\x02\0\x05\x12\x04\xf7\x08\x11\x18\n\
    \r\n\x05\x04v\x02\0\x01\x12\x04\xf7\x08\x19!\n\r\n\x05\x04v\x02\0\x03\
    \x12\x04\xf7\x08$%\n\x0c\n\x04\x04v\x02\x01\x12\x04\xf8\x08\x08#\n\r\n\
    \x05\x04v\x02\x01\x04\x12\x04\xf8\x08\x08\x10\n\r\n\x05\x04v\x02\x01\x05\
    \x12\x04\xf8\x08\x11\x17\n\r\n\x05\x04v\x02\x01\x01\x12\x04\xf8\x08\x18\
    \x1e\n\r\n\x05\x04v\x02\x01\x03\x12\x04\xf8\x08!\"\n\x0c\n\x04\x04v\x02\
    \x02\x12\x04\xf9\x08\x08\"\n\r\n\x05\x04v\x02\x02\x04\x12\x04\xf9\x08\
    \x08\x10\n\r\n\x05\x04v\x02\x02\x05\x12\x04\xf9\x08\x11\x17\n\r\n\x05\
    \x04v\x02\x02\x01\x12\x04\xf9\x08\x18\x1d\n\r\n\x05\x04v\x02\x02\x03\x12\
    \x04\xf9\x08\x20!\n\x0c\n\x02\x04w\x12\x06\xfc\x08\0\xff\x08\x01\n\x0b\n\
    \x03\x04w\x01\x12\x04\xfc\x08\x08\x1c\n\x0c\n\x04\x04w\x02\0\x12\x04\xfd\
    \x08\x08(\n\r\n\x05\x04w\x02\0\x04\x12\x04\xfd\x08\x08\x10\n\r\n\x05\x04\
    w\x02\0\x05\x12\x04\xfd\x08\x11\x17\n\r\n\x05\x04w\x02\0\x01\x12\x04\xfd\
    \x08\x18#\n\r\n\x05\x04w\x02\0\x03\x12\x04\xfd\x08&'\n\x0c\n\x04\x04w\
    \x02\x01\x12\x04\xfe\x08\x08#\n\r\n\x05\x04w\x02\x01\x04\x12\x04\xfe\x08\
    \x08\x10\n\r\n\x05\x04w\x02\x01\x05\x12\x04\xfe\x08\x11\x17\n\r\n\x05\
    \x04w\x02\x01\x01\x12\x04\xfe\x08\x18\x1e\n\r\n\x05\x04w\x02\x01\x03\x12\
    \x04\xfe\x08!\"\n\x0c\n\x02\x04x\x12\x06\x81\t\0\x83\t\x01\n\x0b\n\x03\
    \x04x\x01\x12\x04\x81\t\x08'\n\x0c\n\x04\x04x\x02\0\x12\x04\x82\t\x08#\n\
    \r\n\x05\x04x\x02\0\x04\x12\x04\x82\t\x08\x10\n\r\n\x05\x04x\x02\0\x05\
    \x12\x04\x82\t\x11\x17\n\r\n\x05\x04x\x02\0\x01\x12\x04\x82\t\x18\x1e\n\
    \r\n\x05\x04x\x02\0\x03\x12\x04\x82\t!\"\n\x0c\n\x02\x04y\x12\x06\x85\t\
    \0\x8d\t\x01\n\x0b\n\x03\x04y\x01\x12\x04\x85\t\x08(\n\x0e\n\x04\x04y\
    \x03\0\x12\x06\x86\t\x08\x89\t\t\n\r\n\x05\x04y\x03\0\x01\x12\x04\x86\t\
    \x10\x19\n\x0e\n\x06\x04y\x03\0\x02\0\x12\x04\x87\t\x10)\n\x0f\n\x07\x04\
    y\x03\0\x02\0\x04\x12\x04\x87\t\x10\x18\n\x0f\n\x07\x04y\x03\0\x02\0\x05\
    \x12\x04\x87\t\x19\x1f\n\x0f\n\x07\x04y\x03\0\x02\0\x01\x12\x04\x87\t\
    \x20$\n\x0f\n\x07\x04y\x03\0\x02\0\x03\x12\x04\x87\t'(\n\x0e\n\x06\x04y\
    \x03\0\x02\x01\x12\x04\x88\t\x10*\n\x0f\n\x07\x04y\x03\0\x02\x01\x04\x12\
    \x04\x88\t\x10\x18\n\x0f\n\x07\x04y\x03\0\x02\x01\x05\x12\x04\x88\t\x19\
    \x1f\n\x0f\n\x07\x04y\x03\0\x02\x01\x01\x12\x04\x88\t\x20%\n\x0f\n\x07\
    \x04y\x03\0\x02\x01\x03\x12\x04\x88\t()\n\x0c\n\x04\x04y\x02\0\x12\x04\
    \x8b\t\x08M\n\r\n\x05\x04y\x02\0\x04\x12\x04\x8b\t\x08\x10\n\r\n\x05\x04\
    y\x02\0\x06\x12\x04\x8b\t\x11<\n\r\n\x05\x04y\x02\0\x01\x12\x04\x8b\t=H\
    \n\r\n\x05\x04y\x02\0\x03\x12\x04\x8b\tKL\n\x0c\n\x04\x04y\x02\x01\x12\
    \x04\x8c\t\x08#\n\r\n\x05\x04y\x02\x01\x04\x12\x04\x8c\t\x08\x10\n\r\n\
    \x05\x04y\x02\x01\x05\x12\x04\x8c\t\x11\x17\n\r\n\x05\x04y\x02\x01\x01\
    \x12\x04\x8c\t\x18\x1e\n\r\n\x05\x04y\x02\x01\x03\x12\x04\x8c\t!\"\n\x0c\
    \n\x02\x04z\x12\x06\x8f\t\0\x94\t\x01\n\x0b\n\x03\x04z\x01\x12\x04\x8f\t\
    \x087\n\x0c\n\x04\x04z\x02\0\x12\x04\x90\t\x08\"\n\r\n\x05\x04z\x02\0\
    \x04\x12\x04\x90\t\x08\x10\n\r\n\x05\x04z\x02\0\x05\x12\x04\x90\t\x11\
    \x17\n\r\n\x05\x04z\x02\0\x01\x12\x04\x90\t\x18\x1d\n\r\n\x05\x04z\x02\0\
    \x03\x12\x04\x90\t\x20!\n\x0c\n\x04\x04z\x02\x01\x12\x04\x91\t\x08!\n\r\
    \n\x05\x04z\x02\x01\x04\x12\x04\x91\t\x08\x10\n\r\n\x05\x04z\x02\x01\x05\
    \x12\x04\x91\t\x11\x17\n\r\n\x05\x04z\x02\x01\x01\x12\x04\x91\t\x18\x1c\
    \n\r\n\x05\x04z\x02\x01\x03\x12\x04\x91\t\x1f\x20\n\x0c\n\x04\x04z\x02\
    \x02\x12\x04\x92\t\x08$\n\r\n\x05\x04z\x02\x02\x04\x12\x04\x92\t\x08\x10\
    \n\r\n\x05\x04z\x02\x02\x05\x12\x04\x92\t\x11\x16\n\r\n\x05\x04z\x02\x02\
    \x01\x12\x04\x92\t\x17\x1f\n\r\n\x05\x04z\x02\x02\x03\x12\x04\x92\t\"#\n\
    \x0c\n\x04\x04z\x02\x03\x12\x04\x93\t\x08(\n\r\n\x05\x04z\x02\x03\x04\
    \x12\x04\x93\t\x08\x10\n\r\n\x05\x04z\x02\x03\x05\x12\x04\x93\t\x11\x17\
    \n\r\n\x05\x04z\x02\x03\x01\x12\x04\x93\t\x18#\n\r\n\x05\x04z\x02\x03\
    \x03\x12\x04\x93\t&'\n\x0c\n\x02\x04{\x12\x06\x96\t\0\x9e\t\x01\n\x0b\n\
    \x03\x04{\x01\x12\x04\x96\t\x08%\n\x0c\n\x04\x04{\x02\0\x12\x04\x97\t\
    \x08-\n\r\n\x05\x04{\x02\0\x04\x12\x04\x97\t\x08\x10\n\r\n\x05\x04{\x02\
    \0\x05\x12\x04\x97\t\x11\x17\n\r\n\x05\x04{\x02\0\x01\x12\x04\x97\t\x18(\
    \n\r\n\x05\x04{\x02\0\x03\x12\x04\x97\t+,\n\x0c\n\x04\x04{\x02\x01\x12\
    \x04\x98\t\x08!\n\r\n\x05\x04{\x02\x01\x04\x12\x04\x98\t\x08\x10\n\r\n\
    \x05\x04{\x02\x01\x05\x12\x04\x98\t\x11\x16\n\r\n\x05\x04{\x02\x01\x01\
    \x12\x04\x98\t\x17\x1c\n\r\n\x05\x04{\x02\x01\x03\x12\x04\x98\t\x1f\x20\
    \n\x0c\n\x04\x04{\x02\x02\x12\x04\x99\t\x08!\n\r\n\x05\x04{\x02\x02\x04\
    \x12\x04\x99\t\x08\x10\n\r\n\x05\x04{\x02\x02\x05\x12\x04\x99\t\x11\x16\
    \n\r\n\x05\x04{\x02\x02\x01\x12\x04\x99\t\x17\x1c\n\r\n\x05\x04{\x02\x02\
    \x03\x12\x04\x99\t\x1f\x20\n\x0c\n\x04\x04{\x02\x03\x12\x04\x9a\t\x08!\n\
    \r\n\x05\x04{\x02\x03\x04\x12\x04\x9a\t\x08\x10\n\r\n\x05\x04{\x02\x03\
    \x05\x12\x04\x9a\t\x11\x16\n\r\n\x05\x04{\x02\x03\x01\x12\x04\x9a\t\x17\
    \x1c\n\r\n\x05\x04{\x02\x03\x03\x12\x04\x9a\t\x1f\x20\n\x0c\n\x04\x04{\
    \x02\x04\x12\x04\x9b\t\x08!\n\r\n\x05\x04{\x02\x04\x04\x12\x04\x9b\t\x08\
    \x10\n\r\n\x05\x04{\x02\x04\x05\x12\x04\x9b\t\x11\x16\n\r\n\x05\x04{\x02\
    \x04\x01\x12\x04\x9b\t\x17\x1c\n\r\n\x05\x04{\x02\x04\x03\x12\x04\x9b\t\
    \x1f\x20\n\x0c\n\x04\x04{\x02\x05\x12\x04\x9c\t\x08!\n\r\n\x05\x04{\x02\
    \x05\x04\x12\x04\x9c\t\x08\x10\n\r\n\x05\x04{\x02\x05\x05\x12\x04\x9c\t\
    \x11\x16\n\r\n\x05\x04{\x02\x05\x01\x12\x04\x9c\t\x17\x1c\n\r\n\x05\x04{\
    \x02\x05\x03\x12\x04\x9c\t\x1f\x20\n\x0c\n\x04\x04{\x02\x06\x12\x04\x9d\
    \t\x08!\n\r\n\x05\x04{\x02\x06\x04\x12\x04\x9d\t\x08\x10\n\r\n\x05\x04{\
    \x02\x06\x05\x12\x04\x9d\t\x11\x16\n\r\n\x05\x04{\x02\x06\x01\x12\x04\
    \x9d\t\x17\x1c\n\r\n\x05\x04{\x02\x06\x03\x12\x04\x9d\t\x1f\x20\n\x0c\n\
    \x02\x04|\x12\x06\xa0\t\0\xaa\t\x01\n\x0b\n\x03\x04|\x01\x12\x04\xa0\t\
    \x08(\n\x0c\n\x04\x04|\x02\0\x12\x04\xa1\t\x08-\n\r\n\x05\x04|\x02\0\x04\
    \x12\x04\xa1\t\x08\x10\n\r\n\x05\x04|\x02\0\x05\x12\x04\xa1\t\x11\x17\n\
    \r\n\x05\x04|\x02\0\x01\x12\x04\xa1\t\x18(\n\r\n\x05\x04|\x02\0\x03\x12\
    \x04\xa1\t+,\n\x0c\n\x04\x04|\x02\x01\x12\x04\xa2\t\x08!\n\r\n\x05\x04|\
    \x02\x01\x04\x12\x04\xa2\t\x08\x10\n\r\n\x05\x04|\x02\x01\x05\x12\x04\
    \xa2\t\x11\x16\n\r\n\x05\x04|\x02\x01\x01\x12\x04\xa2\t\x17\x1c\n\r\n\
    \x05\x04|\x02\x01\x03\x12\x04\xa2\t\x1f\x20\n\x0c\n\x04\x04|\x02\x02\x12\
    \x04\xa3\t\x08!\n\r\n\x05\x04|\x02\x02\x04\x12\x04\xa3\t\x08\x10\n\r\n\
    \x05\x04|\x02\x02\x05\x12\x04\xa3\t\x11\x16\n\r\n\x05\x04|\x02\x02\x01\
    \x12\x04\xa3\t\x17\x1c\n\r\n\x05\x04|\x02\x02\x03\x12\x04\xa3\t\x1f\x20\
    \n\x0c\n\x04\x04|\x02\x03\x12\x04\xa4\t\x08!\n\r\n\x05\x04|\x02\x03\x04\
    \x12\x04\xa4\t\x08\x10\n\r\n\x05\x04|\x02\x03\x05\x12\x04\xa4\t\x11\x16\
    \n\r\n\x05\x04|\x02\x03\x01\x12\x04\xa4\t\x17\x1c\n\r\n\x05\x04|\x02\x03\
    \x03\x12\x04\xa4\t\x1f\x20\n\x0c\n\x04\x04|\x02\x04\x12\x04\xa5\t\x08!\n\
    \r\n\x05\x04|\x02\x04\x04\x12\x04\xa5\t\x08\x10\n\r\n\x05\x04|\x02\x04\
    \x05\x12\x04\xa5\t\x11\x16\n\r\n\x05\x04|\x02\x04\x01\x12\x04\xa5\t\x17\
    \x1c\n\r\n\x05\x04|\x02\x04\x03\x12\x04\xa5\t\x1f\x20\n\x0c\n\x04\x04|\
    \x02\x05\x12\x04\xa6\t\x08!\n\r\n\x05\x04|\x02\x05\x04\x12\x04\xa6\t\x08\
    \x10\n\r\n\x05\x04|\x02\x05\x05\x12\x04\xa6\t\x11\x16\n\r\n\x05\x04|\x02\
    \x05\x01\x12\x04\xa6\t\x17\x1c\n\r\n\x05\x04|\x02\x05\x03\x12\x04\xa6\t\
    \x1f\x20\n\x0c\n\x04\x04|\x02\x06\x12\x04\xa7\t\x08!\n\r\n\x05\x04|\x02\
    \x06\x04\x12\x04\xa7\t\x08\x10\n\r\n\x05\x04|\x02\x06\x05\x12\x04\xa7\t\
    \x11\x16\n\r\n\x05\x04|\x02\x06\x01\x12\x04\xa7\t\x17\x1c\n\r\n\x05\x04|\
    \x02\x06\x03\x12\x04\xa7\t\x1f\x20\n\x0c\n\x04\x04|\x02\x07\x12\x04\xa8\
    \t\x08+\n\r\n\x05\x04|\x02\x07\x04\x12\x04\xa8\t\x08\x10\n\r\n\x05\x04|\
    \x02\x07\x05\x12\x04\xa8\t\x11\x15\n\r\n\x05\x04|\x02\x07\x01\x12\x04\
    \xa8\t\x16&\n\r\n\x05\x04|\x02\x07\x03\x12\x04\xa8\t)*\n\x0c\n\x04\x04|\
    \x02\x08\x12\x04\xa9\t\x08(\n\r\n\x05\x04|\x02\x08\x04\x12\x04\xa9\t\x08\
    \x10\n\r\n\x05\x04|\x02\x08\x05\x12\x04\xa9\t\x11\x17\n\r\n\x05\x04|\x02\
    \x08\x01\x12\x04\xa9\t\x18#\n\r\n\x05\x04|\x02\x08\x03\x12\x04\xa9\t&'\n\
    \x0c\n\x02\x04}\x12\x06\xac\t\0\xaf\t\x01\n\x0b\n\x03\x04}\x01\x12\x04\
    \xac\t\x08\x19\n\x0c\n\x04\x04}\x02\0\x12\x04\xad\t\x08'\n\r\n\x05\x04}\
    \x02\0\x04\x12\x04\xad\t\x08\x10\n\r\n\x05\x04}\x02\0\x05\x12\x04\xad\t\
    \x11\x16\n\r\n\x05\x04}\x02\0\x01\x12\x04\xad\t\x17\"\n\r\n\x05\x04}\x02\
    \0\x03\x12\x04\xad\t%&\n\x0c\n\x04\x04}\x02\x01\x12\x04\xae\t\x081\n\r\n\
    \x05\x04}\x02\x01\x04\x12\x04\xae\t\x08\x10\n\r\n\x05\x04}\x02\x01\x05\
    \x12\x04\xae\t\x11\x17\n\r\n\x05\x04}\x02\x01\x01\x12\x04\xae\t\x18,\n\r\
    \n\x05\x04}\x02\x01\x03\x12\x04\xae\t/0\n\x0c\n\x02\x04~\x12\x06\xb1\t\0\
    \xc2\t\x01\n\x0b\n\x03\x04~\x01\x12\x04\xb1\t\x08\x16\n\x0e\n\x04\x04~\
    \x04\0\x12\x06\xb2\t\x08\xbb\t\t\n\r\n\x05\x04~\x04\0\x01\x12\x04\xb2\t\
    \r\x19\n\x0e\n\x06\x04~\x04\0\x02\0\x12\x04\xb3\t\x10!\n\x0f\n\x07\x04~\
    \x04\0\x02\0\x01\x12\x04\xb3\t\x10\x1c\n\x0f\n\x07\x04~\x04\0\x02\0\x02\
    \x12\x04\xb3\t\x1f\x20\n\x0e\n\x06\x04~\x04\0\x02\x01\x12\x04\xb4\t\x10+\
    \n\x0f\n\x07\x04~\x04\0\x02\x01\x01\x12\x04\xb4\t\x10&\n\x0f\n\x07\x04~\
    \x04\0\x02\x01\x02\x12\x04\xb4\t)*\n\x0e\n\x06\x04~\x04\0\x02\x02\x12\
    \x04\xb5\t\x10+\n\x0f\n\x07\x04~\x04\0\x02\x02\x01\x12\x04\xb5\t\x10&\n\
    \x0f\n\x07\x04~\x04\0\x02\x02\x02\x12\x04\xb5\t)*\n\x0e\n\x06\x04~\x04\0\
    \x02\x03\x12\x04\xb6\t\x10/\n\x0f\n\x07\x04~\x04\0\x02\x03\x01\x12\x04\
    \xb6\t\x10*\n\x0f\n\x07\x04~\x04\0\x02\x03\x02\x12\x04\xb6\t-.\n\x0e\n\
    \x06\x04~\x04\0\x02\x04\x12\x04\xb7\t\x10+\n\x0f\n\x07\x04~\x04\0\x02\
    \x04\x01\x12\x04\xb7\t\x10&\n\x0f\n\x07\x04~\x04\0\x02\x04\x02\x12\x04\
    \xb7\t)*\n\x0e\n\x06\x04~\x04\0\x02\x05\x12\x04\xb8\t\x10,\n\x0f\n\x07\
    \x04~\x04\0\x02\x05\x01\x12\x04\xb8\t\x10'\n\x0f\n\x07\x04~\x04\0\x02\
    \x05\x02\x12\x04\xb8\t*+\n\x0e\n\x06\x04~\x04\0\x02\x06\x12\x04\xb9\t\
    \x10-\n\x0f\n\x07\x04~\x04\0\x02\x06\x01\x12\x04\xb9\t\x10(\n\x0f\n\x07\
    \x04~\x04\0\x02\x06\x02\x12\x04\xb9\t+,\n\x0e\n\x06\x04~\x04\0\x02\x07\
    \x12\x04\xba\t\x10*\n\x0f\n\x07\x04~\x04\0\x02\x07\x01\x12\x04\xba\t\x10\
    %\n\x0f\n\x07\x04~\x04\0\x02\x07\x02\x12\x04\xba\t()\n\x0c\n\x04\x04~\
    \x02\0\x12\x04\xbd\t\x08d\n\r\n\x05\x04~\x02\0\x04\x12\x04\xbd\t\x08\x10\
    \n\r\n\x05\x04~\x02\0\x06\x12\x04\xbd\t\x11-\n\r\n\x05\x04~\x02\0\x01\
    \x12\x04\xbd\t.2\n\r\n\x05\x04~\x02\0\x03\x12\x04\xbd\t56\n\r\n\x05\x04~\
    \x02\0\x08\x12\x04\xbd\t7c\n\r\n\x05\x04~\x02\0\x07\x12\x04\xbd\tBN\n\
    \x10\n\x08\x04~\x02\0\x08\xe0\xd4\x03\x12\x04\xbd\tPb\n\x0c\n\x04\x04~\
    \x02\x01\x12\x04\xbe\t\x08\"\n\r\n\x05\x04~\x02\x01\x04\x12\x04\xbe\t\
    \x08\x10\n\r\n\x05\x04~\x02\x01\x05\x12\x04\xbe\t\x11\x16\n\r\n\x05\x04~\
    \x02\x01\x01\x12\x04\xbe\t\x17\x1d\n\r\n\x05\x04~\x02\x01\x03\x12\x04\
    \xbe\t\x20!\n\x0c\n\x04\x04~\x02\x02\x12\x04\xbf\t\x08'\n\r\n\x05\x04~\
    \x02\x02\x04\x12\x04\xbf\t\x08\x10\n\r\n\x05\x04~\x02\x02\x05\x12\x04\
    \xbf\t\x11\x16\n\r\n\x05\x04~\x02\x02\x01\x12\x04\xbf\t\x17\"\n\r\n\x05\
    \x04~\x02\x02\x03\x12\x04\xbf\t%&\n\x0c\n\x04\x04~\x02\x03\x12\x04\xc0\t\
    \x08<\n\r\n\x05\x04~\x02\x03\x04\x12\x04\xc0\t\x08\x10\n\r\n\x05\x04~\
    \x02\x03\x05\x12\x04\xc0\t\x11\x17\n\r\n\x05\x04~\x02\x03\x01\x12\x04\
    \xc0\t\x18\"\n\r\n\x05\x04~\x02\x03\x03\x12\x04\xc0\t%&\n\r\n\x05\x04~\
    \x02\x03\x08\x12\x04\xc0\t';\n\x10\n\x08\x04~\x02\x03\x08\xe0\xd4\x03\
    \x12\x04\xc0\t(:\n\x0c\n\x04\x04~\x02\x04\x12\x04\xc1\t\x08:\n\r\n\x05\
    \x04~\x02\x04\x04\x12\x04\xc1\t\x08\x10\n\r\n\x05\x04~\x02\x04\x05\x12\
    \x04\xc1\t\x11\x17\n\r\n\x05\x04~\x02\x04\x01\x12\x04\xc1\t\x18\x20\n\r\
    \n\x05\x04~\x02\x04\x03\x12\x04\xc1\t#$\n\r\n\x05\x04~\x02\x04\x08\x12\
    \x04\xc1\t%9\n\x10\n\x08\x04~\x02\x04\x08\xe0\xd4\x03\x12\x04\xc1\t&8\n\
    \x0c\n\x02\x04\x7f\x12\x06\xc4\t\0\xc6\t\x01\n\x0b\n\x03\x04\x7f\x01\x12\
    \x04\xc4\t\x08\x1f\n\x0c\n\x04\x04\x7f\x02\0\x12\x04\xc5\t\x08-\n\r\n\
    \x05\x04\x7f\x02\0\x04\x12\x04\xc5\t\x08\x10\n\r\n\x05\x04\x7f\x02\0\x06\
    \x12\x04\xc5\t\x11\x20\n\r\n\x05\x04\x7f\x02\0\x01\x12\x04\xc5\t!(\n\r\n\
    \x05\x04\x7f\x02\0\x03\x12\x04\xc5\t+,\n\r\n\x03\x04\x80\x01\x12\x06\xc8\
    \t\0\xcb\t\x01\n\x0c\n\x04\x04\x80\x01\x01\x12\x04\xc8\t\x08\x18\n\r\n\
    \x05\x04\x80\x01\x02\0\x12\x04\xc9\t\x08+\n\x0e\n\x06\x04\x80\x01\x02\0\
    \x04\x12\x04\xc9\t\x08\x10\n\x0e\n\x06\x04\x80\x01\x02\0\x05\x12\x04\xc9\
    \t\x11\x17\n\x0e\n\x06\x04\x80\x01\x02\0\x01\x12\x04\xc9\t\x18&\n\x0e\n\
    \x06\x04\x80\x01\x02\0\x03\x12\x04\xc9\t)*\n\r\n\x05\x04\x80\x01\x02\x01\
    \x12\x04\xca\t\x08$\n\x0e\n\x06\x04\x80\x01\x02\x01\x04\x12\x04\xca\t\
    \x08\x10\n\x0e\n\x06\x04\x80\x01\x02\x01\x05\x12\x04\xca\t\x11\x16\n\x0e\
    \n\x06\x04\x80\x01\x02\x01\x01\x12\x04\xca\t\x17\x1f\n\x0e\n\x06\x04\x80\
    \x01\x02\x01\x03\x12\x04\xca\t\"#\n\r\n\x03\x04\x81\x01\x12\x06\xcd\t\0\
    \xdc\t\x01\n\x0c\n\x04\x04\x81\x01\x01\x12\x04\xcd\t\x08\x1a\n\x0f\n\x05\
    \x04\x81\x01\x04\0\x12\x06\xce\t\x08\xd5\t\t\n\x0e\n\x06\x04\x81\x01\x04\
    \0\x01\x12\x04\xce\t\r\x1d\n\x0f\n\x07\x04\x81\x01\x04\0\x02\0\x12\x04\
    \xcf\t\x108\n\x10\n\x08\x04\x81\x01\x04\0\x02\0\x01\x12\x04\xcf\t\x103\n\
    \x10\n\x08\x04\x81\x01\x04\0\x02\0\x02\x12\x04\xcf\t67\n\x0f\n\x07\x04\
    \x81\x01\x04\0\x02\x01\x12\x04\xd0\t\x10/\n\x10\n\x08\x04\x81\x01\x04\0\
    \x02\x01\x01\x12\x04\xd0\t\x10*\n\x10\n\x08\x04\x81\x01\x04\0\x02\x01\
    \x02\x12\x04\xd0\t-.\n\x0f\n\x07\x04\x81\x01\x04\0\x02\x02\x12\x04\xd1\t\
    \x10A\n\x10\n\x08\x04\x81\x01\x04\0\x02\x02\x01\x12\x04\xd1\t\x10<\n\x10\
    \n\x08\x04\x81\x01\x04\0\x02\x02\x02\x12\x04\xd1\t?@\n\x0f\n\x07\x04\x81\
    \x01\x04\0\x02\x03\x12\x04\xd2\t\x10<\n\x10\n\x08\x04\x81\x01\x04\0\x02\
    \x03\x01\x12\x04\xd2\t\x107\n\x10\n\x08\x04\x81\x01\x04\0\x02\x03\x02\
    \x12\x04\xd2\t:;\n\x0f\n\x07\x04\x81\x01\x04\0\x02\x04\x12\x04\xd3\t\x10\
    1\n\x10\n\x08\x04\x81\x01\x04\0\x02\x04\x01\x12\x04\xd3\t\x10,\n\x10\n\
    \x08\x04\x81\x01\x04\0\x02\x04\x02\x12\x04\xd3\t/0\n\x0f\n\x07\x04\x81\
    \x01\x04\0\x02\x05\x12\x04\xd4\t\x10+\n\x10\n\x08\x04\x81\x01\x04\0\x02\
    \x05\x01\x12\x04\xd4\t\x10&\n\x10\n\x08\x04\x81\x01\x04\0\x02\x05\x02\
    \x12\x04\xd4\t)*\n\r\n\x05\x04\x81\x01\x02\0\x12\x04\xd7\t\x08A\n\x0e\n\
    \x06\x04\x81\x01\x02\0\x04\x12\x04\xd7\t\x08\x10\n\x0e\n\x06\x04\x81\x01\
    \x02\0\x05\x12\x04\xd7\t\x11\x17\n\x0e\n\x06\x04\x81\x01\x02\0\x01\x12\
    \x04\xd7\t\x18'\n\x0e\n\x06\x04\x81\x01\x02\0\x03\x12\x04\xd7\t*+\n\x0e\
    \n\x06\x04\x81\x01\x02\0\x08\x12\x04\xd7\t,@\n\x11\n\t\x04\x81\x01\x02\0\
    \x08\xe0\xd4\x03\x12\x04\xd7\t-?\n\r\n\x05\x04\x81\x01\x02\x01\x12\x04\
    \xd8\t\x08'\n\x0e\n\x06\x04\x81\x01\x02\x01\x04\x12\x04\xd8\t\x08\x10\n\
    \x0e\n\x06\x04\x81\x01\x02\x01\x05\x12\x04\xd8\t\x11\x17\n\x0e\n\x06\x04\
    \x81\x01\x02\x01\x01\x12\x04\xd8\t\x18\"\n\x0e\n\x06\x04\x81\x01\x02\x01\
    \x03\x12\x04\xd8\t%&\n\r\n\x05\x04\x81\x01\x02\x02\x12\x04\xd9\t\x08-\n\
    \x0e\n\x06\x04\x81\x01\x02\x02\x04\x12\x04\xd9\t\x08\x10\n\x0e\n\x06\x04\
    \x81\x01\x02\x02\x05\x12\x04\xd9\t\x11\x18\n\x0e\n\x06\x04\x81\x01\x02\
    \x02\x01\x12\x04\xd9\t\x19(\n\x0e\n\x06\x04\x81\x01\x02\x02\x03\x12\x04\
    \xd9\t+,\n\r\n\x05\x04\x81\x01\x02\x03\x12\x04\xda\t\x08f\n\x0e\n\x06\
    \x04\x81\x01\x02\x03\x04\x12\x04\xda\t\x08\x10\n\x0e\n\x06\x04\x81\x01\
    \x02\x03\x06\x12\x04\xda\t\x115\n\x0e\n\x06\x04\x81\x01\x02\x03\x01\x12\
    \x04\xda\t6:\n\x0e\n\x06\x04\x81\x01\x02\x03\x03\x12\x04\xda\t=>\n\x0e\n\
    \x06\x04\x81\x01\x02\x03\x08\x12\x04\xda\t?e\n\x0e\n\x06\x04\x81\x01\x02\
    \x03\x07\x12\x04\xda\tJd\n\r\n\x05\x04\x81\x01\x02\x04\x12\x04\xdb\t\x08\
    0\n\x0e\n\x06\x04\x81\x01\x02\x04\x04\x12\x04\xdb\t\x08\x10\n\x0e\n\x06\
    \x04\x81\x01\x02\x04\x05\x12\x04\xdb\t\x11\x17\n\x0e\n\x06\x04\x81\x01\
    \x02\x04\x01\x12\x04\xdb\t\x18+\n\x0e\n\x06\x04\x81\x01\x02\x04\x03\x12\
    \x04\xdb\t./\n\r\n\x03\x04\x82\x01\x12\x06\xde\t\0\xe0\t\x01\n\x0c\n\x04\
    \x04\x82\x01\x01\x12\x04\xde\t\x08\x1f\n\r\n\x05\x04\x82\x01\x02\0\x12\
    \x04\xdf\t\x087\n\x0e\n\x06\x04\x82\x01\x02\0\x04\x12\x04\xdf\t\x08\x10\
    \n\x0e\n\x06\x04\x82\x01\x02\0\x06\x12\x04\xdf\t\x11$\n\x0e\n\x06\x04\
    \x82\x01\x02\0\x01\x12\x04\xdf\t%2\n\x0e\n\x06\x04\x82\x01\x02\0\x03\x12\
    \x04\xdf\t56\n\r\n\x03\x04\x83\x01\x12\x06\xe2\t\0\xe5\t\x01\n\x0c\n\x04\
    \x04\x83\x01\x01\x12\x04\xe2\t\x08#\n\r\n\x05\x04\x83\x01\x02\0\x12\x04\
    \xe3\t\x08'\n\x0e\n\x06\x04\x83\x01\x02\0\x04\x12\x04\xe3\t\x08\x10\n\
    \x0e\n\x06\x04\x83\x01\x02\0\x05\x12\x04\xe3\t\x11\x17\n\x0e\n\x06\x04\
    \x83\x01\x02\0\x01\x12\x04\xe3\t\x18\"\n\x0e\n\x06\x04\x83\x01\x02\0\x03\
    \x12\x04\xe3\t%&\n\r\n\x05\x04\x83\x01\x02\x01\x12\x04\xe4\t\x08,\n\x0e\
    \n\x06\x04\x83\x01\x02\x01\x04\x12\x04\xe4\t\x08\x10\n\x0e\n\x06\x04\x83\
    \x01\x02\x01\x05\x12\x04\xe4\t\x11\x17\n\x0e\n\x06\x04\x83\x01\x02\x01\
    \x01\x12\x04\xe4\t\x18'\n\x0e\n\x06\x04\x83\x01\x02\x01\x03\x12\x04\xe4\
    \t*+\n\r\n\x03\x04\x84\x01\x12\x06\xe7\t\0\xe8\t\x01\n\x0c\n\x04\x04\x84\
    \x01\x01\x12\x04\xe7\t\x08(\n\r\n\x03\x04\x85\x01\x12\x06\xea\t\0\x9b\n\
    \x01\n\x0c\n\x04\x04\x85\x01\x01\x12\x04\xea\t\x08\x1b\n\x0f\n\x05\x04\
    \x85\x01\x03\0\x12\x06\xeb\t\x08\x82\n\t\n\x0e\n\x06\x04\x85\x01\x03\0\
    \x01\x12\x04\xeb\t\x10\x16\n\x0f\n\x07\x04\x85\x01\x03\0\x02\0\x12\x04\
    \xec\t\x10.\n\x10\n\x08\x04\x85\x01\x03\0\x02\0\x04\x12\x04\xec\t\x10\
    \x18\n\x10\n\x08\x04\x85\x01\x03\0\x02\0\x05\x12\x04\xec\t\x19\x20\n\x10\
    \n\x08\x04\x85\x01\x03\0\x02\0\x01\x12\x04\xec\t!)\n\x10\n\x08\x04\x85\
    \x01\x03\0\x02\0\x03\x12\x04\xec\t,-\n\x0f\n\x07\x04\x85\x01\x03\0\x02\
    \x01\x12\x04\xed\t\x106\n\x10\n\x08\x04\x85\x01\x03\0\x02\x01\x04\x12\
    \x04\xed\t\x10\x18\n\x10\n\x08\x04\x85\x01\x03\0\x02\x01\x05\x12\x04\xed\
    \t\x19\x1f\n\x10\n\x08\x04\x85\x01\x03\0\x02\x01\x01\x12\x04\xed\t\x201\
    \n\x10\n\x08\x04\x85\x01\x03\0\x02\x01\x03\x12\x04\xed\t45\n\x0f\n\x07\
    \x04\x85\x01\x03\0\x02\x02\x12\x04\xee\t\x10)\n\x10\n\x08\x04\x85\x01\
    \x03\0\x02\x02\x04\x12\x04\xee\t\x10\x18\n\x10\n\x08\x04\x85\x01\x03\0\
    \x02\x02\x05\x12\x04\xee\t\x19\x1f\n\x10\n\x08\x04\x85\x01\x03\0\x02\x02\
    \x01\x12\x04\xee\t\x20$\n\x10\n\x08\x04\x85\x01\x03\0\x02\x02\x03\x12\
    \x04\xee\t'(\n\x0f\n\x07\x04\x85\x01\x03\0\x02\x03\x12\x04\xef\t\x10*\n\
    \x10\n\x08\x04\x85\x01\x03\0\x02\x03\x04\x12\x04\xef\t\x10\x18\n\x10\n\
    \x08\x04\x85\x01\x03\0\x02\x03\x05\x12\x04\xef\t\x19\x1f\n\x10\n\x08\x04\
    \x85\x01\x03\0\x02\x03\x01\x12\x04\xef\t\x20%\n\x10\n\x08\x04\x85\x01\
    \x03\0\x02\x03\x03\x12\x04\xef\t()\n\x0f\n\x07\x04\x85\x01\x03\0\x02\x04\
    \x12\x04\xf0\t\x10)\n\x10\n\x08\x04\x85\x01\x03\0\x02\x04\x04\x12\x04\
    \xf0\t\x10\x18\n\x10\n\x08\x04\x85\x01\x03\0\x02\x04\x05\x12\x04\xf0\t\
    \x19\x1f\n\x10\n\x08\x04\x85\x01\x03\0\x02\x04\x01\x12\x04\xf0\t\x20$\n\
    \x10\n\x08\x04\x85\x01\x03\0\x02\x04\x03\x12\x04\xf0\t'(\n\x0f\n\x07\x04\
    \x85\x01\x03\0\x02\x05\x12\x04\xf1\t\x10*\n\x10\n\x08\x04\x85\x01\x03\0\
    \x02\x05\x04\x12\x04\xf1\t\x10\x18\n\x10\n\x08\x04\x85\x01\x03\0\x02\x05\
    \x05\x12\x04\xf1\t\x19\x1f\n\x10\n\x08\x04\x85\x01\x03\0\x02\x05\x01\x12\
    \x04\xf1\t\x20%\n\x10\n\x08\x04\x85\x01\x03\0\x02\x05\x03\x12\x04\xf1\t(\
    )\n\x0f\n\x07\x04\x85\x01\x03\0\x02\x06\x12\x04\xf2\t\x10)\n\x10\n\x08\
    \x04\x85\x01\x03\0\x02\x06\x04\x12\x04\xf2\t\x10\x18\n\x10\n\x08\x04\x85\
    \x01\x03\0\x02\x06\x05\x12\x04\xf2\t\x19\x1f\n\x10\n\x08\x04\x85\x01\x03\
    \0\x02\x06\x01\x12\x04\xf2\t\x20$\n\x10\n\x08\x04\x85\x01\x03\0\x02\x06\
    \x03\x12\x04\xf2\t'(\n\x0f\n\x07\x04\x85\x01\x03\0\x02\x07\x12\x04\xf3\t\
    \x104\n\x10\n\x08\x04\x85\x01\x03\0\x02\x07\x04\x12\x04\xf3\t\x10\x18\n\
    \x10\n\x08\x04\x85\x01\x03\0\x02\x07\x05\x12\x04\xf3\t\x19\x1f\n\x10\n\
    \x08\x04\x85\x01\x03\0\x02\x07\x01\x12\x04\xf3\t\x20.\n\x10\n\x08\x04\
    \x85\x01\x03\0\x02\x07\x03\x12\x04\xf3\t13\n\x0f\n\x07\x04\x85\x01\x03\0\
    \x02\x08\x12\x04\xf4\t\x10+\n\x10\n\x08\x04\x85\x01\x03\0\x02\x08\x04\
    \x12\x04\xf4\t\x10\x18\n\x10\n\x08\x04\x85\x01\x03\0\x02\x08\x05\x12\x04\
    \xf4\t\x19\x1f\n\x10\n\x08\x04\x85\x01\x03\0\x02\x08\x01\x12\x04\xf4\t\
    \x20%\n\x10\n\x08\x04\x85\x01\x03\0\x02\x08\x03\x12\x04\xf4\t(*\n\x0f\n\
    \x07\x04\x85\x01\x03\0\x02\t\x12\x04\xf5\t\x10,\n\x10\n\x08\x04\x85\x01\
    \x03\0\x02\t\x04\x12\x04\xf5\t\x10\x18\n\x10\n\x08\x04\x85\x01\x03\0\x02\
    \t\x05\x12\x04\xf5\t\x19\x1f\n\x10\n\x08\x04\x85\x01\x03\0\x02\t\x01\x12\
    \x04\xf5\t\x20&\n\x10\n\x08\x04\x85\x01\x03\0\x02\t\x03\x12\x04\xf5\t)+\
    \n\x0f\n\x07\x04\x85\x01\x03\0\x02\n\x12\x04\xf6\t\x10,\n\x10\n\x08\x04\
    \x85\x01\x03\0\x02\n\x04\x12\x04\xf6\t\x10\x18\n\x10\n\x08\x04\x85\x01\
    \x03\0\x02\n\x05\x12\x04\xf6\t\x19\x1f\n\x10\n\x08\x04\x85\x01\x03\0\x02\
    \n\x01\x12\x04\xf6\t\x20&\n\x10\n\x08\x04\x85\x01\x03\0\x02\n\x03\x12\
    \x04\xf6\t)+\n\x0f\n\x07\x04\x85\x01\x03\0\x02\x0b\x12\x04\xf7\t\x10-\n\
    \x10\n\x08\x04\x85\x01\x03\0\x02\x0b\x04\x12\x04\xf7\t\x10\x18\n\x10\n\
    \x08\x04\x85\x01\x03\0\x02\x0b\x05\x12\x04\xf7\t\x19\x1f\n\x10\n\x08\x04\
    \x85\x01\x03\0\x02\x0b\x01\x12\x04\xf7\t\x20'\n\x10\n\x08\x04\x85\x01\
    \x03\0\x02\x0b\x03\x12\x04\xf7\t*,\n\x0f\n\x07\x04\x85\x01\x03\0\x02\x0c\
    \x12\x04\xf8\t\x10-\n\x10\n\x08\x04\x85\x01\x03\0\x02\x0c\x04\x12\x04\
    \xf8\t\x10\x18\n\x10\n\x08\x04\x85\x01\x03\0\x02\x0c\x05\x12\x04\xf8\t\
    \x19\x1f\n\x10\n\x08\x04\x85\x01\x03\0\x02\x0c\x01\x12\x04\xf8\t\x20'\n\
    \x10\n\x08\x04\x85\x01\x03\0\x02\x0c\x03\x12\x04\xf8\t*,\n\x0f\n\x07\x04\
    \x85\x01\x03\0\x02\r\x12\x04\xf9\t\x101\n\x10\n\x08\x04\x85\x01\x03\0\
    \x02\r\x04\x12\x04\xf9\t\x10\x18\n\x10\n\x08\x04\x85\x01\x03\0\x02\r\x05\
    \x12\x04\xf9\t\x19\x1f\n\x10\n\x08\x04\x85\x01\x03\0\x02\r\x01\x12\x04\
    \xf9\t\x20+\n\x10\n\x08\x04\x85\x01\x03\0\x02\r\x03\x12\x04\xf9\t.0\n\
    \x0f\n\x07\x04\x85\x01\x03\0\x02\x0e\x12\x04\xfa\t\x101\n\x10\n\x08\x04\
    \x85\x01\x03\0\x02\x0e\x04\x12\x04\xfa\t\x10\x18\n\x10\n\x08\x04\x85\x01\
    \x03\0\x02\x0e\x05\x12\x04\xfa\t\x19\x1f\n\x10\n\x08\x04\x85\x01\x03\0\
    \x02\x0e\x01\x12\x04\xfa\t\x20+\n\x10\n\x08\x04\x85\x01\x03\0\x02\x0e\
    \x03\x12\x04\xfa\t.0\n\x0f\n\x07\x04\x85\x01\x03\0\x02\x0f\x12\x04\xfb\t\
    \x102\n\x10\n\x08\x04\x85\x01\x03\0\x02\x0f\x04\x12\x04\xfb\t\x10\x18\n\
    \x10\n\x08\x04\x85\x01\x03\0\x02\x0f\x05\x12\x04\xfb\t\x19\x1f\n\x10\n\
    \x08\x04\x85\x01\x03\0\x02\x0f\x01\x12\x04\xfb\t\x20,\n\x10\n\x08\x04\
    \x85\x01\x03\0\x02\x0f\x03\x12\x04\xfb\t/1\n\x0f\n\x07\x04\x85\x01\x03\0\
    \x02\x10\x12\x04\xfc\t\x103\n\x10\n\x08\x04\x85\x01\x03\0\x02\x10\x04\
    \x12\x04\xfc\t\x10\x18\n\x10\n\x08\x04\x85\x01\x03\0\x02\x10\x05\x12\x04\
    \xfc\t\x19\x1f\n\x10\n\x08\x04\x85\x01\x03\0\x02\x10\x01\x12\x04\xfc\t\
    \x20-\n\x10\n\x08\x04\x85\x01\x03\0\x02\x10\x03\x12\x04\xfc\t02\n\x0f\n\
    \x07\x04\x85\x01\x03\0\x02\x11\x12\x04\xfd\t\x103\n\x10\n\x08\x04\x85\
    \x01\x03\0\x02\x11\x04\x12\x04\xfd\t\x10\x18\n\x10\n\x08\x04\x85\x01\x03\
    \0\x02\x11\x05\x12\x04\xfd\t\x19\x1f\n\x10\n\x08\x04\x85\x01\x03\0\x02\
    \x11\x01\x12\x04\xfd\t\x20-\n\x10\n\x08\x04\x85\x01\x03\0\x02\x11\x03\
    \x12\x04\xfd\t02\n\x0f\n\x07\x04\x85\x01\x03\0\x02\x12\x12\x04\xfe\t\x10\
    ;\n\x10\n\x08\x04\x85\x01\x03\0\x02\x12\x04\x12\x04\xfe\t\x10\x18\n\x10\
    \n\x08\x04\x85\x01\x03\0\x02\x12\x06\x12\x04\xfe\t\x19(\n\x10\n\x08\x04\
    \x85\x01\x03\0\x02\x12\x01\x12\x04\xfe\t)5\n\x10\n\x08\x04\x85\x01\x03\0\
    \x02\x12\x03\x12\x04\xfe\t8:\n\x0f\n\x07\x04\x85\x01\x03\0\x02\x13\x12\
    \x04\xff\t\x100\n\x10\n\x08\x04\x85\x01\x03\0\x02\x13\x04\x12\x04\xff\t\
    \x10\x18\n\x10\n\x08\x04\x85\x01\x03\0\x02\x13\x05\x12\x04\xff\t\x19\x1f\
    \n\x10\n\x08\x04\x85\x01\x03\0\x02\x13\x01\x12\x04\xff\t\x20*\n\x10\n\
    \x08\x04\x85\x01\x03\0\x02\x13\x03\x12\x04\xff\t-/\n\x0f\n\x07\x04\x85\
    \x01\x03\0\x02\x14\x12\x04\x80\n\x10j\n\x10\n\x08\x04\x85\x01\x03\0\x02\
    \x14\x04\x12\x04\x80\n\x10\x18\n\x10\n\x08\x04\x85\x01\x03\0\x02\x14\x06\
    \x12\x04\x80\n\x19,\n\x10\n\x08\x04\x85\x01\x03\0\x02\x14\x01\x12\x04\
    \x80\n-9\n\x10\n\x08\x04\x85\x01\x03\0\x02\x14\x03\x12\x04\x80\n<>\n\x10\
    \n\x08\x04\x85\x01\x03\0\x02\x14\x08\x12\x04\x80\n?i\n\x10\n\x08\x04\x85\
    \x01\x03\0\x02\x14\x07\x12\x04\x80\nJh\n\x0f\n\x07\x04\x85\x01\x03\0\x02\
    \x15\x12\x04\x81\n\x102\n\x10\n\x08\x04\x85\x01\x03\0\x02\x15\x04\x12\
    \x04\x81\n\x10\x18\n\x10\n\x08\x04\x85\x01\x03\0\x02\x15\x05\x12\x04\x81\
    \n\x19\x1f\n\x10\n\x08\x04\x85\x01\x03\0\x02\x15\x01\x12\x04\x81\n\x20,\
    \n\x10\n\x08\x04\x85\x01\x03\0\x02\x15\x03\x12\x04\x81\n/1\n\x0f\n\x05\
    \x04\x85\x01\x04\0\x12\x06\x84\n\x08\x8c\n\t\n\x0e\n\x06\x04\x85\x01\x04\
    \0\x01\x12\x04\x84\n\r\x13\n\x0f\n\x07\x04\x85\x01\x04\0\x02\0\x12\x04\
    \x85\n\x10$\n\x10\n\x08\x04\x85\x01\x04\0\x02\0\x01\x12\x04\x85\n\x10\
    \x1f\n\x10\n\x08\x04\x85\x01\x04\0\x02\0\x02\x12\x04\x85\n\"#\n\x0f\n\
    \x07\x04\x85\x01\x04\0\x02\x01\x12\x04\x86\n\x10$\n\x10\n\x08\x04\x85\
    \x01\x04\0\x02\x01\x01\x12\x04\x86\n\x10\x1f\n\x10\n\x08\x04\x85\x01\x04\
    \0\x02\x01\x02\x12\x04\x86\n\"#\n\x0f\n\x07\x04\x85\x01\x04\0\x02\x02\
    \x12\x04\x87\n\x10)\n\x10\n\x08\x04\x85\x01\x04\0\x02\x02\x01\x12\x04\
    \x87\n\x10$\n\x10\n\x08\x04\x85\x01\x04\0\x02\x02\x02\x12\x04\x87\n'(\n\
    \x0f\n\x07\x04\x85\x01\x04\0\x02\x03\x12\x04\x88\n\x10)\n\x10\n\x08\x04\
    \x85\x01\x04\0\x02\x03\x01\x12\x04\x88\n\x10$\n\x10\n\x08\x04\x85\x01\
    \x04\0\x02\x03\x02\x12\x04\x88\n'(\n\x0f\n\x07\x04\x85\x01\x04\0\x02\x04\
    \x12\x04\x89\n\x10)\n\x10\n\x08\x04\x85\x01\x04\0\x02\x04\x01\x12\x04\
    \x89\n\x10$\n\x10\n\x08\x04\x85\x01\x04\0\x02\x04\x02\x12\x04\x89\n'(\n\
    \x0f\n\x07\x04\x85\x01\x04\0\x02\x05\x12\x04\x8a\n\x10)\n\x10\n\x08\x04\
    \x85\x01\x04\0\x02\x05\x01\x12\x04\x8a\n\x10$\n\x10\n\x08\x04\x85\x01\
    \x04\0\x02\x05\x02\x12\x04\x8a\n'(\n\x0f\n\x07\x04\x85\x01\x04\0\x02\x06\
    \x12\x04\x8b\n\x10+\n\x10\n\x08\x04\x85\x01\x04\0\x02\x06\x01\x12\x04\
    \x8b\n\x10&\n\x10\n\x08\x04\x85\x01\x04\0\x02\x06\x02\x12\x04\x8b\n)*\n\
    \r\n\x05\x04\x85\x01\x02\0\x12\x04\x8e\n\x08:\n\x0e\n\x06\x04\x85\x01\
    \x02\0\x04\x12\x04\x8e\n\x08\x10\n\x0e\n\x06\x04\x85\x01\x02\0\x05\x12\
    \x04\x8e\n\x11\x17\n\x0e\n\x06\x04\x85\x01\x02\0\x01\x12\x04\x8e\n\x18\
    \x20\n\x0e\n\x06\x04\x85\x01\x02\0\x03\x12\x04\x8e\n#$\n\x0e\n\x06\x04\
    \x85\x01\x02\0\x08\x12\x04\x8e\n%9\n\x11\n\t\x04\x85\x01\x02\0\x08\xe0\
    \xd4\x03\x12\x04\x8e\n&8\n\r\n\x05\x04\x85\x01\x02\x01\x12\x04\x8f\n\x08\
    '\n\x0e\n\x06\x04\x85\x01\x02\x01\x04\x12\x04\x8f\n\x08\x10\n\x0e\n\x06\
    \x04\x85\x01\x02\x01\x05\x12\x04\x8f\n\x11\x16\n\x0e\n\x06\x04\x85\x01\
    \x02\x01\x01\x12\x04\x8f\n\x17\"\n\x0e\n\x06\x04\x85\x01\x02\x01\x03\x12\
    \x04\x8f\n%&\n\r\n\x05\x04\x85\x01\x02\x02\x12\x04\x90\n\x08T\n\x0e\n\
    \x06\x04\x85\x01\x02\x02\x04\x12\x04\x90\n\x08\x10\n\x0e\n\x06\x04\x85\
    \x01\x02\x02\x06\x12\x04\x90\n\x11,\n\x0e\n\x06\x04\x85\x01\x02\x02\x01\
    \x12\x04\x90\n-3\n\x0e\n\x06\x04\x85\x01\x02\x02\x03\x12\x04\x90\n67\n\
    \x0e\n\x06\x04\x85\x01\x02\x02\x08\x12\x04\x90\n8S\n\x0e\n\x06\x04\x85\
    \x01\x02\x02\x07\x12\x04\x90\nCR\n\r\n\x05\x04\x85\x01\x02\x03\x12\x04\
    \x91\n\x08%\n\x0e\n\x06\x04\x85\x01\x02\x03\x04\x12\x04\x91\n\x08\x10\n\
    \x0e\n\x06\x04\x85\x01\x02\x03\x05\x12\x04\x91\n\x11\x17\n\x0e\n\x06\x04\
    \x85\x01\x02\x03\x01\x12\x04\x91\n\x18\x20\n\x0e\n\x06\x04\x85\x01\x02\
    \x03\x03\x12\x04\x91\n#$\n\r\n\x05\x04\x85\x01\x02\x04\x12\x04\x92\n\x08\
    &\n\x0e\n\x06\x04\x85\x01\x02\x04\x04\x12\x04\x92\n\x08\x10\n\x0e\n\x06\
    \x04\x85\x01\x02\x04\x05\x12\x04\x92\n\x11\x17\n\x0e\n\x06\x04\x85\x01\
    \x02\x04\x01\x12\x04\x92\n\x18!\n\x0e\n\x06\x04\x85\x01\x02\x04\x03\x12\
    \x04\x92\n$%\n\r\n\x05\x04\x85\x01\x02\x05\x12\x04\x93\n\x08'\n\x0e\n\
    \x06\x04\x85\x01\x02\x05\x04\x12\x04\x93\n\x08\x10\n\x0e\n\x06\x04\x85\
    \x01\x02\x05\x05\x12\x04\x93\n\x11\x17\n\x0e\n\x06\x04\x85\x01\x02\x05\
    \x01\x12\x04\x93\n\x18\"\n\x0e\n\x06\x04\x85\x01\x02\x05\x03\x12\x04\x93\
    \n%&\n\r\n\x05\x04\x85\x01\x02\x06\x12\x04\x94\n\x08)\n\x0e\n\x06\x04\
    \x85\x01\x02\x06\x04\x12\x04\x94\n\x08\x10\n\x0e\n\x06\x04\x85\x01\x02\
    \x06\x05\x12\x04\x94\n\x11\x17\n\x0e\n\x06\x04\x85\x01\x02\x06\x01\x12\
    \x04\x94\n\x18$\n\x0e\n\x06\x04\x85\x01\x02\x06\x03\x12\x04\x94\n'(\n\r\
    \n\x05\x04\x85\x01\x02\x07\x12\x04\x95\n\x08&\n\x0e\n\x06\x04\x85\x01\
    \x02\x07\x04\x12\x04\x95\n\x08\x10\n\x0e\n\x06\x04\x85\x01\x02\x07\x05\
    \x12\x04\x95\n\x11\x17\n\x0e\n\x06\x04\x85\x01\x02\x07\x01\x12\x04\x95\n\
    \x18!\n\x0e\n\x06\x04\x85\x01\x02\x07\x03\x12\x04\x95\n$%\n\r\n\x05\x04\
    \x85\x01\x02\x08\x12\x04\x96\n\x084\n\x0e\n\x06\x04\x85\x01\x02\x08\x04\
    \x12\x04\x96\n\x08\x10\n\x0e\n\x06\x04\x85\x01\x02\x08\x05\x12\x04\x96\n\
    \x11\x17\n\x0e\n\x06\x04\x85\x01\x02\x08\x01\x12\x04\x96\n\x18!\n\x0e\n\
    \x06\x04\x85\x01\x02\x08\x03\x12\x04\x96\n$%\n\x0e\n\x06\x04\x85\x01\x02\
    \x08\x08\x12\x04\x96\n&3\n\x0e\n\x06\x04\x85\x01\x02\x08\x07\x12\x04\x96\
    \n12\n\r\n\x05\x04\x85\x01\x02\t\x12\x04\x97\n\x08:\n\x0e\n\x06\x04\x85\
    \x01\x02\t\x04\x12\x04\x97\n\x08\x10\n\x0e\n\x06\x04\x85\x01\x02\t\x06\
    \x12\x04\x97\n\x11,\n\x0e\n\x06\x04\x85\x01\x02\t\x01\x12\x04\x97\n-4\n\
    \x0e\n\x06\x04\x85\x01\x02\t\x03\x12\x04\x97\n79\n\r\n\x05\x04\x85\x01\
    \x02\n\x12\x04\x98\n\x08(\n\x0e\n\x06\x04\x85\x01\x02\n\x04\x12\x04\x98\
    \n\x08\x10\n\x0e\n\x06\x04\x85\x01\x02\n\x05\x12\x04\x98\n\x11\x17\n\x0e\
    \n\x06\x04\x85\x01\x02\n\x01\x12\x04\x98\n\x18\"\n\x0e\n\x06\x04\x85\x01\
    \x02\n\x03\x12\x04\x98\n%'\n\r\n\x05\x04\x85\x01\x02\x0b\x12\x04\x99\n\
    \x08#\n\x0e\n\x06\x04\x85\x01\x02\x0b\x04\x12\x04\x99\n\x08\x10\n\x0e\n\
    \x06\x04\x85\x01\x02\x0b\x05\x12\x04\x99\n\x11\x17\n\x0e\n\x06\x04\x85\
    \x01\x02\x0b\x01\x12\x04\x99\n\x18\x1d\n\x0e\n\x06\x04\x85\x01\x02\x0b\
    \x03\x12\x04\x99\n\x20\"\n\r\n\x05\x04\x85\x01\x02\x0c\x12\x04\x9a\n\x08\
    \"\n\x0e\n\x06\x04\x85\x01\x02\x0c\x04\x12\x04\x9a\n\x08\x10\n\x0e\n\x06\
    \x04\x85\x01\x02\x0c\x05\x12\x04\x9a\n\x11\x17\n\x0e\n\x06\x04\x85\x01\
    \x02\x0c\x01\x12\x04\x9a\n\x18\x1c\n\x0e\n\x06\x04\x85\x01\x02\x0c\x03\
    \x12\x04\x9a\n\x1f!\n\r\n\x03\x04\x86\x01\x12\x06\x9d\n\0\x9e\n\x01\n\
    \x0c\n\x04\x04\x86\x01\x01\x12\x04\x9d\n\x08#\n\r\n\x03\x04\x87\x01\x12\
    \x06\xa0\n\0\xa2\n\x01\n\x0c\n\x04\x04\x87\x01\x01\x12\x04\xa0\n\x08!\n\
    \r\n\x05\x04\x87\x01\x02\0\x12\x04\xa1\n\x08+\n\x0e\n\x06\x04\x87\x01\
    \x02\0\x04\x12\x04\xa1\n\x08\x10\n\x0e\n\x06\x04\x87\x01\x02\0\x06\x12\
    \x04\xa1\n\x11\x1d\n\x0e\n\x06\x04\x87\x01\x02\0\x01\x12\x04\xa1\n\x1e&\
    \n\x0e\n\x06\x04\x87\x01\x02\0\x03\x12\x04\xa1\n)*\n\r\n\x03\x04\x88\x01\
    \x12\x06\xa4\n\0\xa9\n\x01\n\x0c\n\x04\x04\x88\x01\x01\x12\x04\xa4\n\x08\
    3\n\r\n\x05\x04\x88\x01\x02\0\x12\x04\xa5\n\x08$\n\x0e\n\x06\x04\x88\x01\
    \x02\0\x04\x12\x04\xa5\n\x08\x10\n\x0e\n\x06\x04\x88\x01\x02\0\x05\x12\
    \x04\xa5\n\x11\x17\n\x0e\n\x06\x04\x88\x01\x02\0\x01\x12\x04\xa5\n\x18\
    \x1f\n\x0e\n\x06\x04\x88\x01\x02\0\x03\x12\x04\xa5\n\"#\n\r\n\x05\x04\
    \x88\x01\x02\x01\x12\x04\xa6\n\x08$\n\x0e\n\x06\x04\x88\x01\x02\x01\x04\
    \x12\x04\xa6\n\x08\x10\n\x0e\n\x06\x04\x88\x01\x02\x01\x05\x12\x04\xa6\n\
    \x11\x17\n\x0e\n\x06\x04\x88\x01\x02\x01\x01\x12\x04\xa6\n\x18\x1f\n\x0e\
    \n\x06\x04\x88\x01\x02\x01\x03\x12\x04\xa6\n\"#\n\r\n\x05\x04\x88\x01\
    \x02\x02\x12\x04\xa7\n\x08$\n\x0e\n\x06\x04\x88\x01\x02\x02\x04\x12\x04\
    \xa7\n\x08\x10\n\x0e\n\x06\x04\x88\x01\x02\x02\x05\x12\x04\xa7\n\x11\x17\
    \n\x0e\n\x06\x04\x88\x01\x02\x02\x01\x12\x04\xa7\n\x18\x1f\n\x0e\n\x06\
    \x04\x88\x01\x02\x02\x03\x12\x04\xa7\n\"#\n\r\n\x05\x04\x88\x01\x02\x03\
    \x12\x04\xa8\n\x08$\n\x0e\n\x06\x04\x88\x01\x02\x03\x04\x12\x04\xa8\n\
    \x08\x10\n\x0e\n\x06\x04\x88\x01\x02\x03\x05\x12\x04\xa8\n\x11\x17\n\x0e\
    \n\x06\x04\x88\x01\x02\x03\x01\x12\x04\xa8\n\x18\x1f\n\x0e\n\x06\x04\x88\
    \x01\x02\x03\x03\x12\x04\xa8\n\"#\n\r\n\x03\x04\x89\x01\x12\x06\xab\n\0\
    \xad\n\x01\n\x0c\n\x04\x04\x89\x01\x01\x12\x04\xab\n\x084\n\r\n\x05\x04\
    \x89\x01\x02\0\x12\x04\xac\n\x089\n\x0e\n\x06\x04\x89\x01\x02\0\x04\x12\
    \x04\xac\n\x08\x10\n\x0e\n\x06\x04\x89\x01\x02\0\x06\x12\x04\xac\n\x11+\
    \n\x0e\n\x06\x04\x89\x01\x02\0\x01\x12\x04\xac\n,4\n\x0e\n\x06\x04\x89\
    \x01\x02\0\x03\x12\x04\xac\n78\n\r\n\x03\x04\x8a\x01\x12\x06\xaf\n\0\xc9\
    \n\x01\n\x0c\n\x04\x04\x8a\x01\x01\x12\x04\xaf\n\x08\x1e\n\r\n\x05\x04\
    \x8a\x01\x02\0\x12\x04\xb0\n\x08<\n\x0e\n\x06\x04\x8a\x01\x02\0\x04\x12\
    \x04\xb0\n\x08\x10\n\x0e\n\x06\x04\x8a\x01\x02\0\x05\x12\x04\xb0\n\x11\
    \x17\n\x0e\n\x06\x04\x8a\x01\x02\0\x01\x12\x04\xb0\n\x18\"\n\x0e\n\x06\
    \x04\x8a\x01\x02\0\x03\x12\x04\xb0\n%&\n\x0e\n\x06\x04\x8a\x01\x02\0\x08\
    \x12\x04\xb0\n';\n\x11\n\t\x04\x8a\x01\x02\0\x08\xe0\xd4\x03\x12\x04\xb0\
    \n(:\n\r\n\x05\x04\x8a\x01\x02\x01\x12\x04\xb1\n\x08<\n\x0e\n\x06\x04\
    \x8a\x01\x02\x01\x04\x12\x04\xb1\n\x08\x10\n\x0e\n\x06\x04\x8a\x01\x02\
    \x01\x05\x12\x04\xb1\n\x11\x16\n\x0e\n\x06\x04\x8a\x01\x02\x01\x01\x12\
    \x04\xb1\n\x17\"\n\x0e\n\x06\x04\x8a\x01\x02\x01\x03\x12\x04\xb1\n%&\n\
    \x0e\n\x06\x04\x8a\x01\x02\x01\x08\x12\x04\xb1\n';\n\x11\n\t\x04\x8a\x01\
    \x02\x01\x08\xe0\xd4\x03\x12\x04\xb1\n(:\n\r\n\x05\x04\x8a\x01\x02\x02\
    \x12\x04\xb2\n\x08;\n\x0e\n\x06\x04\x8a\x01\x02\x02\x04\x12\x04\xb2\n\
    \x08\x10\n\x0e\n\x06\x04\x8a\x01\x02\x02\x05\x12\x04\xb2\n\x11\x17\n\x0e\
    \n\x06\x04\x8a\x01\x02\x02\x01\x12\x04\xb2\n\x18!\n\x0e\n\x06\x04\x8a\
    \x01\x02\x02\x03\x12\x04\xb2\n$%\n\x0e\n\x06\x04\x8a\x01\x02\x02\x08\x12\
    \x04\xb2\n&:\n\x11\n\t\x04\x8a\x01\x02\x02\x08\xe0\xd4\x03\x12\x04\xb2\n\
    '9\n\r\n\x05\x04\x8a\x01\x02\x03\x12\x04\xb3\n\x08\"\n\x0e\n\x06\x04\x8a\
    \x01\x02\x03\x04\x12\x04\xb3\n\x08\x10\n\x0e\n\x06\x04\x8a\x01\x02\x03\
    \x05\x12\x04\xb3\n\x11\x17\n\x0e\n\x06\x04\x8a\x01\x02\x03\x01\x12\x04\
    \xb3\n\x18\x1d\n\x0e\n\x06\x04\x8a\x01\x02\x03\x03\x12\x04\xb3\n\x20!\n\
    \r\n\x05\x04\x8a\x01\x02\x04\x12\x04\xb4\n\x08#\n\x0e\n\x06\x04\x8a\x01\
    \x02\x04\x04\x12\x04\xb4\n\x08\x10\n\x0e\n\x06\x04\x8a\x01\x02\x04\x05\
    \x12\x04\xb4\n\x11\x17\n\x0e\n\x06\x04\x8a\x01\x02\x04\x01\x12\x04\xb4\n\
    \x18\x1d\n\x0e\n\x06\x04\x8a\x01\x02\x04\x03\x12\x04\xb4\n\x20\"\n\r\n\
    \x05\x04\x8a\x01\x02\x05\x12\x04\xb5\n\x08#\n\x0e\n\x06\x04\x8a\x01\x02\
    \x05\x04\x12\x04\xb5\n\x08\x10\n\x0e\n\x06\x04\x8a\x01\x02\x05\x05\x12\
    \x04\xb5\n\x11\x17\n\x0e\n\x06\x04\x8a\x01\x02\x05\x01\x12\x04\xb5\n\x18\
    \x1d\n\x0e\n\x06\x04\x8a\x01\x02\x05\x03\x12\x04\xb5\n\x20\"\n\r\n\x05\
    \x04\x8a\x01\x02\x06\x12\x04\xb6\n\x08$\n\x0e\n\x06\x04\x8a\x01\x02\x06\
    \x04\x12\x04\xb6\n\x08\x10\n\x0e\n\x06\x04\x8a\x01\x02\x06\x05\x12\x04\
    \xb6\n\x11\x17\n\x0e\n\x06\x04\x8a\x01\x02\x06\x01\x12\x04\xb6\n\x18\x1e\
    \n\x0e\n\x06\x04\x8a\x01\x02\x06\x03\x12\x04\xb6\n!#\n\r\n\x05\x04\x8a\
    \x01\x02\x07\x12\x04\xb7\n\x08$\n\x0e\n\x06\x04\x8a\x01\x02\x07\x04\x12\
    \x04\xb7\n\x08\x10\n\x0e\n\x06\x04\x8a\x01\x02\x07\x05\x12\x04\xb7\n\x11\
    \x17\n\x0e\n\x06\x04\x8a\x01\x02\x07\x01\x12\x04\xb7\n\x18\x1e\n\x0e\n\
    \x06\x04\x8a\x01\x02\x07\x03\x12\x04\xb7\n!#\n\r\n\x05\x04\x8a\x01\x02\
    \x08\x12\x04\xb8\n\x08%\n\x0e\n\x06\x04\x8a\x01\x02\x08\x04\x12\x04\xb8\
    \n\x08\x10\n\x0e\n\x06\x04\x8a\x01\x02\x08\x05\x12\x04\xb8\n\x11\x17\n\
    \x0e\n\x06\x04\x8a\x01\x02\x08\x01\x12\x04\xb8\n\x18\x1f\n\x0e\n\x06\x04\
    \x8a\x01\x02\x08\x03\x12\x04\xb8\n\"$\n\r\n\x05\x04\x8a\x01\x02\t\x12\
    \x04\xb9\n\x08%\n\x0e\n\x06\x04\x8a\x01\x02\t\x04\x12\x04\xb9\n\x08\x10\
    \n\x0e\n\x06\x04\x8a\x01\x02\t\x05\x12\x04\xb9\n\x11\x17\n\x0e\n\x06\x04\
    \x8a\x01\x02\t\x01\x12\x04\xb9\n\x18\x1f\n\x0e\n\x06\x04\x8a\x01\x02\t\
    \x03\x12\x04\xb9\n\"$\n\r\n\x05\x04\x8a\x01\x02\n\x12\x04\xba\n\x08*\n\
    \x0e\n\x06\x04\x8a\x01\x02\n\x04\x12\x04\xba\n\x08\x10\n\x0e\n\x06\x04\
    \x8a\x01\x02\n\x05\x12\x04\xba\n\x11\x17\n\x0e\n\x06\x04\x8a\x01\x02\n\
    \x01\x12\x04\xba\n\x18$\n\x0e\n\x06\x04\x8a\x01\x02\n\x03\x12\x04\xba\n'\
    )\n\r\n\x05\x04\x8a\x01\x02\x0b\x12\x04\xbb\n\x08*\n\x0e\n\x06\x04\x8a\
    \x01\x02\x0b\x04\x12\x04\xbb\n\x08\x10\n\x0e\n\x06\x04\x8a\x01\x02\x0b\
    \x05\x12\x04\xbb\n\x11\x17\n\x0e\n\x06\x04\x8a\x01\x02\x0b\x01\x12\x04\
    \xbb\n\x18$\n\x0e\n\x06\x04\x8a\x01\x02\x0b\x03\x12\x04\xbb\n')\n\r\n\
    \x05\x04\x8a\x01\x02\x0c\x12\x04\xbc\n\x08(\n\x0e\n\x06\x04\x8a\x01\x02\
    \x0c\x04\x12\x04\xbc\n\x08\x10\n\x0e\n\x06\x04\x8a\x01\x02\x0c\x05\x12\
    \x04\xbc\n\x11\x17\n\x0e\n\x06\x04\x8a\x01\x02\x0c\x01\x12\x04\xbc\n\x18\
    \"\n\x0e\n\x06\x04\x8a\x01\x02\x0c\x03\x12\x04\xbc\n%'\n\r\n\x05\x04\x8a\
    \x01\x02\r\x12\x04\xbd\n\x08*\n\x0e\n\x06\x04\x8a\x01\x02\r\x04\x12\x04\
    \xbd\n\x08\x10\n\x0e\n\x06\x04\x8a\x01\x02\r\x05\x12\x04\xbd\n\x11\x17\n\
    \x0e\n\x06\x04\x8a\x01\x02\r\x01\x12\x04\xbd\n\x18$\n\x0e\n\x06\x04\x8a\
    \x01\x02\r\x03\x12\x04\xbd\n')\n\r\n\x05\x04\x8a\x01\x02\x0e\x12\x04\xbe\
    \n\x08*\n\x0e\n\x06\x04\x8a\x01\x02\x0e\x04\x12\x04\xbe\n\x08\x10\n\x0e\
    \n\x06\x04\x8a\x01\x02\x0e\x05\x12\x04\xbe\n\x11\x17\n\x0e\n\x06\x04\x8a\
    \x01\x02\x0e\x01\x12\x04\xbe\n\x18$\n\x0e\n\x06\x04\x8a\x01\x02\x0e\x03\
    \x12\x04\xbe\n')\n\r\n\x05\x04\x8a\x01\x02\x0f\x12\x04\xbf\n\x08(\n\x0e\
    \n\x06\x04\x8a\x01\x02\x0f\x04\x12\x04\xbf\n\x08\x10\n\x0e\n\x06\x04\x8a\
    \x01\x02\x0f\x05\x12\x04\xbf\n\x11\x17\n\x0e\n\x06\x04\x8a\x01\x02\x0f\
    \x01\x12\x04\xbf\n\x18\"\n\x0e\n\x06\x04\x8a\x01\x02\x0f\x03\x12\x04\xbf\
    \n%'\n\r\n\x05\x04\x8a\x01\x02\x10\x12\x04\xc0\n\x08+\n\x0e\n\x06\x04\
    \x8a\x01\x02\x10\x04\x12\x04\xc0\n\x08\x10\n\x0e\n\x06\x04\x8a\x01\x02\
    \x10\x05\x12\x04\xc0\n\x11\x17\n\x0e\n\x06\x04\x8a\x01\x02\x10\x01\x12\
    \x04\xc0\n\x18%\n\x0e\n\x06\x04\x8a\x01\x02\x10\x03\x12\x04\xc0\n(*\n\r\
    \n\x05\x04\x8a\x01\x02\x11\x12\x04\xc1\n\x08+\n\x0e\n\x06\x04\x8a\x01\
    \x02\x11\x04\x12\x04\xc1\n\x08\x10\n\x0e\n\x06\x04\x8a\x01\x02\x11\x05\
    \x12\x04\xc1\n\x11\x17\n\x0e\n\x06\x04\x8a\x01\x02\x11\x01\x12\x04\xc1\n\
    \x18%\n\x0e\n\x06\x04\x8a\x01\x02\x11\x03\x12\x04\xc1\n(*\n\r\n\x05\x04\
    \x8a\x01\x02\x12\x12\x04\xc2\n\x08)\n\x0e\n\x06\x04\x8a\x01\x02\x12\x04\
    \x12\x04\xc2\n\x08\x10\n\x0e\n\x06\x04\x8a\x01\x02\x12\x05\x12\x04\xc2\n\
    \x11\x17\n\x0e\n\x06\x04\x8a\x01\x02\x12\x01\x12\x04\xc2\n\x18#\n\x0e\n\
    \x06\x04\x8a\x01\x02\x12\x03\x12\x04\xc2\n&(\n\r\n\x05\x04\x8a\x01\x02\
    \x13\x12\x04\xc3\n\x08,\n\x0e\n\x06\x04\x8a\x01\x02\x13\x04\x12\x04\xc3\
    \n\x08\x10\n\x0e\n\x06\x04\x8a\x01\x02\x13\x05\x12\x04\xc3\n\x11\x17\n\
    \x0e\n\x06\x04\x8a\x01\x02\x13\x01\x12\x04\xc3\n\x18&\n\x0e\n\x06\x04\
    \x8a\x01\x02\x13\x03\x12\x04\xc3\n)+\n\r\n\x05\x04\x8a\x01\x02\x14\x12\
    \x04\xc4\n\x08,\n\x0e\n\x06\x04\x8a\x01\x02\x14\x04\x12\x04\xc4\n\x08\
    \x10\n\x0e\n\x06\x04\x8a\x01\x02\x14\x05\x12\x04\xc4\n\x11\x17\n\x0e\n\
    \x06\x04\x8a\x01\x02\x14\x01\x12\x04\xc4\n\x18&\n\x0e\n\x06\x04\x8a\x01\
    \x02\x14\x03\x12\x04\xc4\n)+\n\r\n\x05\x04\x8a\x01\x02\x15\x12\x04\xc5\n\
    \x08*\n\x0e\n\x06\x04\x8a\x01\x02\x15\x04\x12\x04\xc5\n\x08\x10\n\x0e\n\
    \x06\x04\x8a\x01\x02\x15\x05\x12\x04\xc5\n\x11\x17\n\x0e\n\x06\x04\x8a\
    \x01\x02\x15\x01\x12\x04\xc5\n\x18$\n\x0e\n\x06\x04\x8a\x01\x02\x15\x03\
    \x12\x04\xc5\n')\n\r\n\x05\x04\x8a\x01\x02\x16\x12\x04\xc6\n\x08,\n\x0e\
    \n\x06\x04\x8a\x01\x02\x16\x04\x12\x04\xc6\n\x08\x10\n\x0e\n\x06\x04\x8a\
    \x01\x02\x16\x05\x12\x04\xc6\n\x11\x17\n\x0e\n\x06\x04\x8a\x01\x02\x16\
    \x01\x12\x04\xc6\n\x18&\n\x0e\n\x06\x04\x8a\x01\x02\x16\x03\x12\x04\xc6\
    \n)+\n\r\n\x05\x04\x8a\x01\x02\x17\x12\x04\xc7\n\x08,\n\x0e\n\x06\x04\
    \x8a\x01\x02\x17\x04\x12\x04\xc7\n\x08\x10\n\x0e\n\x06\x04\x8a\x01\x02\
    \x17\x05\x12\x04\xc7\n\x11\x17\n\x0e\n\x06\x04\x8a\x01\x02\x17\x01\x12\
    \x04\xc7\n\x18&\n\x0e\n\x06\x04\x8a\x01\x02\x17\x03\x12\x04\xc7\n)+\n\r\
    \n\x05\x04\x8a\x01\x02\x18\x12\x04\xc8\n\x08*\n\x0e\n\x06\x04\x8a\x01\
    \x02\x18\x04\x12\x04\xc8\n\x08\x10\n\x0e\n\x06\x04\x8a\x01\x02\x18\x05\
    \x12\x04\xc8\n\x11\x17\n\x0e\n\x06\x04\x8a\x01\x02\x18\x01\x12\x04\xc8\n\
    \x18$\n\x0e\n\x06\x04\x8a\x01\x02\x18\x03\x12\x04\xc8\n')\n\r\n\x03\x04\
    \x8b\x01\x12\x06\xcb\n\0\xd1\n\x01\n\x0c\n\x04\x04\x8b\x01\x01\x12\x04\
    \xcb\n\x08\x17\n\r\n\x05\x04\x8b\x01\x02\0\x12\x04\xcc\n\x08<\n\x0e\n\
    \x06\x04\x8b\x01\x02\0\x04\x12\x04\xcc\n\x08\x10\n\x0e\n\x06\x04\x8b\x01\
    \x02\0\x05\x12\x04\xcc\n\x11\x17\n\x0e\n\x06\x04\x8b\x01\x02\0\x01\x12\
    \x04\xcc\n\x18\"\n\x0e\n\x06\x04\x8b\x01\x02\0\x03\x12\x04\xcc\n%&\n\x0e\
    \n\x06\x04\x8b\x01\x02\0\x08\x12\x04\xcc\n';\n\x11\n\t\x04\x8b\x01\x02\0\
    \x08\xe0\xd4\x03\x12\x04\xcc\n(:\n\r\n\x05\x04\x8b\x01\x02\x01\x12\x04\
    \xcd\n\x08<\n\x0e\n\x06\x04\x8b\x01\x02\x01\x04\x12\x04\xcd\n\x08\x10\n\
    \x0e\n\x06\x04\x8b\x01\x02\x01\x05\x12\x04\xcd\n\x11\x16\n\x0e\n\x06\x04\
    \x8b\x01\x02\x01\x01\x12\x04\xcd\n\x17\"\n\x0e\n\x06\x04\x8b\x01\x02\x01\
    \x03\x12\x04\xcd\n%&\n\x0e\n\x06\x04\x8b\x01\x02\x01\x08\x12\x04\xcd\n';\
    \n\x11\n\t\x04\x8b\x01\x02\x01\x08\xe0\xd4\x03\x12\x04\xcd\n(:\n\r\n\x05\
    \x04\x8b\x01\x02\x02\x12\x04\xce\n\x08+\n\x0e\n\x06\x04\x8b\x01\x02\x02\
    \x04\x12\x04\xce\n\x08\x10\n\x0e\n\x06\x04\x8b\x01\x02\x02\x05\x12\x04\
    \xce\n\x11\x17\n\x0e\n\x06\x04\x8b\x01\x02\x02\x01\x12\x04\xce\n\x18&\n\
    \x0e\n\x06\x04\x8b\x01\x02\x02\x03\x12\x04\xce\n)*\n\r\n\x05\x04\x8b\x01\
    \x02\x03\x12\x04\xcf\n\x08-\n\x0e\n\x06\x04\x8b\x01\x02\x03\x04\x12\x04\
    \xcf\n\x08\x10\n\x0e\n\x06\x04\x8b\x01\x02\x03\x05\x12\x04\xcf\n\x11\x17\
    \n\x0e\n\x06\x04\x8b\x01\x02\x03\x01\x12\x04\xcf\n\x18(\n\x0e\n\x06\x04\
    \x8b\x01\x02\x03\x03\x12\x04\xcf\n+,\n\r\n\x05\x04\x8b\x01\x02\x04\x12\
    \x04\xd0\n\x08,\n\x0e\n\x06\x04\x8b\x01\x02\x04\x04\x12\x04\xd0\n\x08\
    \x10\n\x0e\n\x06\x04\x8b\x01\x02\x04\x05\x12\x04\xd0\n\x11\x17\n\x0e\n\
    \x06\x04\x8b\x01\x02\x04\x01\x12\x04\xd0\n\x18'\n\x0e\n\x06\x04\x8b\x01\
    \x02\x04\x03\x12\x04\xd0\n*+\n\r\n\x03\x04\x8c\x01\x12\x06\xd3\n\0\xd8\n\
    \x01\n\x0c\n\x04\x04\x8c\x01\x01\x12\x04\xd3\n\x08&\n\r\n\x05\x04\x8c\
    \x01\x02\0\x12\x04\xd4\n\x08&\n\x0e\n\x06\x04\x8c\x01\x02\0\x04\x12\x04\
    \xd4\n\x08\x10\n\x0e\n\x06\x04\x8c\x01\x02\0\x05\x12\x04\xd4\n\x11\x17\n\
    \x0e\n\x06\x04\x8c\x01\x02\0\x01\x12\x04\xd4\n\x18!\n\x0e\n\x06\x04\x8c\
    \x01\x02\0\x03\x12\x04\xd4\n$%\n\r\n\x05\x04\x8c\x01\x02\x01\x12\x04\xd5\
    \n\x08%\n\x0e\n\x06\x04\x8c\x01\x02\x01\x04\x12\x04\xd5\n\x08\x10\n\x0e\
    \n\x06\x04\x8c\x01\x02\x01\x05\x12\x04\xd5\n\x11\x17\n\x0e\n\x06\x04\x8c\
    \x01\x02\x01\x01\x12\x04\xd5\n\x18\x20\n\x0e\n\x06\x04\x8c\x01\x02\x01\
    \x03\x12\x04\xd5\n#$\n\r\n\x05\x04\x8c\x01\x02\x02\x12\x04\xd6\n\x08Q\n\
    \x0e\n\x06\x04\x8c\x01\x02\x02\x04\x12\x04\xd6\n\x08\x10\n\x0e\n\x06\x04\
    \x8c\x01\x02\x02\x06\x12\x04\xd6\n\x11\"\n\x0e\n\x06\x04\x8c\x01\x02\x02\
    \x01\x12\x04\xd6\n#)\n\x0e\n\x06\x04\x8c\x01\x02\x02\x03\x12\x04\xd6\n,-\
    \n\x0e\n\x06\x04\x8c\x01\x02\x02\x08\x12\x04\xd6\n.P\n\x0e\n\x06\x04\x8c\
    \x01\x02\x02\x07\x12\x04\xd6\n9O\n\r\n\x05\x04\x8c\x01\x02\x03\x12\x04\
    \xd7\n\x08%\n\x0e\n\x06\x04\x8c\x01\x02\x03\x04\x12\x04\xd7\n\x08\x10\n\
    \x0e\n\x06\x04\x8c\x01\x02\x03\x05\x12\x04\xd7\n\x11\x17\n\x0e\n\x06\x04\
    \x8c\x01\x02\x03\x01\x12\x04\xd7\n\x18\x20\n\x0e\n\x06\x04\x8c\x01\x02\
    \x03\x03\x12\x04\xd7\n#$\n\r\n\x03\x04\x8d\x01\x12\x06\xda\n\0\xde\n\x01\
    \n\x0c\n\x04\x04\x8d\x01\x01\x12\x04\xda\n\x08,\n\r\n\x05\x04\x8d\x01\
    \x02\0\x12\x04\xdb\n\x08\"\n\x0e\n\x06\x04\x8d\x01\x02\0\x04\x12\x04\xdb\
    \n\x08\x10\n\x0e\n\x06\x04\x8d\x01\x02\0\x05\x12\x04\xdb\n\x11\x15\n\x0e\
    \n\x06\x04\x8d\x01\x02\0\x01\x12\x04\xdb\n\x16\x1d\n\x0e\n\x06\x04\x8d\
    \x01\x02\0\x03\x12\x04\xdb\n\x20!\n\r\n\x05\x04\x8d\x01\x02\x01\x12\x04\
    \xdc\n\x08(\n\x0e\n\x06\x04\x8d\x01\x02\x01\x04\x12\x04\xdc\n\x08\x10\n\
    \x0e\n\x06\x04\x8d\x01\x02\x01\x05\x12\x04\xdc\n\x11\x15\n\x0e\n\x06\x04\
    \x8d\x01\x02\x01\x01\x12\x04\xdc\n\x16#\n\x0e\n\x06\x04\x8d\x01\x02\x01\
    \x03\x12\x04\xdc\n&'\n\r\n\x05\x04\x8d\x01\x02\x02\x12\x04\xdd\n\x08)\n\
    \x0e\n\x06\x04\x8d\x01\x02\x02\x04\x12\x04\xdd\n\x08\x10\n\x0e\n\x06\x04\
    \x8d\x01\x02\x02\x05\x12\x04\xdd\n\x11\x15\n\x0e\n\x06\x04\x8d\x01\x02\
    \x02\x01\x12\x04\xdd\n\x16$\n\x0e\n\x06\x04\x8d\x01\x02\x02\x03\x12\x04\
    \xdd\n'(\n\r\n\x03\x04\x8e\x01\x12\x06\xe0\n\0\xe1\n\x01\n\x0c\n\x04\x04\
    \x8e\x01\x01\x12\x04\xe0\n\x08*\n\r\n\x03\x04\x8f\x01\x12\x06\xe3\n\0\
    \xf4\n\x01\n\x0c\n\x04\x04\x8f\x01\x01\x12\x04\xe3\n\x083\n\x0f\n\x05\
    \x04\x8f\x01\x03\0\x12\x06\xe4\n\x08\xf1\n\t\n\x0e\n\x06\x04\x8f\x01\x03\
    \0\x01\x12\x04\xe4\n\x10\x1f\n\x0f\n\x07\x04\x8f\x01\x03\0\x02\0\x12\x04\
    \xe5\n\x10)\n\x10\n\x08\x04\x8f\x01\x03\0\x02\0\x04\x12\x04\xe5\n\x10\
    \x18\n\x10\n\x08\x04\x8f\x01\x03\0\x02\0\x05\x12\x04\xe5\n\x19\x1f\n\x10\
    \n\x08\x04\x8f\x01\x03\0\x02\0\x01\x12\x04\xe5\n\x20$\n\x10\n\x08\x04\
    \x8f\x01\x03\0\x02\0\x03\x12\x04\xe5\n'(\n\x0f\n\x07\x04\x8f\x01\x03\0\
    \x02\x01\x12\x04\xe6\n\x10,\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x01\x04\
    \x12\x04\xe6\n\x10\x18\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x01\x05\x12\x04\
    \xe6\n\x19\x1f\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x01\x01\x12\x04\xe6\n\
    \x20'\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x01\x03\x12\x04\xe6\n*+\n\x0f\n\
    \x07\x04\x8f\x01\x03\0\x02\x02\x12\x04\xe7\n\x10.\n\x10\n\x08\x04\x8f\
    \x01\x03\0\x02\x02\x04\x12\x04\xe7\n\x10\x18\n\x10\n\x08\x04\x8f\x01\x03\
    \0\x02\x02\x05\x12\x04\xe7\n\x19\x1f\n\x10\n\x08\x04\x8f\x01\x03\0\x02\
    \x02\x01\x12\x04\xe7\n\x20)\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x02\x03\
    \x12\x04\xe7\n,-\n\x0f\n\x07\x04\x8f\x01\x03\0\x02\x03\x12\x04\xe8\n\x10\
    0\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x03\x04\x12\x04\xe8\n\x10\x18\n\x10\
    \n\x08\x04\x8f\x01\x03\0\x02\x03\x05\x12\x04\xe8\n\x19\x1f\n\x10\n\x08\
    \x04\x8f\x01\x03\0\x02\x03\x01\x12\x04\xe8\n\x20+\n\x10\n\x08\x04\x8f\
    \x01\x03\0\x02\x03\x03\x12\x04\xe8\n./\n\x0f\n\x07\x04\x8f\x01\x03\0\x02\
    \x04\x12\x04\xe9\n\x10.\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x04\x04\x12\
    \x04\xe9\n\x10\x18\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x04\x05\x12\x04\xe9\
    \n\x19\x1f\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x04\x01\x12\x04\xe9\n\x20)\
    \n\x10\n\x08\x04\x8f\x01\x03\0\x02\x04\x03\x12\x04\xe9\n,-\n\x0f\n\x07\
    \x04\x8f\x01\x03\0\x02\x05\x12\x04\xea\n\x100\n\x10\n\x08\x04\x8f\x01\
    \x03\0\x02\x05\x04\x12\x04\xea\n\x10\x18\n\x10\n\x08\x04\x8f\x01\x03\0\
    \x02\x05\x05\x12\x04\xea\n\x19\x1f\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x05\
    \x01\x12\x04\xea\n\x20+\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x05\x03\x12\
    \x04\xea\n./\n\x0f\n\x07\x04\x8f\x01\x03\0\x02\x06\x12\x04\xeb\n\x10/\n\
    \x10\n\x08\x04\x8f\x01\x03\0\x02\x06\x04\x12\x04\xeb\n\x10\x18\n\x10\n\
    \x08\x04\x8f\x01\x03\0\x02\x06\x05\x12\x04\xeb\n\x19\x1f\n\x10\n\x08\x04\
    \x8f\x01\x03\0\x02\x06\x01\x12\x04\xeb\n\x20*\n\x10\n\x08\x04\x8f\x01\
    \x03\0\x02\x06\x03\x12\x04\xeb\n-.\n\x0f\n\x07\x04\x8f\x01\x03\0\x02\x07\
    \x12\x04\xec\n\x101\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x07\x04\x12\x04\
    \xec\n\x10\x18\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x07\x05\x12\x04\xec\n\
    \x19\x1f\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x07\x01\x12\x04\xec\n\x20,\n\
    \x10\n\x08\x04\x8f\x01\x03\0\x02\x07\x03\x12\x04\xec\n/0\n\x0f\n\x07\x04\
    \x8f\x01\x03\0\x02\x08\x12\x04\xed\n\x100\n\x10\n\x08\x04\x8f\x01\x03\0\
    \x02\x08\x04\x12\x04\xed\n\x10\x18\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x08\
    \x05\x12\x04\xed\n\x19\x1f\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x08\x01\x12\
    \x04\xed\n\x20+\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x08\x03\x12\x04\xed\n.\
    /\n\x0f\n\x07\x04\x8f\x01\x03\0\x02\t\x12\x04\xee\n\x103\n\x10\n\x08\x04\
    \x8f\x01\x03\0\x02\t\x04\x12\x04\xee\n\x10\x18\n\x10\n\x08\x04\x8f\x01\
    \x03\0\x02\t\x05\x12\x04\xee\n\x19\x1f\n\x10\n\x08\x04\x8f\x01\x03\0\x02\
    \t\x01\x12\x04\xee\n\x20-\n\x10\n\x08\x04\x8f\x01\x03\0\x02\t\x03\x12\
    \x04\xee\n02\n\x0f\n\x07\x04\x8f\x01\x03\0\x02\n\x12\x04\xef\n\x101\n\
    \x10\n\x08\x04\x8f\x01\x03\0\x02\n\x04\x12\x04\xef\n\x10\x18\n\x10\n\x08\
    \x04\x8f\x01\x03\0\x02\n\x05\x12\x04\xef\n\x19\x1f\n\x10\n\x08\x04\x8f\
    \x01\x03\0\x02\n\x01\x12\x04\xef\n\x20+\n\x10\n\x08\x04\x8f\x01\x03\0\
    \x02\n\x03\x12\x04\xef\n.0\n\x0f\n\x07\x04\x8f\x01\x03\0\x02\x0b\x12\x04\
    \xf0\n\x103\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x0b\x04\x12\x04\xf0\n\x10\
    \x18\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x0b\x05\x12\x04\xf0\n\x19\x1f\n\
    \x10\n\x08\x04\x8f\x01\x03\0\x02\x0b\x01\x12\x04\xf0\n\x20-\n\x10\n\x08\
    \x04\x8f\x01\x03\0\x02\x0b\x03\x12\x04\xf0\n02\n\r\n\x05\x04\x8f\x01\x02\
    \0\x12\x04\xf3\n\x08[\n\x0e\n\x06\x04\x8f\x01\x02\0\x04\x12\x04\xf3\n\
    \x08\x10\n\x0e\n\x06\x04\x8f\x01\x02\0\x06\x12\x04\xf3\n\x11M\n\x0e\n\
    \x06\x04\x8f\x01\x02\0\x01\x12\x04\xf3\nNV\n\x0e\n\x06\x04\x8f\x01\x02\0\
    \x03\x12\x04\xf3\nYZ\n\r\n\x03\x04\x90\x01\x12\x06\xf6\n\0\x82\x0b\x01\n\
    \x0c\n\x04\x04\x90\x01\x01\x12\x04\xf6\n\x08\x1b\n\x0f\n\x05\x04\x90\x01\
    \x04\0\x12\x06\xf7\n\x08\xfe\n\t\n\x0e\n\x06\x04\x90\x01\x04\0\x01\x12\
    \x04\xf7\n\r\x14\n\x0f\n\x07\x04\x90\x01\x04\0\x02\0\x12\x04\xf8\n\x10$\
    \n\x10\n\x08\x04\x90\x01\x04\0\x02\0\x01\x12\x04\xf8\n\x10\x1f\n\x10\n\
    \x08\x04\x90\x01\x04\0\x02\0\x02\x12\x04\xf8\n\"#\n\x0f\n\x07\x04\x90\
    \x01\x04\0\x02\x01\x12\x04\xf9\n\x10%\n\x10\n\x08\x04\x90\x01\x04\0\x02\
    \x01\x01\x12\x04\xf9\n\x10\x20\n\x10\n\x08\x04\x90\x01\x04\0\x02\x01\x02\
    \x12\x04\xf9\n#$\n\x0f\n\x07\x04\x90\x01\x04\0\x02\x02\x12\x04\xfa\n\x10\
    !\n\x10\n\x08\x04\x90\x01\x04\0\x02\x02\x01\x12\x04\xfa\n\x10\x1c\n\x10\
    \n\x08\x04\x90\x01\x04\0\x02\x02\x02\x12\x04\xfa\n\x1f\x20\n\x0f\n\x07\
    \x04\x90\x01\x04\0\x02\x03\x12\x04\xfb\n\x10'\n\x10\n\x08\x04\x90\x01\
    \x04\0\x02\x03\x01\x12\x04\xfb\n\x10\"\n\x10\n\x08\x04\x90\x01\x04\0\x02\
    \x03\x02\x12\x04\xfb\n%&\n\x0f\n\x07\x04\x90\x01\x04\0\x02\x04\x12\x04\
    \xfc\n\x10%\n\x10\n\x08\x04\x90\x01\x04\0\x02\x04\x01\x12\x04\xfc\n\x10\
    \x20\n\x10\n\x08\x04\x90\x01\x04\0\x02\x04\x02\x12\x04\xfc\n#$\n\x0f\n\
    \x07\x04\x90\x01\x04\0\x02\x05\x12\x04\xfd\n\x10\"\n\x10\n\x08\x04\x90\
    \x01\x04\0\x02\x05\x01\x12\x04\xfd\n\x10\x1d\n\x10\n\x08\x04\x90\x01\x04\
    \0\x02\x05\x02\x12\x04\xfd\n\x20!\n\r\n\x05\x04\x90\x01\x02\0\x12\x04\
    \x80\x0b\x08.\n\x0e\n\x06\x04\x90\x01\x02\0\x04\x12\x04\x80\x0b\x08\x10\
    \n\x0e\n\x06\x04\x90\x01\x02\0\x05\x12\x04\x80\x0b\x11\x17\n\x0e\n\x06\
    \x04\x90\x01\x02\0\x01\x12\x04\x80\x0b\x18)\n\x0e\n\x06\x04\x90\x01\x02\
    \0\x03\x12\x04\x80\x0b,-\n\r\n\x05\x04\x90\x01\x02\x01\x12\x04\x81\x0b\
    \x08U\n\x0e\n\x06\x04\x90\x01\x02\x01\x04\x12\x04\x81\x0b\x08\x10\n\x0e\
    \n\x06\x04\x90\x01\x02\x01\x06\x12\x04\x81\x0b\x11-\n\x0e\n\x06\x04\x90\
    \x01\x02\x01\x01\x12\x04\x81\x0b.4\n\x0e\n\x06\x04\x90\x01\x02\x01\x03\
    \x12\x04\x81\x0b78\n\x0e\n\x06\x04\x90\x01\x02\x01\x08\x12\x04\x81\x0b9T\
    \n\x0e\n\x06\x04\x90\x01\x02\x01\x07\x12\x04\x81\x0bDS\n\r\n\x03\x04\x91\
    \x01\x12\x06\x84\x0b\0\xa0\x0b\x01\n\x0c\n\x04\x04\x91\x01\x01\x12\x04\
    \x84\x0b\x08#\n\r\n\x05\x04\x91\x01\x02\0\x12\x04\x85\x0b\x08:\n\x0e\n\
    \x06\x04\x91\x01\x02\0\x04\x12\x04\x85\x0b\x08\x10\n\x0e\n\x06\x04\x91\
    \x01\x02\0\x05\x12\x04\x85\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\0\x01\
    \x12\x04\x85\x0b\x18\x20\n\x0e\n\x06\x04\x91\x01\x02\0\x03\x12\x04\x85\
    \x0b#$\n\x0e\n\x06\x04\x91\x01\x02\0\x08\x12\x04\x85\x0b%9\n\x11\n\t\x04\
    \x91\x01\x02\0\x08\xe0\xd4\x03\x12\x04\x85\x0b&8\n\r\n\x05\x04\x91\x01\
    \x02\x01\x12\x04\x86\x0b\x08<\n\x0e\n\x06\x04\x91\x01\x02\x01\x04\x12\
    \x04\x86\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x01\x05\x12\x04\x86\x0b\
    \x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x01\x01\x12\x04\x86\x0b\x18\"\n\x0e\
    \n\x06\x04\x91\x01\x02\x01\x03\x12\x04\x86\x0b%&\n\x0e\n\x06\x04\x91\x01\
    \x02\x01\x08\x12\x04\x86\x0b';\n\x11\n\t\x04\x91\x01\x02\x01\x08\xe0\xd4\
    \x03\x12\x04\x86\x0b(:\n\r\n\x05\x04\x91\x01\x02\x02\x12\x04\x87\x0b\x08\
    <\n\x0e\n\x06\x04\x91\x01\x02\x02\x04\x12\x04\x87\x0b\x08\x10\n\x0e\n\
    \x06\x04\x91\x01\x02\x02\x05\x12\x04\x87\x0b\x11\x16\n\x0e\n\x06\x04\x91\
    \x01\x02\x02\x01\x12\x04\x87\x0b\x17\"\n\x0e\n\x06\x04\x91\x01\x02\x02\
    \x03\x12\x04\x87\x0b%&\n\x0e\n\x06\x04\x91\x01\x02\x02\x08\x12\x04\x87\
    \x0b';\n\x11\n\t\x04\x91\x01\x02\x02\x08\xe0\xd4\x03\x12\x04\x87\x0b(:\n\
    \r\n\x05\x04\x91\x01\x02\x03\x12\x04\x88\x0b\x08$\n\x0e\n\x06\x04\x91\
    \x01\x02\x03\x04\x12\x04\x88\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x03\
    \x05\x12\x04\x88\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x03\x01\x12\x04\
    \x88\x0b\x18\x1f\n\x0e\n\x06\x04\x91\x01\x02\x03\x03\x12\x04\x88\x0b\"#\
    \n\r\n\x05\x04\x91\x01\x02\x04\x12\x04\x89\x0b\x08&\n\x0e\n\x06\x04\x91\
    \x01\x02\x04\x04\x12\x04\x89\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x04\
    \x05\x12\x04\x89\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x04\x01\x12\x04\
    \x89\x0b\x18!\n\x0e\n\x06\x04\x91\x01\x02\x04\x03\x12\x04\x89\x0b$%\n\r\
    \n\x05\x04\x91\x01\x02\x05\x12\x04\x8a\x0b\x08#\n\x0e\n\x06\x04\x91\x01\
    \x02\x05\x04\x12\x04\x8a\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x05\x05\
    \x12\x04\x8a\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x05\x01\x12\x04\x8a\
    \x0b\x18\x1e\n\x0e\n\x06\x04\x91\x01\x02\x05\x03\x12\x04\x8a\x0b!\"\n\r\
    \n\x05\x04\x91\x01\x02\x06\x12\x04\x8b\x0b\x08.\n\x0e\n\x06\x04\x91\x01\
    \x02\x06\x04\x12\x04\x8b\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x06\x05\
    \x12\x04\x8b\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x06\x01\x12\x04\x8b\
    \x0b\x18)\n\x0e\n\x06\x04\x91\x01\x02\x06\x03\x12\x04\x8b\x0b,-\n\r\n\
    \x05\x04\x91\x01\x02\x07\x12\x04\x8c\x0b\x08!\n\x0e\n\x06\x04\x91\x01\
    \x02\x07\x04\x12\x04\x8c\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x07\x05\
    \x12\x04\x8c\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x07\x01\x12\x04\x8c\
    \x0b\x18\x1c\n\x0e\n\x06\x04\x91\x01\x02\x07\x03\x12\x04\x8c\x0b\x1f\x20\
    \n\r\n\x05\x04\x91\x01\x02\x08\x12\x04\x8d\x0b\x08\"\n\x0e\n\x06\x04\x91\
    \x01\x02\x08\x04\x12\x04\x8d\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x08\
    \x05\x12\x04\x8d\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x08\x01\x12\x04\
    \x8d\x0b\x18\x1d\n\x0e\n\x06\x04\x91\x01\x02\x08\x03\x12\x04\x8d\x0b\x20\
    !\n\r\n\x05\x04\x91\x01\x02\t\x12\x04\x8e\x0b\x08\"\n\x0e\n\x06\x04\x91\
    \x01\x02\t\x04\x12\x04\x8e\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\t\x05\
    \x12\x04\x8e\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\t\x01\x12\x04\x8e\
    \x0b\x18\x1c\n\x0e\n\x06\x04\x91\x01\x02\t\x03\x12\x04\x8e\x0b\x1f!\n\r\
    \n\x05\x04\x91\x01\x02\n\x12\x04\x8f\x0b\x08#\n\x0e\n\x06\x04\x91\x01\
    \x02\n\x04\x12\x04\x8f\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\n\x05\x12\
    \x04\x8f\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\n\x01\x12\x04\x8f\x0b\
    \x18\x1d\n\x0e\n\x06\x04\x91\x01\x02\n\x03\x12\x04\x8f\x0b\x20\"\n\r\n\
    \x05\x04\x91\x01\x02\x0b\x12\x04\x90\x0b\x08,\n\x0e\n\x06\x04\x91\x01\
    \x02\x0b\x04\x12\x04\x90\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x0b\x05\
    \x12\x04\x90\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x0b\x01\x12\x04\x90\
    \x0b\x18&\n\x0e\n\x06\x04\x91\x01\x02\x0b\x03\x12\x04\x90\x0b)+\n\r\n\
    \x05\x04\x91\x01\x02\x0c\x12\x04\x91\x0b\x082\n\x0e\n\x06\x04\x91\x01\
    \x02\x0c\x04\x12\x04\x91\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x0c\x05\
    \x12\x04\x91\x0b\x11\x16\n\x0e\n\x06\x04\x91\x01\x02\x0c\x01\x12\x04\x91\
    \x0b\x17,\n\x0e\n\x06\x04\x91\x01\x02\x0c\x03\x12\x04\x91\x0b/1\n\r\n\
    \x05\x04\x91\x01\x02\r\x12\x04\x92\x0b\x08\"\n\x0e\n\x06\x04\x91\x01\x02\
    \r\x04\x12\x04\x92\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\r\x05\x12\x04\
    \x92\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\r\x01\x12\x04\x92\x0b\x18\
    \x1c\n\x0e\n\x06\x04\x91\x01\x02\r\x03\x12\x04\x92\x0b\x1f!\n\r\n\x05\
    \x04\x91\x01\x02\x0e\x12\x04\x93\x0b\x08,\n\x0e\n\x06\x04\x91\x01\x02\
    \x0e\x04\x12\x04\x93\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x0e\x05\x12\
    \x04\x93\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x0e\x01\x12\x04\x93\x0b\
    \x18&\n\x0e\n\x06\x04\x91\x01\x02\x0e\x03\x12\x04\x93\x0b)+\n\r\n\x05\
    \x04\x91\x01\x02\x0f\x12\x04\x94\x0b\x08#\n\x0e\n\x06\x04\x91\x01\x02\
    \x0f\x04\x12\x04\x94\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x0f\x05\x12\
    \x04\x94\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x0f\x01\x12\x04\x94\x0b\
    \x18\x1d\n\x0e\n\x06\x04\x91\x01\x02\x0f\x03\x12\x04\x94\x0b\x20\"\n\r\n\
    \x05\x04\x91\x01\x02\x10\x12\x04\x95\x0b\x08$\n\x0e\n\x06\x04\x91\x01\
    \x02\x10\x04\x12\x04\x95\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x10\x05\
    \x12\x04\x95\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x10\x01\x12\x04\x95\
    \x0b\x18\x1e\n\x0e\n\x06\x04\x91\x01\x02\x10\x03\x12\x04\x95\x0b!#\n\r\n\
    \x05\x04\x91\x01\x02\x11\x12\x04\x96\x0b\x08$\n\x0e\n\x06\x04\x91\x01\
    \x02\x11\x04\x12\x04\x96\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x11\x05\
    \x12\x04\x96\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x11\x01\x12\x04\x96\
    \x0b\x18\x1e\n\x0e\n\x06\x04\x91\x01\x02\x11\x03\x12\x04\x96\x0b!#\n\r\n\
    \x05\x04\x91\x01\x02\x12\x12\x04\x97\x0b\x08%\n\x0e\n\x06\x04\x91\x01\
    \x02\x12\x04\x12\x04\x97\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x12\x05\
    \x12\x04\x97\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x12\x01\x12\x04\x97\
    \x0b\x18\x1f\n\x0e\n\x06\x04\x91\x01\x02\x12\x03\x12\x04\x97\x0b\"$\n\r\
    \n\x05\x04\x91\x01\x02\x13\x12\x04\x98\x0b\x08%\n\x0e\n\x06\x04\x91\x01\
    \x02\x13\x04\x12\x04\x98\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x13\x05\
    \x12\x04\x98\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x13\x01\x12\x04\x98\
    \x0b\x18\x1f\n\x0e\n\x06\x04\x91\x01\x02\x13\x03\x12\x04\x98\x0b\"$\n\r\
    \n\x05\x04\x91\x01\x02\x14\x12\x04\x99\x0b\x08)\n\x0e\n\x06\x04\x91\x01\
    \x02\x14\x04\x12\x04\x99\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x14\x05\
    \x12\x04\x99\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x14\x01\x12\x04\x99\
    \x0b\x18#\n\x0e\n\x06\x04\x91\x01\x02\x14\x03\x12\x04\x99\x0b&(\n\r\n\
    \x05\x04\x91\x01\x02\x15\x12\x04\x9a\x0b\x08)\n\x0e\n\x06\x04\x91\x01\
    \x02\x15\x04\x12\x04\x9a\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x15\x05\
    \x12\x04\x9a\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x15\x01\x12\x04\x9a\
    \x0b\x18#\n\x0e\n\x06\x04\x91\x01\x02\x15\x03\x12\x04\x9a\x0b&(\n\r\n\
    \x05\x04\x91\x01\x02\x16\x12\x04\x9b\x0b\x08*\n\x0e\n\x06\x04\x91\x01\
    \x02\x16\x04\x12\x04\x9b\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x16\x05\
    \x12\x04\x9b\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x16\x01\x12\x04\x9b\
    \x0b\x18$\n\x0e\n\x06\x04\x91\x01\x02\x16\x03\x12\x04\x9b\x0b')\n\r\n\
    \x05\x04\x91\x01\x02\x17\x12\x04\x9c\x0b\x08+\n\x0e\n\x06\x04\x91\x01\
    \x02\x17\x04\x12\x04\x9c\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x17\x05\
    \x12\x04\x9c\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x17\x01\x12\x04\x9c\
    \x0b\x18%\n\x0e\n\x06\x04\x91\x01\x02\x17\x03\x12\x04\x9c\x0b(*\n\r\n\
    \x05\x04\x91\x01\x02\x18\x12\x04\x9d\x0b\x08+\n\x0e\n\x06\x04\x91\x01\
    \x02\x18\x04\x12\x04\x9d\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x18\x05\
    \x12\x04\x9d\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x18\x01\x12\x04\x9d\
    \x0b\x18%\n\x0e\n\x06\x04\x91\x01\x02\x18\x03\x12\x04\x9d\x0b(*\n\r\n\
    \x05\x04\x91\x01\x02\x19\x12\x04\x9e\x0b\x08'\n\x0e\n\x06\x04\x91\x01\
    \x02\x19\x04\x12\x04\x9e\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x19\x05\
    \x12\x04\x9e\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x19\x01\x12\x04\x9e\
    \x0b\x18!\n\x0e\n\x06\x04\x91\x01\x02\x19\x03\x12\x04\x9e\x0b$&\n\r\n\
    \x05\x04\x91\x01\x02\x1a\x12\x04\x9f\x0b\x08*\n\x0e\n\x06\x04\x91\x01\
    \x02\x1a\x04\x12\x04\x9f\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x1a\x05\
    \x12\x04\x9f\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x1a\x01\x12\x04\x9f\
    \x0b\x18$\n\x0e\n\x06\x04\x91\x01\x02\x1a\x03\x12\x04\x9f\x0b')\n\r\n\
    \x03\x04\x92\x01\x12\x06\xa2\x0b\0\xa3\x0b\x01\n\x0c\n\x04\x04\x92\x01\
    \x01\x12\x04\xa2\x0b\x08$\n\r\n\x03\x04\x93\x01\x12\x06\xa5\x0b\0\xa8\
    \x0b\x01\n\x0c\n\x04\x04\x93\x01\x01\x12\x04\xa5\x0b\x08\"\n\r\n\x05\x04\
    \x93\x01\x02\0\x12\x04\xa6\x0b\x08!\n\x0e\n\x06\x04\x93\x01\x02\0\x04\
    \x12\x04\xa6\x0b\x08\x10\n\x0e\n\x06\x04\x93\x01\x02\0\x05\x12\x04\xa6\
    \x0b\x11\x17\n\x0e\n\x06\x04\x93\x01\x02\0\x01\x12\x04\xa6\x0b\x18\x1c\n\
    \x0e\n\x06\x04\x93\x01\x02\0\x03\x12\x04\xa6\x0b\x1f\x20\n\r\n\x05\x04\
    \x93\x01\x02\x01\x12\x04\xa7\x0b\x08(\n\x0e\n\x06\x04\x93\x01\x02\x01\
    \x04\x12\x04\xa7\x0b\x08\x10\n\x0e\n\x06\x04\x93\x01\x02\x01\x05\x12\x04\
    \xa7\x0b\x11\x16\n\x0e\n\x06\x04\x93\x01\x02\x01\x01\x12\x04\xa7\x0b\x17\
    #\n\x0e\n\x06\x04\x93\x01\x02\x01\x03\x12\x04\xa7\x0b&'\n\r\n\x03\x04\
    \x94\x01\x12\x06\xaa\x0b\0\xac\x0b\x01\n\x0c\n\x04\x04\x94\x01\x01\x12\
    \x04\xaa\x0b\x08,\n\r\n\x05\x04\x94\x01\x02\0\x12\x04\xab\x0b\x08H\n\x0e\
    \n\x06\x04\x94\x01\x02\0\x04\x12\x04\xab\x0b\x08\x10\n\x0e\n\x06\x04\x94\
    \x01\x02\0\x06\x12\x04\xab\x0b\x11,\n\x0e\n\x06\x04\x94\x01\x02\0\x01\
    \x12\x04\xab\x0b-C\n\x0e\n\x06\x04\x94\x01\x02\0\x03\x12\x04\xab\x0bFG\n\
    \r\n\x03\x04\x95\x01\x12\x06\xae\x0b\0\xb1\x0b\x01\n\x0c\n\x04\x04\x95\
    \x01\x01\x12\x04\xae\x0b\x08%\n\r\n\x05\x04\x95\x01\x02\0\x12\x04\xaf\
    \x0b\x08&\n\x0e\n\x06\x04\x95\x01\x02\0\x04\x12\x04\xaf\x0b\x08\x10\n\
    \x0e\n\x06\x04\x95\x01\x02\0\x05\x12\x04\xaf\x0b\x11\x17\n\x0e\n\x06\x04\
    \x95\x01\x02\0\x01\x12\x04\xaf\x0b\x18!\n\x0e\n\x06\x04\x95\x01\x02\0\
    \x03\x12\x04\xaf\x0b$%\n\r\n\x05\x04\x95\x01\x02\x01\x12\x04\xb0\x0b\x08\
    ]\n\x0e\n\x06\x04\x95\x01\x02\x01\x04\x12\x04\xb0\x0b\x08\x10\n\x0e\n\
    \x06\x04\x95\x01\x02\x01\x06\x12\x04\xb0\x0b\x116\n\x0e\n\x06\x04\x95\
    \x01\x02\x01\x01\x12\x04\xb0\x0b7X\n\x0e\n\x06\x04\x95\x01\x02\x01\x03\
    \x12\x04\xb0\x0b[\\\n\r\n\x03\x04\x96\x01\x12\x06\xb3\x0b\0\xb5\x0b\x01\
    \n\x0c\n\x04\x04\x96\x01\x01\x12\x04\xb3\x0b\x08\x1e\n\r\n\x05\x04\x96\
    \x01\x02\0\x12\x04\xb4\x0b\x08T\n\x0e\n\x06\x04\x96\x01\x02\0\x04\x12\
    \x04\xb4\x0b\x08\x10\n\x0e\n\x06\x04\x96\x01\x02\0\x06\x12\x04\xb4\x0b\
    \x11\x1f\n\x0e\n\x06\x04\x96\x01\x02\0\x01\x12\x04\xb4\x0b\x20+\n\x0e\n\
    \x06\x04\x96\x01\x02\0\x03\x12\x04\xb4\x0b./\n\x0e\n\x06\x04\x96\x01\x02\
    \0\x08\x12\x04\xb4\x0b0S\n\x0e\n\x06\x04\x96\x01\x02\0\x07\x12\x04\xb4\
    \x0b;R\n\r\n\x03\x04\x97\x01\x12\x06\xb7\x0b\0\xc6\x0b\x01\n\x0c\n\x04\
    \x04\x97\x01\x01\x12\x04\xb7\x0b\x08#\n\x0f\n\x05\x04\x97\x01\x03\0\x12\
    \x06\xb8\x0b\x08\xbc\x0b\t\n\x0e\n\x06\x04\x97\x01\x03\0\x01\x12\x04\xb8\
    \x0b\x10\x19\n\x0f\n\x07\x04\x97\x01\x03\0\x02\0\x12\x04\xb9\x0b\x10)\n\
    \x10\n\x08\x04\x97\x01\x03\0\x02\0\x04\x12\x04\xb9\x0b\x10\x18\n\x10\n\
    \x08\x04\x97\x01\x03\0\x02\0\x05\x12\x04\xb9\x0b\x19\x1f\n\x10\n\x08\x04\
    \x97\x01\x03\0\x02\0\x01\x12\x04\xb9\x0b\x20$\n\x10\n\x08\x04\x97\x01\
    \x03\0\x02\0\x03\x12\x04\xb9\x0b'(\n\x0f\n\x07\x04\x97\x01\x03\0\x02\x01\
    \x12\x04\xba\x0b\x10)\n\x10\n\x08\x04\x97\x01\x03\0\x02\x01\x04\x12\x04\
    \xba\x0b\x10\x18\n\x10\n\x08\x04\x97\x01\x03\0\x02\x01\x05\x12\x04\xba\
    \x0b\x19\x1f\n\x10\n\x08\x04\x97\x01\x03\0\x02\x01\x01\x12\x04\xba\x0b\
    \x20$\n\x10\n\x08\x04\x97\x01\x03\0\x02\x01\x03\x12\x04\xba\x0b'(\n\x0f\
    \n\x07\x04\x97\x01\x03\0\x02\x02\x12\x04\xbb\x0b\x10`\n\x10\n\x08\x04\
    \x97\x01\x03\0\x02\x02\x04\x12\x04\xbb\x0b\x10\x18\n\x10\n\x08\x04\x97\
    \x01\x03\0\x02\x02\x06\x12\x04\xbb\x0b\x19<\n\x10\n\x08\x04\x97\x01\x03\
    \0\x02\x02\x01\x12\x04\xbb\x0b=H\n\x10\n\x08\x04\x97\x01\x03\0\x02\x02\
    \x03\x12\x04\xbb\x0bKL\n\x10\n\x08\x04\x97\x01\x03\0\x02\x02\x08\x12\x04\
    \xbb\x0bM_\n\x10\n\x08\x04\x97\x01\x03\0\x02\x02\x07\x12\x04\xbb\x0bX^\n\
    \x0f\n\x05\x04\x97\x01\x04\0\x12\x06\xbe\x0b\x08\xc3\x0b\t\n\x0e\n\x06\
    \x04\x97\x01\x04\0\x01\x12\x04\xbe\x0b\r\x13\n\x0f\n\x07\x04\x97\x01\x04\
    \0\x02\0\x12\x04\xbf\x0b\x10\x1c\n\x10\n\x08\x04\x97\x01\x04\0\x02\0\x01\
    \x12\x04\xbf\x0b\x10\x17\n\x10\n\x08\x04\x97\x01\x04\0\x02\0\x02\x12\x04\
    \xbf\x0b\x1a\x1b\n\x0f\n\x07\x04\x97\x01\x04\0\x02\x01\x12\x04\xc0\x0b\
    \x10\x1b\n\x10\n\x08\x04\x97\x01\x04\0\x02\x01\x01\x12\x04\xc0\x0b\x10\
    \x16\n\x10\n\x08\x04\x97\x01\x04\0\x02\x01\x02\x12\x04\xc0\x0b\x19\x1a\n\
    \x0f\n\x07\x04\x97\x01\x04\0\x02\x02\x12\x04\xc1\x0b\x10\x20\n\x10\n\x08\
    \x04\x97\x01\x04\0\x02\x02\x01\x12\x04\xc1\x0b\x10\x1b\n\x10\n\x08\x04\
    \x97\x01\x04\0\x02\x02\x02\x12\x04\xc1\x0b\x1e\x1f\n\x0f\n\x07\x04\x97\
    \x01\x04\0\x02\x03\x12\x04\xc2\x0b\x10%\n\x10\n\x08\x04\x97\x01\x04\0\
    \x02\x03\x01\x12\x04\xc2\x0b\x10\x20\n\x10\n\x08\x04\x97\x01\x04\0\x02\
    \x03\x02\x12\x04\xc2\x0b#$\n\r\n\x05\x04\x97\x01\x02\0\x12\x04\xc5\x0b\
    \x08E\n\x0e\n\x06\x04\x97\x01\x02\0\x04\x12\x04\xc5\x0b\x08\x10\n\x0e\n\
    \x06\x04\x97\x01\x02\0\x06\x12\x04\xc5\x0b\x117\n\x0e\n\x06\x04\x97\x01\
    \x02\0\x01\x12\x04\xc5\x0b8@\n\x0e\n\x06\x04\x97\x01\x02\0\x03\x12\x04\
    \xc5\x0bCD\n\r\n\x03\x04\x98\x01\x12\x06\xc8\x0b\0\xca\x0b\x01\n\x0c\n\
    \x04\x04\x98\x01\x01\x12\x04\xc8\x0b\x08\"\n\r\n\x05\x04\x98\x01\x02\0\
    \x12\x04\xc9\x0b\x08%\n\x0e\n\x06\x04\x98\x01\x02\0\x04\x12\x04\xc9\x0b\
    \x08\x10\n\x0e\n\x06\x04\x98\x01\x02\0\x05\x12\x04\xc9\x0b\x11\x17\n\x0e\
    \n\x06\x04\x98\x01\x02\0\x01\x12\x04\xc9\x0b\x18\x20\n\x0e\n\x06\x04\x98\
    \x01\x02\0\x03\x12\x04\xc9\x0b#$\n\r\n\x03\x04\x99\x01\x12\x06\xcc\x0b\0\
    \xcf\x0b\x01\n\x0c\n\x04\x04\x99\x01\x01\x12\x04\xcc\x0b\x08\x1b\n\r\n\
    \x05\x04\x99\x01\x02\0\x12\x04\xcd\x0b\x08Z\n\x0e\n\x06\x04\x99\x01\x02\
    \0\x04\x12\x04\xcd\x0b\x08\x10\n\x0e\n\x06\x04\x99\x01\x02\0\x06\x12\x04\
    \xcd\x0b\x11$\n\x0e\n\x06\x04\x99\x01\x02\0\x01\x12\x04\xcd\x0b%2\n\x0e\
    \n\x06\x04\x99\x01\x02\0\x03\x12\x04\xcd\x0b56\n\x0e\n\x06\x04\x99\x01\
    \x02\0\x08\x12\x04\xcd\x0b7Y\n\x0e\n\x06\x04\x99\x01\x02\0\x07\x12\x04\
    \xcd\x0bBX\n\r\n\x05\x04\x99\x01\x02\x01\x12\x04\xce\x0b\x08%\n\x0e\n\
    \x06\x04\x99\x01\x02\x01\x04\x12\x04\xce\x0b\x08\x10\n\x0e\n\x06\x04\x99\
    \x01\x02\x01\x05\x12\x04\xce\x0b\x11\x17\n\x0e\n\x06\x04\x99\x01\x02\x01\
    \x01\x12\x04\xce\x0b\x18\x20\n\x0e\n\x06\x04\x99\x01\x02\x01\x03\x12\x04\
    \xce\x0b#$\n\r\n\x03\x04\x9a\x01\x12\x06\xd1\x0b\0\xd5\x0b\x01\n\x0c\n\
    \x04\x04\x9a\x01\x01\x12\x04\xd1\x0b\x08\x1c\n\r\n\x05\x04\x9a\x01\x02\0\
    \x12\x04\xd2\x0b\x08Z\n\x0e\n\x06\x04\x9a\x01\x02\0\x04\x12\x04\xd2\x0b\
    \x08\x10\n\x0e\n\x06\x04\x9a\x01\x02\0\x06\x12\x04\xd2\x0b\x11$\n\x0e\n\
    \x06\x04\x9a\x01\x02\0\x01\x12\x04\xd2\x0b%2\n\x0e\n\x06\x04\x9a\x01\x02\
    \0\x03\x12\x04\xd2\x0b56\n\x0e\n\x06\x04\x9a\x01\x02\0\x08\x12\x04\xd2\
    \x0b7Y\n\x0e\n\x06\x04\x9a\x01\x02\0\x07\x12\x04\xd2\x0bBX\n\r\n\x05\x04\
    \x9a\x01\x02\x01\x12\x04\xd3\x0b\x08%\n\x0e\n\x06\x04\x9a\x01\x02\x01\
    \x04\x12\x04\xd3\x0b\x08\x10\n\x0e\n\x06\x04\x9a\x01\x02\x01\x05\x12\x04\
    \xd3\x0b\x11\x17\n\x0e\n\x06\x04\x9a\x01\x02\x01\x01\x12\x04\xd3\x0b\x18\
    \x20\n\x0e\n\x06\x04\x9a\x01\x02\x01\x03\x12\x04\xd3\x0b#$\n\r\n\x05\x04\
    \x9a\x01\x02\x02\x12\x04\xd4\x0b\x08$\n\x0e\n\x06\x04\x9a\x01\x02\x02\
    \x04\x12\x04\xd4\x0b\x08\x10\n\x0e\n\x06\x04\x9a\x01\x02\x02\x05\x12\x04\
    \xd4\x0b\x11\x16\n\x0e\n\x06\x04\x9a\x01\x02\x02\x01\x12\x04\xd4\x0b\x17\
    \x1f\n\x0e\n\x06\x04\x9a\x01\x02\x02\x03\x12\x04\xd4\x0b\"#\n\r\n\x03\
    \x04\x9b\x01\x12\x06\xd7\x0b\0\xe1\x0b\x01\n\x0c\n\x04\x04\x9b\x01\x01\
    \x12\x04\xd7\x0b\x08\x17\n\r\n\x05\x04\x9b\x01\x02\0\x12\x04\xd8\x0b\x08\
    <\n\x0e\n\x06\x04\x9b\x01\x02\0\x04\x12\x04\xd8\x0b\x08\x10\n\x0e\n\x06\
    \x04\x9b\x01\x02\0\x05\x12\x04\xd8\x0b\x11\x17\n\x0e\n\x06\x04\x9b\x01\
    \x02\0\x01\x12\x04\xd8\x0b\x18\"\n\x0e\n\x06\x04\x9b\x01\x02\0\x03\x12\
    \x04\xd8\x0b%&\n\x0e\n\x06\x04\x9b\x01\x02\0\x08\x12\x04\xd8\x0b';\n\x11\
    \n\t\x04\x9b\x01\x02\0\x08\xe0\xd4\x03\x12\x04\xd8\x0b(:\n\r\n\x05\x04\
    \x9b\x01\x02\x01\x12\x04\xd9\x0b\x08:\n\x0e\n\x06\x04\x9b\x01\x02\x01\
    \x04\x12\x04\xd9\x0b\x08\x10\n\x0e\n\x06\x04\x9b\x01\x02\x01\x05\x12\x04\
    \xd9\x0b\x11\x17\n\x0e\n\x06\x04\x9b\x01\x02\x01\x01\x12\x04\xd9\x0b\x18\
    \x20\n\x0e\n\x06\x04\x9b\x01\x02\x01\x03\x12\x04\xd9\x0b#$\n\x0e\n\x06\
    \x04\x9b\x01\x02\x01\x08\x12\x04\xd9\x0b%9\n\x11\n\t\x04\x9b\x01\x02\x01\
    \x08\xe0\xd4\x03\x12\x04\xd9\x0b&8\n\r\n\x05\x04\x9b\x01\x02\x02\x12\x04\
    \xda\x0b\x08$\n\x0e\n\x06\x04\x9b\x01\x02\x02\x04\x12\x04\xda\x0b\x08\
    \x10\n\x0e\n\x06\x04\x9b\x01\x02\x02\x05\x12\x04\xda\x0b\x11\x17\n\x0e\n\
    \x06\x04\x9b\x01\x02\x02\x01\x12\x04\xda\x0b\x18\x1f\n\x0e\n\x06\x04\x9b\
    \x01\x02\x02\x03\x12\x04\xda\x0b\"#\n\r\n\x05\x04\x9b\x01\x02\x03\x12\
    \x04\xdb\x0b\x08:\n\x0e\n\x06\x04\x9b\x01\x02\x03\x04\x12\x04\xdb\x0b\
    \x08\x10\n\x0e\n\x06\x04\x9b\x01\x02\x03\x05\x12\x04\xdb\x0b\x11\x15\n\
    \x0e\n\x06\x04\x9b\x01\x02\x03\x01\x12\x04\xdb\x0b\x16#\n\x0e\n\x06\x04\
    \x9b\x01\x02\x03\x03\x12\x04\xdb\x0b&'\n\x0e\n\x06\x04\x9b\x01\x02\x03\
    \x08\x12\x04\xdb\x0b(9\n\x0e\n\x06\x04\x9b\x01\x02\x03\x07\x12\x04\xdb\
    \x0b38\n\r\n\x05\x04\x9b\x01\x02\x04\x12\x04\xdc\x0b\x08:\n\x0e\n\x06\
    \x04\x9b\x01\x02\x04\x04\x12\x04\xdc\x0b\x08\x10\n\x0e\n\x06\x04\x9b\x01\
    \x02\x04\x05\x12\x04\xdc\x0b\x11\x15\n\x0e\n\x06\x04\x9b\x01\x02\x04\x01\
    \x12\x04\xdc\x0b\x16#\n\x0e\n\x06\x04\x9b\x01\x02\x04\x03\x12\x04\xdc\
    \x0b&'\n\x0e\n\x06\x04\x9b\x01\x02\x04\x08\x12\x04\xdc\x0b(9\n\x0e\n\x06\
    \x04\x9b\x01\x02\x04\x07\x12\x04\xdc\x0b38\n\r\n\x05\x04\x9b\x01\x02\x05\
    \x12\x04\xdd\x0b\x08:\n\x0e\n\x06\x04\x9b\x01\x02\x05\x04\x12\x04\xdd\
    \x0b\x08\x10\n\x0e\n\x06\x04\x9b\x01\x02\x05\x05\x12\x04\xdd\x0b\x11\x15\
    \n\x0e\n\x06\x04\x9b\x01\x02\x05\x01\x12\x04\xdd\x0b\x16#\n\x0e\n\x06\
    \x04\x9b\x01\x02\x05\x03\x12\x04\xdd\x0b&'\n\x0e\n\x06\x04\x9b\x01\x02\
    \x05\x08\x12\x04\xdd\x0b(9\n\x0e\n\x06\x04\x9b\x01\x02\x05\x07\x12\x04\
    \xdd\x0b38\n\r\n\x05\x04\x9b\x01\x02\x06\x12\x04\xde\x0b\x089\n\x0e\n\
    \x06\x04\x9b\x01\x02\x06\x04\x12\x04\xde\x0b\x08\x10\n\x0e\n\x06\x04\x9b\
    \x01\x02\x06\x05\x12\x04\xde\x0b\x11\x15\n\x0e\n\x06\x04\x9b\x01\x02\x06\
    \x01\x12\x04\xde\x0b\x16\"\n\x0e\n\x06\x04\x9b\x01\x02\x06\x03\x12\x04\
    \xde\x0b%&\n\x0e\n\x06\x04\x9b\x01\x02\x06\x08\x12\x04\xde\x0b'8\n\x0e\n\
    \x06\x04\x9b\x01\x02\x06\x07\x12\x04\xde\x0b27\n\r\n\x05\x04\x9b\x01\x02\
    \x07\x12\x04\xdf\x0b\x08>\n\x0e\n\x06\x04\x9b\x01\x02\x07\x04\x12\x04\
    \xdf\x0b\x08\x10\n\x0e\n\x06\x04\x9b\x01\x02\x07\x05\x12\x04\xdf\x0b\x11\
    \x17\n\x0e\n\x06\x04\x9b\x01\x02\x07\x01\x12\x04\xdf\x0b\x18*\n\x0e\n\
    \x06\x04\x9b\x01\x02\x07\x03\x12\x04\xdf\x0b-/\n\x0e\n\x06\x04\x9b\x01\
    \x02\x07\x08\x12\x04\xdf\x0b0=\n\x0e\n\x06\x04\x9b\x01\x02\x07\x07\x12\
    \x04\xdf\x0b;<\n\r\n\x05\x04\x9b\x01\x02\x08\x12\x04\xe0\x0b\x08'\n\x0e\
    \n\x06\x04\x9b\x01\x02\x08\x04\x12\x04\xe0\x0b\x08\x10\n\x0e\n\x06\x04\
    \x9b\x01\x02\x08\x05\x12\x04\xe0\x0b\x11\x17\n\x0e\n\x06\x04\x9b\x01\x02\
    \x08\x01\x12\x04\xe0\x0b\x18!\n\x0e\n\x06\x04\x9b\x01\x02\x08\x03\x12\
    \x04\xe0\x0b$&\n\r\n\x03\x04\x9c\x01\x12\x06\xe3\x0b\0\xed\x0b\x01\n\x0c\
    \n\x04\x04\x9c\x01\x01\x12\x04\xe3\x0b\x08\x10\n\r\n\x05\x04\x9c\x01\x02\
    \0\x12\x04\xe4\x0b\x08'\n\x0e\n\x06\x04\x9c\x01\x02\0\x04\x12\x04\xe4\
    \x0b\x08\x10\n\x0e\n\x06\x04\x9c\x01\x02\0\x05\x12\x04\xe4\x0b\x11\x17\n\
    \x0e\n\x06\x04\x9c\x01\x02\0\x01\x12\x04\xe4\x0b\x18\"\n\x0e\n\x06\x04\
    \x9c\x01\x02\0\x03\x12\x04\xe4\x0b%&\n\r\n\x05\x04\x9c\x01\x02\x01\x12\
    \x04\xe5\x0b\x08:\n\x0e\n\x06\x04\x9c\x01\x02\x01\x04\x12\x04\xe5\x0b\
    \x08\x10\n\x0e\n\x06\x04\x9c\x01\x02\x01\x05\x12\x04\xe5\x0b\x11\x17\n\
    \x0e\n\x06\x04\x9c\x01\x02\x01\x01\x12\x04\xe5\x0b\x18\x20\n\x0e\n\x06\
    \x04\x9c\x01\x02\x01\x03\x12\x04\xe5\x0b#$\n\x0e\n\x06\x04\x9c\x01\x02\
    \x01\x08\x12\x04\xe5\x0b%9\n\x11\n\t\x04\x9c\x01\x02\x01\x08\xe0\xd4\x03\
    \x12\x04\xe5\x0b&8\n\r\n\x05\x04\x9c\x01\x02\x02\x12\x04\xe6\x0b\x08%\n\
    \x0e\n\x06\x04\x9c\x01\x02\x02\x04\x12\x04\xe6\x0b\x08\x10\n\x0e\n\x06\
    \x04\x9c\x01\x02\x02\x05\x12\x04\xe6\x0b\x11\x17\n\x0e\n\x06\x04\x9c\x01\
    \x02\x02\x01\x12\x04\xe6\x0b\x18\x20\n\x0e\n\x06\x04\x9c\x01\x02\x02\x03\
    \x12\x04\xe6\x0b#$\n\r\n\x05\x04\x9c\x01\x02\x03\x12\x04\xe7\x0b\x083\n\
    \x0e\n\x06\x04\x9c\x01\x02\x03\x04\x12\x04\xe7\x0b\x08\x10\n\x0e\n\x06\
    \x04\x9c\x01\x02\x03\x05\x12\x04\xe7\x0b\x11\x15\n\x0e\n\x06\x04\x9c\x01\
    \x02\x03\x01\x12\x04\xe7\x0b\x16\x1c\n\x0e\n\x06\x04\x9c\x01\x02\x03\x03\
    \x12\x04\xe7\x0b\x1f\x20\n\x0e\n\x06\x04\x9c\x01\x02\x03\x08\x12\x04\xe7\
    \x0b!2\n\x0e\n\x06\x04\x9c\x01\x02\x03\x07\x12\x04\xe7\x0b,1\n\r\n\x05\
    \x04\x9c\x01\x02\x04\x12\x04\xe8\x0b\x08%\n\x0e\n\x06\x04\x9c\x01\x02\
    \x04\x04\x12\x04\xe8\x0b\x08\x10\n\x0e\n\x06\x04\x9c\x01\x02\x04\x05\x12\
    \x04\xe8\x0b\x11\x17\n\x0e\n\x06\x04\x9c\x01\x02\x04\x01\x12\x04\xe8\x0b\
    \x18\x20\n\x0e\n\x06\x04\x9c\x01\x02\x04\x03\x12\x04\xe8\x0b#$\n\r\n\x05\
    \x04\x9c\x01\x02\x05\x12\x04\xe9\x0b\x08%\n\x0e\n\x06\x04\x9c\x01\x02\
    \x05\x04\x12\x04\xe9\x0b\x08\x10\n\x0e\n\x06\x04\x9c\x01\x02\x05\x05\x12\
    \x04\xe9\x0b\x11\x17\n\x0e\n\x06\x04\x9c\x01\x02\x05\x01\x12\x04\xe9\x0b\
    \x18\x20\n\x0e\n\x06\x04\x9c\x01\x02\x05\x03\x12\x04\xe9\x0b#$\n\r\n\x05\
    \x04\x9c\x01\x02\x06\x12\x04\xea\x0b\x08%\n\x0e\n\x06\x04\x9c\x01\x02\
    \x06\x04\x12\x04\xea\x0b\x08\x10\n\x0e\n\x06\x04\x9c\x01\x02\x06\x05\x12\
    \x04\xea\x0b\x11\x17\n\x0e\n\x06\x04\x9c\x01\x02\x06\x01\x12\x04\xea\x0b\
    \x18\x20\n\x0e\n\x06\x04\x9c\x01\x02\x06\x03\x12\x04\xea\x0b#$\n\r\n\x05\
    \x04\x9c\x01\x02\x07\x12\x04\xeb\x0b\x085\n\x0e\n\x06\x04\x9c\x01\x02\
    \x07\x04\x12\x04\xeb\x0b\x08\x10\n\x0e\n\x06\x04\x9c\x01\x02\x07\x05\x12\
    \x04\xeb\x0b\x11\x17\n\x0e\n\x06\x04\x9c\x01\x02\x07\x01\x12\x04\xeb\x0b\
    \x180\n\x0e\n\x06\x04\x9c\x01\x02\x07\x03\x12\x04\xeb\x0b34\n\r\n\x05\
    \x04\x9c\x01\x02\x08\x12\x04\xec\x0b\x08&\n\x0e\n\x06\x04\x9c\x01\x02\
    \x08\x04\x12\x04\xec\x0b\x08\x10\n\x0e\n\x06\x04\x9c\x01\x02\x08\x05\x12\
    \x04\xec\x0b\x11\x17\n\x0e\n\x06\x04\x9c\x01\x02\x08\x01\x12\x04\xec\x0b\
    \x18!\n\x0e\n\x06\x04\x9c\x01\x02\x08\x03\x12\x04\xec\x0b$%\n\r\n\x03\
    \x04\x9d\x01\x12\x06\xef\x0b\0\xf5\x0b\x01\n\x0c\n\x04\x04\x9d\x01\x01\
    \x12\x04\xef\x0b\x08!\n\r\n\x05\x04\x9d\x01\x02\0\x12\x04\xf0\x0b\x08'\n\
    \x0e\n\x06\x04\x9d\x01\x02\0\x04\x12\x04\xf0\x0b\x08\x10\n\x0e\n\x06\x04\
    \x9d\x01\x02\0\x05\x12\x04\xf0\x0b\x11\x17\n\x0e\n\x06\x04\x9d\x01\x02\0\
    \x01\x12\x04\xf0\x0b\x18\"\n\x0e\n\x06\x04\x9d\x01\x02\0\x03\x12\x04\xf0\
    \x0b%&\n\r\n\x05\x04\x9d\x01\x02\x01\x12\x04\xf1\x0b\x08:\n\x0e\n\x06\
    \x04\x9d\x01\x02\x01\x04\x12\x04\xf1\x0b\x08\x10\n\x0e\n\x06\x04\x9d\x01\
    \x02\x01\x05\x12\x04\xf1\x0b\x11\x17\n\x0e\n\x06\x04\x9d\x01\x02\x01\x01\
    \x12\x04\xf1\x0b\x18\x20\n\x0e\n\x06\x04\x9d\x01\x02\x01\x03\x12\x04\xf1\
    \x0b#$\n\x0e\n\x06\x04\x9d\x01\x02\x01\x08\x12\x04\xf1\x0b%9\n\x11\n\t\
    \x04\x9d\x01\x02\x01\x08\xe0\xd4\x03\x12\x04\xf1\x0b&8\n\r\n\x05\x04\x9d\
    \x01\x02\x02\x12\x04\xf2\x0b\x08\"\n\x0e\n\x06\x04\x9d\x01\x02\x02\x04\
    \x12\x04\xf2\x0b\x08\x10\n\x0e\n\x06\x04\x9d\x01\x02\x02\x05\x12\x04\xf2\
    \x0b\x11\x17\n\x0e\n\x06\x04\x9d\x01\x02\x02\x01\x12\x04\xf2\x0b\x18\x1d\
    \n\x0e\n\x06\x04\x9d\x01\x02\x02\x03\x12\x04\xf2\x0b\x20!\n\r\n\x05\x04\
    \x9d\x01\x02\x03\x12\x04\xf3\x0b\x08&\n\x0e\n\x06\x04\x9d\x01\x02\x03\
    \x04\x12\x04\xf3\x0b\x08\x10\n\x0e\n\x06\x04\x9d\x01\x02\x03\x05\x12\x04\
    \xf3\x0b\x11\x17\n\x0e\n\x06\x04\x9d\x01\x02\x03\x01\x12\x04\xf3\x0b\x18\
    !\n\x0e\n\x06\x04\x9d\x01\x02\x03\x03\x12\x04\xf3\x0b$%\n\r\n\x05\x04\
    \x9d\x01\x02\x04\x12\x04\xf4\x0b\x08(\n\x0e\n\x06\x04\x9d\x01\x02\x04\
    \x04\x12\x04\xf4\x0b\x08\x10\n\x0e\n\x06\x04\x9d\x01\x02\x04\x05\x12\x04\
    \xf4\x0b\x11\x17\n\x0e\n\x06\x04\x9d\x01\x02\x04\x01\x12\x04\xf4\x0b\x18\
    #\n\x0e\n\x06\x04\x9d\x01\x02\x04\x03\x12\x04\xf4\x0b&'\n\r\n\x03\x04\
    \x9e\x01\x12\x06\xf7\x0b\0\xf9\x0b\x01\n\x0c\n\x04\x04\x9e\x01\x01\x12\
    \x04\xf7\x0b\x08\x1b\n\r\n\x05\x04\x9e\x01\x02\0\x12\x04\xf8\x0b\x08%\n\
    \x0e\n\x06\x04\x9e\x01\x02\0\x04\x12\x04\xf8\x0b\x08\x10\n\x0e\n\x06\x04\
    \x9e\x01\x02\0\x05\x12\x04\xf8\x0b\x11\x17\n\x0e\n\x06\x04\x9e\x01\x02\0\
    \x01\x12\x04\xf8\x0b\x18\x20\n\x0e\n\x06\x04\x9e\x01\x02\0\x03\x12\x04\
    \xf8\x0b#$\n\r\n\x03\x04\x9f\x01\x12\x06\xfb\x0b\0\xfd\x0b\x01\n\x0c\n\
    \x04\x04\x9f\x01\x01\x12\x04\xfb\x0b\x08\x1a\n\r\n\x05\x04\x9f\x01\x02\0\
    \x12\x04\xfc\x0b\x08,\n\x0e\n\x06\x04\x9f\x01\x02\0\x04\x12\x04\xfc\x0b\
    \x08\x10\n\x0e\n\x06\x04\x9f\x01\x02\0\x05\x12\x04\xfc\x0b\x11\x17\n\x0e\
    \n\x06\x04\x9f\x01\x02\0\x01\x12\x04\xfc\x0b\x18'\n\x0e\n\x06\x04\x9f\
    \x01\x02\0\x03\x12\x04\xfc\x0b*+\n\r\n\x03\x04\xa0\x01\x12\x06\xff\x0b\0\
    \x81\x0c\x01\n\x0c\n\x04\x04\xa0\x01\x01\x12\x04\xff\x0b\x08\x1d\n\r\n\
    \x05\x04\xa0\x01\x02\0\x12\x04\x80\x0c\x08*\n\x0e\n\x06\x04\xa0\x01\x02\
    \0\x04\x12\x04\x80\x0c\x08\x10\n\x0e\n\x06\x04\xa0\x01\x02\0\x05\x12\x04\
    \x80\x0c\x11\x17\n\x0e\n\x06\x04\xa0\x01\x02\0\x01\x12\x04\x80\x0c\x18%\
    \n\x0e\n\x06\x04\xa0\x01\x02\0\x03\x12\x04\x80\x0c()\n\r\n\x03\x04\xa1\
    \x01\x12\x06\x83\x0c\0\x86\x0c\x01\n\x0c\n\x04\x04\xa1\x01\x01\x12\x04\
    \x83\x0c\x08\x20\n\r\n\x05\x04\xa1\x01\x02\0\x12\x04\x84\x0c\x08*\n\x0e\
    \n\x06\x04\xa1\x01\x02\0\x04\x12\x04\x84\x0c\x08\x10\n\x0e\n\x06\x04\xa1\
    \x01\x02\0\x05\x12\x04\x84\x0c\x11\x17\n\x0e\n\x06\x04\xa1\x01\x02\0\x01\
    \x12\x04\x84\x0c\x18%\n\x0e\n\x06\x04\xa1\x01\x02\0\x03\x12\x04\x84\x0c(\
    )\n\r\n\x05\x04\xa1\x01\x02\x01\x12\x04\x85\x0c\x08+\n\x0e\n\x06\x04\xa1\
    \x01\x02\x01\x04\x12\x04\x85\x0c\x08\x10\n\x0e\n\x06\x04\xa1\x01\x02\x01\
    \x05\x12\x04\x85\x0c\x11\x17\n\x0e\n\x06\x04\xa1\x01\x02\x01\x01\x12\x04\
    \x85\x0c\x18&\n\x0e\n\x06\x04\xa1\x01\x02\x01\x03\x12\x04\x85\x0c)*\n\r\
    \n\x03\x04\xa2\x01\x12\x06\x88\x0c\0\x8c\x0c\x01\n\x0c\n\x04\x04\xa2\x01\
    \x01\x12\x04\x88\x0c\x08%\n\r\n\x05\x04\xa2\x01\x02\0\x12\x04\x89\x0c\
    \x08-\n\x0e\n\x06\x04\xa2\x01\x02\0\x04\x12\x04\x89\x0c\x08\x10\n\x0e\n\
    \x06\x04\xa2\x01\x02\0\x05\x12\x04\x89\x0c\x11\x17\n\x0e\n\x06\x04\xa2\
    \x01\x02\0\x01\x12\x04\x89\x0c\x18(\n\x0e\n\x06\x04\xa2\x01\x02\0\x03\
    \x12\x04\x89\x0c+,\n\r\n\x05\x04\xa2\x01\x02\x01\x12\x04\x8a\x0c\x08(\n\
    \x0e\n\x06\x04\xa2\x01\x02\x01\x04\x12\x04\x8a\x0c\x08\x10\n\x0e\n\x06\
    \x04\xa2\x01\x02\x01\x05\x12\x04\x8a\x0c\x11\x17\n\x0e\n\x06\x04\xa2\x01\
    \x02\x01\x01\x12\x04\x8a\x0c\x18#\n\x0e\n\x06\x04\xa2\x01\x02\x01\x03\
    \x12\x04\x8a\x0c&'\n\r\n\x05\x04\xa2\x01\x02\x02\x12\x04\x8b\x0c\x08%\n\
    \x0e\n\x06\x04\xa2\x01\x02\x02\x04\x12\x04\x8b\x0c\x08\x10\n\x0e\n\x06\
    \x04\xa2\x01\x02\x02\x05\x12\x04\x8b\x0c\x11\x17\n\x0e\n\x06\x04\xa2\x01\
    \x02\x02\x01\x12\x04\x8b\x0c\x18\x20\n\x0e\n\x06\x04\xa2\x01\x02\x02\x03\
    \x12\x04\x8b\x0c#$\n\r\n\x03\x04\xa3\x01\x12\x06\x8e\x0c\0\x90\x0c\x01\n\
    \x0c\n\x04\x04\xa3\x01\x01\x12\x04\x8e\x0c\x08&\n\r\n\x05\x04\xa3\x01\
    \x02\0\x12\x04\x8f\x0c\x08\"\n\x0e\n\x06\x04\xa3\x01\x02\0\x04\x12\x04\
    \x8f\x0c\x08\x10\n\x0e\n\x06\x04\xa3\x01\x02\0\x05\x12\x04\x8f\x0c\x11\
    \x15\n\x0e\n\x06\x04\xa3\x01\x02\0\x01\x12\x04\x8f\x0c\x16\x1d\n\x0e\n\
    \x06\x04\xa3\x01\x02\0\x03\x12\x04\x8f\x0c\x20!\n\r\n\x03\x04\xa4\x01\
    \x12\x06\x92\x0c\0\x9b\x0c\x01\n\x0c\n\x04\x04\xa4\x01\x01\x12\x04\x92\
    \x0c\x08+\n\x0f\n\x05\x04\xa4\x01\x03\0\x12\x06\x93\x0c\x08\x96\x0c\t\n\
    \x0e\n\x06\x04\xa4\x01\x03\0\x01\x12\x04\x93\x0c\x10\x16\n\x0f\n\x07\x04\
    \xa4\x01\x03\0\x02\0\x12\x04\x94\x0c\x10.\n\x10\n\x08\x04\xa4\x01\x03\0\
    \x02\0\x04\x12\x04\x94\x0c\x10\x18\n\x10\n\x08\x04\xa4\x01\x03\0\x02\0\
    \x05\x12\x04\x94\x0c\x19\x1f\n\x10\n\x08\x04\xa4\x01\x03\0\x02\0\x01\x12\
    \x04\x94\x0c\x20)\n\x10\n\x08\x04\xa4\x01\x03\0\x02\0\x03\x12\x04\x94\
    \x0c,-\n\x0f\n\x07\x04\xa4\x01\x03\0\x02\x01\x12\x04\x95\x0c\x10P\n\x10\
    \n\x08\x04\xa4\x01\x03\0\x02\x01\x04\x12\x04\x95\x0c\x10\x18\n\x10\n\x08\
    \x04\xa4\x01\x03\0\x02\x01\x06\x12\x04\x95\x0c\x19$\n\x10\n\x08\x04\xa4\
    \x01\x03\0\x02\x01\x01\x12\x04\x95\x0c%-\n\x10\n\x08\x04\xa4\x01\x03\0\
    \x02\x01\x03\x12\x04\x95\x0c01\n\x10\n\x08\x04\xa4\x01\x03\0\x02\x01\x08\
    \x12\x04\x95\x0c2O\n\x10\n\x08\x04\xa4\x01\x03\0\x02\x01\x07\x12\x04\x95\
    \x0c=N\n\r\n\x05\x04\xa4\x01\x02\0\x12\x04\x98\x0c\x08%\n\x0e\n\x06\x04\
    \xa4\x01\x02\0\x04\x12\x04\x98\x0c\x08\x10\n\x0e\n\x06\x04\xa4\x01\x02\0\
    \x05\x12\x04\x98\x0c\x11\x17\n\x0e\n\x06\x04\xa4\x01\x02\0\x01\x12\x04\
    \x98\x0c\x18\x20\n\x0e\n\x06\x04\xa4\x01\x02\0\x03\x12\x04\x98\x0c#$\n\r\
    \n\x05\x04\xa4\x01\x02\x01\x12\x04\x99\x0c\x08%\n\x0e\n\x06\x04\xa4\x01\
    \x02\x01\x04\x12\x04\x99\x0c\x08\x10\n\x0e\n\x06\x04\xa4\x01\x02\x01\x05\
    \x12\x04\x99\x0c\x11\x17\n\x0e\n\x06\x04\xa4\x01\x02\x01\x01\x12\x04\x99\
    \x0c\x18\x20\n\x0e\n\x06\x04\xa4\x01\x02\x01\x03\x12\x04\x99\x0c#$\n\r\n\
    \x05\x04\xa4\x01\x02\x02\x12\x04\x9a\x0c\x08H\n\x0e\n\x06\x04\xa4\x01\
    \x02\x02\x04\x12\x04\x9a\x0c\x08\x10\n\x0e\n\x06\x04\xa4\x01\x02\x02\x06\
    \x12\x04\x9a\x0c\x11<\n\x0e\n\x06\x04\xa4\x01\x02\x02\x01\x12\x04\x9a\
    \x0c=C\n\x0e\n\x06\x04\xa4\x01\x02\x02\x03\x12\x04\x9a\x0cFG\n\r\n\x03\
    \x04\xa5\x01\x12\x06\x9d\x0c\0\x9f\x0c\x01\n\x0c\n\x04\x04\xa5\x01\x01\
    \x12\x04\x9d\x0c\x08,\n\r\n\x05\x04\xa5\x01\x02\0\x12\x04\x9e\x0c\x08\"\
    \n\x0e\n\x06\x04\xa5\x01\x02\0\x04\x12\x04\x9e\x0c\x08\x10\n\x0e\n\x06\
    \x04\xa5\x01\x02\0\x05\x12\x04\x9e\x0c\x11\x15\n\x0e\n\x06\x04\xa5\x01\
    \x02\0\x01\x12\x04\x9e\x0c\x16\x1d\n\x0e\n\x06\x04\xa5\x01\x02\0\x03\x12\
    \x04\x9e\x0c\x20!\n\r\n\x03\x04\xa6\x01\x12\x06\xa1\x0c\0\xa4\x0c\x01\n\
    \x0c\n\x04\x04\xa6\x01\x01\x12\x04\xa1\x0c\x08!\n\r\n\x05\x04\xa6\x01\
    \x02\0\x12\x04\xa2\x0c\x08%\n\x0e\n\x06\x04\xa6\x01\x02\0\x04\x12\x04\
    \xa2\x0c\x08\x10\n\x0e\n\x06\x04\xa6\x01\x02\0\x05\x12\x04\xa2\x0c\x11\
    \x17\n\x0e\n\x06\x04\xa6\x01\x02\0\x01\x12\x04\xa2\x0c\x18\x20\n\x0e\n\
    \x06\x04\xa6\x01\x02\0\x03\x12\x04\xa2\x0c#$\n\r\n\x05\x04\xa6\x01\x02\
    \x01\x12\x04\xa3\x0c\x08(\n\x0e\n\x06\x04\xa6\x01\x02\x01\x04\x12\x04\
    \xa3\x0c\x08\x10\n\x0e\n\x06\x04\xa6\x01\x02\x01\x05\x12\x04\xa3\x0c\x11\
    \x17\n\x0e\n\x06\x04\xa6\x01\x02\x01\x01\x12\x04\xa3\x0c\x18#\n\x0e\n\
    \x06\x04\xa6\x01\x02\x01\x03\x12\x04\xa3\x0c&'\n\r\n\x03\x04\xa7\x01\x12\
    \x06\xa6\x0c\0\xaa\x0c\x01\n\x0c\n\x04\x04\xa7\x01\x01\x12\x04\xa6\x0c\
    \x08\x1c\n\r\n\x05\x04\xa7\x01\x02\0\x12\x04\xa7\x0c\x08,\n\x0e\n\x06\
    \x04\xa7\x01\x02\0\x04\x12\x04\xa7\x0c\x08\x10\n\x0e\n\x06\x04\xa7\x01\
    \x02\0\x05\x12\x04\xa7\x0c\x11\x17\n\x0e\n\x06\x04\xa7\x01\x02\0\x01\x12\
    \x04\xa7\x0c\x18'\n\x0e\n\x06\x04\xa7\x01\x02\0\x03\x12\x04\xa7\x0c*+\n\
    \r\n\x05\x04\xa7\x01\x02\x01\x12\x04\xa8\x0c\x08(\n\x0e\n\x06\x04\xa7\
    \x01\x02\x01\x04\x12\x04\xa8\x0c\x08\x10\n\x0e\n\x06\x04\xa7\x01\x02\x01\
    \x05\x12\x04\xa8\x0c\x11\x17\n\x0e\n\x06\x04\xa7\x01\x02\x01\x01\x12\x04\
    \xa8\x0c\x18#\n\x0e\n\x06\x04\xa7\x01\x02\x01\x03\x12\x04\xa8\x0c&'\n\r\
    \n\x05\x04\xa7\x01\x02\x02\x12\x04\xa9\x0c\x08;\n\x0e\n\x06\x04\xa7\x01\
    \x02\x02\x04\x12\x04\xa9\x0c\x08\x10\n\x0e\n\x06\x04\xa7\x01\x02\x02\x06\
    \x12\x04\xa9\x0c\x11*\n\x0e\n\x06\x04\xa7\x01\x02\x02\x01\x12\x04\xa9\
    \x0c+6\n\x0e\n\x06\x04\xa7\x01\x02\x02\x03\x12\x04\xa9\x0c9:\n\r\n\x03\
    \x04\xa8\x01\x12\x06\xac\x0c\0\xae\x0c\x01\n\x0c\n\x04\x04\xa8\x01\x01\
    \x12\x04\xac\x0c\x08$\n\r\n\x05\x04\xa8\x01\x02\0\x12\x04\xad\x0c\x080\n\
    \x0e\n\x06\x04\xa8\x01\x02\0\x04\x12\x04\xad\x0c\x08\x10\n\x0e\n\x06\x04\
    \xa8\x01\x02\0\x05\x12\x04\xad\x0c\x11\x17\n\x0e\n\x06\x04\xa8\x01\x02\0\
    \x01\x12\x04\xad\x0c\x18+\n\x0e\n\x06\x04\xa8\x01\x02\0\x03\x12\x04\xad\
    \x0c./\n\r\n\x03\x04\xa9\x01\x12\x06\xb0\x0c\0\xb2\x0c\x01\n\x0c\n\x04\
    \x04\xa9\x01\x01\x12\x04\xb0\x0c\x08\x1b\n\r\n\x05\x04\xa9\x01\x02\0\x12\
    \x04\xb1\x0c\x084\n\x0e\n\x06\x04\xa9\x01\x02\0\x04\x12\x04\xb1\x0c\x08\
    \x10\n\x0e\n\x06\x04\xa9\x01\x02\0\x05\x12\x04\xb1\x0c\x11\x15\n\x0e\n\
    \x06\x04\xa9\x01\x02\0\x01\x12\x04\xb1\x0c\x16\x1d\n\x0e\n\x06\x04\xa9\
    \x01\x02\0\x03\x12\x04\xb1\x0c\x20!\n\x0e\n\x06\x04\xa9\x01\x02\0\x08\
    \x12\x04\xb1\x0c\"3\n\x0e\n\x06\x04\xa9\x01\x02\0\x07\x12\x04\xb1\x0c-2\
    \n\r\n\x03\x04\xaa\x01\x12\x06\xb4\x0c\0\xb6\x0c\x01\n\x0c\n\x04\x04\xaa\
    \x01\x01\x12\x04\xb4\x0c\x08*\n\r\n\x05\x04\xaa\x01\x02\0\x12\x04\xb5\
    \x0c\x08\x20\n\x0e\n\x06\x04\xaa\x01\x02\0\x04\x12\x04\xb5\x0c\x08\x10\n\
    \x0e\n\x06\x04\xaa\x01\x02\0\x05\x12\x04\xb5\x0c\x11\x15\n\x0e\n\x06\x04\
    \xaa\x01\x02\0\x01\x12\x04\xb5\x0c\x16\x1b\n\x0e\n\x06\x04\xaa\x01\x02\0\
    \x03\x12\x04\xb5\x0c\x1e\x1f\n\r\n\x03\x04\xab\x01\x12\x06\xb8\x0c\0\xc0\
    \x0c\x01\n\x0c\n\x04\x04\xab\x01\x01\x12\x04\xb8\x0c\x08\x1f\n\r\n\x05\
    \x04\xab\x01\x02\0\x12\x04\xb9\x0c\x08%\n\x0e\n\x06\x04\xab\x01\x02\0\
    \x04\x12\x04\xb9\x0c\x08\x10\n\x0e\n\x06\x04\xab\x01\x02\0\x05\x12\x04\
    \xb9\x0c\x11\x17\n\x0e\n\x06\x04\xab\x01\x02\0\x01\x12\x04\xb9\x0c\x18\
    \x20\n\x0e\n\x06\x04\xab\x01\x02\0\x03\x12\x04\xb9\x0c#$\n\r\n\x05\x04\
    \xab\x01\x02\x01\x12\x04\xba\x0c\x08(\n\x0e\n\x06\x04\xab\x01\x02\x01\
    \x04\x12\x04\xba\x0c\x08\x10\n\x0e\n\x06\x04\xab\x01\x02\x01\x05\x12\x04\
    \xba\x0c\x11\x15\n\x0e\n\x06\x04\xab\x01\x02\x01\x01\x12\x04\xba\x0c\x16\
    #\n\x0e\n\x06\x04\xab\x01\x02\x01\x03\x12\x04\xba\x0c&'\n\r\n\x05\x04\
    \xab\x01\x02\x02\x12\x04\xbb\x0c\x08(\n\x0e\n\x06\x04\xab\x01\x02\x02\
    \x04\x12\x04\xbb\x0c\x08\x10\n\x0e\n\x06\x04\xab\x01\x02\x02\x05\x12\x04\
    \xbb\x0c\x11\x15\n\x0e\n\x06\x04\xab\x01\x02\x02\x01\x12\x04\xbb\x0c\x16\
    #\n\x0e\n\x06\x04\xab\x01\x02\x02\x03\x12\x04\xbb\x0c&'\n\r\n\x05\x04\
    \xab\x01\x02\x03\x12\x04\xbc\x0c\x08(\n\x0e\n\x06\x04\xab\x01\x02\x03\
    \x04\x12\x04\xbc\x0c\x08\x10\n\x0e\n\x06\x04\xab\x01\x02\x03\x05\x12\x04\
    \xbc\x0c\x11\x15\n\x0e\n\x06\x04\xab\x01\x02\x03\x01\x12\x04\xbc\x0c\x16\
    #\n\x0e\n\x06\x04\xab\x01\x02\x03\x03\x12\x04\xbc\x0c&'\n\r\n\x05\x04\
    \xab\x01\x02\x04\x12\x04\xbd\x0c\x08)\n\x0e\n\x06\x04\xab\x01\x02\x04\
    \x04\x12\x04\xbd\x0c\x08\x10\n\x0e\n\x06\x04\xab\x01\x02\x04\x05\x12\x04\
    \xbd\x0c\x11\x17\n\x0e\n\x06\x04\xab\x01\x02\x04\x01\x12\x04\xbd\x0c\x18\
    $\n\x0e\n\x06\x04\xab\x01\x02\x04\x03\x12\x04\xbd\x0c'(\n\r\n\x05\x04\
    \xab\x01\x02\x05\x12\x04\xbe\x0c\x082\n\x0e\n\x06\x04\xab\x01\x02\x05\
    \x04\x12\x04\xbe\x0c\x08\x10\n\x0e\n\x06\x04\xab\x01\x02\x05\x05\x12\x04\
    \xbe\x0c\x11\x17\n\x0e\n\x06\x04\xab\x01\x02\x05\x01\x12\x04\xbe\x0c\x18\
    -\n\x0e\n\x06\x04\xab\x01\x02\x05\x03\x12\x04\xbe\x0c01\n\r\n\x05\x04\
    \xab\x01\x02\x06\x12\x04\xbf\x0c\x08-\n\x0e\n\x06\x04\xab\x01\x02\x06\
    \x04\x12\x04\xbf\x0c\x08\x10\n\x0e\n\x06\x04\xab\x01\x02\x06\x05\x12\x04\
    \xbf\x0c\x11\x15\n\x0e\n\x06\x04\xab\x01\x02\x06\x01\x12\x04\xbf\x0c\x16\
    (\n\x0e\n\x06\x04\xab\x01\x02\x06\x03\x12\x04\xbf\x0c+,\n\r\n\x03\x04\
    \xac\x01\x12\x06\xc2\x0c\0\xc5\x0c\x01\n\x0c\n\x04\x04\xac\x01\x01\x12\
    \x04\xc2\x0c\x08\x1b\n\r\n\x05\x04\xac\x01\x02\0\x12\x04\xc3\x0c\x08'\n\
    \x0e\n\x06\x04\xac\x01\x02\0\x04\x12\x04\xc3\x0c\x08\x10\n\x0e\n\x06\x04\
    \xac\x01\x02\0\x05\x12\x04\xc3\x0c\x11\x18\n\x0e\n\x06\x04\xac\x01\x02\0\
    \x01\x12\x04\xc3\x0c\x19\"\n\x0e\n\x06\x04\xac\x01\x02\0\x03\x12\x04\xc3\
    \x0c%&\n\r\n\x05\x04\xac\x01\x02\x01\x12\x04\xc4\x0c\x08,\n\x0e\n\x06\
    \x04\xac\x01\x02\x01\x04\x12\x04\xc4\x0c\x08\x10\n\x0e\n\x06\x04\xac\x01\
    \x02\x01\x05\x12\x04\xc4\x0c\x11\x17\n\x0e\n\x06\x04\xac\x01\x02\x01\x01\
    \x12\x04\xc4\x0c\x18'\n\x0e\n\x06\x04\xac\x01\x02\x01\x03\x12\x04\xc4\
    \x0c*+\n\r\n\x03\x04\xad\x01\x12\x06\xc7\x0c\0\xcb\x0c\x01\n\x0c\n\x04\
    \x04\xad\x01\x01\x12\x04\xc7\x0c\x08\x1b\n\r\n\x05\x04\xad\x01\x02\0\x12\
    \x04\xc8\x0c\x08.\n\x0e\n\x06\x04\xad\x01\x02\0\x04\x12\x04\xc8\x0c\x08\
    \x10\n\x0e\n\x06\x04\xad\x01\x02\0\x05\x12\x04\xc8\x0c\x11\x17\n\x0e\n\
    \x06\x04\xad\x01\x02\0\x01\x12\x04\xc8\x0c\x18)\n\x0e\n\x06\x04\xad\x01\
    \x02\0\x03\x12\x04\xc8\x0c,-\n\r\n\x05\x04\xad\x01\x02\x01\x12\x04\xc9\
    \x0c\x08\x20\n\x0e\n\x06\x04\xad\x01\x02\x01\x04\x12\x04\xc9\x0c\x08\x10\
    \n\x0e\n\x06\x04\xad\x01\x02\x01\x05\x12\x04\xc9\x0c\x11\x16\n\x0e\n\x06\
    \x04\xad\x01\x02\x01\x01\x12\x04\xc9\x0c\x17\x1b\n\x0e\n\x06\x04\xad\x01\
    \x02\x01\x03\x12\x04\xc9\x0c\x1e\x1f\n\r\n\x05\x04\xad\x01\x02\x02\x12\
    \x04\xca\x0c\x08*\n\x0e\n\x06\x04\xad\x01\x02\x02\x04\x12\x04\xca\x0c\
    \x08\x10\n\x0e\n\x06\x04\xad\x01\x02\x02\x05\x12\x04\xca\x0c\x11\x17\n\
    \x0e\n\x06\x04\xad\x01\x02\x02\x01\x12\x04\xca\x0c\x18%\n\x0e\n\x06\x04\
    \xad\x01\x02\x02\x03\x12\x04\xca\x0c()\n\r\n\x03\x04\xae\x01\x12\x06\xcd\
    \x0c\0\xd3\x0c\x01\n\x0c\n\x04\x04\xae\x01\x01\x12\x04\xcd\x0c\x08\x1b\n\
    \r\n\x05\x04\xae\x01\x02\0\x12\x04\xce\x0c\x08-\n\x0e\n\x06\x04\xae\x01\
    \x02\0\x04\x12\x04\xce\x0c\x08\x10\n\x0e\n\x06\x04\xae\x01\x02\0\x05\x12\
    \x04\xce\x0c\x11\x17\n\x0e\n\x06\x04\xae\x01\x02\0\x01\x12\x04\xce\x0c\
    \x18(\n\x0e\n\x06\x04\xae\x01\x02\0\x03\x12\x04\xce\x0c+,\n\r\n\x05\x04\
    \xae\x01\x02\x01\x12\x04\xcf\x0c\x08.\n\x0e\n\x06\x04\xae\x01\x02\x01\
    \x04\x12\x04\xcf\x0c\x08\x10\n\x0e\n\x06\x04\xae\x01\x02\x01\x05\x12\x04\
    \xcf\x0c\x11\x17\n\x0e\n\x06\x04\xae\x01\x02\x01\x01\x12\x04\xcf\x0c\x18\
    )\n\x0e\n\x06\x04\xae\x01\x02\x01\x03\x12\x04\xcf\x0c,-\n\r\n\x05\x04\
    \xae\x01\x02\x02\x12\x04\xd0\x0c\x08%\n\x0e\n\x06\x04\xae\x01\x02\x02\
    \x04\x12\x04\xd0\x0c\x08\x10\n\x0e\n\x06\x04\xae\x01\x02\x02\x05\x12\x04\
    \xd0\x0c\x11\x17\n\x0e\n\x06\x04\xae\x01\x02\x02\x01\x12\x04\xd0\x0c\x18\
    \x20\n\x0e\n\x06\x04\xae\x01\x02\x02\x03\x12\x04\xd0\x0c#$\n\r\n\x05\x04\
    \xae\x01\x02\x03\x12\x04\xd1\x0c\x08-\n\x0e\n\x06\x04\xae\x01\x02\x03\
    \x04\x12\x04\xd1\x0c\x08\x10\n\x0e\n\x06\x04\xae\x01\x02\x03\x05\x12\x04\
    \xd1\x0c\x11\x17\n\x0e\n\x06\x04\xae\x01\x02\x03\x01\x12\x04\xd1\x0c\x18\
    (\n\x0e\n\x06\x04\xae\x01\x02\x03\x03\x12\x04\xd1\x0c+,\n\r\n\x05\x04\
    \xae\x01\x02\x04\x12\x04\xd2\x0c\x08\"\n\x0e\n\x06\x04\xae\x01\x02\x04\
    \x04\x12\x04\xd2\x0c\x08\x10\n\x0e\n\x06\x04\xae\x01\x02\x04\x05\x12\x04\
    \xd2\x0c\x11\x17\n\x0e\n\x06\x04\xae\x01\x02\x04\x01\x12\x04\xd2\x0c\x18\
    \x1d\n\x0e\n\x06\x04\xae\x01\x02\x04\x03\x12\x04\xd2\x0c\x20!\n\r\n\x03\
    \x04\xaf\x01\x12\x06\xd5\x0c\0\xd7\x0c\x01\n\x0c\n\x04\x04\xaf\x01\x01\
    \x12\x04\xd5\x0c\x08\x15\n\r\n\x05\x04\xaf\x01\x02\0\x12\x04\xd6\x0c\x08\
    -\n\x0e\n\x06\x04\xaf\x01\x02\0\x04\x12\x04\xd6\x0c\x08\x10\n\x0e\n\x06\
    \x04\xaf\x01\x02\0\x05\x12\x04\xd6\x0c\x11\x16\n\x0e\n\x06\x04\xaf\x01\
    \x02\0\x01\x12\x04\xd6\x0c\x17(\n\x0e\n\x06\x04\xaf\x01\x02\0\x03\x12\
    \x04\xd6\x0c+,\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::steammessages::file_descriptor().clone());
            deps.push(super::base_gcmessages::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(193);
            messages.push(CMsgTFGoldenWrenchBroadcast::generated_message_descriptor_data());
            messages.push(CMsgTFSaxxyBroadcast::generated_message_descriptor_data());
            messages.push(CMsgGCTFSpecificItemBroadcast::generated_message_descriptor_data());
            messages.push(CMsgTFWorldStatus::generated_message_descriptor_data());
            messages.push(CSOTFDuelSummary::generated_message_descriptor_data());
            messages.push(CSOTFMapContribution::generated_message_descriptor_data());
            messages.push(CMsgTFFreeTrialChooseMostHelpfulFriend::generated_message_descriptor_data());
            messages.push(CMsgTFRequestTF2Friends::generated_message_descriptor_data());
            messages.push(CMsgTFRequestTF2FriendsResponse::generated_message_descriptor_data());
            messages.push(CSOTFPlayerInfo::generated_message_descriptor_data());
            messages.push(CMsgTFThankedBySomeone::generated_message_descriptor_data());
            messages.push(CMsgTFThankedSomeone::generated_message_descriptor_data());
            messages.push(CMsgTFFreeTrialConvertedToPremium::generated_message_descriptor_data());
            messages.push(CMsgSaxxyAwarded::generated_message_descriptor_data());
            messages.push(CMsgReplaySubmitContestEntry::generated_message_descriptor_data());
            messages.push(CMsgReplaySubmitContestEntryResponse::generated_message_descriptor_data());
            messages.push(CReplayCachedContestData::generated_message_descriptor_data());
            messages.push(CMsgTFCoaching_AddToCoaches::generated_message_descriptor_data());
            messages.push(CMsgTFCoaching_RemoveFromCoaches::generated_message_descriptor_data());
            messages.push(CMsgTFCoaching_FindCoach::generated_message_descriptor_data());
            messages.push(CMsgTFCoaching_FindCoachResponse::generated_message_descriptor_data());
            messages.push(CMsgTFCoaching_AskCoach::generated_message_descriptor_data());
            messages.push(CMsgTFCoaching_AskCoachResponse::generated_message_descriptor_data());
            messages.push(CMsgTFCoaching_CoachJoinGame::generated_message_descriptor_data());
            messages.push(CMsgTFCoaching_CoachJoining::generated_message_descriptor_data());
            messages.push(CMsgTFCoaching_CoachJoined::generated_message_descriptor_data());
            messages.push(CMsgTFCoaching_LikeCurrentCoach::generated_message_descriptor_data());
            messages.push(CMsgTFCoaching_RemoveCurrentCoach::generated_message_descriptor_data());
            messages.push(CMsgTFQuickplay_ScoreServers::generated_message_descriptor_data());
            messages.push(CMsgTFQuickplay_ScoreServersResponse::generated_message_descriptor_data());
            messages.push(CMsgTFQuickplay_PlayerJoining::generated_message_descriptor_data());
            messages.push(CMsgGC_GameServer_LevelInfo::generated_message_descriptor_data());
            messages.push(CMsgGC_GameServer_AuthChallenge::generated_message_descriptor_data());
            messages.push(CMsgGC_GameServer_AuthResult::generated_message_descriptor_data());
            messages.push(CMsgGC_GameServer_AuthChallengeResponse::generated_message_descriptor_data());
            messages.push(CMsgGC_GameServer_CreateIdentity::generated_message_descriptor_data());
            messages.push(CMsgGC_GameServer_CreateIdentityResponse::generated_message_descriptor_data());
            messages.push(CMsgGC_GameServer_List::generated_message_descriptor_data());
            messages.push(CMsgGC_GameServer_ListResponse::generated_message_descriptor_data());
            messages.push(CMsgGC_GameServer_ResetIdentity::generated_message_descriptor_data());
            messages.push(CMsgGC_GameServer_ResetIdentityResponse::generated_message_descriptor_data());
            messages.push(CMsgGC_GameServer_AckPolicy::generated_message_descriptor_data());
            messages.push(CMsgGC_GameServer_AckPolicyResponse::generated_message_descriptor_data());
            messages.push(CMsgGC_Client_UseServerModificationItem::generated_message_descriptor_data());
            messages.push(CMsgGC_Client_UseServerModificationItem_Response::generated_message_descriptor_data());
            messages.push(CMsgGC_GameServer_UseServerModificationItem::generated_message_descriptor_data());
            messages.push(CMsgGC_GameServer_UseServerModificationItem_Response::generated_message_descriptor_data());
            messages.push(CMsgGC_GameServer_ServerModificationItemExpired::generated_message_descriptor_data());
            messages.push(CMsgGC_GameServer_ServerModificationItem::generated_message_descriptor_data());
            messages.push(CMsgGC_Halloween_ReservedItem::generated_message_descriptor_data());
            messages.push(CMsgGC_Halloween_GrantItem::generated_message_descriptor_data());
            messages.push(CMsgGC_Halloween_GrantItemResponse::generated_message_descriptor_data());
            messages.push(CMsgGC_Halloween_ItemClaimed::generated_message_descriptor_data());
            messages.push(CMsgGC_PickupItemEligibility_Query::generated_message_descriptor_data());
            messages.push(CMsgGC_PickupItemEligibility_QueryResponse::generated_message_descriptor_data());
            messages.push(CSOTFPartyMember::generated_message_descriptor_data());
            messages.push(TFPendingPartyMember::generated_message_descriptor_data());
            messages.push(TFSyncedMMUIState::generated_message_descriptor_data());
            messages.push(CTFGroupMatchCriteriaProto::generated_message_descriptor_data());
            messages.push(CTFCasualMatchCriteria::generated_message_descriptor_data());
            messages.push(CTFPerPlayerMatchCriteriaProto::generated_message_descriptor_data());
            messages.push(CTFPartyOptions::generated_message_descriptor_data());
            messages.push(CMsgPartySetOptions::generated_message_descriptor_data());
            messages.push(CMsgPartySetOptionsResponse::generated_message_descriptor_data());
            messages.push(CMsgPartyQueueForMatch::generated_message_descriptor_data());
            messages.push(CMsgPartyQueueForMatchResponse::generated_message_descriptor_data());
            messages.push(CMsgPartyQueueForStandby::generated_message_descriptor_data());
            messages.push(CMsgPartyQueueForStandbyResponse::generated_message_descriptor_data());
            messages.push(CMsgPartyRemoveFromQueue::generated_message_descriptor_data());
            messages.push(CMsgPartyRemoveFromQueueResponse::generated_message_descriptor_data());
            messages.push(CMsgPartyRemoveFromStandbyQueue::generated_message_descriptor_data());
            messages.push(CMsgPartyRemoveFromStandbyQueueResponse::generated_message_descriptor_data());
            messages.push(CMsgPartyInvitePlayer::generated_message_descriptor_data());
            messages.push(CMsgPartyRequestJoinPlayer::generated_message_descriptor_data());
            messages.push(CMsgPartyClearPendingPlayer::generated_message_descriptor_data());
            messages.push(CMsgPartyClearPendingPlayerResponse::generated_message_descriptor_data());
            messages.push(CMsgPartyClearOtherPartyRequest::generated_message_descriptor_data());
            messages.push(CMsgPartyClearOtherPartyRequestResponse::generated_message_descriptor_data());
            messages.push(CMsgPartyPromoteToLeader::generated_message_descriptor_data());
            messages.push(CMsgPartyKickMember::generated_message_descriptor_data());
            messages.push(CMsgPartySendChat::generated_message_descriptor_data());
            messages.push(CMsgPartyChatMsg::generated_message_descriptor_data());
            messages.push(CSOTFParty::generated_message_descriptor_data());
            messages.push(CSOTFPartyInvite::generated_message_descriptor_data());
            messages.push(CTFLobbyPlayerProto::generated_message_descriptor_data());
            messages.push(CTFLobbyInviteProto::generated_message_descriptor_data());
            messages.push(CSOTFGameServerLobby::generated_message_descriptor_data());
            messages.push(CMsgExitMatchmaking::generated_message_descriptor_data());
            messages.push(CMsgAcceptLobbyInvite::generated_message_descriptor_data());
            messages.push(CMsgAcceptLobbyInviteReply::generated_message_descriptor_data());
            messages.push(CMsgMatchmakingSearchCountRequest::generated_message_descriptor_data());
            messages.push(CMsgMatchmakingSearchCountResponse::generated_message_descriptor_data());
            messages.push(CMsgKickedFromMatchmakingQueue::generated_message_descriptor_data());
            messages.push(CMsgGameServerMatchmakingStatus::generated_message_descriptor_data());
            messages.push(CMsgMatchmakingProgress::generated_message_descriptor_data());
            messages.push(CMsgMvMVictoryInfo::generated_message_descriptor_data());
            messages.push(CGCMsgTFHelloResponse::generated_message_descriptor_data());
            messages.push(CGCMsgTFSync::generated_message_descriptor_data());
            messages.push(CGCMsgTFSyncEx::generated_message_descriptor_data());
            messages.push(CMsgMvMVictory::generated_message_descriptor_data());
            messages.push(CMsgMvMMannUpVictoryReply::generated_message_descriptor_data());
            messages.push(CMsgGameServerKickingLobby::generated_message_descriptor_data());
            messages.push(CMsgGameServerKickingLobbyResponse::generated_message_descriptor_data());
            messages.push(CMsgLeaveGameAndPrepareToJoinParty::generated_message_descriptor_data());
            messages.push(CMsgPlayerLeftMatch::generated_message_descriptor_data());
            messages.push(CMsgPlayerLeftMatchResponse::generated_message_descriptor_data());
            messages.push(CMsgProcessMatchVoteKick::generated_message_descriptor_data());
            messages.push(CMsgProcessMatchVoteKickResponse::generated_message_descriptor_data());
            messages.push(CMsgPlayerVoteKickedAfterLeavingMatchResponse::generated_message_descriptor_data());
            messages.push(CMsgHalloween_ServerBossEvent::generated_message_descriptor_data());
            messages.push(CMsgHalloween_Merasmus2012::generated_message_descriptor_data());
            messages.push(CMsgUpdateHalloweenMerasmusLootLevel::generated_message_descriptor_data());
            messages.push(CAttribute_String::generated_message_descriptor_data());
            messages.push(CAttribute_DynamicRecipeComponent::generated_message_descriptor_data());
            messages.push(CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT::generated_message_descriptor_data());
            messages.push(CAttribute_ItemSlotCriteria::generated_message_descriptor_data());
            messages.push(CMsgSetItemSlotAttribute::generated_message_descriptor_data());
            messages.push(CSOWarData::generated_message_descriptor_data());
            messages.push(CGCMsgGC_War_IndividualUpdate::generated_message_descriptor_data());
            messages.push(CGCMsgGC_War_JoinWar::generated_message_descriptor_data());
            messages.push(CGCMsgGC_War_RequestGlobalStats::generated_message_descriptor_data());
            messages.push(CGCMsgGC_War_GlobalStatsResponse::generated_message_descriptor_data());
            messages.push(CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate::generated_message_descriptor_data());
            messages.push(CAttribute_WorldItemPlacement::generated_message_descriptor_data());
            messages.push(CGCMsg_WorldItemPlacement_Update::generated_message_descriptor_data());
            messages.push(CMsgAcknowledgeXP::generated_message_descriptor_data());
            messages.push(CMsgTFXPSource::generated_message_descriptor_data());
            messages.push(CMsgTFXPSourceBreakdown::generated_message_descriptor_data());
            messages.push(CMsgTFClientInit::generated_message_descriptor_data());
            messages.push(CMsgGCNotification::generated_message_descriptor_data());
            messages.push(CMsgGCNotificationQueue::generated_message_descriptor_data());
            messages.push(CMsgNotificationAcknowledge::generated_message_descriptor_data());
            messages.push(CMsgNotificationAcknowledgeReply::generated_message_descriptor_data());
            messages.push(CMsgGC_Match_Result::generated_message_descriptor_data());
            messages.push(CMsgGC_Match_ResultResponse::generated_message_descriptor_data());
            messages.push(CEconItemPreviewDataBlock::generated_message_descriptor_data());
            messages.push(CMsgGC_Client2GCEconPreviewDataBlockRequest::generated_message_descriptor_data());
            messages.push(CMsgGC_Client2GCEconPreviewDataBlockResponse::generated_message_descriptor_data());
            messages.push(CSOTFLadderPlayerStats::generated_message_descriptor_data());
            messages.push(CSOTFRatingData::generated_message_descriptor_data());
            messages.push(CMsgGC_TFVoteKickPlayerRequest::generated_message_descriptor_data());
            messages.push(CMsgGC_VoteKickPlayerRequestResponse::generated_message_descriptor_data());
            messages.push(CMsgGC_DailyCompetitiveStatsRollup::generated_message_descriptor_data());
            messages.push(CMsgGC_DailyCompetitiveStatsRollup_Response::generated_message_descriptor_data());
            messages.push(CMsgGC_ReportPlayer::generated_message_descriptor_data());
            messages.push(CSOTFMatchResultPlayerStats::generated_message_descriptor_data());
            messages.push(CMsgGCRequestMatchMakerStats::generated_message_descriptor_data());
            messages.push(CMsgGCDataCenterPopulation::generated_message_descriptor_data());
            messages.push(CMsgGCMatchGroupDataCenterPopulation::generated_message_descriptor_data());
            messages.push(CMsgGCMatchMakerStatsResponse::generated_message_descriptor_data());
            messages.push(CMsgGCMatchHistoryLoad::generated_message_descriptor_data());
            messages.push(CMsgGCDataCenterPing_Update::generated_message_descriptor_data());
            messages.push(CMsgGC_KickPlayerFromLobby::generated_message_descriptor_data());
            messages.push(CMsgGCSurveyRequest::generated_message_descriptor_data());
            messages.push(CMsgGCSurveyResponse::generated_message_descriptor_data());
            messages.push(CSOQuestMapNode::generated_message_descriptor_data());
            messages.push(CSOQuest::generated_message_descriptor_data());
            messages.push(CSOQuestMapRewardPurchase::generated_message_descriptor_data());
            messages.push(CMsgGCQuestIdentify::generated_message_descriptor_data());
            messages.push(CMsgGCQuestDevGive::generated_message_descriptor_data());
            messages.push(CMsgGCQuestNodeTurnIn::generated_message_descriptor_data());
            messages.push(CMsgGCQuestMapUnlockNode::generated_message_descriptor_data());
            messages.push(CMsgGCNewMatchForLobbyRequest::generated_message_descriptor_data());
            messages.push(CMsgGCNewMatchForLobbyResponse::generated_message_descriptor_data());
            messages.push(CMsgGCChangeMatchPlayerTeamsRequest::generated_message_descriptor_data());
            messages.push(CMsgGCChangeMatchPlayerTeamsResponse::generated_message_descriptor_data());
            messages.push(CMsgGCQuestComplete_Debug::generated_message_descriptor_data());
            messages.push(CMsgGCQuestMap_Debug::generated_message_descriptor_data());
            messages.push(CMsgGCQuestMapPurchaseReward::generated_message_descriptor_data());
            messages.push(CMsgGCQuestResponse::generated_message_descriptor_data());
            messages.push(CMsgGCSetDisablePartyQuestProgress::generated_message_descriptor_data());
            messages.push(CMsgQuestProgressReport::generated_message_descriptor_data());
            messages.push(CMsgConsumePaintkit::generated_message_descriptor_data());
            messages.push(CMsgPainkitDevGrant::generated_message_descriptor_data());
            messages.push(GCQuestStrangeEvent::generated_message_descriptor_data());
            messages.push(CMsgSDRTicket::generated_message_descriptor_data());
            messages.push(cmsg_tfquickplay_score_servers::ServerInfo::generated_message_descriptor_data());
            messages.push(cmsg_tfquickplay_score_servers_response::ServerInfo::generated_message_descriptor_data());
            messages.push(cmsg_gc_game_server_list_response::GameServerIdentity::generated_message_descriptor_data());
            messages.push(csotfparty_member::Activity::generated_message_descriptor_data());
            messages.push(csotfparty::QueueEntry::generated_message_descriptor_data());
            messages.push(csotfparty_invite::PartyMember::generated_message_descriptor_data());
            messages.push(cmsg_game_server_matchmaking_status::Player::generated_message_descriptor_data());
            messages.push(cmsg_mv_mvictory_info::Item::generated_message_descriptor_data());
            messages.push(cmsg_mv_mvictory_info::Player::generated_message_descriptor_data());
            messages.push(cmsg_mv_mvictory::Player::generated_message_descriptor_data());
            messages.push(cmsg_process_match_vote_kick::Vote::generated_message_descriptor_data());
            messages.push(cmsg_update_halloween_merasmus_loot_level::Player::generated_message_descriptor_data());
            messages.push(cgcmsg_gc_war_global_stats_response::SideScore::generated_message_descriptor_data());
            messages.push(cmsg_gc_match_result::Player::generated_message_descriptor_data());
            messages.push(cmsg_gc_daily_competitive_stats_rollup_response::RankBucketEntry::generated_message_descriptor_data());
            messages.push(cmsg_gcdata_center_ping_update::PingEntry::generated_message_descriptor_data());
            messages.push(cmsg_gcchange_match_player_teams_request::Member::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(28);
            enums.push(ETFGCMsg::generated_enum_descriptor_data());
            enums.push(EServerModificationItemType::generated_enum_descriptor_data());
            enums.push(ETFSyncedMMMenuStep::generated_enum_descriptor_data());
            enums.push(ETFMatchGroup::generated_enum_descriptor_data());
            enums.push(ETFPartyChatType::generated_enum_descriptor_data());
            enums.push(TF_GC_GameState::generated_enum_descriptor_data());
            enums.push(TF_GC_TEAM::generated_enum_descriptor_data());
            enums.push(TFMatchLeaveReason::generated_enum_descriptor_data());
            enums.push(TFVoteKickReason::generated_enum_descriptor_data());
            enums.push(ServerMatchmakingState::generated_enum_descriptor_data());
            enums.push(SurveyQuestionType::generated_enum_descriptor_data());
            enums.push(cmsg_gc_game_server_create_identity_response::EStatus::generated_enum_descriptor_data());
            enums.push(cmsg_gc_client_use_server_modification_item_response::EServerModificationItemResponse::generated_enum_descriptor_data());
            enums.push(cmsg_gc_game_server_use_server_modification_item_response::EServerModificationItemServerResponse::generated_enum_descriptor_data());
            enums.push(tfpending_party_member::EType::generated_enum_descriptor_data());
            enums.push(csotfparty_invite::Type::generated_enum_descriptor_data());
            enums.push(ctflobby_player_proto::ConnectState::generated_enum_descriptor_data());
            enums.push(ctflobby_player_proto::Type::generated_enum_descriptor_data());
            enums.push(csotfgame_server_lobby::State::generated_enum_descriptor_data());
            enums.push(csotfgame_server_lobby::WarMatch::generated_enum_descriptor_data());
            enums.push(cmsg_game_server_matchmaking_status::PlayerConnectState::generated_enum_descriptor_data());
            enums.push(cmsg_game_server_matchmaking_status::Event::generated_enum_descriptor_data());
            enums.push(cmsg_mv_mvictory_info::GrantReason::generated_enum_descriptor_data());
            enums.push(cmsg_tfxpsource::XPSourceType::generated_enum_descriptor_data());
            enums.push(cmsg_gcnotification::NotificationType::generated_enum_descriptor_data());
            enums.push(cmsg_gc_match_result::Status::generated_enum_descriptor_data());
            enums.push(cmsg_gc_report_player::EReason::generated_enum_descriptor_data());
            enums.push(cmsg_gcdata_center_ping_update::Status::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
