// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `tf2/tf_proto_def_messages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:CMsgFieldID)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFieldID {
    // message fields
    // @@protoc_insertion_point(field:CMsgFieldID.field)
    pub field: ::std::vec::Vec<cmsg_field_id::CMsgField>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFieldID.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFieldID {
    fn default() -> &'a CMsgFieldID {
        <CMsgFieldID as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFieldID {
    pub fn new() -> CMsgFieldID {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "field",
            |m: &CMsgFieldID| { &m.field },
            |m: &mut CMsgFieldID| { &mut m.field },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgFieldID>(
            "CMsgFieldID",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgFieldID {
    const NAME: &'static str = "CMsgFieldID";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.field.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.field {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.field {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFieldID {
        CMsgFieldID::new()
    }

    fn clear(&mut self) {
        self.field.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFieldID {
        static instance: CMsgFieldID = CMsgFieldID {
            field: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgFieldID {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgFieldID").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgFieldID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFieldID {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgFieldID`
pub mod cmsg_field_id {
    // @@protoc_insertion_point(message:CMsgFieldID.CMsgField)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CMsgField {
        // message fields
        // @@protoc_insertion_point(field:CMsgFieldID.CMsgField.field_number)
        pub field_number: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgFieldID.CMsgField.repeated_index)
        pub repeated_index: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgFieldID.CMsgField.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CMsgField {
        fn default() -> &'a CMsgField {
            <CMsgField as ::protobuf::Message>::default_instance()
        }
    }

    impl CMsgField {
        pub fn new() -> CMsgField {
            ::std::default::Default::default()
        }

        // optional uint32 field_number = 1;

        pub fn field_number(&self) -> u32 {
            self.field_number.unwrap_or(0)
        }

        pub fn clear_field_number(&mut self) {
            self.field_number = ::std::option::Option::None;
        }

        pub fn has_field_number(&self) -> bool {
            self.field_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_field_number(&mut self, v: u32) {
            self.field_number = ::std::option::Option::Some(v);
        }

        // optional uint32 repeated_index = 2;

        pub fn repeated_index(&self) -> u32 {
            self.repeated_index.unwrap_or(0)
        }

        pub fn clear_repeated_index(&mut self) {
            self.repeated_index = ::std::option::Option::None;
        }

        pub fn has_repeated_index(&self) -> bool {
            self.repeated_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_repeated_index(&mut self, v: u32) {
            self.repeated_index = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "field_number",
                |m: &CMsgField| { &m.field_number },
                |m: &mut CMsgField| { &mut m.field_number },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "repeated_index",
                |m: &CMsgField| { &m.repeated_index },
                |m: &mut CMsgField| { &mut m.repeated_index },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgField>(
                "CMsgFieldID.CMsgField",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CMsgField {
        const NAME: &'static str = "CMsgField";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.field_number = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.repeated_index = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.field_number {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.repeated_index {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.field_number {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.repeated_index {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CMsgField {
            CMsgField::new()
        }

        fn clear(&mut self) {
            self.field_number = ::std::option::Option::None;
            self.repeated_index = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CMsgField {
            static instance: CMsgField = CMsgField {
                field_number: ::std::option::Option::None,
                repeated_index: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CMsgField {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgFieldID.CMsgField").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CMsgField {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CMsgField {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgUniversalFieldID)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgUniversalFieldID {
    // message fields
    // @@protoc_insertion_point(field:CMsgUniversalFieldID.source_type)
    pub source_type: ::std::option::Option<::protobuf::EnumOrUnknown<EValueDefinitionSource>>,
    // @@protoc_insertion_point(field:CMsgUniversalFieldID.defining_obj_id)
    pub defining_obj_id: ::protobuf::MessageField<CMsgProtoDefID>,
    // @@protoc_insertion_point(field:CMsgUniversalFieldID.field_id)
    pub field_id: ::protobuf::MessageField<CMsgFieldID>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgUniversalFieldID.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgUniversalFieldID {
    fn default() -> &'a CMsgUniversalFieldID {
        <CMsgUniversalFieldID as ::protobuf::Message>::default_instance()
    }
}

impl CMsgUniversalFieldID {
    pub fn new() -> CMsgUniversalFieldID {
        ::std::default::Default::default()
    }

    // optional .EValueDefinitionSource source_type = 1;

    pub fn source_type(&self) -> EValueDefinitionSource {
        match self.source_type {
            Some(e) => e.enum_value_or(EValueDefinitionSource::REFERENCE_DEFINES),
            None => EValueDefinitionSource::REFERENCE_DEFINES,
        }
    }

    pub fn clear_source_type(&mut self) {
        self.source_type = ::std::option::Option::None;
    }

    pub fn has_source_type(&self) -> bool {
        self.source_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_type(&mut self, v: EValueDefinitionSource) {
        self.source_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_type",
            |m: &CMsgUniversalFieldID| { &m.source_type },
            |m: &mut CMsgUniversalFieldID| { &mut m.source_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgProtoDefID>(
            "defining_obj_id",
            |m: &CMsgUniversalFieldID| { &m.defining_obj_id },
            |m: &mut CMsgUniversalFieldID| { &mut m.defining_obj_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgFieldID>(
            "field_id",
            |m: &CMsgUniversalFieldID| { &m.field_id },
            |m: &mut CMsgUniversalFieldID| { &mut m.field_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgUniversalFieldID>(
            "CMsgUniversalFieldID",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgUniversalFieldID {
    const NAME: &'static str = "CMsgUniversalFieldID";

    fn is_initialized(&self) -> bool {
        for v in &self.defining_obj_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.field_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.source_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.defining_obj_id)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.field_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.source_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.defining_obj_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.field_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.source_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.defining_obj_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.field_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgUniversalFieldID {
        CMsgUniversalFieldID::new()
    }

    fn clear(&mut self) {
        self.source_type = ::std::option::Option::None;
        self.defining_obj_id.clear();
        self.field_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgUniversalFieldID {
        static instance: CMsgUniversalFieldID = CMsgUniversalFieldID {
            source_type: ::std::option::Option::None,
            defining_obj_id: ::protobuf::MessageField::none(),
            field_id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgUniversalFieldID {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgUniversalFieldID").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgUniversalFieldID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgUniversalFieldID {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgVariableDefinition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgVariableDefinition {
    // message fields
    // @@protoc_insertion_point(field:CMsgVariableDefinition.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgVariableDefinition.inherit)
    pub inherit: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgVariableDefinition.value)
    pub value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgVariableDefinition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgVariableDefinition {
    fn default() -> &'a CMsgVariableDefinition {
        <CMsgVariableDefinition as ::protobuf::Message>::default_instance()
    }
}

impl CMsgVariableDefinition {
    pub fn new() -> CMsgVariableDefinition {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool inherit = 2;

    pub fn inherit(&self) -> bool {
        self.inherit.unwrap_or(true)
    }

    pub fn clear_inherit(&mut self) {
        self.inherit = ::std::option::Option::None;
    }

    pub fn has_inherit(&self) -> bool {
        self.inherit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inherit(&mut self, v: bool) {
        self.inherit = ::std::option::Option::Some(v);
    }

    // optional string value = 3;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgVariableDefinition| { &m.name },
            |m: &mut CMsgVariableDefinition| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "inherit",
            |m: &CMsgVariableDefinition| { &m.inherit },
            |m: &mut CMsgVariableDefinition| { &mut m.inherit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CMsgVariableDefinition| { &m.value },
            |m: &mut CMsgVariableDefinition| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgVariableDefinition>(
            "CMsgVariableDefinition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgVariableDefinition {
    const NAME: &'static str = "CMsgVariableDefinition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.inherit = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.inherit {
            my_size += 1 + 1;
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.inherit {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgVariableDefinition {
        CMsgVariableDefinition::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.inherit = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgVariableDefinition {
        static instance: CMsgVariableDefinition = CMsgVariableDefinition {
            name: ::std::option::Option::None,
            inherit: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgVariableDefinition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgVariableDefinition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgVariableDefinition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgVariableDefinition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgProtoDefHeader)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgProtoDefHeader {
    // message fields
    // @@protoc_insertion_point(field:CMsgProtoDefHeader.defindex)
    pub defindex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgProtoDefHeader.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgProtoDefHeader.prefabs)
    pub prefabs: ::std::vec::Vec<CMsgProtoDefID>,
    // @@protoc_insertion_point(field:CMsgProtoDefHeader.tags)
    pub tags: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgProtoDefHeader.prefab_only)
    pub prefab_only: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgProtoDefHeader.variables)
    pub variables: ::std::vec::Vec<CMsgVariableDefinition>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgProtoDefHeader.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgProtoDefHeader {
    fn default() -> &'a CMsgProtoDefHeader {
        <CMsgProtoDefHeader as ::protobuf::Message>::default_instance()
    }
}

impl CMsgProtoDefHeader {
    pub fn new() -> CMsgProtoDefHeader {
        ::std::default::Default::default()
    }

    // required uint32 defindex = 1;

    pub fn defindex(&self) -> u32 {
        self.defindex.unwrap_or(0)
    }

    pub fn clear_defindex(&mut self) {
        self.defindex = ::std::option::Option::None;
    }

    pub fn has_defindex(&self) -> bool {
        self.defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defindex(&mut self, v: u32) {
        self.defindex = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool prefab_only = 5;

    pub fn prefab_only(&self) -> bool {
        self.prefab_only.unwrap_or(false)
    }

    pub fn clear_prefab_only(&mut self) {
        self.prefab_only = ::std::option::Option::None;
    }

    pub fn has_prefab_only(&self) -> bool {
        self.prefab_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prefab_only(&mut self, v: bool) {
        self.prefab_only = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "defindex",
            |m: &CMsgProtoDefHeader| { &m.defindex },
            |m: &mut CMsgProtoDefHeader| { &mut m.defindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgProtoDefHeader| { &m.name },
            |m: &mut CMsgProtoDefHeader| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "prefabs",
            |m: &CMsgProtoDefHeader| { &m.prefabs },
            |m: &mut CMsgProtoDefHeader| { &mut m.prefabs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tags",
            |m: &CMsgProtoDefHeader| { &m.tags },
            |m: &mut CMsgProtoDefHeader| { &mut m.tags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "prefab_only",
            |m: &CMsgProtoDefHeader| { &m.prefab_only },
            |m: &mut CMsgProtoDefHeader| { &mut m.prefab_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "variables",
            |m: &CMsgProtoDefHeader| { &m.variables },
            |m: &mut CMsgProtoDefHeader| { &mut m.variables },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgProtoDefHeader>(
            "CMsgProtoDefHeader",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgProtoDefHeader {
    const NAME: &'static str = "CMsgProtoDefHeader";

    fn is_initialized(&self) -> bool {
        if self.defindex.is_none() {
            return false;
        }
        for v in &self.prefabs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.variables {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.defindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.prefabs.push(is.read_message()?);
                },
                34 => {
                    self.tags.push(is.read_string()?);
                },
                40 => {
                    self.prefab_only = ::std::option::Option::Some(is.read_bool()?);
                },
                50 => {
                    self.variables.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.defindex {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.prefabs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(v) = self.prefab_only {
            my_size += 1 + 1;
        }
        for value in &self.variables {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.defindex {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.prefabs {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.tags {
            os.write_string(4, &v)?;
        };
        if let Some(v) = self.prefab_only {
            os.write_bool(5, v)?;
        }
        for v in &self.variables {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgProtoDefHeader {
        CMsgProtoDefHeader::new()
    }

    fn clear(&mut self) {
        self.defindex = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.prefabs.clear();
        self.tags.clear();
        self.prefab_only = ::std::option::Option::None;
        self.variables.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgProtoDefHeader {
        static instance: CMsgProtoDefHeader = CMsgProtoDefHeader {
            defindex: ::std::option::Option::None,
            name: ::std::option::Option::None,
            prefabs: ::std::vec::Vec::new(),
            tags: ::std::vec::Vec::new(),
            prefab_only: ::std::option::Option::None,
            variables: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgProtoDefHeader {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgProtoDefHeader").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgProtoDefHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgProtoDefHeader {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgValidTypes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgValidTypes {
    // message fields
    // @@protoc_insertion_point(field:CMsgValidTypes.types)
    pub types: ::std::vec::Vec<::protobuf::EnumOrUnknown<ProtoDefTypes>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgValidTypes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgValidTypes {
    fn default() -> &'a CMsgValidTypes {
        <CMsgValidTypes as ::protobuf::Message>::default_instance()
    }
}

impl CMsgValidTypes {
    pub fn new() -> CMsgValidTypes {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "types",
            |m: &CMsgValidTypes| { &m.types },
            |m: &mut CMsgValidTypes| { &mut m.types },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgValidTypes>(
            "CMsgValidTypes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgValidTypes {
    const NAME: &'static str = "CMsgValidTypes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.types.push(is.read_enum_or_unknown()?);
                },
                10 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.types)?
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.types {
            my_size += ::protobuf::rt::int32_size(1, value.value());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.types {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(v))?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgValidTypes {
        CMsgValidTypes::new()
    }

    fn clear(&mut self) {
        self.types.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgValidTypes {
        static instance: CMsgValidTypes = CMsgValidTypes {
            types: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgValidTypes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgValidTypes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgValidTypes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgValidTypes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgProtoDefID)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgProtoDefID {
    // message fields
    // @@protoc_insertion_point(field:CMsgProtoDefID.defindex)
    pub defindex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgProtoDefID.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<ProtoDefTypes>>,
    // message oneof groups
    pub instance: ::std::option::Option<cmsg_proto_def_id::Instance>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgProtoDefID.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgProtoDefID {
    fn default() -> &'a CMsgProtoDefID {
        <CMsgProtoDefID as ::protobuf::Message>::default_instance()
    }
}

impl CMsgProtoDefID {
    pub fn new() -> CMsgProtoDefID {
        ::std::default::Default::default()
    }

    // optional uint32 defindex = 1;

    pub fn defindex(&self) -> u32 {
        self.defindex.unwrap_or(0)
    }

    pub fn clear_defindex(&mut self) {
        self.defindex = ::std::option::Option::None;
    }

    pub fn has_defindex(&self) -> bool {
        self.defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defindex(&mut self, v: u32) {
        self.defindex = ::std::option::Option::Some(v);
    }

    // optional .ProtoDefTypes type = 2;

    pub fn type_(&self) -> ProtoDefTypes {
        match self.type_ {
            Some(e) => e.enum_value_or(ProtoDefTypes::DEF_TYPE_QUEST_MAP_NODE),
            None => ProtoDefTypes::DEF_TYPE_QUEST_MAP_NODE,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ProtoDefTypes) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .CMsgQuestMapNodeDef instance_def_type_quest_map_node = 3;

    pub fn instance_def_type_quest_map_node(&self) -> &CMsgQuestMapNodeDef {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapNode(ref v)) => v,
            _ => <CMsgQuestMapNodeDef as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_instance_def_type_quest_map_node(&mut self) {
        self.instance = ::std::option::Option::None;
    }

    pub fn has_instance_def_type_quest_map_node(&self) -> bool {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapNode(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_instance_def_type_quest_map_node(&mut self, v: CMsgQuestMapNodeDef) {
        self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapNode(v))
    }

    // Mutable pointer to the field.
    pub fn mut_instance_def_type_quest_map_node(&mut self) -> &mut CMsgQuestMapNodeDef {
        if let ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapNode(_)) = self.instance {
        } else {
            self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapNode(CMsgQuestMapNodeDef::new()));
        }
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapNode(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_instance_def_type_quest_map_node(&mut self) -> CMsgQuestMapNodeDef {
        if self.has_instance_def_type_quest_map_node() {
            match self.instance.take() {
                ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapNode(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgQuestMapNodeDef::new()
        }
    }

    // optional .CMsgQuestTheme instance_def_type_quest_theme = 5;

    pub fn instance_def_type_quest_theme(&self) -> &CMsgQuestTheme {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestTheme(ref v)) => v,
            _ => <CMsgQuestTheme as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_instance_def_type_quest_theme(&mut self) {
        self.instance = ::std::option::Option::None;
    }

    pub fn has_instance_def_type_quest_theme(&self) -> bool {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestTheme(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_instance_def_type_quest_theme(&mut self, v: CMsgQuestTheme) {
        self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestTheme(v))
    }

    // Mutable pointer to the field.
    pub fn mut_instance_def_type_quest_theme(&mut self) -> &mut CMsgQuestTheme {
        if let ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestTheme(_)) = self.instance {
        } else {
            self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestTheme(CMsgQuestTheme::new()));
        }
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestTheme(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_instance_def_type_quest_theme(&mut self) -> CMsgQuestTheme {
        if self.has_instance_def_type_quest_theme() {
            match self.instance.take() {
                ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestTheme(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgQuestTheme::new()
        }
    }

    // optional .CMsgQuestMapRegionDef instance_def_type_quest_map_region = 6;

    pub fn instance_def_type_quest_map_region(&self) -> &CMsgQuestMapRegionDef {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapRegion(ref v)) => v,
            _ => <CMsgQuestMapRegionDef as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_instance_def_type_quest_map_region(&mut self) {
        self.instance = ::std::option::Option::None;
    }

    pub fn has_instance_def_type_quest_map_region(&self) -> bool {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapRegion(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_instance_def_type_quest_map_region(&mut self, v: CMsgQuestMapRegionDef) {
        self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapRegion(v))
    }

    // Mutable pointer to the field.
    pub fn mut_instance_def_type_quest_map_region(&mut self) -> &mut CMsgQuestMapRegionDef {
        if let ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapRegion(_)) = self.instance {
        } else {
            self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapRegion(CMsgQuestMapRegionDef::new()));
        }
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapRegion(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_instance_def_type_quest_map_region(&mut self) -> CMsgQuestMapRegionDef {
        if self.has_instance_def_type_quest_map_region() {
            match self.instance.take() {
                ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapRegion(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgQuestMapRegionDef::new()
        }
    }

    // optional .CMsgQuestDef instance_def_type_quest = 7;

    pub fn instance_def_type_quest(&self) -> &CMsgQuestDef {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuest(ref v)) => v,
            _ => <CMsgQuestDef as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_instance_def_type_quest(&mut self) {
        self.instance = ::std::option::Option::None;
    }

    pub fn has_instance_def_type_quest(&self) -> bool {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_instance_def_type_quest(&mut self, v: CMsgQuestDef) {
        self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_instance_def_type_quest(&mut self) -> &mut CMsgQuestDef {
        if let ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuest(_)) = self.instance {
        } else {
            self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuest(CMsgQuestDef::new()));
        }
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_instance_def_type_quest(&mut self) -> CMsgQuestDef {
        if self.has_instance_def_type_quest() {
            match self.instance.take() {
                ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuest(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgQuestDef::new()
        }
    }

    // optional .CMsgQuestObjectiveDef instance_def_type_quest_objective = 8;

    pub fn instance_def_type_quest_objective(&self) -> &CMsgQuestObjectiveDef {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestObjective(ref v)) => v,
            _ => <CMsgQuestObjectiveDef as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_instance_def_type_quest_objective(&mut self) {
        self.instance = ::std::option::Option::None;
    }

    pub fn has_instance_def_type_quest_objective(&self) -> bool {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestObjective(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_instance_def_type_quest_objective(&mut self, v: CMsgQuestObjectiveDef) {
        self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestObjective(v))
    }

    // Mutable pointer to the field.
    pub fn mut_instance_def_type_quest_objective(&mut self) -> &mut CMsgQuestObjectiveDef {
        if let ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestObjective(_)) = self.instance {
        } else {
            self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestObjective(CMsgQuestObjectiveDef::new()));
        }
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestObjective(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_instance_def_type_quest_objective(&mut self) -> CMsgQuestObjectiveDef {
        if self.has_instance_def_type_quest_objective() {
            match self.instance.take() {
                ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestObjective(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgQuestObjectiveDef::new()
        }
    }

    // optional .CMsgPaintKit_Variables instance_def_type_paintkit_variables = 9;

    pub fn instance_def_type_paintkit_variables(&self) -> &CMsgPaintKit_Variables {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitVariables(ref v)) => v,
            _ => <CMsgPaintKit_Variables as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_instance_def_type_paintkit_variables(&mut self) {
        self.instance = ::std::option::Option::None;
    }

    pub fn has_instance_def_type_paintkit_variables(&self) -> bool {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitVariables(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_instance_def_type_paintkit_variables(&mut self, v: CMsgPaintKit_Variables) {
        self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitVariables(v))
    }

    // Mutable pointer to the field.
    pub fn mut_instance_def_type_paintkit_variables(&mut self) -> &mut CMsgPaintKit_Variables {
        if let ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitVariables(_)) = self.instance {
        } else {
            self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitVariables(CMsgPaintKit_Variables::new()));
        }
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitVariables(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_instance_def_type_paintkit_variables(&mut self) -> CMsgPaintKit_Variables {
        if self.has_instance_def_type_paintkit_variables() {
            match self.instance.take() {
                ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitVariables(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgPaintKit_Variables::new()
        }
    }

    // optional .CMsgPaintKit_Operation instance_def_type_paintkit_operation = 10;

    pub fn instance_def_type_paintkit_operation(&self) -> &CMsgPaintKit_Operation {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitOperation(ref v)) => v,
            _ => <CMsgPaintKit_Operation as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_instance_def_type_paintkit_operation(&mut self) {
        self.instance = ::std::option::Option::None;
    }

    pub fn has_instance_def_type_paintkit_operation(&self) -> bool {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitOperation(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_instance_def_type_paintkit_operation(&mut self, v: CMsgPaintKit_Operation) {
        self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitOperation(v))
    }

    // Mutable pointer to the field.
    pub fn mut_instance_def_type_paintkit_operation(&mut self) -> &mut CMsgPaintKit_Operation {
        if let ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitOperation(_)) = self.instance {
        } else {
            self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitOperation(CMsgPaintKit_Operation::new()));
        }
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitOperation(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_instance_def_type_paintkit_operation(&mut self) -> CMsgPaintKit_Operation {
        if self.has_instance_def_type_paintkit_operation() {
            match self.instance.take() {
                ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitOperation(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgPaintKit_Operation::new()
        }
    }

    // optional .CMsgPaintKit_ItemDefinition instance_def_type_paintkit_item_definition = 11;

    pub fn instance_def_type_paintkit_item_definition(&self) -> &CMsgPaintKit_ItemDefinition {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitItemDefinition(ref v)) => v,
            _ => <CMsgPaintKit_ItemDefinition as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_instance_def_type_paintkit_item_definition(&mut self) {
        self.instance = ::std::option::Option::None;
    }

    pub fn has_instance_def_type_paintkit_item_definition(&self) -> bool {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitItemDefinition(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_instance_def_type_paintkit_item_definition(&mut self, v: CMsgPaintKit_ItemDefinition) {
        self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitItemDefinition(v))
    }

    // Mutable pointer to the field.
    pub fn mut_instance_def_type_paintkit_item_definition(&mut self) -> &mut CMsgPaintKit_ItemDefinition {
        if let ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitItemDefinition(_)) = self.instance {
        } else {
            self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitItemDefinition(CMsgPaintKit_ItemDefinition::new()));
        }
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitItemDefinition(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_instance_def_type_paintkit_item_definition(&mut self) -> CMsgPaintKit_ItemDefinition {
        if self.has_instance_def_type_paintkit_item_definition() {
            match self.instance.take() {
                ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitItemDefinition(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgPaintKit_ItemDefinition::new()
        }
    }

    // optional .CMsgPaintKit_Definition instance_def_type_paintkit_definition = 12;

    pub fn instance_def_type_paintkit_definition(&self) -> &CMsgPaintKit_Definition {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitDefinition(ref v)) => v,
            _ => <CMsgPaintKit_Definition as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_instance_def_type_paintkit_definition(&mut self) {
        self.instance = ::std::option::Option::None;
    }

    pub fn has_instance_def_type_paintkit_definition(&self) -> bool {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitDefinition(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_instance_def_type_paintkit_definition(&mut self, v: CMsgPaintKit_Definition) {
        self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitDefinition(v))
    }

    // Mutable pointer to the field.
    pub fn mut_instance_def_type_paintkit_definition(&mut self) -> &mut CMsgPaintKit_Definition {
        if let ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitDefinition(_)) = self.instance {
        } else {
            self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitDefinition(CMsgPaintKit_Definition::new()));
        }
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitDefinition(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_instance_def_type_paintkit_definition(&mut self) -> CMsgPaintKit_Definition {
        if self.has_instance_def_type_paintkit_definition() {
            match self.instance.take() {
                ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitDefinition(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgPaintKit_Definition::new()
        }
    }

    // optional .CMsgHeaderOnly instance_def_type_header_only = 13;

    pub fn instance_def_type_header_only(&self) -> &CMsgHeaderOnly {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeHeaderOnly(ref v)) => v,
            _ => <CMsgHeaderOnly as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_instance_def_type_header_only(&mut self) {
        self.instance = ::std::option::Option::None;
    }

    pub fn has_instance_def_type_header_only(&self) -> bool {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeHeaderOnly(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_instance_def_type_header_only(&mut self, v: CMsgHeaderOnly) {
        self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeHeaderOnly(v))
    }

    // Mutable pointer to the field.
    pub fn mut_instance_def_type_header_only(&mut self) -> &mut CMsgHeaderOnly {
        if let ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeHeaderOnly(_)) = self.instance {
        } else {
            self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeHeaderOnly(CMsgHeaderOnly::new()));
        }
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeHeaderOnly(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_instance_def_type_header_only(&mut self) -> CMsgHeaderOnly {
        if self.has_instance_def_type_header_only() {
            match self.instance.take() {
                ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeHeaderOnly(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgHeaderOnly::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "defindex",
            |m: &CMsgProtoDefID| { &m.defindex },
            |m: &mut CMsgProtoDefID| { &mut m.defindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CMsgProtoDefID| { &m.type_ },
            |m: &mut CMsgProtoDefID| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CMsgQuestMapNodeDef>(
            "instance_def_type_quest_map_node",
            CMsgProtoDefID::has_instance_def_type_quest_map_node,
            CMsgProtoDefID::instance_def_type_quest_map_node,
            CMsgProtoDefID::mut_instance_def_type_quest_map_node,
            CMsgProtoDefID::set_instance_def_type_quest_map_node,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CMsgQuestTheme>(
            "instance_def_type_quest_theme",
            CMsgProtoDefID::has_instance_def_type_quest_theme,
            CMsgProtoDefID::instance_def_type_quest_theme,
            CMsgProtoDefID::mut_instance_def_type_quest_theme,
            CMsgProtoDefID::set_instance_def_type_quest_theme,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CMsgQuestMapRegionDef>(
            "instance_def_type_quest_map_region",
            CMsgProtoDefID::has_instance_def_type_quest_map_region,
            CMsgProtoDefID::instance_def_type_quest_map_region,
            CMsgProtoDefID::mut_instance_def_type_quest_map_region,
            CMsgProtoDefID::set_instance_def_type_quest_map_region,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CMsgQuestDef>(
            "instance_def_type_quest",
            CMsgProtoDefID::has_instance_def_type_quest,
            CMsgProtoDefID::instance_def_type_quest,
            CMsgProtoDefID::mut_instance_def_type_quest,
            CMsgProtoDefID::set_instance_def_type_quest,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CMsgQuestObjectiveDef>(
            "instance_def_type_quest_objective",
            CMsgProtoDefID::has_instance_def_type_quest_objective,
            CMsgProtoDefID::instance_def_type_quest_objective,
            CMsgProtoDefID::mut_instance_def_type_quest_objective,
            CMsgProtoDefID::set_instance_def_type_quest_objective,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CMsgPaintKit_Variables>(
            "instance_def_type_paintkit_variables",
            CMsgProtoDefID::has_instance_def_type_paintkit_variables,
            CMsgProtoDefID::instance_def_type_paintkit_variables,
            CMsgProtoDefID::mut_instance_def_type_paintkit_variables,
            CMsgProtoDefID::set_instance_def_type_paintkit_variables,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CMsgPaintKit_Operation>(
            "instance_def_type_paintkit_operation",
            CMsgProtoDefID::has_instance_def_type_paintkit_operation,
            CMsgProtoDefID::instance_def_type_paintkit_operation,
            CMsgProtoDefID::mut_instance_def_type_paintkit_operation,
            CMsgProtoDefID::set_instance_def_type_paintkit_operation,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CMsgPaintKit_ItemDefinition>(
            "instance_def_type_paintkit_item_definition",
            CMsgProtoDefID::has_instance_def_type_paintkit_item_definition,
            CMsgProtoDefID::instance_def_type_paintkit_item_definition,
            CMsgProtoDefID::mut_instance_def_type_paintkit_item_definition,
            CMsgProtoDefID::set_instance_def_type_paintkit_item_definition,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CMsgPaintKit_Definition>(
            "instance_def_type_paintkit_definition",
            CMsgProtoDefID::has_instance_def_type_paintkit_definition,
            CMsgProtoDefID::instance_def_type_paintkit_definition,
            CMsgProtoDefID::mut_instance_def_type_paintkit_definition,
            CMsgProtoDefID::set_instance_def_type_paintkit_definition,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CMsgHeaderOnly>(
            "instance_def_type_header_only",
            CMsgProtoDefID::has_instance_def_type_header_only,
            CMsgProtoDefID::instance_def_type_header_only,
            CMsgProtoDefID::mut_instance_def_type_header_only,
            CMsgProtoDefID::set_instance_def_type_header_only,
        ));
        oneofs.push(cmsg_proto_def_id::Instance::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgProtoDefID>(
            "CMsgProtoDefID",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgProtoDefID {
    const NAME: &'static str = "CMsgProtoDefID";

    fn is_initialized(&self) -> bool {
        if let Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapNode(ref v)) = self.instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestTheme(ref v)) = self.instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapRegion(ref v)) = self.instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuest(ref v)) = self.instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestObjective(ref v)) = self.instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitVariables(ref v)) = self.instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitOperation(ref v)) = self.instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitItemDefinition(ref v)) = self.instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitDefinition(ref v)) = self.instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(cmsg_proto_def_id::Instance::InstanceDefTypeHeaderOnly(ref v)) = self.instance {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.defindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapNode(is.read_message()?));
                },
                42 => {
                    self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestTheme(is.read_message()?));
                },
                50 => {
                    self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapRegion(is.read_message()?));
                },
                58 => {
                    self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuest(is.read_message()?));
                },
                66 => {
                    self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestObjective(is.read_message()?));
                },
                74 => {
                    self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitVariables(is.read_message()?));
                },
                82 => {
                    self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitOperation(is.read_message()?));
                },
                90 => {
                    self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitItemDefinition(is.read_message()?));
                },
                98 => {
                    self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitDefinition(is.read_message()?));
                },
                106 => {
                    self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeHeaderOnly(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.defindex {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let ::std::option::Option::Some(ref v) = self.instance {
            match v {
                &cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapNode(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_proto_def_id::Instance::InstanceDefTypeQuestTheme(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapRegion(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_proto_def_id::Instance::InstanceDefTypeQuest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_proto_def_id::Instance::InstanceDefTypeQuestObjective(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_proto_def_id::Instance::InstanceDefTypePaintkitVariables(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_proto_def_id::Instance::InstanceDefTypePaintkitOperation(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_proto_def_id::Instance::InstanceDefTypePaintkitItemDefinition(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_proto_def_id::Instance::InstanceDefTypePaintkitDefinition(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_proto_def_id::Instance::InstanceDefTypeHeaderOnly(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.defindex {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let ::std::option::Option::Some(ref v) = self.instance {
            match v {
                &cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapNode(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &cmsg_proto_def_id::Instance::InstanceDefTypeQuestTheme(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapRegion(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &cmsg_proto_def_id::Instance::InstanceDefTypeQuest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &cmsg_proto_def_id::Instance::InstanceDefTypeQuestObjective(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &cmsg_proto_def_id::Instance::InstanceDefTypePaintkitVariables(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
                &cmsg_proto_def_id::Instance::InstanceDefTypePaintkitOperation(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
                &cmsg_proto_def_id::Instance::InstanceDefTypePaintkitItemDefinition(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &cmsg_proto_def_id::Instance::InstanceDefTypePaintkitDefinition(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
                &cmsg_proto_def_id::Instance::InstanceDefTypeHeaderOnly(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgProtoDefID {
        CMsgProtoDefID::new()
    }

    fn clear(&mut self) {
        self.defindex = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.instance = ::std::option::Option::None;
        self.instance = ::std::option::Option::None;
        self.instance = ::std::option::Option::None;
        self.instance = ::std::option::Option::None;
        self.instance = ::std::option::Option::None;
        self.instance = ::std::option::Option::None;
        self.instance = ::std::option::Option::None;
        self.instance = ::std::option::Option::None;
        self.instance = ::std::option::Option::None;
        self.instance = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgProtoDefID {
        static instance: CMsgProtoDefID = CMsgProtoDefID {
            defindex: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            instance: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgProtoDefID {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgProtoDefID").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgProtoDefID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgProtoDefID {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgProtoDefID`
pub mod cmsg_proto_def_id {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:CMsgProtoDefID.instance)
    pub enum Instance {
        // @@protoc_insertion_point(oneof_field:CMsgProtoDefID.instance_def_type_quest_map_node)
        InstanceDefTypeQuestMapNode(super::CMsgQuestMapNodeDef),
        // @@protoc_insertion_point(oneof_field:CMsgProtoDefID.instance_def_type_quest_theme)
        InstanceDefTypeQuestTheme(super::CMsgQuestTheme),
        // @@protoc_insertion_point(oneof_field:CMsgProtoDefID.instance_def_type_quest_map_region)
        InstanceDefTypeQuestMapRegion(super::CMsgQuestMapRegionDef),
        // @@protoc_insertion_point(oneof_field:CMsgProtoDefID.instance_def_type_quest)
        InstanceDefTypeQuest(super::CMsgQuestDef),
        // @@protoc_insertion_point(oneof_field:CMsgProtoDefID.instance_def_type_quest_objective)
        InstanceDefTypeQuestObjective(super::CMsgQuestObjectiveDef),
        // @@protoc_insertion_point(oneof_field:CMsgProtoDefID.instance_def_type_paintkit_variables)
        InstanceDefTypePaintkitVariables(super::CMsgPaintKit_Variables),
        // @@protoc_insertion_point(oneof_field:CMsgProtoDefID.instance_def_type_paintkit_operation)
        InstanceDefTypePaintkitOperation(super::CMsgPaintKit_Operation),
        // @@protoc_insertion_point(oneof_field:CMsgProtoDefID.instance_def_type_paintkit_item_definition)
        InstanceDefTypePaintkitItemDefinition(super::CMsgPaintKit_ItemDefinition),
        // @@protoc_insertion_point(oneof_field:CMsgProtoDefID.instance_def_type_paintkit_definition)
        InstanceDefTypePaintkitDefinition(super::CMsgPaintKit_Definition),
        // @@protoc_insertion_point(oneof_field:CMsgProtoDefID.instance_def_type_header_only)
        InstanceDefTypeHeaderOnly(super::CMsgHeaderOnly),
    }

    impl ::protobuf::Oneof for Instance {
    }

    impl ::protobuf::OneofFull for Instance {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::CMsgProtoDefID as ::protobuf::MessageFull>::descriptor().oneof_by_name("instance").unwrap()).clone()
        }
    }

    impl Instance {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Instance>("instance")
        }
    }
}

// @@protoc_insertion_point(message:CMsgQuestObjectiveDef)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgQuestObjectiveDef {
    // message fields
    // @@protoc_insertion_point(field:CMsgQuestObjectiveDef.header)
    pub header: ::protobuf::MessageField<CMsgProtoDefHeader>,
    // @@protoc_insertion_point(field:CMsgQuestObjectiveDef.loc_desctoken)
    pub loc_desctoken: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestObjectiveDef.points)
    pub points: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgQuestObjectiveDef.conditions_defindex)
    pub conditions_defindex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgQuestObjectiveDef.map)
    pub map: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestObjectiveDef.game_mode)
    pub game_mode: ::std::vec::Vec<::protobuf::EnumOrUnknown<cmsg_quest_objective_def::ETF2GameModes>>,
    // @@protoc_insertion_point(field:CMsgQuestObjectiveDef.team)
    pub team: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_quest_objective_def::ETF2Team>>,
    // @@protoc_insertion_point(field:CMsgQuestObjectiveDef.condition_vars)
    pub condition_vars: ::std::vec::Vec<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgQuestObjectiveDef.classes_vars)
    pub classes_vars: ::std::vec::Vec<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgQuestObjectiveDef.conditions)
    pub conditions: ::std::vec::Vec<::protobuf::EnumOrUnknown<cmsg_quest_objective_def::ETF2Conditions>>,
    // @@protoc_insertion_point(field:CMsgQuestObjectiveDef.condition_logic)
    pub condition_logic: ::std::option::Option<::protobuf::EnumOrUnknown<LogicalOperation>>,
    // @@protoc_insertion_point(field:CMsgQuestObjectiveDef.item_name)
    pub item_name: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestObjectiveDef.item_logic)
    pub item_logic: ::std::option::Option<::protobuf::EnumOrUnknown<LogicalOperation>>,
    // @@protoc_insertion_point(field:CMsgQuestObjectiveDef.jump_state)
    pub jump_state: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgQuestObjectiveDef.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgQuestObjectiveDef {
    fn default() -> &'a CMsgQuestObjectiveDef {
        <CMsgQuestObjectiveDef as ::protobuf::Message>::default_instance()
    }
}

impl CMsgQuestObjectiveDef {
    pub fn new() -> CMsgQuestObjectiveDef {
        ::std::default::Default::default()
    }

    // optional string loc_desctoken = 2;

    pub fn loc_desctoken(&self) -> &str {
        match self.loc_desctoken.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_loc_desctoken(&mut self) {
        self.loc_desctoken = ::std::option::Option::None;
    }

    pub fn has_loc_desctoken(&self) -> bool {
        self.loc_desctoken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loc_desctoken(&mut self, v: ::std::string::String) {
        self.loc_desctoken = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loc_desctoken(&mut self) -> &mut ::std::string::String {
        if self.loc_desctoken.is_none() {
            self.loc_desctoken = ::std::option::Option::Some(::std::string::String::new());
        }
        self.loc_desctoken.as_mut().unwrap()
    }

    // Take field
    pub fn take_loc_desctoken(&mut self) -> ::std::string::String {
        self.loc_desctoken.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 points = 3;

    pub fn points(&self) -> u32 {
        self.points.unwrap_or(0)
    }

    pub fn clear_points(&mut self) {
        self.points = ::std::option::Option::None;
    }

    pub fn has_points(&self) -> bool {
        self.points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points(&mut self, v: u32) {
        self.points = ::std::option::Option::Some(v);
    }

    // optional uint32 conditions_defindex = 5;

    pub fn conditions_defindex(&self) -> u32 {
        self.conditions_defindex.unwrap_or(0)
    }

    pub fn clear_conditions_defindex(&mut self) {
        self.conditions_defindex = ::std::option::Option::None;
    }

    pub fn has_conditions_defindex(&self) -> bool {
        self.conditions_defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conditions_defindex(&mut self, v: u32) {
        self.conditions_defindex = ::std::option::Option::Some(v);
    }

    // optional .CMsgQuestObjectiveDef.ETF2Team team = 10;

    pub fn team(&self) -> cmsg_quest_objective_def::ETF2Team {
        match self.team {
            Some(e) => e.enum_value_or(cmsg_quest_objective_def::ETF2Team::TF_TEAM_RED),
            None => cmsg_quest_objective_def::ETF2Team::TF_TEAM_RED,
        }
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: cmsg_quest_objective_def::ETF2Team) {
        self.team = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .LogicalOperation condition_logic = 14;

    pub fn condition_logic(&self) -> LogicalOperation {
        match self.condition_logic {
            Some(e) => e.enum_value_or(LogicalOperation::AND),
            None => LogicalOperation::AND,
        }
    }

    pub fn clear_condition_logic(&mut self) {
        self.condition_logic = ::std::option::Option::None;
    }

    pub fn has_condition_logic(&self) -> bool {
        self.condition_logic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_condition_logic(&mut self, v: LogicalOperation) {
        self.condition_logic = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .LogicalOperation item_logic = 16;

    pub fn item_logic(&self) -> LogicalOperation {
        match self.item_logic {
            Some(e) => e.enum_value_or(LogicalOperation::AND),
            None => LogicalOperation::AND,
        }
    }

    pub fn clear_item_logic(&mut self) {
        self.item_logic = ::std::option::Option::None;
    }

    pub fn has_item_logic(&self) -> bool {
        self.item_logic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_logic(&mut self, v: LogicalOperation) {
        self.item_logic = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 jump_state = 17;

    pub fn jump_state(&self) -> u32 {
        self.jump_state.unwrap_or(0)
    }

    pub fn clear_jump_state(&mut self) {
        self.jump_state = ::std::option::Option::None;
    }

    pub fn has_jump_state(&self) -> bool {
        self.jump_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jump_state(&mut self, v: u32) {
        self.jump_state = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgProtoDefHeader>(
            "header",
            |m: &CMsgQuestObjectiveDef| { &m.header },
            |m: &mut CMsgQuestObjectiveDef| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "loc_desctoken",
            |m: &CMsgQuestObjectiveDef| { &m.loc_desctoken },
            |m: &mut CMsgQuestObjectiveDef| { &mut m.loc_desctoken },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "points",
            |m: &CMsgQuestObjectiveDef| { &m.points },
            |m: &mut CMsgQuestObjectiveDef| { &mut m.points },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "conditions_defindex",
            |m: &CMsgQuestObjectiveDef| { &m.conditions_defindex },
            |m: &mut CMsgQuestObjectiveDef| { &mut m.conditions_defindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "map",
            |m: &CMsgQuestObjectiveDef| { &m.map },
            |m: &mut CMsgQuestObjectiveDef| { &mut m.map },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "game_mode",
            |m: &CMsgQuestObjectiveDef| { &m.game_mode },
            |m: &mut CMsgQuestObjectiveDef| { &mut m.game_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team",
            |m: &CMsgQuestObjectiveDef| { &m.team },
            |m: &mut CMsgQuestObjectiveDef| { &mut m.team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "condition_vars",
            |m: &CMsgQuestObjectiveDef| { &m.condition_vars },
            |m: &mut CMsgQuestObjectiveDef| { &mut m.condition_vars },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "classes_vars",
            |m: &CMsgQuestObjectiveDef| { &m.classes_vars },
            |m: &mut CMsgQuestObjectiveDef| { &mut m.classes_vars },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conditions",
            |m: &CMsgQuestObjectiveDef| { &m.conditions },
            |m: &mut CMsgQuestObjectiveDef| { &mut m.conditions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "condition_logic",
            |m: &CMsgQuestObjectiveDef| { &m.condition_logic },
            |m: &mut CMsgQuestObjectiveDef| { &mut m.condition_logic },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "item_name",
            |m: &CMsgQuestObjectiveDef| { &m.item_name },
            |m: &mut CMsgQuestObjectiveDef| { &mut m.item_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_logic",
            |m: &CMsgQuestObjectiveDef| { &m.item_logic },
            |m: &mut CMsgQuestObjectiveDef| { &mut m.item_logic },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "jump_state",
            |m: &CMsgQuestObjectiveDef| { &m.jump_state },
            |m: &mut CMsgQuestObjectiveDef| { &mut m.jump_state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgQuestObjectiveDef>(
            "CMsgQuestObjectiveDef",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgQuestObjectiveDef {
    const NAME: &'static str = "CMsgQuestObjectiveDef";

    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.condition_vars {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.classes_vars {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.loc_desctoken = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.points = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.conditions_defindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.map.push(is.read_string()?);
                },
                72 => {
                    self.game_mode.push(is.read_enum_or_unknown()?);
                },
                74 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.game_mode)?
                },
                80 => {
                    self.team = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                90 => {
                    self.condition_vars.push(is.read_message()?);
                },
                98 => {
                    self.classes_vars.push(is.read_message()?);
                },
                104 => {
                    self.conditions.push(is.read_enum_or_unknown()?);
                },
                106 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.conditions)?
                },
                112 => {
                    self.condition_logic = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                122 => {
                    self.item_name.push(is.read_string()?);
                },
                128 => {
                    self.item_logic = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                136 => {
                    self.jump_state = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.loc_desctoken.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.points {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.conditions_defindex {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        for value in &self.map {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        for value in &self.game_mode {
            my_size += ::protobuf::rt::int32_size(9, value.value());
        };
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::int32_size(10, v.value());
        }
        for value in &self.condition_vars {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.classes_vars {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.conditions {
            my_size += ::protobuf::rt::int32_size(13, value.value());
        };
        if let Some(v) = self.condition_logic {
            my_size += ::protobuf::rt::int32_size(14, v.value());
        }
        for value in &self.item_name {
            my_size += ::protobuf::rt::string_size(15, &value);
        };
        if let Some(v) = self.item_logic {
            my_size += ::protobuf::rt::int32_size(16, v.value());
        }
        if let Some(v) = self.jump_state {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.loc_desctoken.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.points {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.conditions_defindex {
            os.write_uint32(5, v)?;
        }
        for v in &self.map {
            os.write_string(8, &v)?;
        };
        for v in &self.game_mode {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(v))?;
        };
        if let Some(v) = self.team {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.condition_vars {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        for v in &self.classes_vars {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        for v in &self.conditions {
            os.write_enum(13, ::protobuf::EnumOrUnknown::value(v))?;
        };
        if let Some(v) = self.condition_logic {
            os.write_enum(14, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.item_name {
            os.write_string(15, &v)?;
        };
        if let Some(v) = self.item_logic {
            os.write_enum(16, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.jump_state {
            os.write_uint32(17, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgQuestObjectiveDef {
        CMsgQuestObjectiveDef::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.loc_desctoken = ::std::option::Option::None;
        self.points = ::std::option::Option::None;
        self.conditions_defindex = ::std::option::Option::None;
        self.map.clear();
        self.game_mode.clear();
        self.team = ::std::option::Option::None;
        self.condition_vars.clear();
        self.classes_vars.clear();
        self.conditions.clear();
        self.condition_logic = ::std::option::Option::None;
        self.item_name.clear();
        self.item_logic = ::std::option::Option::None;
        self.jump_state = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgQuestObjectiveDef {
        static instance: CMsgQuestObjectiveDef = CMsgQuestObjectiveDef {
            header: ::protobuf::MessageField::none(),
            loc_desctoken: ::std::option::Option::None,
            points: ::std::option::Option::None,
            conditions_defindex: ::std::option::Option::None,
            map: ::std::vec::Vec::new(),
            game_mode: ::std::vec::Vec::new(),
            team: ::std::option::Option::None,
            condition_vars: ::std::vec::Vec::new(),
            classes_vars: ::std::vec::Vec::new(),
            conditions: ::std::vec::Vec::new(),
            condition_logic: ::std::option::Option::None,
            item_name: ::std::vec::Vec::new(),
            item_logic: ::std::option::Option::None,
            jump_state: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgQuestObjectiveDef {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgQuestObjectiveDef").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgQuestObjectiveDef {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgQuestObjectiveDef {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgQuestObjectiveDef`
pub mod cmsg_quest_objective_def {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgQuestObjectiveDef.ETF2GameModes)
    pub enum ETF2GameModes {
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_Escort)
        kGameCategory_Escort = 0,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_CTF)
        kGameCategory_CTF = 1,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_AttackDefense)
        kGameCategory_AttackDefense = 2,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_Koth)
        kGameCategory_Koth = 3,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_CP)
        kGameCategory_CP = 4,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_EscortRace)
        kGameCategory_EscortRace = 5,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_EventMix)
        kGameCategory_EventMix = 6,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_SD)
        kGameCategory_SD = 7,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_Quickplay)
        kGameCategory_Quickplay = 8,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_Event247)
        kGameCategory_Event247 = 9,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_Arena)
        kGameCategory_Arena = 10,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_RobotDestruction)
        kGameCategory_RobotDestruction = 11,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_Powerup)
        kGameCategory_Powerup = 12,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_Featured)
        kGameCategory_Featured = 13,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_Passtime)
        kGameCategory_Passtime = 14,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_Community_Update)
        kGameCategory_Community_Update = 15,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_Misc)
        kGameCategory_Misc = 16,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_Competitive_6v6)
        kGameCategory_Competitive_6v6 = 17,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_Other)
        kGameCategory_Other = 18,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_Halloween)
        kGameCategory_Halloween = 19,
    }

    impl ::protobuf::Enum for ETF2GameModes {
        const NAME: &'static str = "ETF2GameModes";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ETF2GameModes> {
            match value {
                0 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Escort),
                1 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_CTF),
                2 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_AttackDefense),
                3 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Koth),
                4 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_CP),
                5 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_EscortRace),
                6 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_EventMix),
                7 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_SD),
                8 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Quickplay),
                9 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Event247),
                10 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Arena),
                11 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_RobotDestruction),
                12 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Powerup),
                13 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Featured),
                14 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Passtime),
                15 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Community_Update),
                16 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Misc),
                17 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Competitive_6v6),
                18 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Other),
                19 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Halloween),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ETF2GameModes> {
            match str {
                "kGameCategory_Escort" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Escort),
                "kGameCategory_CTF" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_CTF),
                "kGameCategory_AttackDefense" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_AttackDefense),
                "kGameCategory_Koth" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Koth),
                "kGameCategory_CP" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_CP),
                "kGameCategory_EscortRace" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_EscortRace),
                "kGameCategory_EventMix" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_EventMix),
                "kGameCategory_SD" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_SD),
                "kGameCategory_Quickplay" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Quickplay),
                "kGameCategory_Event247" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Event247),
                "kGameCategory_Arena" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Arena),
                "kGameCategory_RobotDestruction" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_RobotDestruction),
                "kGameCategory_Powerup" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Powerup),
                "kGameCategory_Featured" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Featured),
                "kGameCategory_Passtime" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Passtime),
                "kGameCategory_Community_Update" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Community_Update),
                "kGameCategory_Misc" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Misc),
                "kGameCategory_Competitive_6v6" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Competitive_6v6),
                "kGameCategory_Other" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Other),
                "kGameCategory_Halloween" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Halloween),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ETF2GameModes] = &[
            ETF2GameModes::kGameCategory_Escort,
            ETF2GameModes::kGameCategory_CTF,
            ETF2GameModes::kGameCategory_AttackDefense,
            ETF2GameModes::kGameCategory_Koth,
            ETF2GameModes::kGameCategory_CP,
            ETF2GameModes::kGameCategory_EscortRace,
            ETF2GameModes::kGameCategory_EventMix,
            ETF2GameModes::kGameCategory_SD,
            ETF2GameModes::kGameCategory_Quickplay,
            ETF2GameModes::kGameCategory_Event247,
            ETF2GameModes::kGameCategory_Arena,
            ETF2GameModes::kGameCategory_RobotDestruction,
            ETF2GameModes::kGameCategory_Powerup,
            ETF2GameModes::kGameCategory_Featured,
            ETF2GameModes::kGameCategory_Passtime,
            ETF2GameModes::kGameCategory_Community_Update,
            ETF2GameModes::kGameCategory_Misc,
            ETF2GameModes::kGameCategory_Competitive_6v6,
            ETF2GameModes::kGameCategory_Other,
            ETF2GameModes::kGameCategory_Halloween,
        ];
    }

    impl ::protobuf::EnumFull for ETF2GameModes {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgQuestObjectiveDef.ETF2GameModes").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ETF2GameModes {
        fn default() -> Self {
            ETF2GameModes::kGameCategory_Escort
        }
    }

    impl ETF2GameModes {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ETF2GameModes>("CMsgQuestObjectiveDef.ETF2GameModes")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgQuestObjectiveDef.ETF2Conditions)
    pub enum ETF2Conditions {
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_AIMING)
        TF_COND_AIMING = 0,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_ZOOMED)
        TF_COND_ZOOMED = 1,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_DISGUISING)
        TF_COND_DISGUISING = 2,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_DISGUISED)
        TF_COND_DISGUISED = 3,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_STEALTHED)
        TF_COND_STEALTHED = 4,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_INVULNERABLE)
        TF_COND_INVULNERABLE = 5,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_TELEPORTED)
        TF_COND_TELEPORTED = 6,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_TAUNTING)
        TF_COND_TAUNTING = 7,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_INVULNERABLE_WEARINGOFF)
        TF_COND_INVULNERABLE_WEARINGOFF = 8,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_STEALTHED_BLINK)
        TF_COND_STEALTHED_BLINK = 9,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_SELECTED_TO_TELEPORT)
        TF_COND_SELECTED_TO_TELEPORT = 10,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_CRITBOOSTED)
        TF_COND_CRITBOOSTED = 11,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_TMPDAMAGEBONUS)
        TF_COND_TMPDAMAGEBONUS = 12,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_FEIGN_DEATH)
        TF_COND_FEIGN_DEATH = 13,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_PHASE)
        TF_COND_PHASE = 14,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_STUNNED)
        TF_COND_STUNNED = 15,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_OFFENSEBUFF)
        TF_COND_OFFENSEBUFF = 16,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_SHIELD_CHARGE)
        TF_COND_SHIELD_CHARGE = 17,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_DEMO_BUFF)
        TF_COND_DEMO_BUFF = 18,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_ENERGY_BUFF)
        TF_COND_ENERGY_BUFF = 19,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_RADIUSHEAL)
        TF_COND_RADIUSHEAL = 20,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_HEALTH_BUFF)
        TF_COND_HEALTH_BUFF = 21,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_BURNING)
        TF_COND_BURNING = 22,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_HEALTH_OVERHEALED)
        TF_COND_HEALTH_OVERHEALED = 23,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_URINE)
        TF_COND_URINE = 24,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_BLEEDING)
        TF_COND_BLEEDING = 25,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_DEFENSEBUFF)
        TF_COND_DEFENSEBUFF = 26,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_MAD_MILK)
        TF_COND_MAD_MILK = 27,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_MEGAHEAL)
        TF_COND_MEGAHEAL = 28,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_REGENONDAMAGEBUFF)
        TF_COND_REGENONDAMAGEBUFF = 29,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_MARKEDFORDEATH)
        TF_COND_MARKEDFORDEATH = 30,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_NOHEALINGDAMAGEBUFF)
        TF_COND_NOHEALINGDAMAGEBUFF = 31,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_SPEED_BOOST)
        TF_COND_SPEED_BOOST = 32,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_CRITBOOSTED_PUMPKIN)
        TF_COND_CRITBOOSTED_PUMPKIN = 33,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_CRITBOOSTED_USER_BUFF)
        TF_COND_CRITBOOSTED_USER_BUFF = 34,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_CRITBOOSTED_DEMO_CHARGE)
        TF_COND_CRITBOOSTED_DEMO_CHARGE = 35,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_SODAPOPPER_HYPE)
        TF_COND_SODAPOPPER_HYPE = 36,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_CRITBOOSTED_FIRST_BLOOD)
        TF_COND_CRITBOOSTED_FIRST_BLOOD = 37,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_CRITBOOSTED_BONUS_TIME)
        TF_COND_CRITBOOSTED_BONUS_TIME = 38,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_CRITBOOSTED_CTF_CAPTURE)
        TF_COND_CRITBOOSTED_CTF_CAPTURE = 39,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_CRITBOOSTED_ON_KILL)
        TF_COND_CRITBOOSTED_ON_KILL = 40,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_CANNOT_SWITCH_FROM_MELEE)
        TF_COND_CANNOT_SWITCH_FROM_MELEE = 41,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_DEFENSEBUFF_NO_CRIT_BLOCK)
        TF_COND_DEFENSEBUFF_NO_CRIT_BLOCK = 42,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_REPROGRAMMED)
        TF_COND_REPROGRAMMED = 43,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_CRITBOOSTED_RAGE_BUFF)
        TF_COND_CRITBOOSTED_RAGE_BUFF = 44,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_DEFENSEBUFF_HIGH)
        TF_COND_DEFENSEBUFF_HIGH = 45,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_SNIPERCHARGE_RAGE_BUFF)
        TF_COND_SNIPERCHARGE_RAGE_BUFF = 46,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_DISGUISE_WEARINGOFF)
        TF_COND_DISGUISE_WEARINGOFF = 47,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_MARKEDFORDEATH_SILENT)
        TF_COND_MARKEDFORDEATH_SILENT = 48,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_DISGUISED_AS_DISPENSER)
        TF_COND_DISGUISED_AS_DISPENSER = 49,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_SAPPED)
        TF_COND_SAPPED = 50,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_INVULNERABLE_HIDE_UNLESS_DAMAGED)
        TF_COND_INVULNERABLE_HIDE_UNLESS_DAMAGED = 51,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_INVULNERABLE_USER_BUFF)
        TF_COND_INVULNERABLE_USER_BUFF = 52,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_HALLOWEEN_BOMB_HEAD)
        TF_COND_HALLOWEEN_BOMB_HEAD = 53,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_HALLOWEEN_THRILLER)
        TF_COND_HALLOWEEN_THRILLER = 54,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_RADIUSHEAL_ON_DAMAGE)
        TF_COND_RADIUSHEAL_ON_DAMAGE = 55,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_CRITBOOSTED_CARD_EFFECT)
        TF_COND_CRITBOOSTED_CARD_EFFECT = 56,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_INVULNERABLE_CARD_EFFECT)
        TF_COND_INVULNERABLE_CARD_EFFECT = 57,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_MEDIGUN_UBER_BULLET_RESIST)
        TF_COND_MEDIGUN_UBER_BULLET_RESIST = 58,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_MEDIGUN_UBER_BLAST_RESIST)
        TF_COND_MEDIGUN_UBER_BLAST_RESIST = 59,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_MEDIGUN_UBER_FIRE_RESIST)
        TF_COND_MEDIGUN_UBER_FIRE_RESIST = 60,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_MEDIGUN_SMALL_BULLET_RESIST)
        TF_COND_MEDIGUN_SMALL_BULLET_RESIST = 61,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_MEDIGUN_SMALL_BLAST_RESIST)
        TF_COND_MEDIGUN_SMALL_BLAST_RESIST = 62,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_MEDIGUN_SMALL_FIRE_RESIST)
        TF_COND_MEDIGUN_SMALL_FIRE_RESIST = 63,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_STEALTHED_USER_BUFF)
        TF_COND_STEALTHED_USER_BUFF = 64,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_MEDIGUN_DEBUFF)
        TF_COND_MEDIGUN_DEBUFF = 65,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_STEALTHED_USER_BUFF_FADING)
        TF_COND_STEALTHED_USER_BUFF_FADING = 66,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_BULLET_IMMUNE)
        TF_COND_BULLET_IMMUNE = 67,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_BLAST_IMMUNE)
        TF_COND_BLAST_IMMUNE = 68,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_FIRE_IMMUNE)
        TF_COND_FIRE_IMMUNE = 69,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_PREVENT_DEATH)
        TF_COND_PREVENT_DEATH = 70,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_MVM_BOT_STUN_RADIOWAVE)
        TF_COND_MVM_BOT_STUN_RADIOWAVE = 71,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_HALLOWEEN_SPEED_BOOST)
        TF_COND_HALLOWEEN_SPEED_BOOST = 72,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_HALLOWEEN_QUICK_HEAL)
        TF_COND_HALLOWEEN_QUICK_HEAL = 73,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_HALLOWEEN_GIANT)
        TF_COND_HALLOWEEN_GIANT = 74,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_HALLOWEEN_TINY)
        TF_COND_HALLOWEEN_TINY = 75,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_HALLOWEEN_IN_HELL)
        TF_COND_HALLOWEEN_IN_HELL = 76,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_HALLOWEEN_GHOST_MODE)
        TF_COND_HALLOWEEN_GHOST_MODE = 77,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_MINICRITBOOSTED_ON_KILL)
        TF_COND_MINICRITBOOSTED_ON_KILL = 78,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_OBSCURED_SMOKE)
        TF_COND_OBSCURED_SMOKE = 79,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_PARACHUTE_ACTIVE)
        TF_COND_PARACHUTE_ACTIVE = 80,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_BLASTJUMPING)
        TF_COND_BLASTJUMPING = 81,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_HALLOWEEN_KART)
        TF_COND_HALLOWEEN_KART = 82,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_HALLOWEEN_KART_DASH)
        TF_COND_HALLOWEEN_KART_DASH = 83,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_BALLOON_HEAD)
        TF_COND_BALLOON_HEAD = 84,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_MELEE_ONLY)
        TF_COND_MELEE_ONLY = 85,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_SWIMMING_CURSE)
        TF_COND_SWIMMING_CURSE = 86,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_FREEZE_INPUT)
        TF_COND_FREEZE_INPUT = 87,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_HALLOWEEN_KART_CAGE)
        TF_COND_HALLOWEEN_KART_CAGE = 88,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_DONOTUSE_0)
        TF_COND_DONOTUSE_0 = 89,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_RUNE_STRENGTH)
        TF_COND_RUNE_STRENGTH = 90,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_RUNE_HASTE)
        TF_COND_RUNE_HASTE = 91,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_RUNE_REGEN)
        TF_COND_RUNE_REGEN = 92,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_RUNE_RESIST)
        TF_COND_RUNE_RESIST = 93,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_RUNE_VAMPIRE)
        TF_COND_RUNE_VAMPIRE = 94,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_RUNE_REFLECT)
        TF_COND_RUNE_REFLECT = 95,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_RUNE_PRECISION)
        TF_COND_RUNE_PRECISION = 96,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_RUNE_AGILITY)
        TF_COND_RUNE_AGILITY = 97,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_GRAPPLINGHOOK)
        TF_COND_GRAPPLINGHOOK = 98,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_GRAPPLINGHOOK_SAFEFALL)
        TF_COND_GRAPPLINGHOOK_SAFEFALL = 99,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_GRAPPLINGHOOK_LATCHED)
        TF_COND_GRAPPLINGHOOK_LATCHED = 100,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_GRAPPLINGHOOK_BLEEDING)
        TF_COND_GRAPPLINGHOOK_BLEEDING = 101,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_AFTERBURN_IMMUNE)
        TF_COND_AFTERBURN_IMMUNE = 102,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_RUNE_KNOCKOUT)
        TF_COND_RUNE_KNOCKOUT = 103,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_RUNE_IMBALANCE)
        TF_COND_RUNE_IMBALANCE = 104,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_CRITBOOSTED_RUNE_TEMP)
        TF_COND_CRITBOOSTED_RUNE_TEMP = 105,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_PASSTIME_INTERCEPTION)
        TF_COND_PASSTIME_INTERCEPTION = 106,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_SWIMMING_NO_EFFECTS)
        TF_COND_SWIMMING_NO_EFFECTS = 107,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_PURGATORY)
        TF_COND_PURGATORY = 108,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_RUNE_KING)
        TF_COND_RUNE_KING = 109,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_RUNE_PLAGUE)
        TF_COND_RUNE_PLAGUE = 110,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_RUNE_SUPERNOVA)
        TF_COND_RUNE_SUPERNOVA = 111,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_PLAGUE)
        TF_COND_PLAGUE = 112,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_KING_BUFFED)
        TF_COND_KING_BUFFED = 113,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_TEAM_GLOWS)
        TF_COND_TEAM_GLOWS = 114,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_KNOCKED_INTO_AIR)
        TF_COND_KNOCKED_INTO_AIR = 115,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_COMPETITIVE_WINNER)
        TF_COND_COMPETITIVE_WINNER = 116,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_COMPETITIVE_LOSER)
        TF_COND_COMPETITIVE_LOSER = 117,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_HEALING_DEBUFF)
        TF_COND_HEALING_DEBUFF = 118,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_PASSTIME_PENALTY_DEBUFF)
        TF_COND_PASSTIME_PENALTY_DEBUFF = 119,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_PARACHUTE_DEPLOYED)
        TF_COND_PARACHUTE_DEPLOYED = 120,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_NO_COMBAT_SPEED_BOOST)
        TF_COND_NO_COMBAT_SPEED_BOOST = 121,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_TRANQ_SPY_BOOST)
        TF_COND_TRANQ_SPY_BOOST = 122,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_TRANQ_MARKED)
        TF_COND_TRANQ_MARKED = 123,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_ROCKETPACK)
        TF_COND_ROCKETPACK = 126,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_ROCKETPACK_PASSENGER)
        TF_COND_ROCKETPACK_PASSENGER = 127,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_STEALTHED_PHASE)
        TF_COND_STEALTHED_PHASE = 128,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_CLIP_OVERLOAD)
        TF_COND_CLIP_OVERLOAD = 129,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_SPY_CLASS_STEAL)
        TF_COND_SPY_CLASS_STEAL = 130,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_GAS)
        TF_COND_GAS = 131,
    }

    impl ::protobuf::Enum for ETF2Conditions {
        const NAME: &'static str = "ETF2Conditions";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ETF2Conditions> {
            match value {
                0 => ::std::option::Option::Some(ETF2Conditions::TF_COND_AIMING),
                1 => ::std::option::Option::Some(ETF2Conditions::TF_COND_ZOOMED),
                2 => ::std::option::Option::Some(ETF2Conditions::TF_COND_DISGUISING),
                3 => ::std::option::Option::Some(ETF2Conditions::TF_COND_DISGUISED),
                4 => ::std::option::Option::Some(ETF2Conditions::TF_COND_STEALTHED),
                5 => ::std::option::Option::Some(ETF2Conditions::TF_COND_INVULNERABLE),
                6 => ::std::option::Option::Some(ETF2Conditions::TF_COND_TELEPORTED),
                7 => ::std::option::Option::Some(ETF2Conditions::TF_COND_TAUNTING),
                8 => ::std::option::Option::Some(ETF2Conditions::TF_COND_INVULNERABLE_WEARINGOFF),
                9 => ::std::option::Option::Some(ETF2Conditions::TF_COND_STEALTHED_BLINK),
                10 => ::std::option::Option::Some(ETF2Conditions::TF_COND_SELECTED_TO_TELEPORT),
                11 => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED),
                12 => ::std::option::Option::Some(ETF2Conditions::TF_COND_TMPDAMAGEBONUS),
                13 => ::std::option::Option::Some(ETF2Conditions::TF_COND_FEIGN_DEATH),
                14 => ::std::option::Option::Some(ETF2Conditions::TF_COND_PHASE),
                15 => ::std::option::Option::Some(ETF2Conditions::TF_COND_STUNNED),
                16 => ::std::option::Option::Some(ETF2Conditions::TF_COND_OFFENSEBUFF),
                17 => ::std::option::Option::Some(ETF2Conditions::TF_COND_SHIELD_CHARGE),
                18 => ::std::option::Option::Some(ETF2Conditions::TF_COND_DEMO_BUFF),
                19 => ::std::option::Option::Some(ETF2Conditions::TF_COND_ENERGY_BUFF),
                20 => ::std::option::Option::Some(ETF2Conditions::TF_COND_RADIUSHEAL),
                21 => ::std::option::Option::Some(ETF2Conditions::TF_COND_HEALTH_BUFF),
                22 => ::std::option::Option::Some(ETF2Conditions::TF_COND_BURNING),
                23 => ::std::option::Option::Some(ETF2Conditions::TF_COND_HEALTH_OVERHEALED),
                24 => ::std::option::Option::Some(ETF2Conditions::TF_COND_URINE),
                25 => ::std::option::Option::Some(ETF2Conditions::TF_COND_BLEEDING),
                26 => ::std::option::Option::Some(ETF2Conditions::TF_COND_DEFENSEBUFF),
                27 => ::std::option::Option::Some(ETF2Conditions::TF_COND_MAD_MILK),
                28 => ::std::option::Option::Some(ETF2Conditions::TF_COND_MEGAHEAL),
                29 => ::std::option::Option::Some(ETF2Conditions::TF_COND_REGENONDAMAGEBUFF),
                30 => ::std::option::Option::Some(ETF2Conditions::TF_COND_MARKEDFORDEATH),
                31 => ::std::option::Option::Some(ETF2Conditions::TF_COND_NOHEALINGDAMAGEBUFF),
                32 => ::std::option::Option::Some(ETF2Conditions::TF_COND_SPEED_BOOST),
                33 => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_PUMPKIN),
                34 => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_USER_BUFF),
                35 => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_DEMO_CHARGE),
                36 => ::std::option::Option::Some(ETF2Conditions::TF_COND_SODAPOPPER_HYPE),
                37 => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_FIRST_BLOOD),
                38 => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_BONUS_TIME),
                39 => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_CTF_CAPTURE),
                40 => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_ON_KILL),
                41 => ::std::option::Option::Some(ETF2Conditions::TF_COND_CANNOT_SWITCH_FROM_MELEE),
                42 => ::std::option::Option::Some(ETF2Conditions::TF_COND_DEFENSEBUFF_NO_CRIT_BLOCK),
                43 => ::std::option::Option::Some(ETF2Conditions::TF_COND_REPROGRAMMED),
                44 => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_RAGE_BUFF),
                45 => ::std::option::Option::Some(ETF2Conditions::TF_COND_DEFENSEBUFF_HIGH),
                46 => ::std::option::Option::Some(ETF2Conditions::TF_COND_SNIPERCHARGE_RAGE_BUFF),
                47 => ::std::option::Option::Some(ETF2Conditions::TF_COND_DISGUISE_WEARINGOFF),
                48 => ::std::option::Option::Some(ETF2Conditions::TF_COND_MARKEDFORDEATH_SILENT),
                49 => ::std::option::Option::Some(ETF2Conditions::TF_COND_DISGUISED_AS_DISPENSER),
                50 => ::std::option::Option::Some(ETF2Conditions::TF_COND_SAPPED),
                51 => ::std::option::Option::Some(ETF2Conditions::TF_COND_INVULNERABLE_HIDE_UNLESS_DAMAGED),
                52 => ::std::option::Option::Some(ETF2Conditions::TF_COND_INVULNERABLE_USER_BUFF),
                53 => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_BOMB_HEAD),
                54 => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_THRILLER),
                55 => ::std::option::Option::Some(ETF2Conditions::TF_COND_RADIUSHEAL_ON_DAMAGE),
                56 => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_CARD_EFFECT),
                57 => ::std::option::Option::Some(ETF2Conditions::TF_COND_INVULNERABLE_CARD_EFFECT),
                58 => ::std::option::Option::Some(ETF2Conditions::TF_COND_MEDIGUN_UBER_BULLET_RESIST),
                59 => ::std::option::Option::Some(ETF2Conditions::TF_COND_MEDIGUN_UBER_BLAST_RESIST),
                60 => ::std::option::Option::Some(ETF2Conditions::TF_COND_MEDIGUN_UBER_FIRE_RESIST),
                61 => ::std::option::Option::Some(ETF2Conditions::TF_COND_MEDIGUN_SMALL_BULLET_RESIST),
                62 => ::std::option::Option::Some(ETF2Conditions::TF_COND_MEDIGUN_SMALL_BLAST_RESIST),
                63 => ::std::option::Option::Some(ETF2Conditions::TF_COND_MEDIGUN_SMALL_FIRE_RESIST),
                64 => ::std::option::Option::Some(ETF2Conditions::TF_COND_STEALTHED_USER_BUFF),
                65 => ::std::option::Option::Some(ETF2Conditions::TF_COND_MEDIGUN_DEBUFF),
                66 => ::std::option::Option::Some(ETF2Conditions::TF_COND_STEALTHED_USER_BUFF_FADING),
                67 => ::std::option::Option::Some(ETF2Conditions::TF_COND_BULLET_IMMUNE),
                68 => ::std::option::Option::Some(ETF2Conditions::TF_COND_BLAST_IMMUNE),
                69 => ::std::option::Option::Some(ETF2Conditions::TF_COND_FIRE_IMMUNE),
                70 => ::std::option::Option::Some(ETF2Conditions::TF_COND_PREVENT_DEATH),
                71 => ::std::option::Option::Some(ETF2Conditions::TF_COND_MVM_BOT_STUN_RADIOWAVE),
                72 => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_SPEED_BOOST),
                73 => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_QUICK_HEAL),
                74 => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_GIANT),
                75 => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_TINY),
                76 => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_IN_HELL),
                77 => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_GHOST_MODE),
                78 => ::std::option::Option::Some(ETF2Conditions::TF_COND_MINICRITBOOSTED_ON_KILL),
                79 => ::std::option::Option::Some(ETF2Conditions::TF_COND_OBSCURED_SMOKE),
                80 => ::std::option::Option::Some(ETF2Conditions::TF_COND_PARACHUTE_ACTIVE),
                81 => ::std::option::Option::Some(ETF2Conditions::TF_COND_BLASTJUMPING),
                82 => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_KART),
                83 => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_KART_DASH),
                84 => ::std::option::Option::Some(ETF2Conditions::TF_COND_BALLOON_HEAD),
                85 => ::std::option::Option::Some(ETF2Conditions::TF_COND_MELEE_ONLY),
                86 => ::std::option::Option::Some(ETF2Conditions::TF_COND_SWIMMING_CURSE),
                87 => ::std::option::Option::Some(ETF2Conditions::TF_COND_FREEZE_INPUT),
                88 => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_KART_CAGE),
                89 => ::std::option::Option::Some(ETF2Conditions::TF_COND_DONOTUSE_0),
                90 => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_STRENGTH),
                91 => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_HASTE),
                92 => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_REGEN),
                93 => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_RESIST),
                94 => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_VAMPIRE),
                95 => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_REFLECT),
                96 => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_PRECISION),
                97 => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_AGILITY),
                98 => ::std::option::Option::Some(ETF2Conditions::TF_COND_GRAPPLINGHOOK),
                99 => ::std::option::Option::Some(ETF2Conditions::TF_COND_GRAPPLINGHOOK_SAFEFALL),
                100 => ::std::option::Option::Some(ETF2Conditions::TF_COND_GRAPPLINGHOOK_LATCHED),
                101 => ::std::option::Option::Some(ETF2Conditions::TF_COND_GRAPPLINGHOOK_BLEEDING),
                102 => ::std::option::Option::Some(ETF2Conditions::TF_COND_AFTERBURN_IMMUNE),
                103 => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_KNOCKOUT),
                104 => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_IMBALANCE),
                105 => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_RUNE_TEMP),
                106 => ::std::option::Option::Some(ETF2Conditions::TF_COND_PASSTIME_INTERCEPTION),
                107 => ::std::option::Option::Some(ETF2Conditions::TF_COND_SWIMMING_NO_EFFECTS),
                108 => ::std::option::Option::Some(ETF2Conditions::TF_COND_PURGATORY),
                109 => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_KING),
                110 => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_PLAGUE),
                111 => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_SUPERNOVA),
                112 => ::std::option::Option::Some(ETF2Conditions::TF_COND_PLAGUE),
                113 => ::std::option::Option::Some(ETF2Conditions::TF_COND_KING_BUFFED),
                114 => ::std::option::Option::Some(ETF2Conditions::TF_COND_TEAM_GLOWS),
                115 => ::std::option::Option::Some(ETF2Conditions::TF_COND_KNOCKED_INTO_AIR),
                116 => ::std::option::Option::Some(ETF2Conditions::TF_COND_COMPETITIVE_WINNER),
                117 => ::std::option::Option::Some(ETF2Conditions::TF_COND_COMPETITIVE_LOSER),
                118 => ::std::option::Option::Some(ETF2Conditions::TF_COND_HEALING_DEBUFF),
                119 => ::std::option::Option::Some(ETF2Conditions::TF_COND_PASSTIME_PENALTY_DEBUFF),
                120 => ::std::option::Option::Some(ETF2Conditions::TF_COND_PARACHUTE_DEPLOYED),
                121 => ::std::option::Option::Some(ETF2Conditions::TF_COND_NO_COMBAT_SPEED_BOOST),
                122 => ::std::option::Option::Some(ETF2Conditions::TF_COND_TRANQ_SPY_BOOST),
                123 => ::std::option::Option::Some(ETF2Conditions::TF_COND_TRANQ_MARKED),
                126 => ::std::option::Option::Some(ETF2Conditions::TF_COND_ROCKETPACK),
                127 => ::std::option::Option::Some(ETF2Conditions::TF_COND_ROCKETPACK_PASSENGER),
                128 => ::std::option::Option::Some(ETF2Conditions::TF_COND_STEALTHED_PHASE),
                129 => ::std::option::Option::Some(ETF2Conditions::TF_COND_CLIP_OVERLOAD),
                130 => ::std::option::Option::Some(ETF2Conditions::TF_COND_SPY_CLASS_STEAL),
                131 => ::std::option::Option::Some(ETF2Conditions::TF_COND_GAS),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ETF2Conditions> {
            match str {
                "TF_COND_AIMING" => ::std::option::Option::Some(ETF2Conditions::TF_COND_AIMING),
                "TF_COND_ZOOMED" => ::std::option::Option::Some(ETF2Conditions::TF_COND_ZOOMED),
                "TF_COND_DISGUISING" => ::std::option::Option::Some(ETF2Conditions::TF_COND_DISGUISING),
                "TF_COND_DISGUISED" => ::std::option::Option::Some(ETF2Conditions::TF_COND_DISGUISED),
                "TF_COND_STEALTHED" => ::std::option::Option::Some(ETF2Conditions::TF_COND_STEALTHED),
                "TF_COND_INVULNERABLE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_INVULNERABLE),
                "TF_COND_TELEPORTED" => ::std::option::Option::Some(ETF2Conditions::TF_COND_TELEPORTED),
                "TF_COND_TAUNTING" => ::std::option::Option::Some(ETF2Conditions::TF_COND_TAUNTING),
                "TF_COND_INVULNERABLE_WEARINGOFF" => ::std::option::Option::Some(ETF2Conditions::TF_COND_INVULNERABLE_WEARINGOFF),
                "TF_COND_STEALTHED_BLINK" => ::std::option::Option::Some(ETF2Conditions::TF_COND_STEALTHED_BLINK),
                "TF_COND_SELECTED_TO_TELEPORT" => ::std::option::Option::Some(ETF2Conditions::TF_COND_SELECTED_TO_TELEPORT),
                "TF_COND_CRITBOOSTED" => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED),
                "TF_COND_TMPDAMAGEBONUS" => ::std::option::Option::Some(ETF2Conditions::TF_COND_TMPDAMAGEBONUS),
                "TF_COND_FEIGN_DEATH" => ::std::option::Option::Some(ETF2Conditions::TF_COND_FEIGN_DEATH),
                "TF_COND_PHASE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_PHASE),
                "TF_COND_STUNNED" => ::std::option::Option::Some(ETF2Conditions::TF_COND_STUNNED),
                "TF_COND_OFFENSEBUFF" => ::std::option::Option::Some(ETF2Conditions::TF_COND_OFFENSEBUFF),
                "TF_COND_SHIELD_CHARGE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_SHIELD_CHARGE),
                "TF_COND_DEMO_BUFF" => ::std::option::Option::Some(ETF2Conditions::TF_COND_DEMO_BUFF),
                "TF_COND_ENERGY_BUFF" => ::std::option::Option::Some(ETF2Conditions::TF_COND_ENERGY_BUFF),
                "TF_COND_RADIUSHEAL" => ::std::option::Option::Some(ETF2Conditions::TF_COND_RADIUSHEAL),
                "TF_COND_HEALTH_BUFF" => ::std::option::Option::Some(ETF2Conditions::TF_COND_HEALTH_BUFF),
                "TF_COND_BURNING" => ::std::option::Option::Some(ETF2Conditions::TF_COND_BURNING),
                "TF_COND_HEALTH_OVERHEALED" => ::std::option::Option::Some(ETF2Conditions::TF_COND_HEALTH_OVERHEALED),
                "TF_COND_URINE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_URINE),
                "TF_COND_BLEEDING" => ::std::option::Option::Some(ETF2Conditions::TF_COND_BLEEDING),
                "TF_COND_DEFENSEBUFF" => ::std::option::Option::Some(ETF2Conditions::TF_COND_DEFENSEBUFF),
                "TF_COND_MAD_MILK" => ::std::option::Option::Some(ETF2Conditions::TF_COND_MAD_MILK),
                "TF_COND_MEGAHEAL" => ::std::option::Option::Some(ETF2Conditions::TF_COND_MEGAHEAL),
                "TF_COND_REGENONDAMAGEBUFF" => ::std::option::Option::Some(ETF2Conditions::TF_COND_REGENONDAMAGEBUFF),
                "TF_COND_MARKEDFORDEATH" => ::std::option::Option::Some(ETF2Conditions::TF_COND_MARKEDFORDEATH),
                "TF_COND_NOHEALINGDAMAGEBUFF" => ::std::option::Option::Some(ETF2Conditions::TF_COND_NOHEALINGDAMAGEBUFF),
                "TF_COND_SPEED_BOOST" => ::std::option::Option::Some(ETF2Conditions::TF_COND_SPEED_BOOST),
                "TF_COND_CRITBOOSTED_PUMPKIN" => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_PUMPKIN),
                "TF_COND_CRITBOOSTED_USER_BUFF" => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_USER_BUFF),
                "TF_COND_CRITBOOSTED_DEMO_CHARGE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_DEMO_CHARGE),
                "TF_COND_SODAPOPPER_HYPE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_SODAPOPPER_HYPE),
                "TF_COND_CRITBOOSTED_FIRST_BLOOD" => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_FIRST_BLOOD),
                "TF_COND_CRITBOOSTED_BONUS_TIME" => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_BONUS_TIME),
                "TF_COND_CRITBOOSTED_CTF_CAPTURE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_CTF_CAPTURE),
                "TF_COND_CRITBOOSTED_ON_KILL" => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_ON_KILL),
                "TF_COND_CANNOT_SWITCH_FROM_MELEE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_CANNOT_SWITCH_FROM_MELEE),
                "TF_COND_DEFENSEBUFF_NO_CRIT_BLOCK" => ::std::option::Option::Some(ETF2Conditions::TF_COND_DEFENSEBUFF_NO_CRIT_BLOCK),
                "TF_COND_REPROGRAMMED" => ::std::option::Option::Some(ETF2Conditions::TF_COND_REPROGRAMMED),
                "TF_COND_CRITBOOSTED_RAGE_BUFF" => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_RAGE_BUFF),
                "TF_COND_DEFENSEBUFF_HIGH" => ::std::option::Option::Some(ETF2Conditions::TF_COND_DEFENSEBUFF_HIGH),
                "TF_COND_SNIPERCHARGE_RAGE_BUFF" => ::std::option::Option::Some(ETF2Conditions::TF_COND_SNIPERCHARGE_RAGE_BUFF),
                "TF_COND_DISGUISE_WEARINGOFF" => ::std::option::Option::Some(ETF2Conditions::TF_COND_DISGUISE_WEARINGOFF),
                "TF_COND_MARKEDFORDEATH_SILENT" => ::std::option::Option::Some(ETF2Conditions::TF_COND_MARKEDFORDEATH_SILENT),
                "TF_COND_DISGUISED_AS_DISPENSER" => ::std::option::Option::Some(ETF2Conditions::TF_COND_DISGUISED_AS_DISPENSER),
                "TF_COND_SAPPED" => ::std::option::Option::Some(ETF2Conditions::TF_COND_SAPPED),
                "TF_COND_INVULNERABLE_HIDE_UNLESS_DAMAGED" => ::std::option::Option::Some(ETF2Conditions::TF_COND_INVULNERABLE_HIDE_UNLESS_DAMAGED),
                "TF_COND_INVULNERABLE_USER_BUFF" => ::std::option::Option::Some(ETF2Conditions::TF_COND_INVULNERABLE_USER_BUFF),
                "TF_COND_HALLOWEEN_BOMB_HEAD" => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_BOMB_HEAD),
                "TF_COND_HALLOWEEN_THRILLER" => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_THRILLER),
                "TF_COND_RADIUSHEAL_ON_DAMAGE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_RADIUSHEAL_ON_DAMAGE),
                "TF_COND_CRITBOOSTED_CARD_EFFECT" => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_CARD_EFFECT),
                "TF_COND_INVULNERABLE_CARD_EFFECT" => ::std::option::Option::Some(ETF2Conditions::TF_COND_INVULNERABLE_CARD_EFFECT),
                "TF_COND_MEDIGUN_UBER_BULLET_RESIST" => ::std::option::Option::Some(ETF2Conditions::TF_COND_MEDIGUN_UBER_BULLET_RESIST),
                "TF_COND_MEDIGUN_UBER_BLAST_RESIST" => ::std::option::Option::Some(ETF2Conditions::TF_COND_MEDIGUN_UBER_BLAST_RESIST),
                "TF_COND_MEDIGUN_UBER_FIRE_RESIST" => ::std::option::Option::Some(ETF2Conditions::TF_COND_MEDIGUN_UBER_FIRE_RESIST),
                "TF_COND_MEDIGUN_SMALL_BULLET_RESIST" => ::std::option::Option::Some(ETF2Conditions::TF_COND_MEDIGUN_SMALL_BULLET_RESIST),
                "TF_COND_MEDIGUN_SMALL_BLAST_RESIST" => ::std::option::Option::Some(ETF2Conditions::TF_COND_MEDIGUN_SMALL_BLAST_RESIST),
                "TF_COND_MEDIGUN_SMALL_FIRE_RESIST" => ::std::option::Option::Some(ETF2Conditions::TF_COND_MEDIGUN_SMALL_FIRE_RESIST),
                "TF_COND_STEALTHED_USER_BUFF" => ::std::option::Option::Some(ETF2Conditions::TF_COND_STEALTHED_USER_BUFF),
                "TF_COND_MEDIGUN_DEBUFF" => ::std::option::Option::Some(ETF2Conditions::TF_COND_MEDIGUN_DEBUFF),
                "TF_COND_STEALTHED_USER_BUFF_FADING" => ::std::option::Option::Some(ETF2Conditions::TF_COND_STEALTHED_USER_BUFF_FADING),
                "TF_COND_BULLET_IMMUNE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_BULLET_IMMUNE),
                "TF_COND_BLAST_IMMUNE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_BLAST_IMMUNE),
                "TF_COND_FIRE_IMMUNE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_FIRE_IMMUNE),
                "TF_COND_PREVENT_DEATH" => ::std::option::Option::Some(ETF2Conditions::TF_COND_PREVENT_DEATH),
                "TF_COND_MVM_BOT_STUN_RADIOWAVE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_MVM_BOT_STUN_RADIOWAVE),
                "TF_COND_HALLOWEEN_SPEED_BOOST" => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_SPEED_BOOST),
                "TF_COND_HALLOWEEN_QUICK_HEAL" => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_QUICK_HEAL),
                "TF_COND_HALLOWEEN_GIANT" => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_GIANT),
                "TF_COND_HALLOWEEN_TINY" => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_TINY),
                "TF_COND_HALLOWEEN_IN_HELL" => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_IN_HELL),
                "TF_COND_HALLOWEEN_GHOST_MODE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_GHOST_MODE),
                "TF_COND_MINICRITBOOSTED_ON_KILL" => ::std::option::Option::Some(ETF2Conditions::TF_COND_MINICRITBOOSTED_ON_KILL),
                "TF_COND_OBSCURED_SMOKE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_OBSCURED_SMOKE),
                "TF_COND_PARACHUTE_ACTIVE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_PARACHUTE_ACTIVE),
                "TF_COND_BLASTJUMPING" => ::std::option::Option::Some(ETF2Conditions::TF_COND_BLASTJUMPING),
                "TF_COND_HALLOWEEN_KART" => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_KART),
                "TF_COND_HALLOWEEN_KART_DASH" => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_KART_DASH),
                "TF_COND_BALLOON_HEAD" => ::std::option::Option::Some(ETF2Conditions::TF_COND_BALLOON_HEAD),
                "TF_COND_MELEE_ONLY" => ::std::option::Option::Some(ETF2Conditions::TF_COND_MELEE_ONLY),
                "TF_COND_SWIMMING_CURSE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_SWIMMING_CURSE),
                "TF_COND_FREEZE_INPUT" => ::std::option::Option::Some(ETF2Conditions::TF_COND_FREEZE_INPUT),
                "TF_COND_HALLOWEEN_KART_CAGE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_KART_CAGE),
                "TF_COND_DONOTUSE_0" => ::std::option::Option::Some(ETF2Conditions::TF_COND_DONOTUSE_0),
                "TF_COND_RUNE_STRENGTH" => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_STRENGTH),
                "TF_COND_RUNE_HASTE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_HASTE),
                "TF_COND_RUNE_REGEN" => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_REGEN),
                "TF_COND_RUNE_RESIST" => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_RESIST),
                "TF_COND_RUNE_VAMPIRE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_VAMPIRE),
                "TF_COND_RUNE_REFLECT" => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_REFLECT),
                "TF_COND_RUNE_PRECISION" => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_PRECISION),
                "TF_COND_RUNE_AGILITY" => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_AGILITY),
                "TF_COND_GRAPPLINGHOOK" => ::std::option::Option::Some(ETF2Conditions::TF_COND_GRAPPLINGHOOK),
                "TF_COND_GRAPPLINGHOOK_SAFEFALL" => ::std::option::Option::Some(ETF2Conditions::TF_COND_GRAPPLINGHOOK_SAFEFALL),
                "TF_COND_GRAPPLINGHOOK_LATCHED" => ::std::option::Option::Some(ETF2Conditions::TF_COND_GRAPPLINGHOOK_LATCHED),
                "TF_COND_GRAPPLINGHOOK_BLEEDING" => ::std::option::Option::Some(ETF2Conditions::TF_COND_GRAPPLINGHOOK_BLEEDING),
                "TF_COND_AFTERBURN_IMMUNE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_AFTERBURN_IMMUNE),
                "TF_COND_RUNE_KNOCKOUT" => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_KNOCKOUT),
                "TF_COND_RUNE_IMBALANCE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_IMBALANCE),
                "TF_COND_CRITBOOSTED_RUNE_TEMP" => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_RUNE_TEMP),
                "TF_COND_PASSTIME_INTERCEPTION" => ::std::option::Option::Some(ETF2Conditions::TF_COND_PASSTIME_INTERCEPTION),
                "TF_COND_SWIMMING_NO_EFFECTS" => ::std::option::Option::Some(ETF2Conditions::TF_COND_SWIMMING_NO_EFFECTS),
                "TF_COND_PURGATORY" => ::std::option::Option::Some(ETF2Conditions::TF_COND_PURGATORY),
                "TF_COND_RUNE_KING" => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_KING),
                "TF_COND_RUNE_PLAGUE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_PLAGUE),
                "TF_COND_RUNE_SUPERNOVA" => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_SUPERNOVA),
                "TF_COND_PLAGUE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_PLAGUE),
                "TF_COND_KING_BUFFED" => ::std::option::Option::Some(ETF2Conditions::TF_COND_KING_BUFFED),
                "TF_COND_TEAM_GLOWS" => ::std::option::Option::Some(ETF2Conditions::TF_COND_TEAM_GLOWS),
                "TF_COND_KNOCKED_INTO_AIR" => ::std::option::Option::Some(ETF2Conditions::TF_COND_KNOCKED_INTO_AIR),
                "TF_COND_COMPETITIVE_WINNER" => ::std::option::Option::Some(ETF2Conditions::TF_COND_COMPETITIVE_WINNER),
                "TF_COND_COMPETITIVE_LOSER" => ::std::option::Option::Some(ETF2Conditions::TF_COND_COMPETITIVE_LOSER),
                "TF_COND_HEALING_DEBUFF" => ::std::option::Option::Some(ETF2Conditions::TF_COND_HEALING_DEBUFF),
                "TF_COND_PASSTIME_PENALTY_DEBUFF" => ::std::option::Option::Some(ETF2Conditions::TF_COND_PASSTIME_PENALTY_DEBUFF),
                "TF_COND_PARACHUTE_DEPLOYED" => ::std::option::Option::Some(ETF2Conditions::TF_COND_PARACHUTE_DEPLOYED),
                "TF_COND_NO_COMBAT_SPEED_BOOST" => ::std::option::Option::Some(ETF2Conditions::TF_COND_NO_COMBAT_SPEED_BOOST),
                "TF_COND_TRANQ_SPY_BOOST" => ::std::option::Option::Some(ETF2Conditions::TF_COND_TRANQ_SPY_BOOST),
                "TF_COND_TRANQ_MARKED" => ::std::option::Option::Some(ETF2Conditions::TF_COND_TRANQ_MARKED),
                "TF_COND_ROCKETPACK" => ::std::option::Option::Some(ETF2Conditions::TF_COND_ROCKETPACK),
                "TF_COND_ROCKETPACK_PASSENGER" => ::std::option::Option::Some(ETF2Conditions::TF_COND_ROCKETPACK_PASSENGER),
                "TF_COND_STEALTHED_PHASE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_STEALTHED_PHASE),
                "TF_COND_CLIP_OVERLOAD" => ::std::option::Option::Some(ETF2Conditions::TF_COND_CLIP_OVERLOAD),
                "TF_COND_SPY_CLASS_STEAL" => ::std::option::Option::Some(ETF2Conditions::TF_COND_SPY_CLASS_STEAL),
                "TF_COND_GAS" => ::std::option::Option::Some(ETF2Conditions::TF_COND_GAS),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ETF2Conditions] = &[
            ETF2Conditions::TF_COND_AIMING,
            ETF2Conditions::TF_COND_ZOOMED,
            ETF2Conditions::TF_COND_DISGUISING,
            ETF2Conditions::TF_COND_DISGUISED,
            ETF2Conditions::TF_COND_STEALTHED,
            ETF2Conditions::TF_COND_INVULNERABLE,
            ETF2Conditions::TF_COND_TELEPORTED,
            ETF2Conditions::TF_COND_TAUNTING,
            ETF2Conditions::TF_COND_INVULNERABLE_WEARINGOFF,
            ETF2Conditions::TF_COND_STEALTHED_BLINK,
            ETF2Conditions::TF_COND_SELECTED_TO_TELEPORT,
            ETF2Conditions::TF_COND_CRITBOOSTED,
            ETF2Conditions::TF_COND_TMPDAMAGEBONUS,
            ETF2Conditions::TF_COND_FEIGN_DEATH,
            ETF2Conditions::TF_COND_PHASE,
            ETF2Conditions::TF_COND_STUNNED,
            ETF2Conditions::TF_COND_OFFENSEBUFF,
            ETF2Conditions::TF_COND_SHIELD_CHARGE,
            ETF2Conditions::TF_COND_DEMO_BUFF,
            ETF2Conditions::TF_COND_ENERGY_BUFF,
            ETF2Conditions::TF_COND_RADIUSHEAL,
            ETF2Conditions::TF_COND_HEALTH_BUFF,
            ETF2Conditions::TF_COND_BURNING,
            ETF2Conditions::TF_COND_HEALTH_OVERHEALED,
            ETF2Conditions::TF_COND_URINE,
            ETF2Conditions::TF_COND_BLEEDING,
            ETF2Conditions::TF_COND_DEFENSEBUFF,
            ETF2Conditions::TF_COND_MAD_MILK,
            ETF2Conditions::TF_COND_MEGAHEAL,
            ETF2Conditions::TF_COND_REGENONDAMAGEBUFF,
            ETF2Conditions::TF_COND_MARKEDFORDEATH,
            ETF2Conditions::TF_COND_NOHEALINGDAMAGEBUFF,
            ETF2Conditions::TF_COND_SPEED_BOOST,
            ETF2Conditions::TF_COND_CRITBOOSTED_PUMPKIN,
            ETF2Conditions::TF_COND_CRITBOOSTED_USER_BUFF,
            ETF2Conditions::TF_COND_CRITBOOSTED_DEMO_CHARGE,
            ETF2Conditions::TF_COND_SODAPOPPER_HYPE,
            ETF2Conditions::TF_COND_CRITBOOSTED_FIRST_BLOOD,
            ETF2Conditions::TF_COND_CRITBOOSTED_BONUS_TIME,
            ETF2Conditions::TF_COND_CRITBOOSTED_CTF_CAPTURE,
            ETF2Conditions::TF_COND_CRITBOOSTED_ON_KILL,
            ETF2Conditions::TF_COND_CANNOT_SWITCH_FROM_MELEE,
            ETF2Conditions::TF_COND_DEFENSEBUFF_NO_CRIT_BLOCK,
            ETF2Conditions::TF_COND_REPROGRAMMED,
            ETF2Conditions::TF_COND_CRITBOOSTED_RAGE_BUFF,
            ETF2Conditions::TF_COND_DEFENSEBUFF_HIGH,
            ETF2Conditions::TF_COND_SNIPERCHARGE_RAGE_BUFF,
            ETF2Conditions::TF_COND_DISGUISE_WEARINGOFF,
            ETF2Conditions::TF_COND_MARKEDFORDEATH_SILENT,
            ETF2Conditions::TF_COND_DISGUISED_AS_DISPENSER,
            ETF2Conditions::TF_COND_SAPPED,
            ETF2Conditions::TF_COND_INVULNERABLE_HIDE_UNLESS_DAMAGED,
            ETF2Conditions::TF_COND_INVULNERABLE_USER_BUFF,
            ETF2Conditions::TF_COND_HALLOWEEN_BOMB_HEAD,
            ETF2Conditions::TF_COND_HALLOWEEN_THRILLER,
            ETF2Conditions::TF_COND_RADIUSHEAL_ON_DAMAGE,
            ETF2Conditions::TF_COND_CRITBOOSTED_CARD_EFFECT,
            ETF2Conditions::TF_COND_INVULNERABLE_CARD_EFFECT,
            ETF2Conditions::TF_COND_MEDIGUN_UBER_BULLET_RESIST,
            ETF2Conditions::TF_COND_MEDIGUN_UBER_BLAST_RESIST,
            ETF2Conditions::TF_COND_MEDIGUN_UBER_FIRE_RESIST,
            ETF2Conditions::TF_COND_MEDIGUN_SMALL_BULLET_RESIST,
            ETF2Conditions::TF_COND_MEDIGUN_SMALL_BLAST_RESIST,
            ETF2Conditions::TF_COND_MEDIGUN_SMALL_FIRE_RESIST,
            ETF2Conditions::TF_COND_STEALTHED_USER_BUFF,
            ETF2Conditions::TF_COND_MEDIGUN_DEBUFF,
            ETF2Conditions::TF_COND_STEALTHED_USER_BUFF_FADING,
            ETF2Conditions::TF_COND_BULLET_IMMUNE,
            ETF2Conditions::TF_COND_BLAST_IMMUNE,
            ETF2Conditions::TF_COND_FIRE_IMMUNE,
            ETF2Conditions::TF_COND_PREVENT_DEATH,
            ETF2Conditions::TF_COND_MVM_BOT_STUN_RADIOWAVE,
            ETF2Conditions::TF_COND_HALLOWEEN_SPEED_BOOST,
            ETF2Conditions::TF_COND_HALLOWEEN_QUICK_HEAL,
            ETF2Conditions::TF_COND_HALLOWEEN_GIANT,
            ETF2Conditions::TF_COND_HALLOWEEN_TINY,
            ETF2Conditions::TF_COND_HALLOWEEN_IN_HELL,
            ETF2Conditions::TF_COND_HALLOWEEN_GHOST_MODE,
            ETF2Conditions::TF_COND_MINICRITBOOSTED_ON_KILL,
            ETF2Conditions::TF_COND_OBSCURED_SMOKE,
            ETF2Conditions::TF_COND_PARACHUTE_ACTIVE,
            ETF2Conditions::TF_COND_BLASTJUMPING,
            ETF2Conditions::TF_COND_HALLOWEEN_KART,
            ETF2Conditions::TF_COND_HALLOWEEN_KART_DASH,
            ETF2Conditions::TF_COND_BALLOON_HEAD,
            ETF2Conditions::TF_COND_MELEE_ONLY,
            ETF2Conditions::TF_COND_SWIMMING_CURSE,
            ETF2Conditions::TF_COND_FREEZE_INPUT,
            ETF2Conditions::TF_COND_HALLOWEEN_KART_CAGE,
            ETF2Conditions::TF_COND_DONOTUSE_0,
            ETF2Conditions::TF_COND_RUNE_STRENGTH,
            ETF2Conditions::TF_COND_RUNE_HASTE,
            ETF2Conditions::TF_COND_RUNE_REGEN,
            ETF2Conditions::TF_COND_RUNE_RESIST,
            ETF2Conditions::TF_COND_RUNE_VAMPIRE,
            ETF2Conditions::TF_COND_RUNE_REFLECT,
            ETF2Conditions::TF_COND_RUNE_PRECISION,
            ETF2Conditions::TF_COND_RUNE_AGILITY,
            ETF2Conditions::TF_COND_GRAPPLINGHOOK,
            ETF2Conditions::TF_COND_GRAPPLINGHOOK_SAFEFALL,
            ETF2Conditions::TF_COND_GRAPPLINGHOOK_LATCHED,
            ETF2Conditions::TF_COND_GRAPPLINGHOOK_BLEEDING,
            ETF2Conditions::TF_COND_AFTERBURN_IMMUNE,
            ETF2Conditions::TF_COND_RUNE_KNOCKOUT,
            ETF2Conditions::TF_COND_RUNE_IMBALANCE,
            ETF2Conditions::TF_COND_CRITBOOSTED_RUNE_TEMP,
            ETF2Conditions::TF_COND_PASSTIME_INTERCEPTION,
            ETF2Conditions::TF_COND_SWIMMING_NO_EFFECTS,
            ETF2Conditions::TF_COND_PURGATORY,
            ETF2Conditions::TF_COND_RUNE_KING,
            ETF2Conditions::TF_COND_RUNE_PLAGUE,
            ETF2Conditions::TF_COND_RUNE_SUPERNOVA,
            ETF2Conditions::TF_COND_PLAGUE,
            ETF2Conditions::TF_COND_KING_BUFFED,
            ETF2Conditions::TF_COND_TEAM_GLOWS,
            ETF2Conditions::TF_COND_KNOCKED_INTO_AIR,
            ETF2Conditions::TF_COND_COMPETITIVE_WINNER,
            ETF2Conditions::TF_COND_COMPETITIVE_LOSER,
            ETF2Conditions::TF_COND_HEALING_DEBUFF,
            ETF2Conditions::TF_COND_PASSTIME_PENALTY_DEBUFF,
            ETF2Conditions::TF_COND_PARACHUTE_DEPLOYED,
            ETF2Conditions::TF_COND_NO_COMBAT_SPEED_BOOST,
            ETF2Conditions::TF_COND_TRANQ_SPY_BOOST,
            ETF2Conditions::TF_COND_TRANQ_MARKED,
            ETF2Conditions::TF_COND_ROCKETPACK,
            ETF2Conditions::TF_COND_ROCKETPACK_PASSENGER,
            ETF2Conditions::TF_COND_STEALTHED_PHASE,
            ETF2Conditions::TF_COND_CLIP_OVERLOAD,
            ETF2Conditions::TF_COND_SPY_CLASS_STEAL,
            ETF2Conditions::TF_COND_GAS,
        ];
    }

    impl ::protobuf::EnumFull for ETF2Conditions {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgQuestObjectiveDef.ETF2Conditions").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                ETF2Conditions::TF_COND_AIMING => 0,
                ETF2Conditions::TF_COND_ZOOMED => 1,
                ETF2Conditions::TF_COND_DISGUISING => 2,
                ETF2Conditions::TF_COND_DISGUISED => 3,
                ETF2Conditions::TF_COND_STEALTHED => 4,
                ETF2Conditions::TF_COND_INVULNERABLE => 5,
                ETF2Conditions::TF_COND_TELEPORTED => 6,
                ETF2Conditions::TF_COND_TAUNTING => 7,
                ETF2Conditions::TF_COND_INVULNERABLE_WEARINGOFF => 8,
                ETF2Conditions::TF_COND_STEALTHED_BLINK => 9,
                ETF2Conditions::TF_COND_SELECTED_TO_TELEPORT => 10,
                ETF2Conditions::TF_COND_CRITBOOSTED => 11,
                ETF2Conditions::TF_COND_TMPDAMAGEBONUS => 12,
                ETF2Conditions::TF_COND_FEIGN_DEATH => 13,
                ETF2Conditions::TF_COND_PHASE => 14,
                ETF2Conditions::TF_COND_STUNNED => 15,
                ETF2Conditions::TF_COND_OFFENSEBUFF => 16,
                ETF2Conditions::TF_COND_SHIELD_CHARGE => 17,
                ETF2Conditions::TF_COND_DEMO_BUFF => 18,
                ETF2Conditions::TF_COND_ENERGY_BUFF => 19,
                ETF2Conditions::TF_COND_RADIUSHEAL => 20,
                ETF2Conditions::TF_COND_HEALTH_BUFF => 21,
                ETF2Conditions::TF_COND_BURNING => 22,
                ETF2Conditions::TF_COND_HEALTH_OVERHEALED => 23,
                ETF2Conditions::TF_COND_URINE => 24,
                ETF2Conditions::TF_COND_BLEEDING => 25,
                ETF2Conditions::TF_COND_DEFENSEBUFF => 26,
                ETF2Conditions::TF_COND_MAD_MILK => 27,
                ETF2Conditions::TF_COND_MEGAHEAL => 28,
                ETF2Conditions::TF_COND_REGENONDAMAGEBUFF => 29,
                ETF2Conditions::TF_COND_MARKEDFORDEATH => 30,
                ETF2Conditions::TF_COND_NOHEALINGDAMAGEBUFF => 31,
                ETF2Conditions::TF_COND_SPEED_BOOST => 32,
                ETF2Conditions::TF_COND_CRITBOOSTED_PUMPKIN => 33,
                ETF2Conditions::TF_COND_CRITBOOSTED_USER_BUFF => 34,
                ETF2Conditions::TF_COND_CRITBOOSTED_DEMO_CHARGE => 35,
                ETF2Conditions::TF_COND_SODAPOPPER_HYPE => 36,
                ETF2Conditions::TF_COND_CRITBOOSTED_FIRST_BLOOD => 37,
                ETF2Conditions::TF_COND_CRITBOOSTED_BONUS_TIME => 38,
                ETF2Conditions::TF_COND_CRITBOOSTED_CTF_CAPTURE => 39,
                ETF2Conditions::TF_COND_CRITBOOSTED_ON_KILL => 40,
                ETF2Conditions::TF_COND_CANNOT_SWITCH_FROM_MELEE => 41,
                ETF2Conditions::TF_COND_DEFENSEBUFF_NO_CRIT_BLOCK => 42,
                ETF2Conditions::TF_COND_REPROGRAMMED => 43,
                ETF2Conditions::TF_COND_CRITBOOSTED_RAGE_BUFF => 44,
                ETF2Conditions::TF_COND_DEFENSEBUFF_HIGH => 45,
                ETF2Conditions::TF_COND_SNIPERCHARGE_RAGE_BUFF => 46,
                ETF2Conditions::TF_COND_DISGUISE_WEARINGOFF => 47,
                ETF2Conditions::TF_COND_MARKEDFORDEATH_SILENT => 48,
                ETF2Conditions::TF_COND_DISGUISED_AS_DISPENSER => 49,
                ETF2Conditions::TF_COND_SAPPED => 50,
                ETF2Conditions::TF_COND_INVULNERABLE_HIDE_UNLESS_DAMAGED => 51,
                ETF2Conditions::TF_COND_INVULNERABLE_USER_BUFF => 52,
                ETF2Conditions::TF_COND_HALLOWEEN_BOMB_HEAD => 53,
                ETF2Conditions::TF_COND_HALLOWEEN_THRILLER => 54,
                ETF2Conditions::TF_COND_RADIUSHEAL_ON_DAMAGE => 55,
                ETF2Conditions::TF_COND_CRITBOOSTED_CARD_EFFECT => 56,
                ETF2Conditions::TF_COND_INVULNERABLE_CARD_EFFECT => 57,
                ETF2Conditions::TF_COND_MEDIGUN_UBER_BULLET_RESIST => 58,
                ETF2Conditions::TF_COND_MEDIGUN_UBER_BLAST_RESIST => 59,
                ETF2Conditions::TF_COND_MEDIGUN_UBER_FIRE_RESIST => 60,
                ETF2Conditions::TF_COND_MEDIGUN_SMALL_BULLET_RESIST => 61,
                ETF2Conditions::TF_COND_MEDIGUN_SMALL_BLAST_RESIST => 62,
                ETF2Conditions::TF_COND_MEDIGUN_SMALL_FIRE_RESIST => 63,
                ETF2Conditions::TF_COND_STEALTHED_USER_BUFF => 64,
                ETF2Conditions::TF_COND_MEDIGUN_DEBUFF => 65,
                ETF2Conditions::TF_COND_STEALTHED_USER_BUFF_FADING => 66,
                ETF2Conditions::TF_COND_BULLET_IMMUNE => 67,
                ETF2Conditions::TF_COND_BLAST_IMMUNE => 68,
                ETF2Conditions::TF_COND_FIRE_IMMUNE => 69,
                ETF2Conditions::TF_COND_PREVENT_DEATH => 70,
                ETF2Conditions::TF_COND_MVM_BOT_STUN_RADIOWAVE => 71,
                ETF2Conditions::TF_COND_HALLOWEEN_SPEED_BOOST => 72,
                ETF2Conditions::TF_COND_HALLOWEEN_QUICK_HEAL => 73,
                ETF2Conditions::TF_COND_HALLOWEEN_GIANT => 74,
                ETF2Conditions::TF_COND_HALLOWEEN_TINY => 75,
                ETF2Conditions::TF_COND_HALLOWEEN_IN_HELL => 76,
                ETF2Conditions::TF_COND_HALLOWEEN_GHOST_MODE => 77,
                ETF2Conditions::TF_COND_MINICRITBOOSTED_ON_KILL => 78,
                ETF2Conditions::TF_COND_OBSCURED_SMOKE => 79,
                ETF2Conditions::TF_COND_PARACHUTE_ACTIVE => 80,
                ETF2Conditions::TF_COND_BLASTJUMPING => 81,
                ETF2Conditions::TF_COND_HALLOWEEN_KART => 82,
                ETF2Conditions::TF_COND_HALLOWEEN_KART_DASH => 83,
                ETF2Conditions::TF_COND_BALLOON_HEAD => 84,
                ETF2Conditions::TF_COND_MELEE_ONLY => 85,
                ETF2Conditions::TF_COND_SWIMMING_CURSE => 86,
                ETF2Conditions::TF_COND_FREEZE_INPUT => 87,
                ETF2Conditions::TF_COND_HALLOWEEN_KART_CAGE => 88,
                ETF2Conditions::TF_COND_DONOTUSE_0 => 89,
                ETF2Conditions::TF_COND_RUNE_STRENGTH => 90,
                ETF2Conditions::TF_COND_RUNE_HASTE => 91,
                ETF2Conditions::TF_COND_RUNE_REGEN => 92,
                ETF2Conditions::TF_COND_RUNE_RESIST => 93,
                ETF2Conditions::TF_COND_RUNE_VAMPIRE => 94,
                ETF2Conditions::TF_COND_RUNE_REFLECT => 95,
                ETF2Conditions::TF_COND_RUNE_PRECISION => 96,
                ETF2Conditions::TF_COND_RUNE_AGILITY => 97,
                ETF2Conditions::TF_COND_GRAPPLINGHOOK => 98,
                ETF2Conditions::TF_COND_GRAPPLINGHOOK_SAFEFALL => 99,
                ETF2Conditions::TF_COND_GRAPPLINGHOOK_LATCHED => 100,
                ETF2Conditions::TF_COND_GRAPPLINGHOOK_BLEEDING => 101,
                ETF2Conditions::TF_COND_AFTERBURN_IMMUNE => 102,
                ETF2Conditions::TF_COND_RUNE_KNOCKOUT => 103,
                ETF2Conditions::TF_COND_RUNE_IMBALANCE => 104,
                ETF2Conditions::TF_COND_CRITBOOSTED_RUNE_TEMP => 105,
                ETF2Conditions::TF_COND_PASSTIME_INTERCEPTION => 106,
                ETF2Conditions::TF_COND_SWIMMING_NO_EFFECTS => 107,
                ETF2Conditions::TF_COND_PURGATORY => 108,
                ETF2Conditions::TF_COND_RUNE_KING => 109,
                ETF2Conditions::TF_COND_RUNE_PLAGUE => 110,
                ETF2Conditions::TF_COND_RUNE_SUPERNOVA => 111,
                ETF2Conditions::TF_COND_PLAGUE => 112,
                ETF2Conditions::TF_COND_KING_BUFFED => 113,
                ETF2Conditions::TF_COND_TEAM_GLOWS => 114,
                ETF2Conditions::TF_COND_KNOCKED_INTO_AIR => 115,
                ETF2Conditions::TF_COND_COMPETITIVE_WINNER => 116,
                ETF2Conditions::TF_COND_COMPETITIVE_LOSER => 117,
                ETF2Conditions::TF_COND_HEALING_DEBUFF => 118,
                ETF2Conditions::TF_COND_PASSTIME_PENALTY_DEBUFF => 119,
                ETF2Conditions::TF_COND_PARACHUTE_DEPLOYED => 120,
                ETF2Conditions::TF_COND_NO_COMBAT_SPEED_BOOST => 121,
                ETF2Conditions::TF_COND_TRANQ_SPY_BOOST => 122,
                ETF2Conditions::TF_COND_TRANQ_MARKED => 123,
                ETF2Conditions::TF_COND_ROCKETPACK => 124,
                ETF2Conditions::TF_COND_ROCKETPACK_PASSENGER => 125,
                ETF2Conditions::TF_COND_STEALTHED_PHASE => 126,
                ETF2Conditions::TF_COND_CLIP_OVERLOAD => 127,
                ETF2Conditions::TF_COND_SPY_CLASS_STEAL => 128,
                ETF2Conditions::TF_COND_GAS => 129,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ETF2Conditions {
        fn default() -> Self {
            ETF2Conditions::TF_COND_AIMING
        }
    }

    impl ETF2Conditions {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ETF2Conditions>("CMsgQuestObjectiveDef.ETF2Conditions")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgQuestObjectiveDef.ETF2Team)
    pub enum ETF2Team {
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Team.TF_TEAM_RED)
        TF_TEAM_RED = 2,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Team.TF_TEAM_BLUE)
        TF_TEAM_BLUE = 3,
    }

    impl ::protobuf::Enum for ETF2Team {
        const NAME: &'static str = "ETF2Team";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ETF2Team> {
            match value {
                2 => ::std::option::Option::Some(ETF2Team::TF_TEAM_RED),
                3 => ::std::option::Option::Some(ETF2Team::TF_TEAM_BLUE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ETF2Team> {
            match str {
                "TF_TEAM_RED" => ::std::option::Option::Some(ETF2Team::TF_TEAM_RED),
                "TF_TEAM_BLUE" => ::std::option::Option::Some(ETF2Team::TF_TEAM_BLUE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ETF2Team] = &[
            ETF2Team::TF_TEAM_RED,
            ETF2Team::TF_TEAM_BLUE,
        ];
    }

    impl ::protobuf::EnumFull for ETF2Team {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgQuestObjectiveDef.ETF2Team").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                ETF2Team::TF_TEAM_RED => 0,
                ETF2Team::TF_TEAM_BLUE => 1,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for ETF2Team {
        fn default() -> Self {
            ETF2Team::TF_TEAM_RED
        }
    }

    impl ETF2Team {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ETF2Team>("CMsgQuestObjectiveDef.ETF2Team")
        }
    }
}

// @@protoc_insertion_point(message:CMsgQuestDef)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgQuestDef {
    // message fields
    // @@protoc_insertion_point(field:CMsgQuestDef.header)
    pub header: ::protobuf::MessageField<CMsgProtoDefHeader>,
    // @@protoc_insertion_point(field:CMsgQuestDef.max_points_0)
    pub max_points_0: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgQuestDef.max_points_1)
    pub max_points_1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgQuestDef.max_points_2)
    pub max_points_2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgQuestDef.name_loctoken)
    pub name_loctoken: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestDef.operation)
    pub operation: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestDef.mm_criteria)
    pub mm_criteria: ::protobuf::MessageField<cmsg_quest_def::MMCriteria>,
    // @@protoc_insertion_point(field:CMsgQuestDef.node_image)
    pub node_image: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestDef.icon_image)
    pub icon_image: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestDef.theme)
    pub theme: ::protobuf::MessageField<CMsgProtoDefID>,
    // @@protoc_insertion_point(field:CMsgQuestDef.loaner_names)
    pub loaner_names: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestDef.objectives)
    pub objectives: ::std::vec::Vec<cmsg_quest_def::ObjectiveInstance>,
    // @@protoc_insertion_point(field:CMsgQuestDef.map)
    pub map: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgQuestDef.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgQuestDef {
    fn default() -> &'a CMsgQuestDef {
        <CMsgQuestDef as ::protobuf::Message>::default_instance()
    }
}

impl CMsgQuestDef {
    pub fn new() -> CMsgQuestDef {
        ::std::default::Default::default()
    }

    // optional uint32 max_points_0 = 2;

    pub fn max_points_0(&self) -> u32 {
        self.max_points_0.unwrap_or(0)
    }

    pub fn clear_max_points_0(&mut self) {
        self.max_points_0 = ::std::option::Option::None;
    }

    pub fn has_max_points_0(&self) -> bool {
        self.max_points_0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_points_0(&mut self, v: u32) {
        self.max_points_0 = ::std::option::Option::Some(v);
    }

    // optional uint32 max_points_1 = 3;

    pub fn max_points_1(&self) -> u32 {
        self.max_points_1.unwrap_or(0)
    }

    pub fn clear_max_points_1(&mut self) {
        self.max_points_1 = ::std::option::Option::None;
    }

    pub fn has_max_points_1(&self) -> bool {
        self.max_points_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_points_1(&mut self, v: u32) {
        self.max_points_1 = ::std::option::Option::Some(v);
    }

    // optional uint32 max_points_2 = 4;

    pub fn max_points_2(&self) -> u32 {
        self.max_points_2.unwrap_or(0)
    }

    pub fn clear_max_points_2(&mut self) {
        self.max_points_2 = ::std::option::Option::None;
    }

    pub fn has_max_points_2(&self) -> bool {
        self.max_points_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_points_2(&mut self, v: u32) {
        self.max_points_2 = ::std::option::Option::Some(v);
    }

    // optional string name_loctoken = 5;

    pub fn name_loctoken(&self) -> &str {
        match self.name_loctoken.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name_loctoken(&mut self) {
        self.name_loctoken = ::std::option::Option::None;
    }

    pub fn has_name_loctoken(&self) -> bool {
        self.name_loctoken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name_loctoken(&mut self, v: ::std::string::String) {
        self.name_loctoken = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name_loctoken(&mut self) -> &mut ::std::string::String {
        if self.name_loctoken.is_none() {
            self.name_loctoken = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name_loctoken.as_mut().unwrap()
    }

    // Take field
    pub fn take_name_loctoken(&mut self) -> ::std::string::String {
        self.name_loctoken.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string operation = 7;

    pub fn operation(&self) -> &str {
        match self.operation.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_operation(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_operation(&self) -> bool {
        self.operation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operation(&mut self, v: ::std::string::String) {
        self.operation = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operation(&mut self) -> &mut ::std::string::String {
        if self.operation.is_none() {
            self.operation = ::std::option::Option::Some(::std::string::String::new());
        }
        self.operation.as_mut().unwrap()
    }

    // Take field
    pub fn take_operation(&mut self) -> ::std::string::String {
        self.operation.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string node_image = 12;

    pub fn node_image(&self) -> &str {
        match self.node_image.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_node_image(&mut self) {
        self.node_image = ::std::option::Option::None;
    }

    pub fn has_node_image(&self) -> bool {
        self.node_image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_image(&mut self, v: ::std::string::String) {
        self.node_image = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_image(&mut self) -> &mut ::std::string::String {
        if self.node_image.is_none() {
            self.node_image = ::std::option::Option::Some(::std::string::String::new());
        }
        self.node_image.as_mut().unwrap()
    }

    // Take field
    pub fn take_node_image(&mut self) -> ::std::string::String {
        self.node_image.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string icon_image = 13;

    pub fn icon_image(&self) -> &str {
        match self.icon_image.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_icon_image(&mut self) {
        self.icon_image = ::std::option::Option::None;
    }

    pub fn has_icon_image(&self) -> bool {
        self.icon_image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon_image(&mut self, v: ::std::string::String) {
        self.icon_image = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon_image(&mut self) -> &mut ::std::string::String {
        if self.icon_image.is_none() {
            self.icon_image = ::std::option::Option::Some(::std::string::String::new());
        }
        self.icon_image.as_mut().unwrap()
    }

    // Take field
    pub fn take_icon_image(&mut self) -> ::std::string::String {
        self.icon_image.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgProtoDefHeader>(
            "header",
            |m: &CMsgQuestDef| { &m.header },
            |m: &mut CMsgQuestDef| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_points_0",
            |m: &CMsgQuestDef| { &m.max_points_0 },
            |m: &mut CMsgQuestDef| { &mut m.max_points_0 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_points_1",
            |m: &CMsgQuestDef| { &m.max_points_1 },
            |m: &mut CMsgQuestDef| { &mut m.max_points_1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_points_2",
            |m: &CMsgQuestDef| { &m.max_points_2 },
            |m: &mut CMsgQuestDef| { &mut m.max_points_2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name_loctoken",
            |m: &CMsgQuestDef| { &m.name_loctoken },
            |m: &mut CMsgQuestDef| { &mut m.name_loctoken },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "operation",
            |m: &CMsgQuestDef| { &m.operation },
            |m: &mut CMsgQuestDef| { &mut m.operation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_quest_def::MMCriteria>(
            "mm_criteria",
            |m: &CMsgQuestDef| { &m.mm_criteria },
            |m: &mut CMsgQuestDef| { &mut m.mm_criteria },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "node_image",
            |m: &CMsgQuestDef| { &m.node_image },
            |m: &mut CMsgQuestDef| { &mut m.node_image },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "icon_image",
            |m: &CMsgQuestDef| { &m.icon_image },
            |m: &mut CMsgQuestDef| { &mut m.icon_image },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgProtoDefID>(
            "theme",
            |m: &CMsgQuestDef| { &m.theme },
            |m: &mut CMsgQuestDef| { &mut m.theme },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "loaner_names",
            |m: &CMsgQuestDef| { &m.loaner_names },
            |m: &mut CMsgQuestDef| { &mut m.loaner_names },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "objectives",
            |m: &CMsgQuestDef| { &m.objectives },
            |m: &mut CMsgQuestDef| { &mut m.objectives },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "map",
            |m: &CMsgQuestDef| { &m.map },
            |m: &mut CMsgQuestDef| { &mut m.map },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgQuestDef>(
            "CMsgQuestDef",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgQuestDef {
    const NAME: &'static str = "CMsgQuestDef";

    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mm_criteria {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.theme {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.objectives {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                16 => {
                    self.max_points_0 = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.max_points_1 = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.max_points_2 = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.name_loctoken = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.operation = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.mm_criteria)?;
                },
                98 => {
                    self.node_image = ::std::option::Option::Some(is.read_string()?);
                },
                106 => {
                    self.icon_image = ::std::option::Option::Some(is.read_string()?);
                },
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.theme)?;
                },
                122 => {
                    self.loaner_names.push(is.read_string()?);
                },
                130 => {
                    self.objectives.push(is.read_message()?);
                },
                138 => {
                    self.map.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.max_points_0 {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.max_points_1 {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.max_points_2 {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.name_loctoken.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.operation.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.mm_criteria.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.node_image.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.icon_image.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.theme.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.loaner_names {
            my_size += ::protobuf::rt::string_size(15, &value);
        };
        for value in &self.objectives {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.map {
            my_size += ::protobuf::rt::string_size(17, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.max_points_0 {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.max_points_1 {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.max_points_2 {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.name_loctoken.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.operation.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.mm_criteria.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.node_image.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.icon_image.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.theme.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        for v in &self.loaner_names {
            os.write_string(15, &v)?;
        };
        for v in &self.objectives {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        };
        for v in &self.map {
            os.write_string(17, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgQuestDef {
        CMsgQuestDef::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.max_points_0 = ::std::option::Option::None;
        self.max_points_1 = ::std::option::Option::None;
        self.max_points_2 = ::std::option::Option::None;
        self.name_loctoken = ::std::option::Option::None;
        self.operation = ::std::option::Option::None;
        self.mm_criteria.clear();
        self.node_image = ::std::option::Option::None;
        self.icon_image = ::std::option::Option::None;
        self.theme.clear();
        self.loaner_names.clear();
        self.objectives.clear();
        self.map.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgQuestDef {
        static instance: CMsgQuestDef = CMsgQuestDef {
            header: ::protobuf::MessageField::none(),
            max_points_0: ::std::option::Option::None,
            max_points_1: ::std::option::Option::None,
            max_points_2: ::std::option::Option::None,
            name_loctoken: ::std::option::Option::None,
            operation: ::std::option::Option::None,
            mm_criteria: ::protobuf::MessageField::none(),
            node_image: ::std::option::Option::None,
            icon_image: ::std::option::Option::None,
            theme: ::protobuf::MessageField::none(),
            loaner_names: ::std::vec::Vec::new(),
            objectives: ::std::vec::Vec::new(),
            map: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgQuestDef {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgQuestDef").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgQuestDef {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgQuestDef {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgQuestDef`
pub mod cmsg_quest_def {
    // @@protoc_insertion_point(message:CMsgQuestDef.MMCriteria)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MMCriteria {
        // message fields
        // @@protoc_insertion_point(field:CMsgQuestDef.MMCriteria.group_name)
        pub group_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgQuestDef.MMCriteria.category_name)
        pub category_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgQuestDef.MMCriteria.map_name)
        pub map_name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgQuestDef.MMCriteria.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MMCriteria {
        fn default() -> &'a MMCriteria {
            <MMCriteria as ::protobuf::Message>::default_instance()
        }
    }

    impl MMCriteria {
        pub fn new() -> MMCriteria {
            ::std::default::Default::default()
        }

        // optional string group_name = 1;

        pub fn group_name(&self) -> &str {
            match self.group_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_group_name(&mut self) {
            self.group_name = ::std::option::Option::None;
        }

        pub fn has_group_name(&self) -> bool {
            self.group_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_group_name(&mut self, v: ::std::string::String) {
            self.group_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_group_name(&mut self) -> &mut ::std::string::String {
            if self.group_name.is_none() {
                self.group_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.group_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_group_name(&mut self) -> ::std::string::String {
            self.group_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string category_name = 2;

        pub fn category_name(&self) -> &str {
            match self.category_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_category_name(&mut self) {
            self.category_name = ::std::option::Option::None;
        }

        pub fn has_category_name(&self) -> bool {
            self.category_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_category_name(&mut self, v: ::std::string::String) {
            self.category_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_category_name(&mut self) -> &mut ::std::string::String {
            if self.category_name.is_none() {
                self.category_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.category_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_category_name(&mut self) -> ::std::string::String {
            self.category_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string map_name = 3;

        pub fn map_name(&self) -> &str {
            match self.map_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_map_name(&mut self) {
            self.map_name = ::std::option::Option::None;
        }

        pub fn has_map_name(&self) -> bool {
            self.map_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_map_name(&mut self, v: ::std::string::String) {
            self.map_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_map_name(&mut self) -> &mut ::std::string::String {
            if self.map_name.is_none() {
                self.map_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.map_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_map_name(&mut self) -> ::std::string::String {
            self.map_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "group_name",
                |m: &MMCriteria| { &m.group_name },
                |m: &mut MMCriteria| { &mut m.group_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "category_name",
                |m: &MMCriteria| { &m.category_name },
                |m: &mut MMCriteria| { &mut m.category_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "map_name",
                |m: &MMCriteria| { &m.map_name },
                |m: &mut MMCriteria| { &mut m.map_name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MMCriteria>(
                "CMsgQuestDef.MMCriteria",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MMCriteria {
        const NAME: &'static str = "MMCriteria";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.group_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.category_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.map_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.group_name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.category_name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.map_name.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.group_name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.category_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.map_name.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MMCriteria {
            MMCriteria::new()
        }

        fn clear(&mut self) {
            self.group_name = ::std::option::Option::None;
            self.category_name = ::std::option::Option::None;
            self.map_name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MMCriteria {
            static instance: MMCriteria = MMCriteria {
                group_name: ::std::option::Option::None,
                category_name: ::std::option::Option::None,
                map_name: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MMCriteria {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgQuestDef.MMCriteria").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MMCriteria {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MMCriteria {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgQuestDef.ObjectiveInstance)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ObjectiveInstance {
        // message fields
        // @@protoc_insertion_point(field:CMsgQuestDef.ObjectiveInstance.objective)
        pub objective: ::protobuf::MessageField<super::CMsgProtoDefID>,
        // @@protoc_insertion_point(field:CMsgQuestDef.ObjectiveInstance.point_type)
        pub point_type: ::std::option::Option<::protobuf::EnumOrUnknown<super::EQuestPoints>>,
        // @@protoc_insertion_point(field:CMsgQuestDef.ObjectiveInstance.point_value)
        pub point_value: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgQuestDef.ObjectiveInstance.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ObjectiveInstance {
        fn default() -> &'a ObjectiveInstance {
            <ObjectiveInstance as ::protobuf::Message>::default_instance()
        }
    }

    impl ObjectiveInstance {
        pub fn new() -> ObjectiveInstance {
            ::std::default::Default::default()
        }

        // optional .EQuestPoints point_type = 2;

        pub fn point_type(&self) -> super::EQuestPoints {
            match self.point_type {
                Some(e) => e.enum_value_or(super::EQuestPoints::QUEST_POINTS_NOVICE),
                None => super::EQuestPoints::QUEST_POINTS_NOVICE,
            }
        }

        pub fn clear_point_type(&mut self) {
            self.point_type = ::std::option::Option::None;
        }

        pub fn has_point_type(&self) -> bool {
            self.point_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_point_type(&mut self, v: super::EQuestPoints) {
            self.point_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional uint32 point_value = 3;

        pub fn point_value(&self) -> u32 {
            self.point_value.unwrap_or(0)
        }

        pub fn clear_point_value(&mut self) {
            self.point_value = ::std::option::Option::None;
        }

        pub fn has_point_value(&self) -> bool {
            self.point_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_point_value(&mut self, v: u32) {
            self.point_value = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::CMsgProtoDefID>(
                "objective",
                |m: &ObjectiveInstance| { &m.objective },
                |m: &mut ObjectiveInstance| { &mut m.objective },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "point_type",
                |m: &ObjectiveInstance| { &m.point_type },
                |m: &mut ObjectiveInstance| { &mut m.point_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "point_value",
                |m: &ObjectiveInstance| { &m.point_value },
                |m: &mut ObjectiveInstance| { &mut m.point_value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ObjectiveInstance>(
                "CMsgQuestDef.ObjectiveInstance",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ObjectiveInstance {
        const NAME: &'static str = "ObjectiveInstance";

        fn is_initialized(&self) -> bool {
            for v in &self.objective {
                if !v.is_initialized() {
                    return false;
                }
            };
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.objective)?;
                    },
                    16 => {
                        self.point_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    24 => {
                        self.point_value = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.objective.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.point_type {
                my_size += ::protobuf::rt::int32_size(2, v.value());
            }
            if let Some(v) = self.point_value {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.objective.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if let Some(v) = self.point_type {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.point_value {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ObjectiveInstance {
            ObjectiveInstance::new()
        }

        fn clear(&mut self) {
            self.objective.clear();
            self.point_type = ::std::option::Option::None;
            self.point_value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ObjectiveInstance {
            static instance: ObjectiveInstance = ObjectiveInstance {
                objective: ::protobuf::MessageField::none(),
                point_type: ::std::option::Option::None,
                point_value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ObjectiveInstance {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgQuestDef.ObjectiveInstance").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ObjectiveInstance {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ObjectiveInstance {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgQuestMapStoreItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgQuestMapStoreItem {
    // message fields
    // @@protoc_insertion_point(field:CMsgQuestMapStoreItem.header)
    pub header: ::protobuf::MessageField<CMsgProtoDefHeader>,
    // @@protoc_insertion_point(field:CMsgQuestMapStoreItem.item_name)
    pub item_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestMapStoreItem.reward_lootlist_name)
    pub reward_lootlist_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestMapStoreItem.price)
    pub price: ::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgQuestMapStoreItem.purchase_limit)
    pub purchase_limit: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgQuestMapStoreItem.sort_group)
    pub sort_group: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgQuestMapStoreItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgQuestMapStoreItem {
    fn default() -> &'a CMsgQuestMapStoreItem {
        <CMsgQuestMapStoreItem as ::protobuf::Message>::default_instance()
    }
}

impl CMsgQuestMapStoreItem {
    pub fn new() -> CMsgQuestMapStoreItem {
        ::std::default::Default::default()
    }

    // optional string item_name = 2;

    pub fn item_name(&self) -> &str {
        match self.item_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_item_name(&mut self) {
        self.item_name = ::std::option::Option::None;
    }

    pub fn has_item_name(&self) -> bool {
        self.item_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_name(&mut self, v: ::std::string::String) {
        self.item_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item_name(&mut self) -> &mut ::std::string::String {
        if self.item_name.is_none() {
            self.item_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.item_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_item_name(&mut self) -> ::std::string::String {
        self.item_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string reward_lootlist_name = 6;

    pub fn reward_lootlist_name(&self) -> &str {
        match self.reward_lootlist_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reward_lootlist_name(&mut self) {
        self.reward_lootlist_name = ::std::option::Option::None;
    }

    pub fn has_reward_lootlist_name(&self) -> bool {
        self.reward_lootlist_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_lootlist_name(&mut self, v: ::std::string::String) {
        self.reward_lootlist_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reward_lootlist_name(&mut self) -> &mut ::std::string::String {
        if self.reward_lootlist_name.is_none() {
            self.reward_lootlist_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reward_lootlist_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_reward_lootlist_name(&mut self) -> ::std::string::String {
        self.reward_lootlist_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 purchase_limit = 4;

    pub fn purchase_limit(&self) -> u32 {
        self.purchase_limit.unwrap_or(0)
    }

    pub fn clear_purchase_limit(&mut self) {
        self.purchase_limit = ::std::option::Option::None;
    }

    pub fn has_purchase_limit(&self) -> bool {
        self.purchase_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchase_limit(&mut self, v: u32) {
        self.purchase_limit = ::std::option::Option::Some(v);
    }

    // optional uint32 sort_group = 5;

    pub fn sort_group(&self) -> u32 {
        self.sort_group.unwrap_or(0)
    }

    pub fn clear_sort_group(&mut self) {
        self.sort_group = ::std::option::Option::None;
    }

    pub fn has_sort_group(&self) -> bool {
        self.sort_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sort_group(&mut self, v: u32) {
        self.sort_group = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgProtoDefHeader>(
            "header",
            |m: &CMsgQuestMapStoreItem| { &m.header },
            |m: &mut CMsgQuestMapStoreItem| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_name",
            |m: &CMsgQuestMapStoreItem| { &m.item_name },
            |m: &mut CMsgQuestMapStoreItem| { &mut m.item_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reward_lootlist_name",
            |m: &CMsgQuestMapStoreItem| { &m.reward_lootlist_name },
            |m: &mut CMsgQuestMapStoreItem| { &mut m.reward_lootlist_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVarField>(
            "price",
            |m: &CMsgQuestMapStoreItem| { &m.price },
            |m: &mut CMsgQuestMapStoreItem| { &mut m.price },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "purchase_limit",
            |m: &CMsgQuestMapStoreItem| { &m.purchase_limit },
            |m: &mut CMsgQuestMapStoreItem| { &mut m.purchase_limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sort_group",
            |m: &CMsgQuestMapStoreItem| { &m.sort_group },
            |m: &mut CMsgQuestMapStoreItem| { &mut m.sort_group },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgQuestMapStoreItem>(
            "CMsgQuestMapStoreItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgQuestMapStoreItem {
    const NAME: &'static str = "CMsgQuestMapStoreItem";

    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.price {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.item_name = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.reward_lootlist_name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.price)?;
                },
                32 => {
                    self.purchase_limit = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.sort_group = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.item_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.reward_lootlist_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.price.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.purchase_limit {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.sort_group {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.item_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.reward_lootlist_name.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.price.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.purchase_limit {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.sort_group {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgQuestMapStoreItem {
        CMsgQuestMapStoreItem::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.item_name = ::std::option::Option::None;
        self.reward_lootlist_name = ::std::option::Option::None;
        self.price.clear();
        self.purchase_limit = ::std::option::Option::None;
        self.sort_group = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgQuestMapStoreItem {
        static instance: CMsgQuestMapStoreItem = CMsgQuestMapStoreItem {
            header: ::protobuf::MessageField::none(),
            item_name: ::std::option::Option::None,
            reward_lootlist_name: ::std::option::Option::None,
            price: ::protobuf::MessageField::none(),
            purchase_limit: ::std::option::Option::None,
            sort_group: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgQuestMapStoreItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgQuestMapStoreItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgQuestMapStoreItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgQuestMapStoreItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgQuestMapRegionDef)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgQuestMapRegionDef {
    // message fields
    // @@protoc_insertion_point(field:CMsgQuestMapRegionDef.header)
    pub header: ::protobuf::MessageField<CMsgProtoDefHeader>,
    // @@protoc_insertion_point(field:CMsgQuestMapRegionDef.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestMapRegionDef.resfile)
    pub resfile: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestMapRegionDef.links)
    pub links: ::std::vec::Vec<cmsg_quest_map_region_def::RegionLink>,
    // @@protoc_insertion_point(field:CMsgQuestMapRegionDef.return_link)
    pub return_link: ::protobuf::MessageField<CMsgProtoDefID>,
    // @@protoc_insertion_point(field:CMsgQuestMapRegionDef.radio_freq)
    pub radio_freq: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgQuestMapRegionDef.zoom_scale)
    pub zoom_scale: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgQuestMapRegionDef.star_type)
    pub star_type: ::protobuf::MessageField<CMsgProtoDefID>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgQuestMapRegionDef.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgQuestMapRegionDef {
    fn default() -> &'a CMsgQuestMapRegionDef {
        <CMsgQuestMapRegionDef as ::protobuf::Message>::default_instance()
    }
}

impl CMsgQuestMapRegionDef {
    pub fn new() -> CMsgQuestMapRegionDef {
        ::std::default::Default::default()
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string resfile = 3;

    pub fn resfile(&self) -> &str {
        match self.resfile.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_resfile(&mut self) {
        self.resfile = ::std::option::Option::None;
    }

    pub fn has_resfile(&self) -> bool {
        self.resfile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resfile(&mut self, v: ::std::string::String) {
        self.resfile = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resfile(&mut self) -> &mut ::std::string::String {
        if self.resfile.is_none() {
            self.resfile = ::std::option::Option::Some(::std::string::String::new());
        }
        self.resfile.as_mut().unwrap()
    }

    // Take field
    pub fn take_resfile(&mut self) -> ::std::string::String {
        self.resfile.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float radio_freq = 6;

    pub fn radio_freq(&self) -> f32 {
        self.radio_freq.unwrap_or(0.)
    }

    pub fn clear_radio_freq(&mut self) {
        self.radio_freq = ::std::option::Option::None;
    }

    pub fn has_radio_freq(&self) -> bool {
        self.radio_freq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radio_freq(&mut self, v: f32) {
        self.radio_freq = ::std::option::Option::Some(v);
    }

    // optional float zoom_scale = 7;

    pub fn zoom_scale(&self) -> f32 {
        self.zoom_scale.unwrap_or(0.)
    }

    pub fn clear_zoom_scale(&mut self) {
        self.zoom_scale = ::std::option::Option::None;
    }

    pub fn has_zoom_scale(&self) -> bool {
        self.zoom_scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zoom_scale(&mut self, v: f32) {
        self.zoom_scale = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgProtoDefHeader>(
            "header",
            |m: &CMsgQuestMapRegionDef| { &m.header },
            |m: &mut CMsgQuestMapRegionDef| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgQuestMapRegionDef| { &m.name },
            |m: &mut CMsgQuestMapRegionDef| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "resfile",
            |m: &CMsgQuestMapRegionDef| { &m.resfile },
            |m: &mut CMsgQuestMapRegionDef| { &mut m.resfile },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "links",
            |m: &CMsgQuestMapRegionDef| { &m.links },
            |m: &mut CMsgQuestMapRegionDef| { &mut m.links },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgProtoDefID>(
            "return_link",
            |m: &CMsgQuestMapRegionDef| { &m.return_link },
            |m: &mut CMsgQuestMapRegionDef| { &mut m.return_link },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radio_freq",
            |m: &CMsgQuestMapRegionDef| { &m.radio_freq },
            |m: &mut CMsgQuestMapRegionDef| { &mut m.radio_freq },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "zoom_scale",
            |m: &CMsgQuestMapRegionDef| { &m.zoom_scale },
            |m: &mut CMsgQuestMapRegionDef| { &mut m.zoom_scale },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgProtoDefID>(
            "star_type",
            |m: &CMsgQuestMapRegionDef| { &m.star_type },
            |m: &mut CMsgQuestMapRegionDef| { &mut m.star_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgQuestMapRegionDef>(
            "CMsgQuestMapRegionDef",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgQuestMapRegionDef {
    const NAME: &'static str = "CMsgQuestMapRegionDef";

    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.links {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.return_link {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.star_type {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.resfile = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.links.push(is.read_message()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.return_link)?;
                },
                53 => {
                    self.radio_freq = ::std::option::Option::Some(is.read_float()?);
                },
                61 => {
                    self.zoom_scale = ::std::option::Option::Some(is.read_float()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.star_type)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.resfile.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.links {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.return_link.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.radio_freq {
            my_size += 1 + 4;
        }
        if let Some(v) = self.zoom_scale {
            my_size += 1 + 4;
        }
        if let Some(v) = self.star_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.resfile.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.links {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.return_link.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.radio_freq {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.zoom_scale {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.star_type.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgQuestMapRegionDef {
        CMsgQuestMapRegionDef::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.name = ::std::option::Option::None;
        self.resfile = ::std::option::Option::None;
        self.links.clear();
        self.return_link.clear();
        self.radio_freq = ::std::option::Option::None;
        self.zoom_scale = ::std::option::Option::None;
        self.star_type.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgQuestMapRegionDef {
        static instance: CMsgQuestMapRegionDef = CMsgQuestMapRegionDef {
            header: ::protobuf::MessageField::none(),
            name: ::std::option::Option::None,
            resfile: ::std::option::Option::None,
            links: ::std::vec::Vec::new(),
            return_link: ::protobuf::MessageField::none(),
            radio_freq: ::std::option::Option::None,
            zoom_scale: ::std::option::Option::None,
            star_type: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgQuestMapRegionDef {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgQuestMapRegionDef").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgQuestMapRegionDef {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgQuestMapRegionDef {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgQuestMapRegionDef`
pub mod cmsg_quest_map_region_def {
    // @@protoc_insertion_point(message:CMsgQuestMapRegionDef.RegionLink)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RegionLink {
        // message fields
        // @@protoc_insertion_point(field:CMsgQuestMapRegionDef.RegionLink.target_region_defid)
        pub target_region_defid: ::protobuf::MessageField<super::CMsgProtoDefID>,
        // @@protoc_insertion_point(field:CMsgQuestMapRegionDef.RegionLink.xpos)
        pub xpos: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgQuestMapRegionDef.RegionLink.ypos)
        pub ypos: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgQuestMapRegionDef.RegionLink.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RegionLink {
        fn default() -> &'a RegionLink {
            <RegionLink as ::protobuf::Message>::default_instance()
        }
    }

    impl RegionLink {
        pub fn new() -> RegionLink {
            ::std::default::Default::default()
        }

        // optional uint32 xpos = 2;

        pub fn xpos(&self) -> u32 {
            self.xpos.unwrap_or(0)
        }

        pub fn clear_xpos(&mut self) {
            self.xpos = ::std::option::Option::None;
        }

        pub fn has_xpos(&self) -> bool {
            self.xpos.is_some()
        }

        // Param is passed by value, moved
        pub fn set_xpos(&mut self, v: u32) {
            self.xpos = ::std::option::Option::Some(v);
        }

        // optional uint32 ypos = 3;

        pub fn ypos(&self) -> u32 {
            self.ypos.unwrap_or(0)
        }

        pub fn clear_ypos(&mut self) {
            self.ypos = ::std::option::Option::None;
        }

        pub fn has_ypos(&self) -> bool {
            self.ypos.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ypos(&mut self, v: u32) {
            self.ypos = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::CMsgProtoDefID>(
                "target_region_defid",
                |m: &RegionLink| { &m.target_region_defid },
                |m: &mut RegionLink| { &mut m.target_region_defid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "xpos",
                |m: &RegionLink| { &m.xpos },
                |m: &mut RegionLink| { &mut m.xpos },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ypos",
                |m: &RegionLink| { &m.ypos },
                |m: &mut RegionLink| { &mut m.ypos },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RegionLink>(
                "CMsgQuestMapRegionDef.RegionLink",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RegionLink {
        const NAME: &'static str = "RegionLink";

        fn is_initialized(&self) -> bool {
            if self.target_region_defid.is_none() {
                return false;
            }
            for v in &self.target_region_defid {
                if !v.is_initialized() {
                    return false;
                }
            };
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.target_region_defid)?;
                    },
                    16 => {
                        self.xpos = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.ypos = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.target_region_defid.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.xpos {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.ypos {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.target_region_defid.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if let Some(v) = self.xpos {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.ypos {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RegionLink {
            RegionLink::new()
        }

        fn clear(&mut self) {
            self.target_region_defid.clear();
            self.xpos = ::std::option::Option::None;
            self.ypos = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RegionLink {
            static instance: RegionLink = RegionLink {
                target_region_defid: ::protobuf::MessageField::none(),
                xpos: ::std::option::Option::None,
                ypos: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RegionLink {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgQuestMapRegionDef.RegionLink").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RegionLink {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RegionLink {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgVarField)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgVarField {
    // message fields
    // @@protoc_insertion_point(field:CMsgVarField.variable)
    pub variable: ::std::option::Option<::std::string::String>,
    // message oneof groups
    pub value: ::std::option::Option<cmsg_var_field::Value>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgVarField.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgVarField {
    fn default() -> &'a CMsgVarField {
        <CMsgVarField as ::protobuf::Message>::default_instance()
    }
}

impl CMsgVarField {
    pub fn new() -> CMsgVarField {
        ::std::default::Default::default()
    }

    // optional string variable = 1;

    pub fn variable(&self) -> &str {
        match self.variable.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_variable(&mut self) {
        self.variable = ::std::option::Option::None;
    }

    pub fn has_variable(&self) -> bool {
        self.variable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_variable(&mut self, v: ::std::string::String) {
        self.variable = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_variable(&mut self) -> &mut ::std::string::String {
        if self.variable.is_none() {
            self.variable = ::std::option::Option::Some(::std::string::String::new());
        }
        self.variable.as_mut().unwrap()
    }

    // Take field
    pub fn take_variable(&mut self) -> ::std::string::String {
        self.variable.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float float = 2;

    pub fn float(&self) -> f32 {
        match self.value {
            ::std::option::Option::Some(cmsg_var_field::Value::Float(v)) => v,
            _ => 0.,
        }
    }

    pub fn clear_float(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_float(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(cmsg_var_field::Value::Float(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_float(&mut self, v: f32) {
        self.value = ::std::option::Option::Some(cmsg_var_field::Value::Float(v))
    }

    // optional double double = 3;

    pub fn double(&self) -> f64 {
        match self.value {
            ::std::option::Option::Some(cmsg_var_field::Value::Double(v)) => v,
            _ => 0.,
        }
    }

    pub fn clear_double(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_double(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(cmsg_var_field::Value::Double(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_double(&mut self, v: f64) {
        self.value = ::std::option::Option::Some(cmsg_var_field::Value::Double(v))
    }

    // optional uint32 uint32 = 4;

    pub fn uint32(&self) -> u32 {
        match self.value {
            ::std::option::Option::Some(cmsg_var_field::Value::Uint32(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_uint32(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_uint32(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(cmsg_var_field::Value::Uint32(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_uint32(&mut self, v: u32) {
        self.value = ::std::option::Option::Some(cmsg_var_field::Value::Uint32(v))
    }

    // optional uint64 uint64 = 5;

    pub fn uint64(&self) -> u64 {
        match self.value {
            ::std::option::Option::Some(cmsg_var_field::Value::Uint64(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_uint64(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_uint64(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(cmsg_var_field::Value::Uint64(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_uint64(&mut self, v: u64) {
        self.value = ::std::option::Option::Some(cmsg_var_field::Value::Uint64(v))
    }

    // optional sint32 sint32 = 6;

    pub fn sint32(&self) -> i32 {
        match self.value {
            ::std::option::Option::Some(cmsg_var_field::Value::Sint32(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_sint32(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_sint32(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(cmsg_var_field::Value::Sint32(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sint32(&mut self, v: i32) {
        self.value = ::std::option::Option::Some(cmsg_var_field::Value::Sint32(v))
    }

    // optional sint64 sint64 = 7;

    pub fn sint64(&self) -> i64 {
        match self.value {
            ::std::option::Option::Some(cmsg_var_field::Value::Sint64(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_sint64(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_sint64(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(cmsg_var_field::Value::Sint64(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sint64(&mut self, v: i64) {
        self.value = ::std::option::Option::Some(cmsg_var_field::Value::Sint64(v))
    }

    // optional bool bool = 8;

    pub fn bool(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(cmsg_var_field::Value::Bool(v)) => v,
            _ => false,
        }
    }

    pub fn clear_bool(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_bool(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(cmsg_var_field::Value::Bool(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bool(&mut self, v: bool) {
        self.value = ::std::option::Option::Some(cmsg_var_field::Value::Bool(v))
    }

    // optional string string = 9;

    pub fn string(&self) -> &str {
        match self.value {
            ::std::option::Option::Some(cmsg_var_field::Value::String(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_string(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_string(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(cmsg_var_field::Value::String(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_string(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(cmsg_var_field::Value::String(v))
    }

    // Mutable pointer to the field.
    pub fn mut_string(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(cmsg_var_field::Value::String(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(cmsg_var_field::Value::String(::std::string::String::new()));
        }
        match self.value {
            ::std::option::Option::Some(cmsg_var_field::Value::String(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_string(&mut self) -> ::std::string::String {
        if self.has_string() {
            match self.value.take() {
                ::std::option::Option::Some(cmsg_var_field::Value::String(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "variable",
            |m: &CMsgVarField| { &m.variable },
            |m: &mut CMsgVarField| { &mut m.variable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "float",
            CMsgVarField::has_float,
            CMsgVarField::float,
            CMsgVarField::set_float,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "double",
            CMsgVarField::has_double,
            CMsgVarField::double,
            CMsgVarField::set_double,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "uint32",
            CMsgVarField::has_uint32,
            CMsgVarField::uint32,
            CMsgVarField::set_uint32,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "uint64",
            CMsgVarField::has_uint64,
            CMsgVarField::uint64,
            CMsgVarField::set_uint64,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sint32",
            CMsgVarField::has_sint32,
            CMsgVarField::sint32,
            CMsgVarField::set_sint32,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sint64",
            CMsgVarField::has_sint64,
            CMsgVarField::sint64,
            CMsgVarField::set_sint64,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "bool",
            CMsgVarField::has_bool,
            CMsgVarField::bool,
            CMsgVarField::set_bool,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "string",
            CMsgVarField::has_string,
            CMsgVarField::string,
            CMsgVarField::set_string,
        ));
        oneofs.push(cmsg_var_field::Value::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgVarField>(
            "CMsgVarField",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgVarField {
    const NAME: &'static str = "CMsgVarField";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.variable = ::std::option::Option::Some(is.read_string()?);
                },
                21 => {
                    self.value = ::std::option::Option::Some(cmsg_var_field::Value::Float(is.read_float()?));
                },
                25 => {
                    self.value = ::std::option::Option::Some(cmsg_var_field::Value::Double(is.read_double()?));
                },
                32 => {
                    self.value = ::std::option::Option::Some(cmsg_var_field::Value::Uint32(is.read_uint32()?));
                },
                40 => {
                    self.value = ::std::option::Option::Some(cmsg_var_field::Value::Uint64(is.read_uint64()?));
                },
                48 => {
                    self.value = ::std::option::Option::Some(cmsg_var_field::Value::Sint32(is.read_sint32()?));
                },
                56 => {
                    self.value = ::std::option::Option::Some(cmsg_var_field::Value::Sint64(is.read_sint64()?));
                },
                64 => {
                    self.value = ::std::option::Option::Some(cmsg_var_field::Value::Bool(is.read_bool()?));
                },
                74 => {
                    self.value = ::std::option::Option::Some(cmsg_var_field::Value::String(is.read_string()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.variable.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &cmsg_var_field::Value::Float(v) => {
                    my_size += 1 + 4;
                },
                &cmsg_var_field::Value::Double(v) => {
                    my_size += 1 + 8;
                },
                &cmsg_var_field::Value::Uint32(v) => {
                    my_size += ::protobuf::rt::uint32_size(4, v);
                },
                &cmsg_var_field::Value::Uint64(v) => {
                    my_size += ::protobuf::rt::uint64_size(5, v);
                },
                &cmsg_var_field::Value::Sint32(v) => {
                    my_size += ::protobuf::rt::sint32_size(6, v);
                },
                &cmsg_var_field::Value::Sint64(v) => {
                    my_size += ::protobuf::rt::sint64_size(7, v);
                },
                &cmsg_var_field::Value::Bool(v) => {
                    my_size += 1 + 1;
                },
                &cmsg_var_field::Value::String(ref v) => {
                    my_size += ::protobuf::rt::string_size(9, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.variable.as_ref() {
            os.write_string(1, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &cmsg_var_field::Value::Float(v) => {
                    os.write_float(2, v)?;
                },
                &cmsg_var_field::Value::Double(v) => {
                    os.write_double(3, v)?;
                },
                &cmsg_var_field::Value::Uint32(v) => {
                    os.write_uint32(4, v)?;
                },
                &cmsg_var_field::Value::Uint64(v) => {
                    os.write_uint64(5, v)?;
                },
                &cmsg_var_field::Value::Sint32(v) => {
                    os.write_sint32(6, v)?;
                },
                &cmsg_var_field::Value::Sint64(v) => {
                    os.write_sint64(7, v)?;
                },
                &cmsg_var_field::Value::Bool(v) => {
                    os.write_bool(8, v)?;
                },
                &cmsg_var_field::Value::String(ref v) => {
                    os.write_string(9, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgVarField {
        CMsgVarField::new()
    }

    fn clear(&mut self) {
        self.variable = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgVarField {
        static instance: CMsgVarField = CMsgVarField {
            variable: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgVarField {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgVarField").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgVarField {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgVarField {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgVarField`
pub mod cmsg_var_field {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:CMsgVarField.value)
    pub enum Value {
        // @@protoc_insertion_point(oneof_field:CMsgVarField.float)
        Float(f32),
        // @@protoc_insertion_point(oneof_field:CMsgVarField.double)
        Double(f64),
        // @@protoc_insertion_point(oneof_field:CMsgVarField.uint32)
        Uint32(u32),
        // @@protoc_insertion_point(oneof_field:CMsgVarField.uint64)
        Uint64(u64),
        // @@protoc_insertion_point(oneof_field:CMsgVarField.sint32)
        Sint32(i32),
        // @@protoc_insertion_point(oneof_field:CMsgVarField.sint64)
        Sint64(i64),
        // @@protoc_insertion_point(oneof_field:CMsgVarField.bool)
        Bool(bool),
        // @@protoc_insertion_point(oneof_field:CMsgVarField.string)
        String(::std::string::String),
    }

    impl ::protobuf::Oneof for Value {
    }

    impl ::protobuf::OneofFull for Value {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::CMsgVarField as ::protobuf::MessageFull>::descriptor().oneof_by_name("value").unwrap()).clone()
        }
    }

    impl Value {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Value>("value")
        }
    }
}

// @@protoc_insertion_point(message:CMsgQuestMapStarType)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgQuestMapStarType {
    // message fields
    // @@protoc_insertion_point(field:CMsgQuestMapStarType.header)
    pub header: ::protobuf::MessageField<CMsgProtoDefHeader>,
    // @@protoc_insertion_point(field:CMsgQuestMapStarType.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgQuestMapStarType.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgQuestMapStarType {
    fn default() -> &'a CMsgQuestMapStarType {
        <CMsgQuestMapStarType as ::protobuf::Message>::default_instance()
    }
}

impl CMsgQuestMapStarType {
    pub fn new() -> CMsgQuestMapStarType {
        ::std::default::Default::default()
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgProtoDefHeader>(
            "header",
            |m: &CMsgQuestMapStarType| { &m.header },
            |m: &mut CMsgQuestMapStarType| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgQuestMapStarType| { &m.name },
            |m: &mut CMsgQuestMapStarType| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgQuestMapStarType>(
            "CMsgQuestMapStarType",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgQuestMapStarType {
    const NAME: &'static str = "CMsgQuestMapStarType";

    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgQuestMapStarType {
        CMsgQuestMapStarType::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgQuestMapStarType {
        static instance: CMsgQuestMapStarType = CMsgQuestMapStarType {
            header: ::protobuf::MessageField::none(),
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgQuestMapStarType {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgQuestMapStarType").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgQuestMapStarType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgQuestMapStarType {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgQuestMapNodeDef)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgQuestMapNodeDef {
    // message fields
    // @@protoc_insertion_point(field:CMsgQuestMapNodeDef.header)
    pub header: ::protobuf::MessageField<CMsgProtoDefHeader>,
    // @@protoc_insertion_point(field:CMsgQuestMapNodeDef.name_loctoken)
    pub name_loctoken: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestMapNodeDef.x_pos)
    pub x_pos: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgQuestMapNodeDef.y_pos)
    pub y_pos: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgQuestMapNodeDef.condition)
    pub condition: ::protobuf::MessageField<CMsgQuestMapNodeCondition>,
    // @@protoc_insertion_point(field:CMsgQuestMapNodeDef.owning_region)
    pub owning_region: ::protobuf::MessageField<CMsgProtoDefID>,
    // @@protoc_insertion_point(field:CMsgQuestMapNodeDef.quest_options)
    pub quest_options: ::std::vec::Vec<CMsgProtoDefID>,
    // @@protoc_insertion_point(field:CMsgQuestMapNodeDef.associated_operation)
    pub associated_operation: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestMapNodeDef.reward_item_name)
    pub reward_item_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestMapNodeDef.reward_lootlist_name)
    pub reward_lootlist_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestMapNodeDef.cash_reward)
    pub cash_reward: ::std::option::Option<::protobuf::EnumOrUnknown<ENodeCashReward>>,
    // @@protoc_insertion_point(field:CMsgQuestMapNodeDef.star_type)
    pub star_type: ::protobuf::MessageField<CMsgProtoDefID>,
    // @@protoc_insertion_point(field:CMsgQuestMapNodeDef.stars_to_unlock)
    pub stars_to_unlock: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgQuestMapNodeDef.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgQuestMapNodeDef {
    fn default() -> &'a CMsgQuestMapNodeDef {
        <CMsgQuestMapNodeDef as ::protobuf::Message>::default_instance()
    }
}

impl CMsgQuestMapNodeDef {
    pub fn new() -> CMsgQuestMapNodeDef {
        ::std::default::Default::default()
    }

    // optional string name_loctoken = 4;

    pub fn name_loctoken(&self) -> &str {
        match self.name_loctoken.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name_loctoken(&mut self) {
        self.name_loctoken = ::std::option::Option::None;
    }

    pub fn has_name_loctoken(&self) -> bool {
        self.name_loctoken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name_loctoken(&mut self, v: ::std::string::String) {
        self.name_loctoken = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name_loctoken(&mut self) -> &mut ::std::string::String {
        if self.name_loctoken.is_none() {
            self.name_loctoken = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name_loctoken.as_mut().unwrap()
    }

    // Take field
    pub fn take_name_loctoken(&mut self) -> ::std::string::String {
        self.name_loctoken.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float x_pos = 6;

    pub fn x_pos(&self) -> f32 {
        self.x_pos.unwrap_or(0.)
    }

    pub fn clear_x_pos(&mut self) {
        self.x_pos = ::std::option::Option::None;
    }

    pub fn has_x_pos(&self) -> bool {
        self.x_pos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x_pos(&mut self, v: f32) {
        self.x_pos = ::std::option::Option::Some(v);
    }

    // optional float y_pos = 7;

    pub fn y_pos(&self) -> f32 {
        self.y_pos.unwrap_or(0.)
    }

    pub fn clear_y_pos(&mut self) {
        self.y_pos = ::std::option::Option::None;
    }

    pub fn has_y_pos(&self) -> bool {
        self.y_pos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y_pos(&mut self, v: f32) {
        self.y_pos = ::std::option::Option::Some(v);
    }

    // optional string associated_operation = 16;

    pub fn associated_operation(&self) -> &str {
        match self.associated_operation.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_associated_operation(&mut self) {
        self.associated_operation = ::std::option::Option::None;
    }

    pub fn has_associated_operation(&self) -> bool {
        self.associated_operation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_associated_operation(&mut self, v: ::std::string::String) {
        self.associated_operation = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_associated_operation(&mut self) -> &mut ::std::string::String {
        if self.associated_operation.is_none() {
            self.associated_operation = ::std::option::Option::Some(::std::string::String::new());
        }
        self.associated_operation.as_mut().unwrap()
    }

    // Take field
    pub fn take_associated_operation(&mut self) -> ::std::string::String {
        self.associated_operation.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string reward_item_name = 18;

    pub fn reward_item_name(&self) -> &str {
        match self.reward_item_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reward_item_name(&mut self) {
        self.reward_item_name = ::std::option::Option::None;
    }

    pub fn has_reward_item_name(&self) -> bool {
        self.reward_item_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_item_name(&mut self, v: ::std::string::String) {
        self.reward_item_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reward_item_name(&mut self) -> &mut ::std::string::String {
        if self.reward_item_name.is_none() {
            self.reward_item_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reward_item_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_reward_item_name(&mut self) -> ::std::string::String {
        self.reward_item_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string reward_lootlist_name = 22;

    pub fn reward_lootlist_name(&self) -> &str {
        match self.reward_lootlist_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reward_lootlist_name(&mut self) {
        self.reward_lootlist_name = ::std::option::Option::None;
    }

    pub fn has_reward_lootlist_name(&self) -> bool {
        self.reward_lootlist_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_lootlist_name(&mut self, v: ::std::string::String) {
        self.reward_lootlist_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reward_lootlist_name(&mut self) -> &mut ::std::string::String {
        if self.reward_lootlist_name.is_none() {
            self.reward_lootlist_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reward_lootlist_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_reward_lootlist_name(&mut self) -> ::std::string::String {
        self.reward_lootlist_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .ENodeCashReward cash_reward = 19;

    pub fn cash_reward(&self) -> ENodeCashReward {
        match self.cash_reward {
            Some(e) => e.enum_value_or(ENodeCashReward::CASH_REWARD_NONE),
            None => ENodeCashReward::CASH_REWARD_NONE,
        }
    }

    pub fn clear_cash_reward(&mut self) {
        self.cash_reward = ::std::option::Option::None;
    }

    pub fn has_cash_reward(&self) -> bool {
        self.cash_reward.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cash_reward(&mut self, v: ENodeCashReward) {
        self.cash_reward = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 stars_to_unlock = 21;

    pub fn stars_to_unlock(&self) -> u32 {
        self.stars_to_unlock.unwrap_or(1u32)
    }

    pub fn clear_stars_to_unlock(&mut self) {
        self.stars_to_unlock = ::std::option::Option::None;
    }

    pub fn has_stars_to_unlock(&self) -> bool {
        self.stars_to_unlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stars_to_unlock(&mut self, v: u32) {
        self.stars_to_unlock = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgProtoDefHeader>(
            "header",
            |m: &CMsgQuestMapNodeDef| { &m.header },
            |m: &mut CMsgQuestMapNodeDef| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name_loctoken",
            |m: &CMsgQuestMapNodeDef| { &m.name_loctoken },
            |m: &mut CMsgQuestMapNodeDef| { &mut m.name_loctoken },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "x_pos",
            |m: &CMsgQuestMapNodeDef| { &m.x_pos },
            |m: &mut CMsgQuestMapNodeDef| { &mut m.x_pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "y_pos",
            |m: &CMsgQuestMapNodeDef| { &m.y_pos },
            |m: &mut CMsgQuestMapNodeDef| { &mut m.y_pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgQuestMapNodeCondition>(
            "condition",
            |m: &CMsgQuestMapNodeDef| { &m.condition },
            |m: &mut CMsgQuestMapNodeDef| { &mut m.condition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgProtoDefID>(
            "owning_region",
            |m: &CMsgQuestMapNodeDef| { &m.owning_region },
            |m: &mut CMsgQuestMapNodeDef| { &mut m.owning_region },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "quest_options",
            |m: &CMsgQuestMapNodeDef| { &m.quest_options },
            |m: &mut CMsgQuestMapNodeDef| { &mut m.quest_options },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "associated_operation",
            |m: &CMsgQuestMapNodeDef| { &m.associated_operation },
            |m: &mut CMsgQuestMapNodeDef| { &mut m.associated_operation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reward_item_name",
            |m: &CMsgQuestMapNodeDef| { &m.reward_item_name },
            |m: &mut CMsgQuestMapNodeDef| { &mut m.reward_item_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reward_lootlist_name",
            |m: &CMsgQuestMapNodeDef| { &m.reward_lootlist_name },
            |m: &mut CMsgQuestMapNodeDef| { &mut m.reward_lootlist_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cash_reward",
            |m: &CMsgQuestMapNodeDef| { &m.cash_reward },
            |m: &mut CMsgQuestMapNodeDef| { &mut m.cash_reward },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgProtoDefID>(
            "star_type",
            |m: &CMsgQuestMapNodeDef| { &m.star_type },
            |m: &mut CMsgQuestMapNodeDef| { &mut m.star_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stars_to_unlock",
            |m: &CMsgQuestMapNodeDef| { &m.stars_to_unlock },
            |m: &mut CMsgQuestMapNodeDef| { &mut m.stars_to_unlock },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgQuestMapNodeDef>(
            "CMsgQuestMapNodeDef",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgQuestMapNodeDef {
    const NAME: &'static str = "CMsgQuestMapNodeDef";

    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.condition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.owning_region {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.quest_options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.star_type {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                34 => {
                    self.name_loctoken = ::std::option::Option::Some(is.read_string()?);
                },
                53 => {
                    self.x_pos = ::std::option::Option::Some(is.read_float()?);
                },
                61 => {
                    self.y_pos = ::std::option::Option::Some(is.read_float()?);
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.condition)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.owning_region)?;
                },
                90 => {
                    self.quest_options.push(is.read_message()?);
                },
                130 => {
                    self.associated_operation = ::std::option::Option::Some(is.read_string()?);
                },
                146 => {
                    self.reward_item_name = ::std::option::Option::Some(is.read_string()?);
                },
                178 => {
                    self.reward_lootlist_name = ::std::option::Option::Some(is.read_string()?);
                },
                152 => {
                    self.cash_reward = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                162 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.star_type)?;
                },
                168 => {
                    self.stars_to_unlock = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.name_loctoken.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.x_pos {
            my_size += 1 + 4;
        }
        if let Some(v) = self.y_pos {
            my_size += 1 + 4;
        }
        if let Some(v) = self.condition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.owning_region.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.quest_options {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.associated_operation.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        if let Some(v) = self.reward_item_name.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        if let Some(v) = self.reward_lootlist_name.as_ref() {
            my_size += ::protobuf::rt::string_size(22, &v);
        }
        if let Some(v) = self.cash_reward {
            my_size += ::protobuf::rt::int32_size(19, v.value());
        }
        if let Some(v) = self.star_type.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.stars_to_unlock {
            my_size += ::protobuf::rt::uint32_size(21, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.name_loctoken.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.x_pos {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.y_pos {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.condition.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.owning_region.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        for v in &self.quest_options {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        if let Some(v) = self.associated_operation.as_ref() {
            os.write_string(16, v)?;
        }
        if let Some(v) = self.reward_item_name.as_ref() {
            os.write_string(18, v)?;
        }
        if let Some(v) = self.reward_lootlist_name.as_ref() {
            os.write_string(22, v)?;
        }
        if let Some(v) = self.cash_reward {
            os.write_enum(19, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.star_type.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        }
        if let Some(v) = self.stars_to_unlock {
            os.write_uint32(21, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgQuestMapNodeDef {
        CMsgQuestMapNodeDef::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.name_loctoken = ::std::option::Option::None;
        self.x_pos = ::std::option::Option::None;
        self.y_pos = ::std::option::Option::None;
        self.condition.clear();
        self.owning_region.clear();
        self.quest_options.clear();
        self.associated_operation = ::std::option::Option::None;
        self.reward_item_name = ::std::option::Option::None;
        self.reward_lootlist_name = ::std::option::Option::None;
        self.cash_reward = ::std::option::Option::None;
        self.star_type.clear();
        self.stars_to_unlock = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgQuestMapNodeDef {
        static instance: CMsgQuestMapNodeDef = CMsgQuestMapNodeDef {
            header: ::protobuf::MessageField::none(),
            name_loctoken: ::std::option::Option::None,
            x_pos: ::std::option::Option::None,
            y_pos: ::std::option::Option::None,
            condition: ::protobuf::MessageField::none(),
            owning_region: ::protobuf::MessageField::none(),
            quest_options: ::std::vec::Vec::new(),
            associated_operation: ::std::option::Option::None,
            reward_item_name: ::std::option::Option::None,
            reward_lootlist_name: ::std::option::Option::None,
            cash_reward: ::std::option::Option::None,
            star_type: ::protobuf::MessageField::none(),
            stars_to_unlock: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgQuestMapNodeDef {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgQuestMapNodeDef").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgQuestMapNodeDef {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgQuestMapNodeDef {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPaintKit_Variables)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPaintKit_Variables {
    // message fields
    // @@protoc_insertion_point(field:CMsgPaintKit_Variables.header)
    pub header: ::protobuf::MessageField<CMsgProtoDefHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPaintKit_Variables.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPaintKit_Variables {
    fn default() -> &'a CMsgPaintKit_Variables {
        <CMsgPaintKit_Variables as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPaintKit_Variables {
    pub fn new() -> CMsgPaintKit_Variables {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgProtoDefHeader>(
            "header",
            |m: &CMsgPaintKit_Variables| { &m.header },
            |m: &mut CMsgPaintKit_Variables| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPaintKit_Variables>(
            "CMsgPaintKit_Variables",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPaintKit_Variables {
    const NAME: &'static str = "CMsgPaintKit_Variables";

    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPaintKit_Variables {
        CMsgPaintKit_Variables::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPaintKit_Variables {
        static instance: CMsgPaintKit_Variables = CMsgPaintKit_Variables {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPaintKit_Variables {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPaintKit_Variables").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPaintKit_Variables {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPaintKit_Variables {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPaintKit_Operation_TextureStage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPaintKit_Operation_TextureStage {
    // message fields
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_TextureStage.texture)
    pub texture: ::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_TextureStage.texture_red)
    pub texture_red: ::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_TextureStage.texture_blue)
    pub texture_blue: ::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_TextureStage.adjust_black)
    pub adjust_black: ::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_TextureStage.adjust_offset)
    pub adjust_offset: ::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_TextureStage.adjust_gamma)
    pub adjust_gamma: ::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_TextureStage.rotation)
    pub rotation: ::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_TextureStage.translate_u)
    pub translate_u: ::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_TextureStage.translate_v)
    pub translate_v: ::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_TextureStage.scale_uv)
    pub scale_uv: ::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_TextureStage.flip_u)
    pub flip_u: ::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_TextureStage.flip_v)
    pub flip_v: ::protobuf::MessageField<CMsgVarField>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPaintKit_Operation_TextureStage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPaintKit_Operation_TextureStage {
    fn default() -> &'a CMsgPaintKit_Operation_TextureStage {
        <CMsgPaintKit_Operation_TextureStage as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPaintKit_Operation_TextureStage {
    pub fn new() -> CMsgPaintKit_Operation_TextureStage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVarField>(
            "texture",
            |m: &CMsgPaintKit_Operation_TextureStage| { &m.texture },
            |m: &mut CMsgPaintKit_Operation_TextureStage| { &mut m.texture },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVarField>(
            "texture_red",
            |m: &CMsgPaintKit_Operation_TextureStage| { &m.texture_red },
            |m: &mut CMsgPaintKit_Operation_TextureStage| { &mut m.texture_red },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVarField>(
            "texture_blue",
            |m: &CMsgPaintKit_Operation_TextureStage| { &m.texture_blue },
            |m: &mut CMsgPaintKit_Operation_TextureStage| { &mut m.texture_blue },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVarField>(
            "adjust_black",
            |m: &CMsgPaintKit_Operation_TextureStage| { &m.adjust_black },
            |m: &mut CMsgPaintKit_Operation_TextureStage| { &mut m.adjust_black },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVarField>(
            "adjust_offset",
            |m: &CMsgPaintKit_Operation_TextureStage| { &m.adjust_offset },
            |m: &mut CMsgPaintKit_Operation_TextureStage| { &mut m.adjust_offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVarField>(
            "adjust_gamma",
            |m: &CMsgPaintKit_Operation_TextureStage| { &m.adjust_gamma },
            |m: &mut CMsgPaintKit_Operation_TextureStage| { &mut m.adjust_gamma },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVarField>(
            "rotation",
            |m: &CMsgPaintKit_Operation_TextureStage| { &m.rotation },
            |m: &mut CMsgPaintKit_Operation_TextureStage| { &mut m.rotation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVarField>(
            "translate_u",
            |m: &CMsgPaintKit_Operation_TextureStage| { &m.translate_u },
            |m: &mut CMsgPaintKit_Operation_TextureStage| { &mut m.translate_u },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVarField>(
            "translate_v",
            |m: &CMsgPaintKit_Operation_TextureStage| { &m.translate_v },
            |m: &mut CMsgPaintKit_Operation_TextureStage| { &mut m.translate_v },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVarField>(
            "scale_uv",
            |m: &CMsgPaintKit_Operation_TextureStage| { &m.scale_uv },
            |m: &mut CMsgPaintKit_Operation_TextureStage| { &mut m.scale_uv },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVarField>(
            "flip_u",
            |m: &CMsgPaintKit_Operation_TextureStage| { &m.flip_u },
            |m: &mut CMsgPaintKit_Operation_TextureStage| { &mut m.flip_u },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVarField>(
            "flip_v",
            |m: &CMsgPaintKit_Operation_TextureStage| { &m.flip_v },
            |m: &mut CMsgPaintKit_Operation_TextureStage| { &mut m.flip_v },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPaintKit_Operation_TextureStage>(
            "CMsgPaintKit_Operation_TextureStage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPaintKit_Operation_TextureStage {
    const NAME: &'static str = "CMsgPaintKit_Operation_TextureStage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.texture)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.texture_red)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.texture_blue)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.adjust_black)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.adjust_offset)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.adjust_gamma)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rotation)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.translate_u)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.translate_v)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.scale_uv)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.flip_u)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.flip_v)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.texture.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.texture_red.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.texture_blue.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.adjust_black.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.adjust_offset.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.adjust_gamma.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.rotation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.translate_u.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.translate_v.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.scale_uv.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.flip_u.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.flip_v.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.texture.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.texture_red.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.texture_blue.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.adjust_black.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.adjust_offset.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.adjust_gamma.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.rotation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.translate_u.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.translate_v.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.scale_uv.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.flip_u.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.flip_v.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPaintKit_Operation_TextureStage {
        CMsgPaintKit_Operation_TextureStage::new()
    }

    fn clear(&mut self) {
        self.texture.clear();
        self.texture_red.clear();
        self.texture_blue.clear();
        self.adjust_black.clear();
        self.adjust_offset.clear();
        self.adjust_gamma.clear();
        self.rotation.clear();
        self.translate_u.clear();
        self.translate_v.clear();
        self.scale_uv.clear();
        self.flip_u.clear();
        self.flip_v.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPaintKit_Operation_TextureStage {
        static instance: CMsgPaintKit_Operation_TextureStage = CMsgPaintKit_Operation_TextureStage {
            texture: ::protobuf::MessageField::none(),
            texture_red: ::protobuf::MessageField::none(),
            texture_blue: ::protobuf::MessageField::none(),
            adjust_black: ::protobuf::MessageField::none(),
            adjust_offset: ::protobuf::MessageField::none(),
            adjust_gamma: ::protobuf::MessageField::none(),
            rotation: ::protobuf::MessageField::none(),
            translate_u: ::protobuf::MessageField::none(),
            translate_v: ::protobuf::MessageField::none(),
            scale_uv: ::protobuf::MessageField::none(),
            flip_u: ::protobuf::MessageField::none(),
            flip_v: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPaintKit_Operation_TextureStage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPaintKit_Operation_TextureStage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPaintKit_Operation_TextureStage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPaintKit_Operation_TextureStage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPaintKit_Operation_CombineStage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPaintKit_Operation_CombineStage {
    // message fields
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_CombineStage.adjust_black)
    pub adjust_black: ::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_CombineStage.adjust_offset)
    pub adjust_offset: ::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_CombineStage.adjust_gamma)
    pub adjust_gamma: ::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_CombineStage.rotation)
    pub rotation: ::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_CombineStage.translate_u)
    pub translate_u: ::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_CombineStage.translate_v)
    pub translate_v: ::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_CombineStage.scale_uv)
    pub scale_uv: ::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_CombineStage.flip_u)
    pub flip_u: ::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_CombineStage.flip_v)
    pub flip_v: ::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_CombineStage.operation_node)
    pub operation_node: ::std::vec::Vec<CMsgPaintKit_OperationNode>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPaintKit_Operation_CombineStage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPaintKit_Operation_CombineStage {
    fn default() -> &'a CMsgPaintKit_Operation_CombineStage {
        <CMsgPaintKit_Operation_CombineStage as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPaintKit_Operation_CombineStage {
    pub fn new() -> CMsgPaintKit_Operation_CombineStage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVarField>(
            "adjust_black",
            |m: &CMsgPaintKit_Operation_CombineStage| { &m.adjust_black },
            |m: &mut CMsgPaintKit_Operation_CombineStage| { &mut m.adjust_black },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVarField>(
            "adjust_offset",
            |m: &CMsgPaintKit_Operation_CombineStage| { &m.adjust_offset },
            |m: &mut CMsgPaintKit_Operation_CombineStage| { &mut m.adjust_offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVarField>(
            "adjust_gamma",
            |m: &CMsgPaintKit_Operation_CombineStage| { &m.adjust_gamma },
            |m: &mut CMsgPaintKit_Operation_CombineStage| { &mut m.adjust_gamma },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVarField>(
            "rotation",
            |m: &CMsgPaintKit_Operation_CombineStage| { &m.rotation },
            |m: &mut CMsgPaintKit_Operation_CombineStage| { &mut m.rotation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVarField>(
            "translate_u",
            |m: &CMsgPaintKit_Operation_CombineStage| { &m.translate_u },
            |m: &mut CMsgPaintKit_Operation_CombineStage| { &mut m.translate_u },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVarField>(
            "translate_v",
            |m: &CMsgPaintKit_Operation_CombineStage| { &m.translate_v },
            |m: &mut CMsgPaintKit_Operation_CombineStage| { &mut m.translate_v },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVarField>(
            "scale_uv",
            |m: &CMsgPaintKit_Operation_CombineStage| { &m.scale_uv },
            |m: &mut CMsgPaintKit_Operation_CombineStage| { &mut m.scale_uv },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVarField>(
            "flip_u",
            |m: &CMsgPaintKit_Operation_CombineStage| { &m.flip_u },
            |m: &mut CMsgPaintKit_Operation_CombineStage| { &mut m.flip_u },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVarField>(
            "flip_v",
            |m: &CMsgPaintKit_Operation_CombineStage| { &m.flip_v },
            |m: &mut CMsgPaintKit_Operation_CombineStage| { &mut m.flip_v },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "operation_node",
            |m: &CMsgPaintKit_Operation_CombineStage| { &m.operation_node },
            |m: &mut CMsgPaintKit_Operation_CombineStage| { &mut m.operation_node },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPaintKit_Operation_CombineStage>(
            "CMsgPaintKit_Operation_CombineStage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPaintKit_Operation_CombineStage {
    const NAME: &'static str = "CMsgPaintKit_Operation_CombineStage";

    fn is_initialized(&self) -> bool {
        for v in &self.adjust_black {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.adjust_offset {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.adjust_gamma {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rotation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.translate_u {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.translate_v {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scale_uv {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.flip_u {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.flip_v {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.operation_node {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.adjust_black)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.adjust_offset)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.adjust_gamma)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rotation)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.translate_u)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.translate_v)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.scale_uv)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.flip_u)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.flip_v)?;
                },
                90 => {
                    self.operation_node.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.adjust_black.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.adjust_offset.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.adjust_gamma.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.rotation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.translate_u.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.translate_v.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.scale_uv.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.flip_u.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.flip_v.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.operation_node {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.adjust_black.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.adjust_offset.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.adjust_gamma.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.rotation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.translate_u.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.translate_v.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.scale_uv.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.flip_u.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.flip_v.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        for v in &self.operation_node {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPaintKit_Operation_CombineStage {
        CMsgPaintKit_Operation_CombineStage::new()
    }

    fn clear(&mut self) {
        self.adjust_black.clear();
        self.adjust_offset.clear();
        self.adjust_gamma.clear();
        self.rotation.clear();
        self.translate_u.clear();
        self.translate_v.clear();
        self.scale_uv.clear();
        self.flip_u.clear();
        self.flip_v.clear();
        self.operation_node.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPaintKit_Operation_CombineStage {
        static instance: CMsgPaintKit_Operation_CombineStage = CMsgPaintKit_Operation_CombineStage {
            adjust_black: ::protobuf::MessageField::none(),
            adjust_offset: ::protobuf::MessageField::none(),
            adjust_gamma: ::protobuf::MessageField::none(),
            rotation: ::protobuf::MessageField::none(),
            translate_u: ::protobuf::MessageField::none(),
            translate_v: ::protobuf::MessageField::none(),
            scale_uv: ::protobuf::MessageField::none(),
            flip_u: ::protobuf::MessageField::none(),
            flip_v: ::protobuf::MessageField::none(),
            operation_node: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPaintKit_Operation_CombineStage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPaintKit_Operation_CombineStage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPaintKit_Operation_CombineStage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPaintKit_Operation_CombineStage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPaintKit_Operation_SelectStage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPaintKit_Operation_SelectStage {
    // message fields
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_SelectStage.groups)
    pub groups: ::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_SelectStage.select)
    pub select: ::std::vec::Vec<CMsgVarField>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPaintKit_Operation_SelectStage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPaintKit_Operation_SelectStage {
    fn default() -> &'a CMsgPaintKit_Operation_SelectStage {
        <CMsgPaintKit_Operation_SelectStage as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPaintKit_Operation_SelectStage {
    pub fn new() -> CMsgPaintKit_Operation_SelectStage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVarField>(
            "groups",
            |m: &CMsgPaintKit_Operation_SelectStage| { &m.groups },
            |m: &mut CMsgPaintKit_Operation_SelectStage| { &mut m.groups },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "select",
            |m: &CMsgPaintKit_Operation_SelectStage| { &m.select },
            |m: &mut CMsgPaintKit_Operation_SelectStage| { &mut m.select },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPaintKit_Operation_SelectStage>(
            "CMsgPaintKit_Operation_SelectStage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPaintKit_Operation_SelectStage {
    const NAME: &'static str = "CMsgPaintKit_Operation_SelectStage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.groups)?;
                },
                18 => {
                    self.select.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.groups.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.select {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.groups.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.select {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPaintKit_Operation_SelectStage {
        CMsgPaintKit_Operation_SelectStage::new()
    }

    fn clear(&mut self) {
        self.groups.clear();
        self.select.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPaintKit_Operation_SelectStage {
        static instance: CMsgPaintKit_Operation_SelectStage = CMsgPaintKit_Operation_SelectStage {
            groups: ::protobuf::MessageField::none(),
            select: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPaintKit_Operation_SelectStage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPaintKit_Operation_SelectStage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPaintKit_Operation_SelectStage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPaintKit_Operation_SelectStage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPaintKit_Operation_Sticker)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPaintKit_Operation_Sticker {
    // message fields
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_Sticker.base)
    pub base: ::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_Sticker.weight)
    pub weight: ::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_Sticker.spec)
    pub spec: ::protobuf::MessageField<CMsgVarField>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPaintKit_Operation_Sticker.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPaintKit_Operation_Sticker {
    fn default() -> &'a CMsgPaintKit_Operation_Sticker {
        <CMsgPaintKit_Operation_Sticker as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPaintKit_Operation_Sticker {
    pub fn new() -> CMsgPaintKit_Operation_Sticker {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVarField>(
            "base",
            |m: &CMsgPaintKit_Operation_Sticker| { &m.base },
            |m: &mut CMsgPaintKit_Operation_Sticker| { &mut m.base },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVarField>(
            "weight",
            |m: &CMsgPaintKit_Operation_Sticker| { &m.weight },
            |m: &mut CMsgPaintKit_Operation_Sticker| { &mut m.weight },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVarField>(
            "spec",
            |m: &CMsgPaintKit_Operation_Sticker| { &m.spec },
            |m: &mut CMsgPaintKit_Operation_Sticker| { &mut m.spec },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPaintKit_Operation_Sticker>(
            "CMsgPaintKit_Operation_Sticker",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPaintKit_Operation_Sticker {
    const NAME: &'static str = "CMsgPaintKit_Operation_Sticker";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.weight)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.weight.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.weight.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPaintKit_Operation_Sticker {
        CMsgPaintKit_Operation_Sticker::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.weight.clear();
        self.spec.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPaintKit_Operation_Sticker {
        static instance: CMsgPaintKit_Operation_Sticker = CMsgPaintKit_Operation_Sticker {
            base: ::protobuf::MessageField::none(),
            weight: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPaintKit_Operation_Sticker {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPaintKit_Operation_Sticker").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPaintKit_Operation_Sticker {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPaintKit_Operation_Sticker {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPaintKit_Operation_StickerStage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPaintKit_Operation_StickerStage {
    // message fields
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_StickerStage.sticker)
    pub sticker: ::std::vec::Vec<CMsgPaintKit_Operation_Sticker>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_StickerStage.dest_tl)
    pub dest_tl: ::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_StickerStage.dest_tr)
    pub dest_tr: ::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_StickerStage.dest_bl)
    pub dest_bl: ::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_StickerStage.adjust_black)
    pub adjust_black: ::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_StickerStage.adjust_offset)
    pub adjust_offset: ::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_StickerStage.adjust_gamma)
    pub adjust_gamma: ::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_StickerStage.operation_node)
    pub operation_node: ::std::vec::Vec<CMsgPaintKit_OperationNode>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPaintKit_Operation_StickerStage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPaintKit_Operation_StickerStage {
    fn default() -> &'a CMsgPaintKit_Operation_StickerStage {
        <CMsgPaintKit_Operation_StickerStage as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPaintKit_Operation_StickerStage {
    pub fn new() -> CMsgPaintKit_Operation_StickerStage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sticker",
            |m: &CMsgPaintKit_Operation_StickerStage| { &m.sticker },
            |m: &mut CMsgPaintKit_Operation_StickerStage| { &mut m.sticker },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVarField>(
            "dest_tl",
            |m: &CMsgPaintKit_Operation_StickerStage| { &m.dest_tl },
            |m: &mut CMsgPaintKit_Operation_StickerStage| { &mut m.dest_tl },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVarField>(
            "dest_tr",
            |m: &CMsgPaintKit_Operation_StickerStage| { &m.dest_tr },
            |m: &mut CMsgPaintKit_Operation_StickerStage| { &mut m.dest_tr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVarField>(
            "dest_bl",
            |m: &CMsgPaintKit_Operation_StickerStage| { &m.dest_bl },
            |m: &mut CMsgPaintKit_Operation_StickerStage| { &mut m.dest_bl },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVarField>(
            "adjust_black",
            |m: &CMsgPaintKit_Operation_StickerStage| { &m.adjust_black },
            |m: &mut CMsgPaintKit_Operation_StickerStage| { &mut m.adjust_black },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVarField>(
            "adjust_offset",
            |m: &CMsgPaintKit_Operation_StickerStage| { &m.adjust_offset },
            |m: &mut CMsgPaintKit_Operation_StickerStage| { &mut m.adjust_offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVarField>(
            "adjust_gamma",
            |m: &CMsgPaintKit_Operation_StickerStage| { &m.adjust_gamma },
            |m: &mut CMsgPaintKit_Operation_StickerStage| { &mut m.adjust_gamma },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "operation_node",
            |m: &CMsgPaintKit_Operation_StickerStage| { &m.operation_node },
            |m: &mut CMsgPaintKit_Operation_StickerStage| { &mut m.operation_node },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPaintKit_Operation_StickerStage>(
            "CMsgPaintKit_Operation_StickerStage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPaintKit_Operation_StickerStage {
    const NAME: &'static str = "CMsgPaintKit_Operation_StickerStage";

    fn is_initialized(&self) -> bool {
        for v in &self.sticker {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dest_tl {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dest_tr {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dest_bl {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.adjust_black {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.adjust_offset {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.adjust_gamma {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.operation_node {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sticker.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dest_tl)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dest_tr)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dest_bl)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.adjust_black)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.adjust_offset)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.adjust_gamma)?;
                },
                74 => {
                    self.operation_node.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.sticker {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.dest_tl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dest_tr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dest_bl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.adjust_black.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.adjust_offset.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.adjust_gamma.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.operation_node {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.sticker {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.dest_tl.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.dest_tr.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.dest_bl.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.adjust_black.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.adjust_offset.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.adjust_gamma.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        for v in &self.operation_node {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPaintKit_Operation_StickerStage {
        CMsgPaintKit_Operation_StickerStage::new()
    }

    fn clear(&mut self) {
        self.sticker.clear();
        self.dest_tl.clear();
        self.dest_tr.clear();
        self.dest_bl.clear();
        self.adjust_black.clear();
        self.adjust_offset.clear();
        self.adjust_gamma.clear();
        self.operation_node.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPaintKit_Operation_StickerStage {
        static instance: CMsgPaintKit_Operation_StickerStage = CMsgPaintKit_Operation_StickerStage {
            sticker: ::std::vec::Vec::new(),
            dest_tl: ::protobuf::MessageField::none(),
            dest_tr: ::protobuf::MessageField::none(),
            dest_bl: ::protobuf::MessageField::none(),
            adjust_black: ::protobuf::MessageField::none(),
            adjust_offset: ::protobuf::MessageField::none(),
            adjust_gamma: ::protobuf::MessageField::none(),
            operation_node: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPaintKit_Operation_StickerStage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPaintKit_Operation_StickerStage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPaintKit_Operation_StickerStage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPaintKit_Operation_StickerStage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPaintKit_OperationStage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPaintKit_OperationStage {
    // message oneof groups
    pub stage: ::std::option::Option<cmsg_paint_kit_operation_stage::Stage>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPaintKit_OperationStage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPaintKit_OperationStage {
    fn default() -> &'a CMsgPaintKit_OperationStage {
        <CMsgPaintKit_OperationStage as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPaintKit_OperationStage {
    pub fn new() -> CMsgPaintKit_OperationStage {
        ::std::default::Default::default()
    }

    // optional .CMsgPaintKit_Operation_TextureStage texture_lookup = 1;

    pub fn texture_lookup(&self) -> &CMsgPaintKit_Operation_TextureStage {
        match self.stage {
            ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::TextureLookup(ref v)) => v,
            _ => <CMsgPaintKit_Operation_TextureStage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_texture_lookup(&mut self) {
        self.stage = ::std::option::Option::None;
    }

    pub fn has_texture_lookup(&self) -> bool {
        match self.stage {
            ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::TextureLookup(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_texture_lookup(&mut self, v: CMsgPaintKit_Operation_TextureStage) {
        self.stage = ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::TextureLookup(v))
    }

    // Mutable pointer to the field.
    pub fn mut_texture_lookup(&mut self) -> &mut CMsgPaintKit_Operation_TextureStage {
        if let ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::TextureLookup(_)) = self.stage {
        } else {
            self.stage = ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::TextureLookup(CMsgPaintKit_Operation_TextureStage::new()));
        }
        match self.stage {
            ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::TextureLookup(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_texture_lookup(&mut self) -> CMsgPaintKit_Operation_TextureStage {
        if self.has_texture_lookup() {
            match self.stage.take() {
                ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::TextureLookup(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgPaintKit_Operation_TextureStage::new()
        }
    }

    // optional .CMsgPaintKit_Operation_CombineStage combine_add = 2;

    pub fn combine_add(&self) -> &CMsgPaintKit_Operation_CombineStage {
        match self.stage {
            ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineAdd(ref v)) => v,
            _ => <CMsgPaintKit_Operation_CombineStage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_combine_add(&mut self) {
        self.stage = ::std::option::Option::None;
    }

    pub fn has_combine_add(&self) -> bool {
        match self.stage {
            ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineAdd(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_combine_add(&mut self, v: CMsgPaintKit_Operation_CombineStage) {
        self.stage = ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineAdd(v))
    }

    // Mutable pointer to the field.
    pub fn mut_combine_add(&mut self) -> &mut CMsgPaintKit_Operation_CombineStage {
        if let ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineAdd(_)) = self.stage {
        } else {
            self.stage = ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineAdd(CMsgPaintKit_Operation_CombineStage::new()));
        }
        match self.stage {
            ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineAdd(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_combine_add(&mut self) -> CMsgPaintKit_Operation_CombineStage {
        if self.has_combine_add() {
            match self.stage.take() {
                ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineAdd(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgPaintKit_Operation_CombineStage::new()
        }
    }

    // optional .CMsgPaintKit_Operation_CombineStage combine_lerp = 3;

    pub fn combine_lerp(&self) -> &CMsgPaintKit_Operation_CombineStage {
        match self.stage {
            ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineLerp(ref v)) => v,
            _ => <CMsgPaintKit_Operation_CombineStage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_combine_lerp(&mut self) {
        self.stage = ::std::option::Option::None;
    }

    pub fn has_combine_lerp(&self) -> bool {
        match self.stage {
            ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineLerp(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_combine_lerp(&mut self, v: CMsgPaintKit_Operation_CombineStage) {
        self.stage = ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineLerp(v))
    }

    // Mutable pointer to the field.
    pub fn mut_combine_lerp(&mut self) -> &mut CMsgPaintKit_Operation_CombineStage {
        if let ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineLerp(_)) = self.stage {
        } else {
            self.stage = ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineLerp(CMsgPaintKit_Operation_CombineStage::new()));
        }
        match self.stage {
            ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineLerp(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_combine_lerp(&mut self) -> CMsgPaintKit_Operation_CombineStage {
        if self.has_combine_lerp() {
            match self.stage.take() {
                ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineLerp(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgPaintKit_Operation_CombineStage::new()
        }
    }

    // optional .CMsgPaintKit_Operation_CombineStage combine_multiply = 4;

    pub fn combine_multiply(&self) -> &CMsgPaintKit_Operation_CombineStage {
        match self.stage {
            ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineMultiply(ref v)) => v,
            _ => <CMsgPaintKit_Operation_CombineStage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_combine_multiply(&mut self) {
        self.stage = ::std::option::Option::None;
    }

    pub fn has_combine_multiply(&self) -> bool {
        match self.stage {
            ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineMultiply(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_combine_multiply(&mut self, v: CMsgPaintKit_Operation_CombineStage) {
        self.stage = ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineMultiply(v))
    }

    // Mutable pointer to the field.
    pub fn mut_combine_multiply(&mut self) -> &mut CMsgPaintKit_Operation_CombineStage {
        if let ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineMultiply(_)) = self.stage {
        } else {
            self.stage = ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineMultiply(CMsgPaintKit_Operation_CombineStage::new()));
        }
        match self.stage {
            ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineMultiply(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_combine_multiply(&mut self) -> CMsgPaintKit_Operation_CombineStage {
        if self.has_combine_multiply() {
            match self.stage.take() {
                ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineMultiply(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgPaintKit_Operation_CombineStage::new()
        }
    }

    // optional .CMsgPaintKit_Operation_SelectStage select = 5;

    pub fn select(&self) -> &CMsgPaintKit_Operation_SelectStage {
        match self.stage {
            ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::Select(ref v)) => v,
            _ => <CMsgPaintKit_Operation_SelectStage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_select(&mut self) {
        self.stage = ::std::option::Option::None;
    }

    pub fn has_select(&self) -> bool {
        match self.stage {
            ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::Select(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_select(&mut self, v: CMsgPaintKit_Operation_SelectStage) {
        self.stage = ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::Select(v))
    }

    // Mutable pointer to the field.
    pub fn mut_select(&mut self) -> &mut CMsgPaintKit_Operation_SelectStage {
        if let ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::Select(_)) = self.stage {
        } else {
            self.stage = ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::Select(CMsgPaintKit_Operation_SelectStage::new()));
        }
        match self.stage {
            ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::Select(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_select(&mut self) -> CMsgPaintKit_Operation_SelectStage {
        if self.has_select() {
            match self.stage.take() {
                ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::Select(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgPaintKit_Operation_SelectStage::new()
        }
    }

    // optional .CMsgPaintKit_Operation_StickerStage apply_sticker = 6;

    pub fn apply_sticker(&self) -> &CMsgPaintKit_Operation_StickerStage {
        match self.stage {
            ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::ApplySticker(ref v)) => v,
            _ => <CMsgPaintKit_Operation_StickerStage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_apply_sticker(&mut self) {
        self.stage = ::std::option::Option::None;
    }

    pub fn has_apply_sticker(&self) -> bool {
        match self.stage {
            ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::ApplySticker(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_apply_sticker(&mut self, v: CMsgPaintKit_Operation_StickerStage) {
        self.stage = ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::ApplySticker(v))
    }

    // Mutable pointer to the field.
    pub fn mut_apply_sticker(&mut self) -> &mut CMsgPaintKit_Operation_StickerStage {
        if let ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::ApplySticker(_)) = self.stage {
        } else {
            self.stage = ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::ApplySticker(CMsgPaintKit_Operation_StickerStage::new()));
        }
        match self.stage {
            ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::ApplySticker(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_apply_sticker(&mut self) -> CMsgPaintKit_Operation_StickerStage {
        if self.has_apply_sticker() {
            match self.stage.take() {
                ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::ApplySticker(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgPaintKit_Operation_StickerStage::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CMsgPaintKit_Operation_TextureStage>(
            "texture_lookup",
            CMsgPaintKit_OperationStage::has_texture_lookup,
            CMsgPaintKit_OperationStage::texture_lookup,
            CMsgPaintKit_OperationStage::mut_texture_lookup,
            CMsgPaintKit_OperationStage::set_texture_lookup,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CMsgPaintKit_Operation_CombineStage>(
            "combine_add",
            CMsgPaintKit_OperationStage::has_combine_add,
            CMsgPaintKit_OperationStage::combine_add,
            CMsgPaintKit_OperationStage::mut_combine_add,
            CMsgPaintKit_OperationStage::set_combine_add,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CMsgPaintKit_Operation_CombineStage>(
            "combine_lerp",
            CMsgPaintKit_OperationStage::has_combine_lerp,
            CMsgPaintKit_OperationStage::combine_lerp,
            CMsgPaintKit_OperationStage::mut_combine_lerp,
            CMsgPaintKit_OperationStage::set_combine_lerp,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CMsgPaintKit_Operation_CombineStage>(
            "combine_multiply",
            CMsgPaintKit_OperationStage::has_combine_multiply,
            CMsgPaintKit_OperationStage::combine_multiply,
            CMsgPaintKit_OperationStage::mut_combine_multiply,
            CMsgPaintKit_OperationStage::set_combine_multiply,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CMsgPaintKit_Operation_SelectStage>(
            "select",
            CMsgPaintKit_OperationStage::has_select,
            CMsgPaintKit_OperationStage::select,
            CMsgPaintKit_OperationStage::mut_select,
            CMsgPaintKit_OperationStage::set_select,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CMsgPaintKit_Operation_StickerStage>(
            "apply_sticker",
            CMsgPaintKit_OperationStage::has_apply_sticker,
            CMsgPaintKit_OperationStage::apply_sticker,
            CMsgPaintKit_OperationStage::mut_apply_sticker,
            CMsgPaintKit_OperationStage::set_apply_sticker,
        ));
        oneofs.push(cmsg_paint_kit_operation_stage::Stage::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPaintKit_OperationStage>(
            "CMsgPaintKit_OperationStage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPaintKit_OperationStage {
    const NAME: &'static str = "CMsgPaintKit_OperationStage";

    fn is_initialized(&self) -> bool {
        if let Some(cmsg_paint_kit_operation_stage::Stage::TextureLookup(ref v)) = self.stage {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(cmsg_paint_kit_operation_stage::Stage::CombineAdd(ref v)) = self.stage {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(cmsg_paint_kit_operation_stage::Stage::CombineLerp(ref v)) = self.stage {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(cmsg_paint_kit_operation_stage::Stage::CombineMultiply(ref v)) = self.stage {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(cmsg_paint_kit_operation_stage::Stage::Select(ref v)) = self.stage {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(cmsg_paint_kit_operation_stage::Stage::ApplySticker(ref v)) = self.stage {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.stage = ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::TextureLookup(is.read_message()?));
                },
                18 => {
                    self.stage = ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineAdd(is.read_message()?));
                },
                26 => {
                    self.stage = ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineLerp(is.read_message()?));
                },
                34 => {
                    self.stage = ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineMultiply(is.read_message()?));
                },
                42 => {
                    self.stage = ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::Select(is.read_message()?));
                },
                50 => {
                    self.stage = ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::ApplySticker(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.stage {
            match v {
                &cmsg_paint_kit_operation_stage::Stage::TextureLookup(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_paint_kit_operation_stage::Stage::CombineAdd(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_paint_kit_operation_stage::Stage::CombineLerp(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_paint_kit_operation_stage::Stage::CombineMultiply(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_paint_kit_operation_stage::Stage::Select(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_paint_kit_operation_stage::Stage::ApplySticker(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.stage {
            match v {
                &cmsg_paint_kit_operation_stage::Stage::TextureLookup(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &cmsg_paint_kit_operation_stage::Stage::CombineAdd(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &cmsg_paint_kit_operation_stage::Stage::CombineLerp(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &cmsg_paint_kit_operation_stage::Stage::CombineMultiply(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &cmsg_paint_kit_operation_stage::Stage::Select(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &cmsg_paint_kit_operation_stage::Stage::ApplySticker(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPaintKit_OperationStage {
        CMsgPaintKit_OperationStage::new()
    }

    fn clear(&mut self) {
        self.stage = ::std::option::Option::None;
        self.stage = ::std::option::Option::None;
        self.stage = ::std::option::Option::None;
        self.stage = ::std::option::Option::None;
        self.stage = ::std::option::Option::None;
        self.stage = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPaintKit_OperationStage {
        static instance: CMsgPaintKit_OperationStage = CMsgPaintKit_OperationStage {
            stage: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPaintKit_OperationStage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPaintKit_OperationStage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPaintKit_OperationStage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPaintKit_OperationStage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgPaintKit_OperationStage`
pub mod cmsg_paint_kit_operation_stage {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:CMsgPaintKit_OperationStage.stage)
    pub enum Stage {
        // @@protoc_insertion_point(oneof_field:CMsgPaintKit_OperationStage.texture_lookup)
        TextureLookup(super::CMsgPaintKit_Operation_TextureStage),
        // @@protoc_insertion_point(oneof_field:CMsgPaintKit_OperationStage.combine_add)
        CombineAdd(super::CMsgPaintKit_Operation_CombineStage),
        // @@protoc_insertion_point(oneof_field:CMsgPaintKit_OperationStage.combine_lerp)
        CombineLerp(super::CMsgPaintKit_Operation_CombineStage),
        // @@protoc_insertion_point(oneof_field:CMsgPaintKit_OperationStage.combine_multiply)
        CombineMultiply(super::CMsgPaintKit_Operation_CombineStage),
        // @@protoc_insertion_point(oneof_field:CMsgPaintKit_OperationStage.select)
        Select(super::CMsgPaintKit_Operation_SelectStage),
        // @@protoc_insertion_point(oneof_field:CMsgPaintKit_OperationStage.apply_sticker)
        ApplySticker(super::CMsgPaintKit_Operation_StickerStage),
    }

    impl ::protobuf::Oneof for Stage {
    }

    impl ::protobuf::OneofFull for Stage {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::CMsgPaintKit_OperationStage as ::protobuf::MessageFull>::descriptor().oneof_by_name("stage").unwrap()).clone()
        }
    }

    impl Stage {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Stage>("stage")
        }
    }
}

// @@protoc_insertion_point(message:CMsgPaintKit_OperationNode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPaintKit_OperationNode {
    // message oneof groups
    pub node: ::std::option::Option<cmsg_paint_kit_operation_node::Node>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPaintKit_OperationNode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPaintKit_OperationNode {
    fn default() -> &'a CMsgPaintKit_OperationNode {
        <CMsgPaintKit_OperationNode as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPaintKit_OperationNode {
    pub fn new() -> CMsgPaintKit_OperationNode {
        ::std::default::Default::default()
    }

    // optional .CMsgPaintKit_OperationStage stage = 1;

    pub fn stage(&self) -> &CMsgPaintKit_OperationStage {
        match self.node {
            ::std::option::Option::Some(cmsg_paint_kit_operation_node::Node::Stage(ref v)) => v,
            _ => <CMsgPaintKit_OperationStage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_stage(&mut self) {
        self.node = ::std::option::Option::None;
    }

    pub fn has_stage(&self) -> bool {
        match self.node {
            ::std::option::Option::Some(cmsg_paint_kit_operation_node::Node::Stage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_stage(&mut self, v: CMsgPaintKit_OperationStage) {
        self.node = ::std::option::Option::Some(cmsg_paint_kit_operation_node::Node::Stage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_stage(&mut self) -> &mut CMsgPaintKit_OperationStage {
        if let ::std::option::Option::Some(cmsg_paint_kit_operation_node::Node::Stage(_)) = self.node {
        } else {
            self.node = ::std::option::Option::Some(cmsg_paint_kit_operation_node::Node::Stage(CMsgPaintKit_OperationStage::new()));
        }
        match self.node {
            ::std::option::Option::Some(cmsg_paint_kit_operation_node::Node::Stage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_stage(&mut self) -> CMsgPaintKit_OperationStage {
        if self.has_stage() {
            match self.node.take() {
                ::std::option::Option::Some(cmsg_paint_kit_operation_node::Node::Stage(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgPaintKit_OperationStage::new()
        }
    }

    // optional .CMsgProtoDefID operation_template = 2;

    pub fn operation_template(&self) -> &CMsgProtoDefID {
        match self.node {
            ::std::option::Option::Some(cmsg_paint_kit_operation_node::Node::OperationTemplate(ref v)) => v,
            _ => <CMsgProtoDefID as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_operation_template(&mut self) {
        self.node = ::std::option::Option::None;
    }

    pub fn has_operation_template(&self) -> bool {
        match self.node {
            ::std::option::Option::Some(cmsg_paint_kit_operation_node::Node::OperationTemplate(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_operation_template(&mut self, v: CMsgProtoDefID) {
        self.node = ::std::option::Option::Some(cmsg_paint_kit_operation_node::Node::OperationTemplate(v))
    }

    // Mutable pointer to the field.
    pub fn mut_operation_template(&mut self) -> &mut CMsgProtoDefID {
        if let ::std::option::Option::Some(cmsg_paint_kit_operation_node::Node::OperationTemplate(_)) = self.node {
        } else {
            self.node = ::std::option::Option::Some(cmsg_paint_kit_operation_node::Node::OperationTemplate(CMsgProtoDefID::new()));
        }
        match self.node {
            ::std::option::Option::Some(cmsg_paint_kit_operation_node::Node::OperationTemplate(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_operation_template(&mut self) -> CMsgProtoDefID {
        if self.has_operation_template() {
            match self.node.take() {
                ::std::option::Option::Some(cmsg_paint_kit_operation_node::Node::OperationTemplate(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgProtoDefID::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CMsgPaintKit_OperationStage>(
            "stage",
            CMsgPaintKit_OperationNode::has_stage,
            CMsgPaintKit_OperationNode::stage,
            CMsgPaintKit_OperationNode::mut_stage,
            CMsgPaintKit_OperationNode::set_stage,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CMsgProtoDefID>(
            "operation_template",
            CMsgPaintKit_OperationNode::has_operation_template,
            CMsgPaintKit_OperationNode::operation_template,
            CMsgPaintKit_OperationNode::mut_operation_template,
            CMsgPaintKit_OperationNode::set_operation_template,
        ));
        oneofs.push(cmsg_paint_kit_operation_node::Node::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPaintKit_OperationNode>(
            "CMsgPaintKit_OperationNode",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPaintKit_OperationNode {
    const NAME: &'static str = "CMsgPaintKit_OperationNode";

    fn is_initialized(&self) -> bool {
        if let Some(cmsg_paint_kit_operation_node::Node::Stage(ref v)) = self.node {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(cmsg_paint_kit_operation_node::Node::OperationTemplate(ref v)) = self.node {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.node = ::std::option::Option::Some(cmsg_paint_kit_operation_node::Node::Stage(is.read_message()?));
                },
                18 => {
                    self.node = ::std::option::Option::Some(cmsg_paint_kit_operation_node::Node::OperationTemplate(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.node {
            match v {
                &cmsg_paint_kit_operation_node::Node::Stage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_paint_kit_operation_node::Node::OperationTemplate(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.node {
            match v {
                &cmsg_paint_kit_operation_node::Node::Stage(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &cmsg_paint_kit_operation_node::Node::OperationTemplate(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPaintKit_OperationNode {
        CMsgPaintKit_OperationNode::new()
    }

    fn clear(&mut self) {
        self.node = ::std::option::Option::None;
        self.node = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPaintKit_OperationNode {
        static instance: CMsgPaintKit_OperationNode = CMsgPaintKit_OperationNode {
            node: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPaintKit_OperationNode {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPaintKit_OperationNode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPaintKit_OperationNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPaintKit_OperationNode {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgPaintKit_OperationNode`
pub mod cmsg_paint_kit_operation_node {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:CMsgPaintKit_OperationNode.node)
    pub enum Node {
        // @@protoc_insertion_point(oneof_field:CMsgPaintKit_OperationNode.stage)
        Stage(super::CMsgPaintKit_OperationStage),
        // @@protoc_insertion_point(oneof_field:CMsgPaintKit_OperationNode.operation_template)
        OperationTemplate(super::CMsgProtoDefID),
    }

    impl ::protobuf::Oneof for Node {
    }

    impl ::protobuf::OneofFull for Node {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::CMsgPaintKit_OperationNode as ::protobuf::MessageFull>::descriptor().oneof_by_name("node").unwrap()).clone()
        }
    }

    impl Node {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Node>("node")
        }
    }
}

// @@protoc_insertion_point(message:CMsgPaintKit_Operation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPaintKit_Operation {
    // message fields
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation.header)
    pub header: ::protobuf::MessageField<CMsgProtoDefHeader>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation.operation_node)
    pub operation_node: ::std::vec::Vec<CMsgPaintKit_OperationNode>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPaintKit_Operation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPaintKit_Operation {
    fn default() -> &'a CMsgPaintKit_Operation {
        <CMsgPaintKit_Operation as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPaintKit_Operation {
    pub fn new() -> CMsgPaintKit_Operation {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgProtoDefHeader>(
            "header",
            |m: &CMsgPaintKit_Operation| { &m.header },
            |m: &mut CMsgPaintKit_Operation| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "operation_node",
            |m: &CMsgPaintKit_Operation| { &m.operation_node },
            |m: &mut CMsgPaintKit_Operation| { &mut m.operation_node },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPaintKit_Operation>(
            "CMsgPaintKit_Operation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPaintKit_Operation {
    const NAME: &'static str = "CMsgPaintKit_Operation";

    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.operation_node {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.operation_node.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.operation_node {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.operation_node {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPaintKit_Operation {
        CMsgPaintKit_Operation::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.operation_node.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPaintKit_Operation {
        static instance: CMsgPaintKit_Operation = CMsgPaintKit_Operation {
            header: ::protobuf::MessageField::none(),
            operation_node: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPaintKit_Operation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPaintKit_Operation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPaintKit_Operation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPaintKit_Operation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPaintKit_ItemDefinition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPaintKit_ItemDefinition {
    // message fields
    // @@protoc_insertion_point(field:CMsgPaintKit_ItemDefinition.header)
    pub header: ::protobuf::MessageField<CMsgProtoDefHeader>,
    // @@protoc_insertion_point(field:CMsgPaintKit_ItemDefinition.item_definition_index)
    pub item_definition_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPaintKit_ItemDefinition.variable_template)
    pub variable_template: ::protobuf::MessageField<CMsgProtoDefID>,
    // @@protoc_insertion_point(field:CMsgPaintKit_ItemDefinition.definition)
    pub definition: ::std::vec::Vec<cmsg_paint_kit_item_definition::Definition>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPaintKit_ItemDefinition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPaintKit_ItemDefinition {
    fn default() -> &'a CMsgPaintKit_ItemDefinition {
        <CMsgPaintKit_ItemDefinition as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPaintKit_ItemDefinition {
    pub fn new() -> CMsgPaintKit_ItemDefinition {
        ::std::default::Default::default()
    }

    // required uint32 item_definition_index = 2;

    pub fn item_definition_index(&self) -> u32 {
        self.item_definition_index.unwrap_or(0)
    }

    pub fn clear_item_definition_index(&mut self) {
        self.item_definition_index = ::std::option::Option::None;
    }

    pub fn has_item_definition_index(&self) -> bool {
        self.item_definition_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_definition_index(&mut self, v: u32) {
        self.item_definition_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgProtoDefHeader>(
            "header",
            |m: &CMsgPaintKit_ItemDefinition| { &m.header },
            |m: &mut CMsgPaintKit_ItemDefinition| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_definition_index",
            |m: &CMsgPaintKit_ItemDefinition| { &m.item_definition_index },
            |m: &mut CMsgPaintKit_ItemDefinition| { &mut m.item_definition_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgProtoDefID>(
            "variable_template",
            |m: &CMsgPaintKit_ItemDefinition| { &m.variable_template },
            |m: &mut CMsgPaintKit_ItemDefinition| { &mut m.variable_template },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "definition",
            |m: &CMsgPaintKit_ItemDefinition| { &m.definition },
            |m: &mut CMsgPaintKit_ItemDefinition| { &mut m.definition },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPaintKit_ItemDefinition>(
            "CMsgPaintKit_ItemDefinition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPaintKit_ItemDefinition {
    const NAME: &'static str = "CMsgPaintKit_ItemDefinition";

    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        if self.item_definition_index.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.variable_template {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.definition {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                16 => {
                    self.item_definition_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.variable_template)?;
                },
                34 => {
                    self.definition.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.item_definition_index {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.variable_template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.definition {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.item_definition_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.variable_template.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.definition {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPaintKit_ItemDefinition {
        CMsgPaintKit_ItemDefinition::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.item_definition_index = ::std::option::Option::None;
        self.variable_template.clear();
        self.definition.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPaintKit_ItemDefinition {
        static instance: CMsgPaintKit_ItemDefinition = CMsgPaintKit_ItemDefinition {
            header: ::protobuf::MessageField::none(),
            item_definition_index: ::std::option::Option::None,
            variable_template: ::protobuf::MessageField::none(),
            definition: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPaintKit_ItemDefinition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPaintKit_ItemDefinition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPaintKit_ItemDefinition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPaintKit_ItemDefinition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgPaintKit_ItemDefinition`
pub mod cmsg_paint_kit_item_definition {
    // @@protoc_insertion_point(message:CMsgPaintKit_ItemDefinition.Definition)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Definition {
        // message fields
        // @@protoc_insertion_point(field:CMsgPaintKit_ItemDefinition.Definition.operation_template)
        pub operation_template: ::protobuf::MessageField<super::CMsgProtoDefID>,
        // @@protoc_insertion_point(field:CMsgPaintKit_ItemDefinition.Definition.variable)
        pub variable: ::std::vec::Vec<super::CMsgVarField>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgPaintKit_ItemDefinition.Definition.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Definition {
        fn default() -> &'a Definition {
            <Definition as ::protobuf::Message>::default_instance()
        }
    }

    impl Definition {
        pub fn new() -> Definition {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::CMsgProtoDefID>(
                "operation_template",
                |m: &Definition| { &m.operation_template },
                |m: &mut Definition| { &mut m.operation_template },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "variable",
                |m: &Definition| { &m.variable },
                |m: &mut Definition| { &mut m.variable },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Definition>(
                "CMsgPaintKit_ItemDefinition.Definition",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Definition {
        const NAME: &'static str = "Definition";

        fn is_initialized(&self) -> bool {
            for v in &self.operation_template {
                if !v.is_initialized() {
                    return false;
                }
            };
            for v in &self.variable {
                if !v.is_initialized() {
                    return false;
                }
            };
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.operation_template)?;
                    },
                    18 => {
                        self.variable.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.operation_template.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.variable {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.operation_template.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            for v in &self.variable {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Definition {
            Definition::new()
        }

        fn clear(&mut self) {
            self.operation_template.clear();
            self.variable.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Definition {
            static instance: Definition = Definition {
                operation_template: ::protobuf::MessageField::none(),
                variable: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Definition {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgPaintKit_ItemDefinition.Definition").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Definition {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Definition {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgPaintKit_Definition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPaintKit_Definition {
    // message fields
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.header)
    pub header: ::protobuf::MessageField<CMsgProtoDefHeader>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.loc_desctoken)
    pub loc_desctoken: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.operation_template)
    pub operation_template: ::protobuf::MessageField<CMsgProtoDefID>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.has_team_textures)
    pub has_team_textures: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.item)
    pub item: ::std::vec::Vec<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.paintkit_tool)
    pub paintkit_tool: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.flamethrower)
    pub flamethrower: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.grenadelauncher)
    pub grenadelauncher: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.knife)
    pub knife: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.medigun)
    pub medigun: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.minigun)
    pub minigun: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.pistol)
    pub pistol: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.revolver)
    pub revolver: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.rocketlauncher)
    pub rocketlauncher: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.scattergun)
    pub scattergun: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.shotgun)
    pub shotgun: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.smg)
    pub smg: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.sniperrifle)
    pub sniperrifle: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.stickybomb_launcher)
    pub stickybomb_launcher: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.ubersaw)
    pub ubersaw: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.wrench)
    pub wrench: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.amputator)
    pub amputator: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.atom_launcher)
    pub atom_launcher: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.back_scratcher)
    pub back_scratcher: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.battleaxe)
    pub battleaxe: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.bazaar_sniper)
    pub bazaar_sniper: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.blackbox)
    pub blackbox: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.claidheamohmor)
    pub claidheamohmor: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.crusaders_crossbow)
    pub crusaders_crossbow: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.degreaser)
    pub degreaser: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.demo_cannon)
    pub demo_cannon: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.demo_sultan_sword)
    pub demo_sultan_sword: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.detonator)
    pub detonator: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.gatling_gun)
    pub gatling_gun: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.holymackerel)
    pub holymackerel: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.jag)
    pub jag: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.lochnload)
    pub lochnload: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.powerjack)
    pub powerjack: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.quadball)
    pub quadball: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.reserve_shooter)
    pub reserve_shooter: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.riding_crop)
    pub riding_crop: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.russian_riot)
    pub russian_riot: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.scimitar)
    pub scimitar: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.scorch_shot)
    pub scorch_shot: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.shortstop)
    pub shortstop: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.soda_popper)
    pub soda_popper: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.tele_shotgun)
    pub tele_shotgun: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.tomislav)
    pub tomislav: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.trenchgun)
    pub trenchgun: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.winger_pistol)
    pub winger_pistol: ::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPaintKit_Definition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPaintKit_Definition {
    fn default() -> &'a CMsgPaintKit_Definition {
        <CMsgPaintKit_Definition as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPaintKit_Definition {
    pub fn new() -> CMsgPaintKit_Definition {
        ::std::default::Default::default()
    }

    // optional string loc_desctoken = 2;

    pub fn loc_desctoken(&self) -> &str {
        match self.loc_desctoken.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_loc_desctoken(&mut self) {
        self.loc_desctoken = ::std::option::Option::None;
    }

    pub fn has_loc_desctoken(&self) -> bool {
        self.loc_desctoken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loc_desctoken(&mut self, v: ::std::string::String) {
        self.loc_desctoken = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loc_desctoken(&mut self) -> &mut ::std::string::String {
        if self.loc_desctoken.is_none() {
            self.loc_desctoken = ::std::option::Option::Some(::std::string::String::new());
        }
        self.loc_desctoken.as_mut().unwrap()
    }

    // Take field
    pub fn take_loc_desctoken(&mut self) -> ::std::string::String {
        self.loc_desctoken.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool has_team_textures = 4;

    pub fn has_team_textures(&self) -> bool {
        self.has_team_textures.unwrap_or(false)
    }

    pub fn clear_has_team_textures(&mut self) {
        self.has_team_textures = ::std::option::Option::None;
    }

    pub fn has_has_team_textures(&self) -> bool {
        self.has_team_textures.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_team_textures(&mut self, v: bool) {
        self.has_team_textures = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(50);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgProtoDefHeader>(
            "header",
            |m: &CMsgPaintKit_Definition| { &m.header },
            |m: &mut CMsgPaintKit_Definition| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "loc_desctoken",
            |m: &CMsgPaintKit_Definition| { &m.loc_desctoken },
            |m: &mut CMsgPaintKit_Definition| { &mut m.loc_desctoken },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgProtoDefID>(
            "operation_template",
            |m: &CMsgPaintKit_Definition| { &m.operation_template },
            |m: &mut CMsgPaintKit_Definition| { &mut m.operation_template },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "has_team_textures",
            |m: &CMsgPaintKit_Definition| { &m.has_team_textures },
            |m: &mut CMsgPaintKit_Definition| { &mut m.has_team_textures },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "item",
            |m: &CMsgPaintKit_Definition| { &m.item },
            |m: &mut CMsgPaintKit_Definition| { &mut m.item },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "paintkit_tool",
            |m: &CMsgPaintKit_Definition| { &m.paintkit_tool },
            |m: &mut CMsgPaintKit_Definition| { &mut m.paintkit_tool },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "flamethrower",
            |m: &CMsgPaintKit_Definition| { &m.flamethrower },
            |m: &mut CMsgPaintKit_Definition| { &mut m.flamethrower },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "grenadelauncher",
            |m: &CMsgPaintKit_Definition| { &m.grenadelauncher },
            |m: &mut CMsgPaintKit_Definition| { &mut m.grenadelauncher },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "knife",
            |m: &CMsgPaintKit_Definition| { &m.knife },
            |m: &mut CMsgPaintKit_Definition| { &mut m.knife },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "medigun",
            |m: &CMsgPaintKit_Definition| { &m.medigun },
            |m: &mut CMsgPaintKit_Definition| { &mut m.medigun },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "minigun",
            |m: &CMsgPaintKit_Definition| { &m.minigun },
            |m: &mut CMsgPaintKit_Definition| { &mut m.minigun },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "pistol",
            |m: &CMsgPaintKit_Definition| { &m.pistol },
            |m: &mut CMsgPaintKit_Definition| { &mut m.pistol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "revolver",
            |m: &CMsgPaintKit_Definition| { &m.revolver },
            |m: &mut CMsgPaintKit_Definition| { &mut m.revolver },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "rocketlauncher",
            |m: &CMsgPaintKit_Definition| { &m.rocketlauncher },
            |m: &mut CMsgPaintKit_Definition| { &mut m.rocketlauncher },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "scattergun",
            |m: &CMsgPaintKit_Definition| { &m.scattergun },
            |m: &mut CMsgPaintKit_Definition| { &mut m.scattergun },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "shotgun",
            |m: &CMsgPaintKit_Definition| { &m.shotgun },
            |m: &mut CMsgPaintKit_Definition| { &mut m.shotgun },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "smg",
            |m: &CMsgPaintKit_Definition| { &m.smg },
            |m: &mut CMsgPaintKit_Definition| { &mut m.smg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "sniperrifle",
            |m: &CMsgPaintKit_Definition| { &m.sniperrifle },
            |m: &mut CMsgPaintKit_Definition| { &mut m.sniperrifle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "stickybomb_launcher",
            |m: &CMsgPaintKit_Definition| { &m.stickybomb_launcher },
            |m: &mut CMsgPaintKit_Definition| { &mut m.stickybomb_launcher },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "ubersaw",
            |m: &CMsgPaintKit_Definition| { &m.ubersaw },
            |m: &mut CMsgPaintKit_Definition| { &mut m.ubersaw },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "wrench",
            |m: &CMsgPaintKit_Definition| { &m.wrench },
            |m: &mut CMsgPaintKit_Definition| { &mut m.wrench },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "amputator",
            |m: &CMsgPaintKit_Definition| { &m.amputator },
            |m: &mut CMsgPaintKit_Definition| { &mut m.amputator },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "atom_launcher",
            |m: &CMsgPaintKit_Definition| { &m.atom_launcher },
            |m: &mut CMsgPaintKit_Definition| { &mut m.atom_launcher },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "back_scratcher",
            |m: &CMsgPaintKit_Definition| { &m.back_scratcher },
            |m: &mut CMsgPaintKit_Definition| { &mut m.back_scratcher },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "battleaxe",
            |m: &CMsgPaintKit_Definition| { &m.battleaxe },
            |m: &mut CMsgPaintKit_Definition| { &mut m.battleaxe },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "bazaar_sniper",
            |m: &CMsgPaintKit_Definition| { &m.bazaar_sniper },
            |m: &mut CMsgPaintKit_Definition| { &mut m.bazaar_sniper },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "blackbox",
            |m: &CMsgPaintKit_Definition| { &m.blackbox },
            |m: &mut CMsgPaintKit_Definition| { &mut m.blackbox },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "claidheamohmor",
            |m: &CMsgPaintKit_Definition| { &m.claidheamohmor },
            |m: &mut CMsgPaintKit_Definition| { &mut m.claidheamohmor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "crusaders_crossbow",
            |m: &CMsgPaintKit_Definition| { &m.crusaders_crossbow },
            |m: &mut CMsgPaintKit_Definition| { &mut m.crusaders_crossbow },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "degreaser",
            |m: &CMsgPaintKit_Definition| { &m.degreaser },
            |m: &mut CMsgPaintKit_Definition| { &mut m.degreaser },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "demo_cannon",
            |m: &CMsgPaintKit_Definition| { &m.demo_cannon },
            |m: &mut CMsgPaintKit_Definition| { &mut m.demo_cannon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "demo_sultan_sword",
            |m: &CMsgPaintKit_Definition| { &m.demo_sultan_sword },
            |m: &mut CMsgPaintKit_Definition| { &mut m.demo_sultan_sword },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "detonator",
            |m: &CMsgPaintKit_Definition| { &m.detonator },
            |m: &mut CMsgPaintKit_Definition| { &mut m.detonator },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "gatling_gun",
            |m: &CMsgPaintKit_Definition| { &m.gatling_gun },
            |m: &mut CMsgPaintKit_Definition| { &mut m.gatling_gun },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "holymackerel",
            |m: &CMsgPaintKit_Definition| { &m.holymackerel },
            |m: &mut CMsgPaintKit_Definition| { &mut m.holymackerel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "jag",
            |m: &CMsgPaintKit_Definition| { &m.jag },
            |m: &mut CMsgPaintKit_Definition| { &mut m.jag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "lochnload",
            |m: &CMsgPaintKit_Definition| { &m.lochnload },
            |m: &mut CMsgPaintKit_Definition| { &mut m.lochnload },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "powerjack",
            |m: &CMsgPaintKit_Definition| { &m.powerjack },
            |m: &mut CMsgPaintKit_Definition| { &mut m.powerjack },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "quadball",
            |m: &CMsgPaintKit_Definition| { &m.quadball },
            |m: &mut CMsgPaintKit_Definition| { &mut m.quadball },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "reserve_shooter",
            |m: &CMsgPaintKit_Definition| { &m.reserve_shooter },
            |m: &mut CMsgPaintKit_Definition| { &mut m.reserve_shooter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "riding_crop",
            |m: &CMsgPaintKit_Definition| { &m.riding_crop },
            |m: &mut CMsgPaintKit_Definition| { &mut m.riding_crop },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "russian_riot",
            |m: &CMsgPaintKit_Definition| { &m.russian_riot },
            |m: &mut CMsgPaintKit_Definition| { &mut m.russian_riot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "scimitar",
            |m: &CMsgPaintKit_Definition| { &m.scimitar },
            |m: &mut CMsgPaintKit_Definition| { &mut m.scimitar },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "scorch_shot",
            |m: &CMsgPaintKit_Definition| { &m.scorch_shot },
            |m: &mut CMsgPaintKit_Definition| { &mut m.scorch_shot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "shortstop",
            |m: &CMsgPaintKit_Definition| { &m.shortstop },
            |m: &mut CMsgPaintKit_Definition| { &mut m.shortstop },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "soda_popper",
            |m: &CMsgPaintKit_Definition| { &m.soda_popper },
            |m: &mut CMsgPaintKit_Definition| { &mut m.soda_popper },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "tele_shotgun",
            |m: &CMsgPaintKit_Definition| { &m.tele_shotgun },
            |m: &mut CMsgPaintKit_Definition| { &mut m.tele_shotgun },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "tomislav",
            |m: &CMsgPaintKit_Definition| { &m.tomislav },
            |m: &mut CMsgPaintKit_Definition| { &mut m.tomislav },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "trenchgun",
            |m: &CMsgPaintKit_Definition| { &m.trenchgun },
            |m: &mut CMsgPaintKit_Definition| { &mut m.trenchgun },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_paint_kit_definition::Item>(
            "winger_pistol",
            |m: &CMsgPaintKit_Definition| { &m.winger_pistol },
            |m: &mut CMsgPaintKit_Definition| { &mut m.winger_pistol },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPaintKit_Definition>(
            "CMsgPaintKit_Definition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPaintKit_Definition {
    const NAME: &'static str = "CMsgPaintKit_Definition";

    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.operation_template {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.item {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paintkit_tool {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.flamethrower {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.grenadelauncher {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.knife {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.medigun {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.minigun {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pistol {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.revolver {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rocketlauncher {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scattergun {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.shotgun {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.smg {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sniperrifle {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stickybomb_launcher {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ubersaw {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.wrench {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.amputator {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.atom_launcher {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.back_scratcher {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.battleaxe {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bazaar_sniper {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.blackbox {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.claidheamohmor {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.crusaders_crossbow {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.degreaser {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.demo_cannon {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.demo_sultan_sword {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.detonator {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.gatling_gun {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.holymackerel {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.jag {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.lochnload {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.powerjack {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.quadball {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reserve_shooter {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.riding_crop {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.russian_riot {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scimitar {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scorch_shot {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.shortstop {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.soda_popper {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tele_shotgun {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tomislav {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.trenchgun {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.winger_pistol {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.loc_desctoken = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.operation_template)?;
                },
                32 => {
                    self.has_team_textures = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    self.item.push(is.read_message()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.paintkit_tool)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.flamethrower)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.grenadelauncher)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.knife)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.medigun)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.minigun)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pistol)?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.revolver)?;
                },
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rocketlauncher)?;
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.scattergun)?;
                },
                130 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.shotgun)?;
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.smg)?;
                },
                146 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sniperrifle)?;
                },
                154 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stickybomb_launcher)?;
                },
                162 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ubersaw)?;
                },
                170 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.wrench)?;
                },
                178 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.amputator)?;
                },
                186 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.atom_launcher)?;
                },
                194 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.back_scratcher)?;
                },
                202 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.battleaxe)?;
                },
                210 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bazaar_sniper)?;
                },
                218 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.blackbox)?;
                },
                226 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.claidheamohmor)?;
                },
                234 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.crusaders_crossbow)?;
                },
                242 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.degreaser)?;
                },
                250 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.demo_cannon)?;
                },
                258 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.demo_sultan_sword)?;
                },
                266 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.detonator)?;
                },
                274 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.gatling_gun)?;
                },
                282 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.holymackerel)?;
                },
                290 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.jag)?;
                },
                298 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lochnload)?;
                },
                306 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.powerjack)?;
                },
                314 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.quadball)?;
                },
                322 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.reserve_shooter)?;
                },
                330 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.riding_crop)?;
                },
                338 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.russian_riot)?;
                },
                346 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.scimitar)?;
                },
                354 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.scorch_shot)?;
                },
                362 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.shortstop)?;
                },
                370 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.soda_popper)?;
                },
                378 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tele_shotgun)?;
                },
                386 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tomislav)?;
                },
                394 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.trenchgun)?;
                },
                402 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.winger_pistol)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.loc_desctoken.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.operation_template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.has_team_textures {
            my_size += 1 + 1;
        }
        for value in &self.item {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.paintkit_tool.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.flamethrower.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.grenadelauncher.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.knife.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.medigun.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.minigun.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.pistol.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.revolver.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.rocketlauncher.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.scattergun.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.shotgun.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.smg.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.sniperrifle.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.stickybomb_launcher.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ubersaw.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.wrench.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.amputator.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.atom_launcher.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.back_scratcher.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.battleaxe.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bazaar_sniper.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.blackbox.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.claidheamohmor.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.crusaders_crossbow.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.degreaser.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.demo_cannon.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.demo_sultan_sword.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.detonator.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.gatling_gun.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.holymackerel.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.jag.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.lochnload.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.powerjack.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.quadball.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reserve_shooter.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.riding_crop.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.russian_riot.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.scimitar.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.scorch_shot.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.shortstop.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.soda_popper.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.tele_shotgun.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.tomislav.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.trenchgun.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.winger_pistol.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.loc_desctoken.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.operation_template.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.has_team_textures {
            os.write_bool(4, v)?;
        }
        for v in &self.item {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.paintkit_tool.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.flamethrower.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.grenadelauncher.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.knife.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.medigun.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.minigun.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.pistol.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.revolver.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.rocketlauncher.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        if let Some(v) = self.scattergun.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.shotgun.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.smg.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.sniperrifle.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        if let Some(v) = self.stickybomb_launcher.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        }
        if let Some(v) = self.ubersaw.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        }
        if let Some(v) = self.wrench.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        }
        if let Some(v) = self.amputator.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        }
        if let Some(v) = self.atom_launcher.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        if let Some(v) = self.back_scratcher.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        if let Some(v) = self.battleaxe.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        }
        if let Some(v) = self.bazaar_sniper.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
        }
        if let Some(v) = self.blackbox.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(27, v, os)?;
        }
        if let Some(v) = self.claidheamohmor.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(28, v, os)?;
        }
        if let Some(v) = self.crusaders_crossbow.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(29, v, os)?;
        }
        if let Some(v) = self.degreaser.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
        }
        if let Some(v) = self.demo_cannon.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(31, v, os)?;
        }
        if let Some(v) = self.demo_sultan_sword.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(32, v, os)?;
        }
        if let Some(v) = self.detonator.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(33, v, os)?;
        }
        if let Some(v) = self.gatling_gun.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(34, v, os)?;
        }
        if let Some(v) = self.holymackerel.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(35, v, os)?;
        }
        if let Some(v) = self.jag.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(36, v, os)?;
        }
        if let Some(v) = self.lochnload.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(37, v, os)?;
        }
        if let Some(v) = self.powerjack.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(38, v, os)?;
        }
        if let Some(v) = self.quadball.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(39, v, os)?;
        }
        if let Some(v) = self.reserve_shooter.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(40, v, os)?;
        }
        if let Some(v) = self.riding_crop.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(41, v, os)?;
        }
        if let Some(v) = self.russian_riot.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(42, v, os)?;
        }
        if let Some(v) = self.scimitar.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(43, v, os)?;
        }
        if let Some(v) = self.scorch_shot.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(44, v, os)?;
        }
        if let Some(v) = self.shortstop.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(45, v, os)?;
        }
        if let Some(v) = self.soda_popper.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(46, v, os)?;
        }
        if let Some(v) = self.tele_shotgun.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(47, v, os)?;
        }
        if let Some(v) = self.tomislav.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(48, v, os)?;
        }
        if let Some(v) = self.trenchgun.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(49, v, os)?;
        }
        if let Some(v) = self.winger_pistol.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(50, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPaintKit_Definition {
        CMsgPaintKit_Definition::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.loc_desctoken = ::std::option::Option::None;
        self.operation_template.clear();
        self.has_team_textures = ::std::option::Option::None;
        self.item.clear();
        self.paintkit_tool.clear();
        self.flamethrower.clear();
        self.grenadelauncher.clear();
        self.knife.clear();
        self.medigun.clear();
        self.minigun.clear();
        self.pistol.clear();
        self.revolver.clear();
        self.rocketlauncher.clear();
        self.scattergun.clear();
        self.shotgun.clear();
        self.smg.clear();
        self.sniperrifle.clear();
        self.stickybomb_launcher.clear();
        self.ubersaw.clear();
        self.wrench.clear();
        self.amputator.clear();
        self.atom_launcher.clear();
        self.back_scratcher.clear();
        self.battleaxe.clear();
        self.bazaar_sniper.clear();
        self.blackbox.clear();
        self.claidheamohmor.clear();
        self.crusaders_crossbow.clear();
        self.degreaser.clear();
        self.demo_cannon.clear();
        self.demo_sultan_sword.clear();
        self.detonator.clear();
        self.gatling_gun.clear();
        self.holymackerel.clear();
        self.jag.clear();
        self.lochnload.clear();
        self.powerjack.clear();
        self.quadball.clear();
        self.reserve_shooter.clear();
        self.riding_crop.clear();
        self.russian_riot.clear();
        self.scimitar.clear();
        self.scorch_shot.clear();
        self.shortstop.clear();
        self.soda_popper.clear();
        self.tele_shotgun.clear();
        self.tomislav.clear();
        self.trenchgun.clear();
        self.winger_pistol.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPaintKit_Definition {
        static instance: CMsgPaintKit_Definition = CMsgPaintKit_Definition {
            header: ::protobuf::MessageField::none(),
            loc_desctoken: ::std::option::Option::None,
            operation_template: ::protobuf::MessageField::none(),
            has_team_textures: ::std::option::Option::None,
            item: ::std::vec::Vec::new(),
            paintkit_tool: ::protobuf::MessageField::none(),
            flamethrower: ::protobuf::MessageField::none(),
            grenadelauncher: ::protobuf::MessageField::none(),
            knife: ::protobuf::MessageField::none(),
            medigun: ::protobuf::MessageField::none(),
            minigun: ::protobuf::MessageField::none(),
            pistol: ::protobuf::MessageField::none(),
            revolver: ::protobuf::MessageField::none(),
            rocketlauncher: ::protobuf::MessageField::none(),
            scattergun: ::protobuf::MessageField::none(),
            shotgun: ::protobuf::MessageField::none(),
            smg: ::protobuf::MessageField::none(),
            sniperrifle: ::protobuf::MessageField::none(),
            stickybomb_launcher: ::protobuf::MessageField::none(),
            ubersaw: ::protobuf::MessageField::none(),
            wrench: ::protobuf::MessageField::none(),
            amputator: ::protobuf::MessageField::none(),
            atom_launcher: ::protobuf::MessageField::none(),
            back_scratcher: ::protobuf::MessageField::none(),
            battleaxe: ::protobuf::MessageField::none(),
            bazaar_sniper: ::protobuf::MessageField::none(),
            blackbox: ::protobuf::MessageField::none(),
            claidheamohmor: ::protobuf::MessageField::none(),
            crusaders_crossbow: ::protobuf::MessageField::none(),
            degreaser: ::protobuf::MessageField::none(),
            demo_cannon: ::protobuf::MessageField::none(),
            demo_sultan_sword: ::protobuf::MessageField::none(),
            detonator: ::protobuf::MessageField::none(),
            gatling_gun: ::protobuf::MessageField::none(),
            holymackerel: ::protobuf::MessageField::none(),
            jag: ::protobuf::MessageField::none(),
            lochnload: ::protobuf::MessageField::none(),
            powerjack: ::protobuf::MessageField::none(),
            quadball: ::protobuf::MessageField::none(),
            reserve_shooter: ::protobuf::MessageField::none(),
            riding_crop: ::protobuf::MessageField::none(),
            russian_riot: ::protobuf::MessageField::none(),
            scimitar: ::protobuf::MessageField::none(),
            scorch_shot: ::protobuf::MessageField::none(),
            shortstop: ::protobuf::MessageField::none(),
            soda_popper: ::protobuf::MessageField::none(),
            tele_shotgun: ::protobuf::MessageField::none(),
            tomislav: ::protobuf::MessageField::none(),
            trenchgun: ::protobuf::MessageField::none(),
            winger_pistol: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPaintKit_Definition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPaintKit_Definition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPaintKit_Definition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPaintKit_Definition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgPaintKit_Definition`
pub mod cmsg_paint_kit_definition {
    // @@protoc_insertion_point(message:CMsgPaintKit_Definition.Item)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Item {
        // message fields
        // @@protoc_insertion_point(field:CMsgPaintKit_Definition.Item.item_definition_template)
        pub item_definition_template: ::protobuf::MessageField<super::CMsgProtoDefID>,
        // @@protoc_insertion_point(field:CMsgPaintKit_Definition.Item.data)
        pub data: ::protobuf::MessageField<item::ItemData>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgPaintKit_Definition.Item.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Item {
        fn default() -> &'a Item {
            <Item as ::protobuf::Message>::default_instance()
        }
    }

    impl Item {
        pub fn new() -> Item {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::CMsgProtoDefID>(
                "item_definition_template",
                |m: &Item| { &m.item_definition_template },
                |m: &mut Item| { &mut m.item_definition_template },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, item::ItemData>(
                "data",
                |m: &Item| { &m.data },
                |m: &mut Item| { &mut m.data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Item>(
                "CMsgPaintKit_Definition.Item",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Item {
        const NAME: &'static str = "Item";

        fn is_initialized(&self) -> bool {
            if self.item_definition_template.is_none() {
                return false;
            }
            for v in &self.item_definition_template {
                if !v.is_initialized() {
                    return false;
                }
            };
            for v in &self.data {
                if !v.is_initialized() {
                    return false;
                }
            };
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.item_definition_template)?;
                    },
                    42 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item_definition_template.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.item_definition_template.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if let Some(v) = self.data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Item {
            Item::new()
        }

        fn clear(&mut self) {
            self.item_definition_template.clear();
            self.data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Item {
            static instance: Item = Item {
                item_definition_template: ::protobuf::MessageField::none(),
                data: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Item {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgPaintKit_Definition.Item").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Item {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Item {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Item`
    pub mod item {
        // @@protoc_insertion_point(message:CMsgPaintKit_Definition.Item.ItemData)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ItemData {
            // message fields
            // @@protoc_insertion_point(field:CMsgPaintKit_Definition.Item.ItemData.can_apply_paintkit)
            pub can_apply_paintkit: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:CMsgPaintKit_Definition.Item.ItemData.material_override)
            pub material_override: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:CMsgPaintKit_Definition.Item.ItemData.variable)
            pub variable: ::std::vec::Vec<super::super::CMsgVarField>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgPaintKit_Definition.Item.ItemData.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ItemData {
            fn default() -> &'a ItemData {
                <ItemData as ::protobuf::Message>::default_instance()
            }
        }

        impl ItemData {
            pub fn new() -> ItemData {
                ::std::default::Default::default()
            }

            // optional bool can_apply_paintkit = 2;

            pub fn can_apply_paintkit(&self) -> bool {
                self.can_apply_paintkit.unwrap_or(true)
            }

            pub fn clear_can_apply_paintkit(&mut self) {
                self.can_apply_paintkit = ::std::option::Option::None;
            }

            pub fn has_can_apply_paintkit(&self) -> bool {
                self.can_apply_paintkit.is_some()
            }

            // Param is passed by value, moved
            pub fn set_can_apply_paintkit(&mut self, v: bool) {
                self.can_apply_paintkit = ::std::option::Option::Some(v);
            }

            // optional string material_override = 3;

            pub fn material_override(&self) -> &str {
                match self.material_override.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_material_override(&mut self) {
                self.material_override = ::std::option::Option::None;
            }

            pub fn has_material_override(&self) -> bool {
                self.material_override.is_some()
            }

            // Param is passed by value, moved
            pub fn set_material_override(&mut self, v: ::std::string::String) {
                self.material_override = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_material_override(&mut self) -> &mut ::std::string::String {
                if self.material_override.is_none() {
                    self.material_override = ::std::option::Option::Some(::std::string::String::new());
                }
                self.material_override.as_mut().unwrap()
            }

            // Take field
            pub fn take_material_override(&mut self) -> ::std::string::String {
                self.material_override.take().unwrap_or_else(|| ::std::string::String::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "can_apply_paintkit",
                    |m: &ItemData| { &m.can_apply_paintkit },
                    |m: &mut ItemData| { &mut m.can_apply_paintkit },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "material_override",
                    |m: &ItemData| { &m.material_override },
                    |m: &mut ItemData| { &mut m.material_override },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "variable",
                    |m: &ItemData| { &m.variable },
                    |m: &mut ItemData| { &mut m.variable },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ItemData>(
                    "CMsgPaintKit_Definition.Item.ItemData",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ItemData {
            const NAME: &'static str = "ItemData";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        16 => {
                            self.can_apply_paintkit = ::std::option::Option::Some(is.read_bool()?);
                        },
                        26 => {
                            self.material_override = ::std::option::Option::Some(is.read_string()?);
                        },
                        34 => {
                            self.variable.push(is.read_message()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.can_apply_paintkit {
                    my_size += 1 + 1;
                }
                if let Some(v) = self.material_override.as_ref() {
                    my_size += ::protobuf::rt::string_size(3, &v);
                }
                for value in &self.variable {
                    let len = value.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.can_apply_paintkit {
                    os.write_bool(2, v)?;
                }
                if let Some(v) = self.material_override.as_ref() {
                    os.write_string(3, v)?;
                }
                for v in &self.variable {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ItemData {
                ItemData::new()
            }

            fn clear(&mut self) {
                self.can_apply_paintkit = ::std::option::Option::None;
                self.material_override = ::std::option::Option::None;
                self.variable.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ItemData {
                static instance: ItemData = ItemData {
                    can_apply_paintkit: ::std::option::Option::None,
                    material_override: ::std::option::Option::None,
                    variable: ::std::vec::Vec::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for ItemData {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CMsgPaintKit_Definition.Item.ItemData").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ItemData {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ItemData {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:CMsgQuestTheme)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgQuestTheme {
    // message fields
    // @@protoc_insertion_point(field:CMsgQuestTheme.header)
    pub header: ::protobuf::MessageField<CMsgProtoDefHeader>,
    // @@protoc_insertion_point(field:CMsgQuestTheme.notification_res)
    pub notification_res: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestTheme.quest_item_res)
    pub quest_item_res: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestTheme.in_game_tracker_res)
    pub in_game_tracker_res: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestTheme.give_sounds)
    pub give_sounds: ::std::vec::Vec<cmsg_quest_theme::WeightedStringSet>,
    // @@protoc_insertion_point(field:CMsgQuestTheme.complete_sounds)
    pub complete_sounds: ::std::vec::Vec<cmsg_quest_theme::WeightedStringSet>,
    // @@protoc_insertion_point(field:CMsgQuestTheme.fully_complete_sounds)
    pub fully_complete_sounds: ::std::vec::Vec<cmsg_quest_theme::WeightedStringSet>,
    // @@protoc_insertion_point(field:CMsgQuestTheme.reward_sound)
    pub reward_sound: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestTheme.discard_sound)
    pub discard_sound: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestTheme.reveal_sound)
    pub reveal_sound: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgQuestTheme.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgQuestTheme {
    fn default() -> &'a CMsgQuestTheme {
        <CMsgQuestTheme as ::protobuf::Message>::default_instance()
    }
}

impl CMsgQuestTheme {
    pub fn new() -> CMsgQuestTheme {
        ::std::default::Default::default()
    }

    // optional string notification_res = 2;

    pub fn notification_res(&self) -> &str {
        match self.notification_res.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_notification_res(&mut self) {
        self.notification_res = ::std::option::Option::None;
    }

    pub fn has_notification_res(&self) -> bool {
        self.notification_res.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notification_res(&mut self, v: ::std::string::String) {
        self.notification_res = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_notification_res(&mut self) -> &mut ::std::string::String {
        if self.notification_res.is_none() {
            self.notification_res = ::std::option::Option::Some(::std::string::String::new());
        }
        self.notification_res.as_mut().unwrap()
    }

    // Take field
    pub fn take_notification_res(&mut self) -> ::std::string::String {
        self.notification_res.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string quest_item_res = 3;

    pub fn quest_item_res(&self) -> &str {
        match self.quest_item_res.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_quest_item_res(&mut self) {
        self.quest_item_res = ::std::option::Option::None;
    }

    pub fn has_quest_item_res(&self) -> bool {
        self.quest_item_res.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_item_res(&mut self, v: ::std::string::String) {
        self.quest_item_res = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quest_item_res(&mut self) -> &mut ::std::string::String {
        if self.quest_item_res.is_none() {
            self.quest_item_res = ::std::option::Option::Some(::std::string::String::new());
        }
        self.quest_item_res.as_mut().unwrap()
    }

    // Take field
    pub fn take_quest_item_res(&mut self) -> ::std::string::String {
        self.quest_item_res.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string in_game_tracker_res = 4;

    pub fn in_game_tracker_res(&self) -> &str {
        match self.in_game_tracker_res.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_in_game_tracker_res(&mut self) {
        self.in_game_tracker_res = ::std::option::Option::None;
    }

    pub fn has_in_game_tracker_res(&self) -> bool {
        self.in_game_tracker_res.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_game_tracker_res(&mut self, v: ::std::string::String) {
        self.in_game_tracker_res = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_in_game_tracker_res(&mut self) -> &mut ::std::string::String {
        if self.in_game_tracker_res.is_none() {
            self.in_game_tracker_res = ::std::option::Option::Some(::std::string::String::new());
        }
        self.in_game_tracker_res.as_mut().unwrap()
    }

    // Take field
    pub fn take_in_game_tracker_res(&mut self) -> ::std::string::String {
        self.in_game_tracker_res.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string reward_sound = 8;

    pub fn reward_sound(&self) -> &str {
        match self.reward_sound.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reward_sound(&mut self) {
        self.reward_sound = ::std::option::Option::None;
    }

    pub fn has_reward_sound(&self) -> bool {
        self.reward_sound.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_sound(&mut self, v: ::std::string::String) {
        self.reward_sound = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reward_sound(&mut self) -> &mut ::std::string::String {
        if self.reward_sound.is_none() {
            self.reward_sound = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reward_sound.as_mut().unwrap()
    }

    // Take field
    pub fn take_reward_sound(&mut self) -> ::std::string::String {
        self.reward_sound.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string discard_sound = 9;

    pub fn discard_sound(&self) -> &str {
        match self.discard_sound.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_discard_sound(&mut self) {
        self.discard_sound = ::std::option::Option::None;
    }

    pub fn has_discard_sound(&self) -> bool {
        self.discard_sound.is_some()
    }

    // Param is passed by value, moved
    pub fn set_discard_sound(&mut self, v: ::std::string::String) {
        self.discard_sound = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_discard_sound(&mut self) -> &mut ::std::string::String {
        if self.discard_sound.is_none() {
            self.discard_sound = ::std::option::Option::Some(::std::string::String::new());
        }
        self.discard_sound.as_mut().unwrap()
    }

    // Take field
    pub fn take_discard_sound(&mut self) -> ::std::string::String {
        self.discard_sound.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string reveal_sound = 10;

    pub fn reveal_sound(&self) -> &str {
        match self.reveal_sound.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reveal_sound(&mut self) {
        self.reveal_sound = ::std::option::Option::None;
    }

    pub fn has_reveal_sound(&self) -> bool {
        self.reveal_sound.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reveal_sound(&mut self, v: ::std::string::String) {
        self.reveal_sound = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reveal_sound(&mut self) -> &mut ::std::string::String {
        if self.reveal_sound.is_none() {
            self.reveal_sound = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reveal_sound.as_mut().unwrap()
    }

    // Take field
    pub fn take_reveal_sound(&mut self) -> ::std::string::String {
        self.reveal_sound.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgProtoDefHeader>(
            "header",
            |m: &CMsgQuestTheme| { &m.header },
            |m: &mut CMsgQuestTheme| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "notification_res",
            |m: &CMsgQuestTheme| { &m.notification_res },
            |m: &mut CMsgQuestTheme| { &mut m.notification_res },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quest_item_res",
            |m: &CMsgQuestTheme| { &m.quest_item_res },
            |m: &mut CMsgQuestTheme| { &mut m.quest_item_res },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "in_game_tracker_res",
            |m: &CMsgQuestTheme| { &m.in_game_tracker_res },
            |m: &mut CMsgQuestTheme| { &mut m.in_game_tracker_res },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "give_sounds",
            |m: &CMsgQuestTheme| { &m.give_sounds },
            |m: &mut CMsgQuestTheme| { &mut m.give_sounds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "complete_sounds",
            |m: &CMsgQuestTheme| { &m.complete_sounds },
            |m: &mut CMsgQuestTheme| { &mut m.complete_sounds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fully_complete_sounds",
            |m: &CMsgQuestTheme| { &m.fully_complete_sounds },
            |m: &mut CMsgQuestTheme| { &mut m.fully_complete_sounds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reward_sound",
            |m: &CMsgQuestTheme| { &m.reward_sound },
            |m: &mut CMsgQuestTheme| { &mut m.reward_sound },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "discard_sound",
            |m: &CMsgQuestTheme| { &m.discard_sound },
            |m: &mut CMsgQuestTheme| { &mut m.discard_sound },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reveal_sound",
            |m: &CMsgQuestTheme| { &m.reveal_sound },
            |m: &mut CMsgQuestTheme| { &mut m.reveal_sound },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgQuestTheme>(
            "CMsgQuestTheme",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgQuestTheme {
    const NAME: &'static str = "CMsgQuestTheme";

    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.give_sounds {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.complete_sounds {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fully_complete_sounds {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.notification_res = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.quest_item_res = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.in_game_tracker_res = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.give_sounds.push(is.read_message()?);
                },
                50 => {
                    self.complete_sounds.push(is.read_message()?);
                },
                58 => {
                    self.fully_complete_sounds.push(is.read_message()?);
                },
                66 => {
                    self.reward_sound = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.discard_sound = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.reveal_sound = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.notification_res.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.quest_item_res.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.in_game_tracker_res.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.give_sounds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.complete_sounds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.fully_complete_sounds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.reward_sound.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.discard_sound.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.reveal_sound.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.notification_res.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.quest_item_res.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.in_game_tracker_res.as_ref() {
            os.write_string(4, v)?;
        }
        for v in &self.give_sounds {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.complete_sounds {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.fully_complete_sounds {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if let Some(v) = self.reward_sound.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.discard_sound.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.reveal_sound.as_ref() {
            os.write_string(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgQuestTheme {
        CMsgQuestTheme::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.notification_res = ::std::option::Option::None;
        self.quest_item_res = ::std::option::Option::None;
        self.in_game_tracker_res = ::std::option::Option::None;
        self.give_sounds.clear();
        self.complete_sounds.clear();
        self.fully_complete_sounds.clear();
        self.reward_sound = ::std::option::Option::None;
        self.discard_sound = ::std::option::Option::None;
        self.reveal_sound = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgQuestTheme {
        static instance: CMsgQuestTheme = CMsgQuestTheme {
            header: ::protobuf::MessageField::none(),
            notification_res: ::std::option::Option::None,
            quest_item_res: ::std::option::Option::None,
            in_game_tracker_res: ::std::option::Option::None,
            give_sounds: ::std::vec::Vec::new(),
            complete_sounds: ::std::vec::Vec::new(),
            fully_complete_sounds: ::std::vec::Vec::new(),
            reward_sound: ::std::option::Option::None,
            discard_sound: ::std::option::Option::None,
            reveal_sound: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgQuestTheme {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgQuestTheme").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgQuestTheme {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgQuestTheme {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgQuestTheme`
pub mod cmsg_quest_theme {
    // @@protoc_insertion_point(message:CMsgQuestTheme.WeightedString)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct WeightedString {
        // message fields
        // @@protoc_insertion_point(field:CMsgQuestTheme.WeightedString.string)
        pub string: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgQuestTheme.WeightedString.weight)
        pub weight: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgQuestTheme.WeightedString.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a WeightedString {
        fn default() -> &'a WeightedString {
            <WeightedString as ::protobuf::Message>::default_instance()
        }
    }

    impl WeightedString {
        pub fn new() -> WeightedString {
            ::std::default::Default::default()
        }

        // optional string string = 1;

        pub fn string(&self) -> &str {
            match self.string.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_string(&mut self) {
            self.string = ::std::option::Option::None;
        }

        pub fn has_string(&self) -> bool {
            self.string.is_some()
        }

        // Param is passed by value, moved
        pub fn set_string(&mut self, v: ::std::string::String) {
            self.string = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_string(&mut self) -> &mut ::std::string::String {
            if self.string.is_none() {
                self.string = ::std::option::Option::Some(::std::string::String::new());
            }
            self.string.as_mut().unwrap()
        }

        // Take field
        pub fn take_string(&mut self) -> ::std::string::String {
            self.string.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 weight = 2;

        pub fn weight(&self) -> u32 {
            self.weight.unwrap_or(0)
        }

        pub fn clear_weight(&mut self) {
            self.weight = ::std::option::Option::None;
        }

        pub fn has_weight(&self) -> bool {
            self.weight.is_some()
        }

        // Param is passed by value, moved
        pub fn set_weight(&mut self, v: u32) {
            self.weight = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "string",
                |m: &WeightedString| { &m.string },
                |m: &mut WeightedString| { &mut m.string },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "weight",
                |m: &WeightedString| { &m.weight },
                |m: &mut WeightedString| { &mut m.weight },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WeightedString>(
                "CMsgQuestTheme.WeightedString",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for WeightedString {
        const NAME: &'static str = "WeightedString";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.string = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.weight = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.string.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.weight {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.string.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.weight {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> WeightedString {
            WeightedString::new()
        }

        fn clear(&mut self) {
            self.string = ::std::option::Option::None;
            self.weight = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static WeightedString {
            static instance: WeightedString = WeightedString {
                string: ::std::option::Option::None,
                weight: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for WeightedString {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgQuestTheme.WeightedString").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for WeightedString {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for WeightedString {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgQuestTheme.WeightedStringSet)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct WeightedStringSet {
        // message fields
        // @@protoc_insertion_point(field:CMsgQuestTheme.WeightedStringSet.weighted_strings)
        pub weighted_strings: ::std::vec::Vec<WeightedString>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgQuestTheme.WeightedStringSet.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a WeightedStringSet {
        fn default() -> &'a WeightedStringSet {
            <WeightedStringSet as ::protobuf::Message>::default_instance()
        }
    }

    impl WeightedStringSet {
        pub fn new() -> WeightedStringSet {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "weighted_strings",
                |m: &WeightedStringSet| { &m.weighted_strings },
                |m: &mut WeightedStringSet| { &mut m.weighted_strings },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WeightedStringSet>(
                "CMsgQuestTheme.WeightedStringSet",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for WeightedStringSet {
        const NAME: &'static str = "WeightedStringSet";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.weighted_strings.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.weighted_strings {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.weighted_strings {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> WeightedStringSet {
            WeightedStringSet::new()
        }

        fn clear(&mut self) {
            self.weighted_strings.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static WeightedStringSet {
            static instance: WeightedStringSet = WeightedStringSet {
                weighted_strings: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for WeightedStringSet {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgQuestTheme.WeightedStringSet").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for WeightedStringSet {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for WeightedStringSet {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgQuestMapNodeCondition_NodeState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgQuestMapNodeCondition_NodeState {
    // message fields
    // @@protoc_insertion_point(field:CMsgQuestMapNodeCondition_NodeState.bonus_objectives_required)
    pub bonus_objectives_required: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgQuestMapNodeCondition_NodeState.target_node_defid)
    pub target_node_defid: ::protobuf::MessageField<CMsgProtoDefID>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgQuestMapNodeCondition_NodeState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgQuestMapNodeCondition_NodeState {
    fn default() -> &'a CMsgQuestMapNodeCondition_NodeState {
        <CMsgQuestMapNodeCondition_NodeState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgQuestMapNodeCondition_NodeState {
    pub fn new() -> CMsgQuestMapNodeCondition_NodeState {
        ::std::default::Default::default()
    }

    // optional uint32 bonus_objectives_required = 1;

    pub fn bonus_objectives_required(&self) -> u32 {
        self.bonus_objectives_required.unwrap_or(0u32)
    }

    pub fn clear_bonus_objectives_required(&mut self) {
        self.bonus_objectives_required = ::std::option::Option::None;
    }

    pub fn has_bonus_objectives_required(&self) -> bool {
        self.bonus_objectives_required.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus_objectives_required(&mut self, v: u32) {
        self.bonus_objectives_required = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bonus_objectives_required",
            |m: &CMsgQuestMapNodeCondition_NodeState| { &m.bonus_objectives_required },
            |m: &mut CMsgQuestMapNodeCondition_NodeState| { &mut m.bonus_objectives_required },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgProtoDefID>(
            "target_node_defid",
            |m: &CMsgQuestMapNodeCondition_NodeState| { &m.target_node_defid },
            |m: &mut CMsgQuestMapNodeCondition_NodeState| { &mut m.target_node_defid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgQuestMapNodeCondition_NodeState>(
            "CMsgQuestMapNodeCondition_NodeState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgQuestMapNodeCondition_NodeState {
    const NAME: &'static str = "CMsgQuestMapNodeCondition_NodeState";

    fn is_initialized(&self) -> bool {
        if self.target_node_defid.is_none() {
            return false;
        }
        for v in &self.target_node_defid {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.bonus_objectives_required = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.target_node_defid)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.bonus_objectives_required {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.target_node_defid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.bonus_objectives_required {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.target_node_defid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgQuestMapNodeCondition_NodeState {
        CMsgQuestMapNodeCondition_NodeState::new()
    }

    fn clear(&mut self) {
        self.bonus_objectives_required = ::std::option::Option::None;
        self.target_node_defid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgQuestMapNodeCondition_NodeState {
        static instance: CMsgQuestMapNodeCondition_NodeState = CMsgQuestMapNodeCondition_NodeState {
            bonus_objectives_required: ::std::option::Option::None,
            target_node_defid: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgQuestMapNodeCondition_NodeState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgQuestMapNodeCondition_NodeState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgQuestMapNodeCondition_NodeState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgQuestMapNodeCondition_NodeState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgQuestMapNodeCondition_Logic)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgQuestMapNodeCondition_Logic {
    // message fields
    // @@protoc_insertion_point(field:CMsgQuestMapNodeCondition_Logic.operation)
    pub operation: ::std::option::Option<::protobuf::EnumOrUnknown<LogicalOperation>>,
    // @@protoc_insertion_point(field:CMsgQuestMapNodeCondition_Logic.sub_conditions)
    pub sub_conditions: ::std::vec::Vec<CMsgQuestMapNodeCondition>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgQuestMapNodeCondition_Logic.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgQuestMapNodeCondition_Logic {
    fn default() -> &'a CMsgQuestMapNodeCondition_Logic {
        <CMsgQuestMapNodeCondition_Logic as ::protobuf::Message>::default_instance()
    }
}

impl CMsgQuestMapNodeCondition_Logic {
    pub fn new() -> CMsgQuestMapNodeCondition_Logic {
        ::std::default::Default::default()
    }

    // required .LogicalOperation operation = 1;

    pub fn operation(&self) -> LogicalOperation {
        match self.operation {
            Some(e) => e.enum_value_or(LogicalOperation::AND),
            None => LogicalOperation::AND,
        }
    }

    pub fn clear_operation(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_operation(&self) -> bool {
        self.operation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operation(&mut self, v: LogicalOperation) {
        self.operation = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "operation",
            |m: &CMsgQuestMapNodeCondition_Logic| { &m.operation },
            |m: &mut CMsgQuestMapNodeCondition_Logic| { &mut m.operation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sub_conditions",
            |m: &CMsgQuestMapNodeCondition_Logic| { &m.sub_conditions },
            |m: &mut CMsgQuestMapNodeCondition_Logic| { &mut m.sub_conditions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgQuestMapNodeCondition_Logic>(
            "CMsgQuestMapNodeCondition_Logic",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgQuestMapNodeCondition_Logic {
    const NAME: &'static str = "CMsgQuestMapNodeCondition_Logic";

    fn is_initialized(&self) -> bool {
        if self.operation.is_none() {
            return false;
        }
        for v in &self.sub_conditions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.operation = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.sub_conditions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.operation {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.sub_conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.operation {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.sub_conditions {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgQuestMapNodeCondition_Logic {
        CMsgQuestMapNodeCondition_Logic::new()
    }

    fn clear(&mut self) {
        self.operation = ::std::option::Option::None;
        self.sub_conditions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgQuestMapNodeCondition_Logic {
        static instance: CMsgQuestMapNodeCondition_Logic = CMsgQuestMapNodeCondition_Logic {
            operation: ::std::option::Option::None,
            sub_conditions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgQuestMapNodeCondition_Logic {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgQuestMapNodeCondition_Logic").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgQuestMapNodeCondition_Logic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgQuestMapNodeCondition_Logic {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgQuestMapNodeCondition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgQuestMapNodeCondition {
    // message oneof groups
    pub operation: ::std::option::Option<cmsg_quest_map_node_condition::Operation>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgQuestMapNodeCondition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgQuestMapNodeCondition {
    fn default() -> &'a CMsgQuestMapNodeCondition {
        <CMsgQuestMapNodeCondition as ::protobuf::Message>::default_instance()
    }
}

impl CMsgQuestMapNodeCondition {
    pub fn new() -> CMsgQuestMapNodeCondition {
        ::std::default::Default::default()
    }

    // optional .CMsgQuestMapNodeCondition_NodeState node_state = 1;

    pub fn node_state(&self) -> &CMsgQuestMapNodeCondition_NodeState {
        match self.operation {
            ::std::option::Option::Some(cmsg_quest_map_node_condition::Operation::NodeState(ref v)) => v,
            _ => <CMsgQuestMapNodeCondition_NodeState as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_node_state(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_node_state(&self) -> bool {
        match self.operation {
            ::std::option::Option::Some(cmsg_quest_map_node_condition::Operation::NodeState(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_node_state(&mut self, v: CMsgQuestMapNodeCondition_NodeState) {
        self.operation = ::std::option::Option::Some(cmsg_quest_map_node_condition::Operation::NodeState(v))
    }

    // Mutable pointer to the field.
    pub fn mut_node_state(&mut self) -> &mut CMsgQuestMapNodeCondition_NodeState {
        if let ::std::option::Option::Some(cmsg_quest_map_node_condition::Operation::NodeState(_)) = self.operation {
        } else {
            self.operation = ::std::option::Option::Some(cmsg_quest_map_node_condition::Operation::NodeState(CMsgQuestMapNodeCondition_NodeState::new()));
        }
        match self.operation {
            ::std::option::Option::Some(cmsg_quest_map_node_condition::Operation::NodeState(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_node_state(&mut self) -> CMsgQuestMapNodeCondition_NodeState {
        if self.has_node_state() {
            match self.operation.take() {
                ::std::option::Option::Some(cmsg_quest_map_node_condition::Operation::NodeState(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgQuestMapNodeCondition_NodeState::new()
        }
    }

    // optional .CMsgQuestMapNodeCondition_Logic logical = 2;

    pub fn logical(&self) -> &CMsgQuestMapNodeCondition_Logic {
        match self.operation {
            ::std::option::Option::Some(cmsg_quest_map_node_condition::Operation::Logical(ref v)) => v,
            _ => <CMsgQuestMapNodeCondition_Logic as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_logical(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_logical(&self) -> bool {
        match self.operation {
            ::std::option::Option::Some(cmsg_quest_map_node_condition::Operation::Logical(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_logical(&mut self, v: CMsgQuestMapNodeCondition_Logic) {
        self.operation = ::std::option::Option::Some(cmsg_quest_map_node_condition::Operation::Logical(v))
    }

    // Mutable pointer to the field.
    pub fn mut_logical(&mut self) -> &mut CMsgQuestMapNodeCondition_Logic {
        if let ::std::option::Option::Some(cmsg_quest_map_node_condition::Operation::Logical(_)) = self.operation {
        } else {
            self.operation = ::std::option::Option::Some(cmsg_quest_map_node_condition::Operation::Logical(CMsgQuestMapNodeCondition_Logic::new()));
        }
        match self.operation {
            ::std::option::Option::Some(cmsg_quest_map_node_condition::Operation::Logical(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_logical(&mut self) -> CMsgQuestMapNodeCondition_Logic {
        if self.has_logical() {
            match self.operation.take() {
                ::std::option::Option::Some(cmsg_quest_map_node_condition::Operation::Logical(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgQuestMapNodeCondition_Logic::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CMsgQuestMapNodeCondition_NodeState>(
            "node_state",
            CMsgQuestMapNodeCondition::has_node_state,
            CMsgQuestMapNodeCondition::node_state,
            CMsgQuestMapNodeCondition::mut_node_state,
            CMsgQuestMapNodeCondition::set_node_state,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CMsgQuestMapNodeCondition_Logic>(
            "logical",
            CMsgQuestMapNodeCondition::has_logical,
            CMsgQuestMapNodeCondition::logical,
            CMsgQuestMapNodeCondition::mut_logical,
            CMsgQuestMapNodeCondition::set_logical,
        ));
        oneofs.push(cmsg_quest_map_node_condition::Operation::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgQuestMapNodeCondition>(
            "CMsgQuestMapNodeCondition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgQuestMapNodeCondition {
    const NAME: &'static str = "CMsgQuestMapNodeCondition";

    fn is_initialized(&self) -> bool {
        if let Some(cmsg_quest_map_node_condition::Operation::NodeState(ref v)) = self.operation {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(cmsg_quest_map_node_condition::Operation::Logical(ref v)) = self.operation {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.operation = ::std::option::Option::Some(cmsg_quest_map_node_condition::Operation::NodeState(is.read_message()?));
                },
                18 => {
                    self.operation = ::std::option::Option::Some(cmsg_quest_map_node_condition::Operation::Logical(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.operation {
            match v {
                &cmsg_quest_map_node_condition::Operation::NodeState(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_quest_map_node_condition::Operation::Logical(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.operation {
            match v {
                &cmsg_quest_map_node_condition::Operation::NodeState(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &cmsg_quest_map_node_condition::Operation::Logical(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgQuestMapNodeCondition {
        CMsgQuestMapNodeCondition::new()
    }

    fn clear(&mut self) {
        self.operation = ::std::option::Option::None;
        self.operation = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgQuestMapNodeCondition {
        static instance: CMsgQuestMapNodeCondition = CMsgQuestMapNodeCondition {
            operation: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgQuestMapNodeCondition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgQuestMapNodeCondition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgQuestMapNodeCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgQuestMapNodeCondition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgQuestMapNodeCondition`
pub mod cmsg_quest_map_node_condition {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:CMsgQuestMapNodeCondition.operation)
    pub enum Operation {
        // @@protoc_insertion_point(oneof_field:CMsgQuestMapNodeCondition.node_state)
        NodeState(super::CMsgQuestMapNodeCondition_NodeState),
        // @@protoc_insertion_point(oneof_field:CMsgQuestMapNodeCondition.logical)
        Logical(super::CMsgQuestMapNodeCondition_Logic),
    }

    impl ::protobuf::Oneof for Operation {
    }

    impl ::protobuf::OneofFull for Operation {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::CMsgQuestMapNodeCondition as ::protobuf::MessageFull>::descriptor().oneof_by_name("operation").unwrap()).clone()
        }
    }

    impl Operation {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Operation>("operation")
        }
    }
}

// @@protoc_insertion_point(message:CMsgHeaderOnly)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHeaderOnly {
    // message fields
    // @@protoc_insertion_point(field:CMsgHeaderOnly.header)
    pub header: ::protobuf::MessageField<CMsgProtoDefHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHeaderOnly.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHeaderOnly {
    fn default() -> &'a CMsgHeaderOnly {
        <CMsgHeaderOnly as ::protobuf::Message>::default_instance()
    }
}

impl CMsgHeaderOnly {
    pub fn new() -> CMsgHeaderOnly {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgProtoDefHeader>(
            "header",
            |m: &CMsgHeaderOnly| { &m.header },
            |m: &mut CMsgHeaderOnly| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgHeaderOnly>(
            "CMsgHeaderOnly",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgHeaderOnly {
    const NAME: &'static str = "CMsgHeaderOnly";

    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHeaderOnly {
        CMsgHeaderOnly::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHeaderOnly {
        static instance: CMsgHeaderOnly = CMsgHeaderOnly {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgHeaderOnly {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgHeaderOnly").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgHeaderOnly {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgHeaderOnly {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:LogicalOperation)
pub enum LogicalOperation {
    // @@protoc_insertion_point(enum_value:LogicalOperation.AND)
    AND = 0,
    // @@protoc_insertion_point(enum_value:LogicalOperation.OR)
    OR = 1,
    // @@protoc_insertion_point(enum_value:LogicalOperation.NOT)
    NOT = 2,
}

impl ::protobuf::Enum for LogicalOperation {
    const NAME: &'static str = "LogicalOperation";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LogicalOperation> {
        match value {
            0 => ::std::option::Option::Some(LogicalOperation::AND),
            1 => ::std::option::Option::Some(LogicalOperation::OR),
            2 => ::std::option::Option::Some(LogicalOperation::NOT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<LogicalOperation> {
        match str {
            "AND" => ::std::option::Option::Some(LogicalOperation::AND),
            "OR" => ::std::option::Option::Some(LogicalOperation::OR),
            "NOT" => ::std::option::Option::Some(LogicalOperation::NOT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [LogicalOperation] = &[
        LogicalOperation::AND,
        LogicalOperation::OR,
        LogicalOperation::NOT,
    ];
}

impl ::protobuf::EnumFull for LogicalOperation {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("LogicalOperation").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for LogicalOperation {
    fn default() -> Self {
        LogicalOperation::AND
    }
}

impl LogicalOperation {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<LogicalOperation>("LogicalOperation")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EValueDefinitionSource)
pub enum EValueDefinitionSource {
    // @@protoc_insertion_point(enum_value:EValueDefinitionSource.REFERENCE_DEFINES)
    REFERENCE_DEFINES = 0,
    // @@protoc_insertion_point(enum_value:EValueDefinitionSource.PARENT_DEFINES)
    PARENT_DEFINES = 1,
    // @@protoc_insertion_point(enum_value:EValueDefinitionSource.THIS_DEFINES)
    THIS_DEFINES = 2,
    // @@protoc_insertion_point(enum_value:EValueDefinitionSource.VARIABLE_DEFINES)
    VARIABLE_DEFINES = 3,
    // @@protoc_insertion_point(enum_value:EValueDefinitionSource.NOT_DEFINED)
    NOT_DEFINED = 4,
}

impl ::protobuf::Enum for EValueDefinitionSource {
    const NAME: &'static str = "EValueDefinitionSource";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EValueDefinitionSource> {
        match value {
            0 => ::std::option::Option::Some(EValueDefinitionSource::REFERENCE_DEFINES),
            1 => ::std::option::Option::Some(EValueDefinitionSource::PARENT_DEFINES),
            2 => ::std::option::Option::Some(EValueDefinitionSource::THIS_DEFINES),
            3 => ::std::option::Option::Some(EValueDefinitionSource::VARIABLE_DEFINES),
            4 => ::std::option::Option::Some(EValueDefinitionSource::NOT_DEFINED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EValueDefinitionSource> {
        match str {
            "REFERENCE_DEFINES" => ::std::option::Option::Some(EValueDefinitionSource::REFERENCE_DEFINES),
            "PARENT_DEFINES" => ::std::option::Option::Some(EValueDefinitionSource::PARENT_DEFINES),
            "THIS_DEFINES" => ::std::option::Option::Some(EValueDefinitionSource::THIS_DEFINES),
            "VARIABLE_DEFINES" => ::std::option::Option::Some(EValueDefinitionSource::VARIABLE_DEFINES),
            "NOT_DEFINED" => ::std::option::Option::Some(EValueDefinitionSource::NOT_DEFINED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EValueDefinitionSource] = &[
        EValueDefinitionSource::REFERENCE_DEFINES,
        EValueDefinitionSource::PARENT_DEFINES,
        EValueDefinitionSource::THIS_DEFINES,
        EValueDefinitionSource::VARIABLE_DEFINES,
        EValueDefinitionSource::NOT_DEFINED,
    ];
}

impl ::protobuf::EnumFull for EValueDefinitionSource {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EValueDefinitionSource").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EValueDefinitionSource {
    fn default() -> Self {
        EValueDefinitionSource::REFERENCE_DEFINES
    }
}

impl EValueDefinitionSource {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EValueDefinitionSource>("EValueDefinitionSource")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ProtoDefTypes)
pub enum ProtoDefTypes {
    // @@protoc_insertion_point(enum_value:ProtoDefTypes.DEF_TYPE_QUEST_MAP_NODE)
    DEF_TYPE_QUEST_MAP_NODE = 0,
    // @@protoc_insertion_point(enum_value:ProtoDefTypes.DEF_TYPE_QUEST_THEME)
    DEF_TYPE_QUEST_THEME = 2,
    // @@protoc_insertion_point(enum_value:ProtoDefTypes.DEF_TYPE_QUEST_MAP_REGION)
    DEF_TYPE_QUEST_MAP_REGION = 3,
    // @@protoc_insertion_point(enum_value:ProtoDefTypes.DEF_TYPE_QUEST)
    DEF_TYPE_QUEST = 4,
    // @@protoc_insertion_point(enum_value:ProtoDefTypes.DEF_TYPE_QUEST_OBJECTIVE)
    DEF_TYPE_QUEST_OBJECTIVE = 5,
    // @@protoc_insertion_point(enum_value:ProtoDefTypes.DEF_TYPE_PAINTKIT_VARIABLES)
    DEF_TYPE_PAINTKIT_VARIABLES = 6,
    // @@protoc_insertion_point(enum_value:ProtoDefTypes.DEF_TYPE_PAINTKIT_OPERATION)
    DEF_TYPE_PAINTKIT_OPERATION = 7,
    // @@protoc_insertion_point(enum_value:ProtoDefTypes.DEF_TYPE_PAINTKIT_ITEM_DEFINITION)
    DEF_TYPE_PAINTKIT_ITEM_DEFINITION = 8,
    // @@protoc_insertion_point(enum_value:ProtoDefTypes.DEF_TYPE_PAINTKIT_DEFINITION)
    DEF_TYPE_PAINTKIT_DEFINITION = 9,
    // @@protoc_insertion_point(enum_value:ProtoDefTypes.DEF_TYPE_HEADER_ONLY)
    DEF_TYPE_HEADER_ONLY = 10,
    // @@protoc_insertion_point(enum_value:ProtoDefTypes.DEF_TYPE_QUEST_MAP_STORE_ITEM)
    DEF_TYPE_QUEST_MAP_STORE_ITEM = 11,
    // @@protoc_insertion_point(enum_value:ProtoDefTypes.DEF_TYPE_QUEST_MAP_STAR_TYPE)
    DEF_TYPE_QUEST_MAP_STAR_TYPE = 12,
}

impl ::protobuf::Enum for ProtoDefTypes {
    const NAME: &'static str = "ProtoDefTypes";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtoDefTypes> {
        match value {
            0 => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_QUEST_MAP_NODE),
            2 => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_QUEST_THEME),
            3 => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_QUEST_MAP_REGION),
            4 => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_QUEST),
            5 => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_QUEST_OBJECTIVE),
            6 => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_PAINTKIT_VARIABLES),
            7 => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_PAINTKIT_OPERATION),
            8 => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_PAINTKIT_ITEM_DEFINITION),
            9 => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_PAINTKIT_DEFINITION),
            10 => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_HEADER_ONLY),
            11 => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_QUEST_MAP_STORE_ITEM),
            12 => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_QUEST_MAP_STAR_TYPE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ProtoDefTypes> {
        match str {
            "DEF_TYPE_QUEST_MAP_NODE" => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_QUEST_MAP_NODE),
            "DEF_TYPE_QUEST_THEME" => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_QUEST_THEME),
            "DEF_TYPE_QUEST_MAP_REGION" => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_QUEST_MAP_REGION),
            "DEF_TYPE_QUEST" => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_QUEST),
            "DEF_TYPE_QUEST_OBJECTIVE" => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_QUEST_OBJECTIVE),
            "DEF_TYPE_PAINTKIT_VARIABLES" => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_PAINTKIT_VARIABLES),
            "DEF_TYPE_PAINTKIT_OPERATION" => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_PAINTKIT_OPERATION),
            "DEF_TYPE_PAINTKIT_ITEM_DEFINITION" => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_PAINTKIT_ITEM_DEFINITION),
            "DEF_TYPE_PAINTKIT_DEFINITION" => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_PAINTKIT_DEFINITION),
            "DEF_TYPE_HEADER_ONLY" => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_HEADER_ONLY),
            "DEF_TYPE_QUEST_MAP_STORE_ITEM" => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_QUEST_MAP_STORE_ITEM),
            "DEF_TYPE_QUEST_MAP_STAR_TYPE" => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_QUEST_MAP_STAR_TYPE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ProtoDefTypes] = &[
        ProtoDefTypes::DEF_TYPE_QUEST_MAP_NODE,
        ProtoDefTypes::DEF_TYPE_QUEST_THEME,
        ProtoDefTypes::DEF_TYPE_QUEST_MAP_REGION,
        ProtoDefTypes::DEF_TYPE_QUEST,
        ProtoDefTypes::DEF_TYPE_QUEST_OBJECTIVE,
        ProtoDefTypes::DEF_TYPE_PAINTKIT_VARIABLES,
        ProtoDefTypes::DEF_TYPE_PAINTKIT_OPERATION,
        ProtoDefTypes::DEF_TYPE_PAINTKIT_ITEM_DEFINITION,
        ProtoDefTypes::DEF_TYPE_PAINTKIT_DEFINITION,
        ProtoDefTypes::DEF_TYPE_HEADER_ONLY,
        ProtoDefTypes::DEF_TYPE_QUEST_MAP_STORE_ITEM,
        ProtoDefTypes::DEF_TYPE_QUEST_MAP_STAR_TYPE,
    ];
}

impl ::protobuf::EnumFull for ProtoDefTypes {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ProtoDefTypes").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ProtoDefTypes::DEF_TYPE_QUEST_MAP_NODE => 0,
            ProtoDefTypes::DEF_TYPE_QUEST_THEME => 1,
            ProtoDefTypes::DEF_TYPE_QUEST_MAP_REGION => 2,
            ProtoDefTypes::DEF_TYPE_QUEST => 3,
            ProtoDefTypes::DEF_TYPE_QUEST_OBJECTIVE => 4,
            ProtoDefTypes::DEF_TYPE_PAINTKIT_VARIABLES => 5,
            ProtoDefTypes::DEF_TYPE_PAINTKIT_OPERATION => 6,
            ProtoDefTypes::DEF_TYPE_PAINTKIT_ITEM_DEFINITION => 7,
            ProtoDefTypes::DEF_TYPE_PAINTKIT_DEFINITION => 8,
            ProtoDefTypes::DEF_TYPE_HEADER_ONLY => 9,
            ProtoDefTypes::DEF_TYPE_QUEST_MAP_STORE_ITEM => 10,
            ProtoDefTypes::DEF_TYPE_QUEST_MAP_STAR_TYPE => 11,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ProtoDefTypes {
    fn default() -> Self {
        ProtoDefTypes::DEF_TYPE_QUEST_MAP_NODE
    }
}

impl ProtoDefTypes {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ProtoDefTypes>("ProtoDefTypes")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EQuestPoints)
pub enum EQuestPoints {
    // @@protoc_insertion_point(enum_value:EQuestPoints.QUEST_POINTS_NOVICE)
    QUEST_POINTS_NOVICE = 0,
    // @@protoc_insertion_point(enum_value:EQuestPoints.QUEST_POINTS_ADVANCED)
    QUEST_POINTS_ADVANCED = 1,
    // @@protoc_insertion_point(enum_value:EQuestPoints.QUEST_POINTS_EXPERT)
    QUEST_POINTS_EXPERT = 2,
}

impl ::protobuf::Enum for EQuestPoints {
    const NAME: &'static str = "EQuestPoints";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EQuestPoints> {
        match value {
            0 => ::std::option::Option::Some(EQuestPoints::QUEST_POINTS_NOVICE),
            1 => ::std::option::Option::Some(EQuestPoints::QUEST_POINTS_ADVANCED),
            2 => ::std::option::Option::Some(EQuestPoints::QUEST_POINTS_EXPERT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EQuestPoints> {
        match str {
            "QUEST_POINTS_NOVICE" => ::std::option::Option::Some(EQuestPoints::QUEST_POINTS_NOVICE),
            "QUEST_POINTS_ADVANCED" => ::std::option::Option::Some(EQuestPoints::QUEST_POINTS_ADVANCED),
            "QUEST_POINTS_EXPERT" => ::std::option::Option::Some(EQuestPoints::QUEST_POINTS_EXPERT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EQuestPoints] = &[
        EQuestPoints::QUEST_POINTS_NOVICE,
        EQuestPoints::QUEST_POINTS_ADVANCED,
        EQuestPoints::QUEST_POINTS_EXPERT,
    ];
}

impl ::protobuf::EnumFull for EQuestPoints {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EQuestPoints").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EQuestPoints {
    fn default() -> Self {
        EQuestPoints::QUEST_POINTS_NOVICE
    }
}

impl EQuestPoints {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EQuestPoints>("EQuestPoints")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EVarFieldType)
pub enum EVarFieldType {
    // @@protoc_insertion_point(enum_value:EVarFieldType.VAR_TYPE_INVALID)
    VAR_TYPE_INVALID = 1,
    // @@protoc_insertion_point(enum_value:EVarFieldType.VAR_TYPE_FLOAT)
    VAR_TYPE_FLOAT = 2,
    // @@protoc_insertion_point(enum_value:EVarFieldType.VAR_TYPE_DOUBLE)
    VAR_TYPE_DOUBLE = 3,
    // @@protoc_insertion_point(enum_value:EVarFieldType.VAR_TYPE_UINT32)
    VAR_TYPE_UINT32 = 4,
    // @@protoc_insertion_point(enum_value:EVarFieldType.VAR_TYPE_UINT64)
    VAR_TYPE_UINT64 = 5,
    // @@protoc_insertion_point(enum_value:EVarFieldType.VAR_TYPE_SINT32)
    VAR_TYPE_SINT32 = 6,
    // @@protoc_insertion_point(enum_value:EVarFieldType.VAR_TYPE_SINT64)
    VAR_TYPE_SINT64 = 7,
    // @@protoc_insertion_point(enum_value:EVarFieldType.VAR_TYPE_BOOL)
    VAR_TYPE_BOOL = 8,
    // @@protoc_insertion_point(enum_value:EVarFieldType.VAR_TYPE_STRING)
    VAR_TYPE_STRING = 9,
}

impl ::protobuf::Enum for EVarFieldType {
    const NAME: &'static str = "EVarFieldType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EVarFieldType> {
        match value {
            1 => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_INVALID),
            2 => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_FLOAT),
            3 => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_DOUBLE),
            4 => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_UINT32),
            5 => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_UINT64),
            6 => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_SINT32),
            7 => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_SINT64),
            8 => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_BOOL),
            9 => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_STRING),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EVarFieldType> {
        match str {
            "VAR_TYPE_INVALID" => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_INVALID),
            "VAR_TYPE_FLOAT" => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_FLOAT),
            "VAR_TYPE_DOUBLE" => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_DOUBLE),
            "VAR_TYPE_UINT32" => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_UINT32),
            "VAR_TYPE_UINT64" => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_UINT64),
            "VAR_TYPE_SINT32" => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_SINT32),
            "VAR_TYPE_SINT64" => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_SINT64),
            "VAR_TYPE_BOOL" => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_BOOL),
            "VAR_TYPE_STRING" => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_STRING),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EVarFieldType] = &[
        EVarFieldType::VAR_TYPE_INVALID,
        EVarFieldType::VAR_TYPE_FLOAT,
        EVarFieldType::VAR_TYPE_DOUBLE,
        EVarFieldType::VAR_TYPE_UINT32,
        EVarFieldType::VAR_TYPE_UINT64,
        EVarFieldType::VAR_TYPE_SINT32,
        EVarFieldType::VAR_TYPE_SINT64,
        EVarFieldType::VAR_TYPE_BOOL,
        EVarFieldType::VAR_TYPE_STRING,
    ];
}

impl ::protobuf::EnumFull for EVarFieldType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EVarFieldType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EVarFieldType::VAR_TYPE_INVALID => 0,
            EVarFieldType::VAR_TYPE_FLOAT => 1,
            EVarFieldType::VAR_TYPE_DOUBLE => 2,
            EVarFieldType::VAR_TYPE_UINT32 => 3,
            EVarFieldType::VAR_TYPE_UINT64 => 4,
            EVarFieldType::VAR_TYPE_SINT32 => 5,
            EVarFieldType::VAR_TYPE_SINT64 => 6,
            EVarFieldType::VAR_TYPE_BOOL => 7,
            EVarFieldType::VAR_TYPE_STRING => 8,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EVarFieldType {
    fn default() -> Self {
        EVarFieldType::VAR_TYPE_INVALID
    }
}

impl EVarFieldType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EVarFieldType>("EVarFieldType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ENodeCashReward)
pub enum ENodeCashReward {
    // @@protoc_insertion_point(enum_value:ENodeCashReward.CASH_REWARD_NONE)
    CASH_REWARD_NONE = 1,
    // @@protoc_insertion_point(enum_value:ENodeCashReward.CASH_REWARD_SMALL)
    CASH_REWARD_SMALL = 2,
    // @@protoc_insertion_point(enum_value:ENodeCashReward.CASH_REWARD_MEDIUM)
    CASH_REWARD_MEDIUM = 3,
    // @@protoc_insertion_point(enum_value:ENodeCashReward.CASH_REWARD_LARGE)
    CASH_REWARD_LARGE = 4,
}

impl ::protobuf::Enum for ENodeCashReward {
    const NAME: &'static str = "ENodeCashReward";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ENodeCashReward> {
        match value {
            1 => ::std::option::Option::Some(ENodeCashReward::CASH_REWARD_NONE),
            2 => ::std::option::Option::Some(ENodeCashReward::CASH_REWARD_SMALL),
            3 => ::std::option::Option::Some(ENodeCashReward::CASH_REWARD_MEDIUM),
            4 => ::std::option::Option::Some(ENodeCashReward::CASH_REWARD_LARGE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ENodeCashReward> {
        match str {
            "CASH_REWARD_NONE" => ::std::option::Option::Some(ENodeCashReward::CASH_REWARD_NONE),
            "CASH_REWARD_SMALL" => ::std::option::Option::Some(ENodeCashReward::CASH_REWARD_SMALL),
            "CASH_REWARD_MEDIUM" => ::std::option::Option::Some(ENodeCashReward::CASH_REWARD_MEDIUM),
            "CASH_REWARD_LARGE" => ::std::option::Option::Some(ENodeCashReward::CASH_REWARD_LARGE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ENodeCashReward] = &[
        ENodeCashReward::CASH_REWARD_NONE,
        ENodeCashReward::CASH_REWARD_SMALL,
        ENodeCashReward::CASH_REWARD_MEDIUM,
        ENodeCashReward::CASH_REWARD_LARGE,
    ];
}

impl ::protobuf::EnumFull for ENodeCashReward {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ENodeCashReward").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ENodeCashReward::CASH_REWARD_NONE => 0,
            ENodeCashReward::CASH_REWARD_SMALL => 1,
            ENodeCashReward::CASH_REWARD_MEDIUM => 2,
            ENodeCashReward::CASH_REWARD_LARGE => 3,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ENodeCashReward {
    fn default() -> Self {
        ENodeCashReward::CASH_REWARD_NONE
    }
}

impl ENodeCashReward {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ENodeCashReward>("ENodeCashReward")
    }
}

/// Extension fields
pub mod exts {

    pub const start_expanded: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::MessageOptions, bool> = ::protobuf::ext::ExtFieldOptional::new(80000, ::protobuf::descriptor::field_descriptor_proto::Type::TYPE_BOOL);

    pub const valid_type: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::FieldOptions, ::protobuf::EnumOrUnknown<super::ProtoDefTypes>> = ::protobuf::ext::ExtFieldOptional::new(70000, ::protobuf::descriptor::field_descriptor_proto::Type::TYPE_ENUM);

    pub const editable: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::FieldOptions, bool> = ::protobuf::ext::ExtFieldOptional::new(70001, ::protobuf::descriptor::field_descriptor_proto::Type::TYPE_BOOL);

    pub const localized: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::FieldOptions, bool> = ::protobuf::ext::ExtFieldOptional::new(70002, ::protobuf::descriptor::field_descriptor_proto::Type::TYPE_BOOL);

    pub const do_not_inherit: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::FieldOptions, bool> = ::protobuf::ext::ExtFieldOptional::new(70003, ::protobuf::descriptor::field_descriptor_proto::Type::TYPE_BOOL);

    pub const display_name: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::FieldOptions, ::std::string::String> = ::protobuf::ext::ExtFieldOptional::new(70004, ::protobuf::descriptor::field_descriptor_proto::Type::TYPE_STRING);

    pub const comment: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::FieldOptions, ::std::string::String> = ::protobuf::ext::ExtFieldOptional::new(70005, ::protobuf::descriptor::field_descriptor_proto::Type::TYPE_STRING);

    pub const max_count: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::FieldOptions, u32> = ::protobuf::ext::ExtFieldOptional::new(70007, ::protobuf::descriptor::field_descriptor_proto::Type::TYPE_UINT32);

    pub const allow_add: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::FieldOptions, bool> = ::protobuf::ext::ExtFieldOptional::new(70008, ::protobuf::descriptor::field_descriptor_proto::Type::TYPE_BOOL);

    pub const allow_delete: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::FieldOptions, bool> = ::protobuf::ext::ExtFieldOptional::new(70009, ::protobuf::descriptor::field_descriptor_proto::Type::TYPE_BOOL);

    pub const panel_class_override: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::FieldOptions, ::std::string::String> = ::protobuf::ext::ExtFieldOptional::new(70010, ::protobuf::descriptor::field_descriptor_proto::Type::TYPE_STRING);

    pub const message_inherhitance_key_field_name: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::FieldOptions, ::std::string::String> = ::protobuf::ext::ExtFieldOptional::new(70011, ::protobuf::descriptor::field_descriptor_proto::Type::TYPE_STRING);

    pub const inherit_reference_variables: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::FieldOptions, bool> = ::protobuf::ext::ExtFieldOptional::new(70012, ::protobuf::descriptor::field_descriptor_proto::Type::TYPE_BOOL);

    pub const self_inherit_only: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::FieldOptions, bool> = ::protobuf::ext::ExtFieldOptional::new(70013, ::protobuf::descriptor::field_descriptor_proto::Type::TYPE_BOOL);

    pub const var_field_type: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::FieldOptions, ::protobuf::EnumOrUnknown<super::EVarFieldType>> = ::protobuf::ext::ExtFieldOptional::new(70014, ::protobuf::descriptor::field_descriptor_proto::Type::TYPE_ENUM);

    pub const merging_key_field: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::FieldOptions, bool> = ::protobuf::ext::ExtFieldOptional::new(70015, ::protobuf::descriptor::field_descriptor_proto::Type::TYPE_BOOL);
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1ftf2/tf_proto_def_messages.proto\x1a\x20google/protobuf/descriptor.\
    proto\"\x92\x01\n\x0bCMsgFieldID\x12,\n\x05field\x18\x01\x20\x03(\x0b2\
    \x16.CMsgFieldID.CMsgFieldR\x05field\x1aU\n\tCMsgField\x12!\n\x0cfield_n\
    umber\x18\x01\x20\x01(\rR\x0bfieldNumber\x12%\n\x0erepeated_index\x18\
    \x02\x20\x01(\rR\rrepeatedIndex\"\xc5\x01\n\x14CMsgUniversalFieldID\x12K\
    \n\x0bsource_type\x18\x01\x20\x01(\x0e2\x17.EValueDefinitionSource:\x11R\
    EFERENCE_DEFINESR\nsourceType\x127\n\x0fdefining_obj_id\x18\x02\x20\x01(\
    \x0b2\x0f.CMsgProtoDefIDR\rdefiningObjId\x12'\n\x08field_id\x18\x03\x20\
    \x01(\x0b2\x0c.CMsgFieldIDR\x07fieldId\"h\n\x16CMsgVariableDefinition\
    \x12\x18\n\x04name\x18\x01\x20\x01(\tR\x04nameB\x04\xf8\x97\"\x01\x12\
    \x1e\n\x07inherit\x18\x02\x20\x01(\x08:\x04trueR\x07inherit\x12\x14\n\
    \x05value\x18\x03\x20\x01(\tR\x05value\"\xa3\x05\n\x12CMsgProtoDefHeader\
    \x12A\n\x08defindex\x18\x01\x20\x02(\rR\x08defindexB%\xaa\x97\"\rAutogen\
    erated\x88\x97\"\0\xa2\x97\"\x08Defindex\xe8\x97\"\x01\x12>\n\x04name\
    \x18\x02\x20\x01(\tR\x04nameB*\xe8\x97\"\x01\xa2\x97\"\x04Name\xaa\x97\"\
    \x1aName\x20to\x20show\x20in\x20the\x20editor\x12\x9e\x01\n\x07prefabs\
    \x18\x03\x20\x03(\x0b2\x0f.CMsgProtoDefIDR\x07prefabsBs\xd2\x97\"\x18CPr\
    efabFieldEditingPanel\xaa\x97\"EInherit\x20the\x20values\x20of\x20these\
    \x20definitions,\x20in\x20order\x20from\x20top\x20to\x20bottom.\xa2\x97\
    \"\x06Prefab\xe8\x97\"\x01\x12y\n\x04tags\x18\x04\x20\x03(\tR\x04tagsBe\
    \xa2\x97\"\x04Tags\xaa\x97\"YStrings\x20used\x20to\x20describe\x20this\
    \x20definition\x20while\x20searching.\x20\x20ie.\x20'class',\x20'shotgun\
    ',\x20'easy'\x12\x81\x01\n\x0bprefab_only\x18\x05\x20\x01(\x08:\x05false\
    R\nprefabOnlyBY\xe8\x97\"\x01\xa2\x97\"\x0bPure\x20Prefab\xaa\x97\"BIf\
    \x20true,\x20this\x20is\x20only\x20a\x20prefab\x20and\x20will\x20not\x20\
    be\x20made\x20into\x20an\x20object\x12j\n\tvariables\x18\x06\x20\x03(\
    \x0b2\x17.CMsgVariableDefinitionR\tvariablesB3\xda\x97\"\x04name\xa2\x97\
    \"\tVariables\xaa\x97\"\x1aVariable\x20value\x20definitions\"6\n\x0eCMsg\
    ValidTypes\x12$\n\x05types\x18\x01\x20\x03(\x0e2\x0e.ProtoDefTypesR\x05t\
    ypes\"\xce\x08\n\x0eCMsgProtoDefID\x12\x1a\n\x08defindex\x18\x01\x20\x01\
    (\rR\x08defindex\x12;\n\x04type\x18\x02\x20\x01(\x0e2\x0e.ProtoDefTypes:\
    \x17DEF_TYPE_QUEST_MAP_NODER\x04type\x12]\n\x20instance_def_type_quest_m\
    ap_node\x18\x03\x20\x01(\x0b2\x14.CMsgQuestMapNodeDefH\0R\x1binstanceDef\
    TypeQuestMapNode\x12S\n\x1dinstance_def_type_quest_theme\x18\x05\x20\x01\
    (\x0b2\x0f.CMsgQuestThemeH\0R\x19instanceDefTypeQuestTheme\x12c\n\"insta\
    nce_def_type_quest_map_region\x18\x06\x20\x01(\x0b2\x16.CMsgQuestMapRegi\
    onDefH\0R\x1dinstanceDefTypeQuestMapRegion\x12F\n\x17instance_def_type_q\
    uest\x18\x07\x20\x01(\x0b2\r.CMsgQuestDefH\0R\x14instanceDefTypeQuest\
    \x12b\n!instance_def_type_quest_objective\x18\x08\x20\x01(\x0b2\x16.CMsg\
    QuestObjectiveDefH\0R\x1dinstanceDefTypeQuestObjective\x12i\n$instance_d\
    ef_type_paintkit_variables\x18\t\x20\x01(\x0b2\x17.CMsgPaintKit_Variable\
    sH\0R\x20instanceDefTypePaintkitVariables\x12i\n$instance_def_type_paint\
    kit_operation\x18\n\x20\x01(\x0b2\x17.CMsgPaintKit_OperationH\0R\x20inst\
    anceDefTypePaintkitOperation\x12y\n*instance_def_type_paintkit_item_defi\
    nition\x18\x0b\x20\x01(\x0b2\x1c.CMsgPaintKit_ItemDefinitionH\0R%instanc\
    eDefTypePaintkitItemDefinition\x12l\n%instance_def_type_paintkit_definit\
    ion\x18\x0c\x20\x01(\x0b2\x18.CMsgPaintKit_DefinitionH\0R!instanceDefTyp\
    ePaintkitDefinition\x12S\n\x1dinstance_def_type_header_only\x18\r\x20\
    \x01(\x0b2\x0f.CMsgHeaderOnlyH\0R\x19instanceDefTypeHeaderOnlyB\n\n\x08i\
    nstance\"\xd2-\n\x15CMsgQuestObjectiveDef\x12+\n\x06header\x18\x01\x20\
    \x02(\x0b2\x13.CMsgProtoDefHeaderR\x06header\x12)\n\rloc_desctoken\x18\
    \x02\x20\x01(\tR\x0clocDesctokenB\x04\x90\x97\"\x01\x12\x16\n\x06points\
    \x18\x03\x20\x01(\rR\x06points\x12/\n\x13conditions_defindex\x18\x05\x20\
    \x01(\rR\x12conditionsDefindex\x12j\n\x03map\x18\x08\x20\x03(\tR\x03mapB\
    X\xa2\x97\"\rMaps\x20Modifier\xaa\x97\"CIf\x20set,\x20the\x20player\x20m\
    ust\x20be\x20on\x20one\x20of\x20the\x20listed\x20maps\x20to\x20get\x20cr\
    edit.\x12\xa6\x01\n\tgame_mode\x18\t\x20\x03(\x0e2$.CMsgQuestObjectiveDe\
    f.ETF2GameModesR\x08gameModeBc\xa2\x97\"\x12Game\x20Mode\x20Modifier\xaa\
    \x97\"IIf\x20set,\x20the\x20player\x20must\x20be\x20in\x20one\x20of\x20t\
    he\x20listed\x20game\x20modes\x20to\x20get\x20credit.\x12\x96\x01\n\x04t\
    eam\x18\n\x20\x01(\x0e2\x1f.CMsgQuestObjectiveDef.ETF2Team:\x0bTF_TEAM_R\
    EDR\x04teamBT\xa2\x97\"\rTeam\x20Modifier\xaa\x97\"?If\x20set,\x20the\
    \x20player\x20must\x20be\x20on\x20the\x20specified\x20team\x20to\x20get\
    \x20credit.\x12L\n\x0econdition_vars\x18\x0b\x20\x03(\x0b2\r.CMsgVarFiel\
    dR\rconditionVarsB\x16\xf0\x97\"\t\xa2\x97\"\x0eObjective\x20Vars\x12H\n\
    \x0cclasses_vars\x18\x0c\x20\x03(\x0b2\r.CMsgVarFieldR\x0bclassesVarsB\
    \x16\xf0\x97\"\t\xa2\x97\"\x0eClass\x20Modifier\x12Y\n\nconditions\x18\r\
    \x20\x03(\x0e2%.CMsgQuestObjectiveDef.ETF2ConditionsR\nconditionsB\x12\
    \xa2\x97\"\x0eRequired\x20Conds\x12\x9a\x01\n\x0fcondition_logic\x18\x0e\
    \x20\x01(\x0e2\x11.LogicalOperation:\x03ANDR\x0econditionLogicBY\xa2\x97\
    \"\x0fCondition\x20Logic\xaa\x97\"BWhat\x20kind\x20of\x20logic\x20to\x20\
    use\x20when\x20evaluating\x20the\x20player's\x20conditions.\x12j\n\titem\
    _name\x18\x0f\x20\x03(\tR\x08itemNameBM\xa2\x97\"\x16Required\x20equippe\
    d\x20item\xaa\x97\"/Require\x20that\x20this\x20item\x20be\x20equipped\
    \x20in\x20any\x20slot.\x12\x86\x01\n\nitem_logic\x18\x10\x20\x01(\x0e2\
    \x11.LogicalOperation:\x03ANDR\titemLogicBO\xa2\x97\"\nItem\x20logic\xaa\
    \x97\"=What\x20kind\x20of\x20logic\x20to\x20use\x20when\x20evaluating\
    \x20the\x20player's\x20items.\x12a\n\njump_state\x18\x11\x20\x01(\rR\tju\
    mpStateBB\xa2\x97\"\nJump\x20logic\xaa\x97\"0What\x20state\x20of\x20jump\
    ing\x20the\x20player\x20needs\x20to\x20be\x20in.\"\xbd\x04\n\rETF2GameMo\
    des\x12\x18\n\x14kGameCategory_Escort\x10\0\x12\x15\n\x11kGameCategory_C\
    TF\x10\x01\x12\x1f\n\x1bkGameCategory_AttackDefense\x10\x02\x12\x16\n\
    \x12kGameCategory_Koth\x10\x03\x12\x14\n\x10kGameCategory_CP\x10\x04\x12\
    \x1c\n\x18kGameCategory_EscortRace\x10\x05\x12\x1a\n\x16kGameCategory_Ev\
    entMix\x10\x06\x12\x14\n\x10kGameCategory_SD\x10\x07\x12\x1b\n\x17kGameC\
    ategory_Quickplay\x10\x08\x12\x1a\n\x16kGameCategory_Event247\x10\t\x12\
    \x17\n\x13kGameCategory_Arena\x10\n\x12\"\n\x1ekGameCategory_RobotDestru\
    ction\x10\x0b\x12\x19\n\x15kGameCategory_Powerup\x10\x0c\x12\x1a\n\x16kG\
    ameCategory_Featured\x10\r\x12\x1a\n\x16kGameCategory_Passtime\x10\x0e\
    \x12\"\n\x1ekGameCategory_Community_Update\x10\x0f\x12\x16\n\x12kGameCat\
    egory_Misc\x10\x10\x12!\n\x1dkGameCategory_Competitive_6v6\x10\x11\x12\
    \x17\n\x13kGameCategory_Other\x10\x12\x12\x1b\n\x17kGameCategory_Hallowe\
    en\x10\x13\"\x92\x1e\n\x0eETF2Conditions\x12\x12\n\x0eTF_COND_AIMING\x10\
    \0\x12\x12\n\x0eTF_COND_ZOOMED\x10\x01\x12\x16\n\x12TF_COND_DISGUISING\
    \x10\x02\x12\x15\n\x11TF_COND_DISGUISED\x10\x03\x12\x15\n\x11TF_COND_STE\
    ALTHED\x10\x04\x12\x18\n\x14TF_COND_INVULNERABLE\x10\x05\x12\x16\n\x12TF\
    _COND_TELEPORTED\x10\x06\x12\x14\n\x10TF_COND_TAUNTING\x10\x07\x12#\n\
    \x1fTF_COND_INVULNERABLE_WEARINGOFF\x10\x08\x12\x1b\n\x17TF_COND_STEALTH\
    ED_BLINK\x10\t\x12\x20\n\x1cTF_COND_SELECTED_TO_TELEPORT\x10\n\x12\x17\n\
    \x13TF_COND_CRITBOOSTED\x10\x0b\x12\x1a\n\x16TF_COND_TMPDAMAGEBONUS\x10\
    \x0c\x12\x17\n\x13TF_COND_FEIGN_DEATH\x10\r\x12\x11\n\rTF_COND_PHASE\x10\
    \x0e\x12\x13\n\x0fTF_COND_STUNNED\x10\x0f\x12\x17\n\x13TF_COND_OFFENSEBU\
    FF\x10\x10\x12\x19\n\x15TF_COND_SHIELD_CHARGE\x10\x11\x12\x15\n\x11TF_CO\
    ND_DEMO_BUFF\x10\x12\x12\x17\n\x13TF_COND_ENERGY_BUFF\x10\x13\x12\x16\n\
    \x12TF_COND_RADIUSHEAL\x10\x14\x12\x17\n\x13TF_COND_HEALTH_BUFF\x10\x15\
    \x12\x13\n\x0fTF_COND_BURNING\x10\x16\x12\x1d\n\x19TF_COND_HEALTH_OVERHE\
    ALED\x10\x17\x12\x11\n\rTF_COND_URINE\x10\x18\x12\x14\n\x10TF_COND_BLEED\
    ING\x10\x19\x12\x17\n\x13TF_COND_DEFENSEBUFF\x10\x1a\x12\x14\n\x10TF_CON\
    D_MAD_MILK\x10\x1b\x12\x14\n\x10TF_COND_MEGAHEAL\x10\x1c\x12\x1d\n\x19TF\
    _COND_REGENONDAMAGEBUFF\x10\x1d\x12\x1a\n\x16TF_COND_MARKEDFORDEATH\x10\
    \x1e\x12\x1f\n\x1bTF_COND_NOHEALINGDAMAGEBUFF\x10\x1f\x12\x17\n\x13TF_CO\
    ND_SPEED_BOOST\x10\x20\x12\x1f\n\x1bTF_COND_CRITBOOSTED_PUMPKIN\x10!\x12\
    !\n\x1dTF_COND_CRITBOOSTED_USER_BUFF\x10\"\x12#\n\x1fTF_COND_CRITBOOSTED\
    _DEMO_CHARGE\x10#\x12\x1b\n\x17TF_COND_SODAPOPPER_HYPE\x10$\x12#\n\x1fTF\
    _COND_CRITBOOSTED_FIRST_BLOOD\x10%\x12\"\n\x1eTF_COND_CRITBOOSTED_BONUS_\
    TIME\x10&\x12#\n\x1fTF_COND_CRITBOOSTED_CTF_CAPTURE\x10'\x12\x1f\n\x1bTF\
    _COND_CRITBOOSTED_ON_KILL\x10(\x12$\n\x20TF_COND_CANNOT_SWITCH_FROM_MELE\
    E\x10)\x12%\n!TF_COND_DEFENSEBUFF_NO_CRIT_BLOCK\x10*\x12\x18\n\x14TF_CON\
    D_REPROGRAMMED\x10+\x12!\n\x1dTF_COND_CRITBOOSTED_RAGE_BUFF\x10,\x12\x1c\
    \n\x18TF_COND_DEFENSEBUFF_HIGH\x10-\x12\"\n\x1eTF_COND_SNIPERCHARGE_RAGE\
    _BUFF\x10.\x12\x1f\n\x1bTF_COND_DISGUISE_WEARINGOFF\x10/\x12!\n\x1dTF_CO\
    ND_MARKEDFORDEATH_SILENT\x100\x12\"\n\x1eTF_COND_DISGUISED_AS_DISPENSER\
    \x101\x12\x12\n\x0eTF_COND_SAPPED\x102\x12,\n(TF_COND_INVULNERABLE_HIDE_\
    UNLESS_DAMAGED\x103\x12\"\n\x1eTF_COND_INVULNERABLE_USER_BUFF\x104\x12\
    \x1f\n\x1bTF_COND_HALLOWEEN_BOMB_HEAD\x105\x12\x1e\n\x1aTF_COND_HALLOWEE\
    N_THRILLER\x106\x12\x20\n\x1cTF_COND_RADIUSHEAL_ON_DAMAGE\x107\x12#\n\
    \x1fTF_COND_CRITBOOSTED_CARD_EFFECT\x108\x12$\n\x20TF_COND_INVULNERABLE_\
    CARD_EFFECT\x109\x12&\n\"TF_COND_MEDIGUN_UBER_BULLET_RESIST\x10:\x12%\n!\
    TF_COND_MEDIGUN_UBER_BLAST_RESIST\x10;\x12$\n\x20TF_COND_MEDIGUN_UBER_FI\
    RE_RESIST\x10<\x12'\n#TF_COND_MEDIGUN_SMALL_BULLET_RESIST\x10=\x12&\n\"T\
    F_COND_MEDIGUN_SMALL_BLAST_RESIST\x10>\x12%\n!TF_COND_MEDIGUN_SMALL_FIRE\
    _RESIST\x10?\x12\x1f\n\x1bTF_COND_STEALTHED_USER_BUFF\x10@\x12\x1a\n\x16\
    TF_COND_MEDIGUN_DEBUFF\x10A\x12&\n\"TF_COND_STEALTHED_USER_BUFF_FADING\
    \x10B\x12\x19\n\x15TF_COND_BULLET_IMMUNE\x10C\x12\x18\n\x14TF_COND_BLAST\
    _IMMUNE\x10D\x12\x17\n\x13TF_COND_FIRE_IMMUNE\x10E\x12\x19\n\x15TF_COND_\
    PREVENT_DEATH\x10F\x12\"\n\x1eTF_COND_MVM_BOT_STUN_RADIOWAVE\x10G\x12!\n\
    \x1dTF_COND_HALLOWEEN_SPEED_BOOST\x10H\x12\x20\n\x1cTF_COND_HALLOWEEN_QU\
    ICK_HEAL\x10I\x12\x1b\n\x17TF_COND_HALLOWEEN_GIANT\x10J\x12\x1a\n\x16TF_\
    COND_HALLOWEEN_TINY\x10K\x12\x1d\n\x19TF_COND_HALLOWEEN_IN_HELL\x10L\x12\
    \x20\n\x1cTF_COND_HALLOWEEN_GHOST_MODE\x10M\x12#\n\x1fTF_COND_MINICRITBO\
    OSTED_ON_KILL\x10N\x12\x1a\n\x16TF_COND_OBSCURED_SMOKE\x10O\x12\x1c\n\
    \x18TF_COND_PARACHUTE_ACTIVE\x10P\x12\x18\n\x14TF_COND_BLASTJUMPING\x10Q\
    \x12\x1a\n\x16TF_COND_HALLOWEEN_KART\x10R\x12\x1f\n\x1bTF_COND_HALLOWEEN\
    _KART_DASH\x10S\x12\x18\n\x14TF_COND_BALLOON_HEAD\x10T\x12\x16\n\x12TF_C\
    OND_MELEE_ONLY\x10U\x12\x1a\n\x16TF_COND_SWIMMING_CURSE\x10V\x12\x18\n\
    \x14TF_COND_FREEZE_INPUT\x10W\x12\x1f\n\x1bTF_COND_HALLOWEEN_KART_CAGE\
    \x10X\x12\x16\n\x12TF_COND_DONOTUSE_0\x10Y\x12\x19\n\x15TF_COND_RUNE_STR\
    ENGTH\x10Z\x12\x16\n\x12TF_COND_RUNE_HASTE\x10[\x12\x16\n\x12TF_COND_RUN\
    E_REGEN\x10\\\x12\x17\n\x13TF_COND_RUNE_RESIST\x10]\x12\x18\n\x14TF_COND\
    _RUNE_VAMPIRE\x10^\x12\x18\n\x14TF_COND_RUNE_REFLECT\x10_\x12\x1a\n\x16T\
    F_COND_RUNE_PRECISION\x10`\x12\x18\n\x14TF_COND_RUNE_AGILITY\x10a\x12\
    \x19\n\x15TF_COND_GRAPPLINGHOOK\x10b\x12\"\n\x1eTF_COND_GRAPPLINGHOOK_SA\
    FEFALL\x10c\x12!\n\x1dTF_COND_GRAPPLINGHOOK_LATCHED\x10d\x12\"\n\x1eTF_C\
    OND_GRAPPLINGHOOK_BLEEDING\x10e\x12\x1c\n\x18TF_COND_AFTERBURN_IMMUNE\
    \x10f\x12\x19\n\x15TF_COND_RUNE_KNOCKOUT\x10g\x12\x1a\n\x16TF_COND_RUNE_\
    IMBALANCE\x10h\x12!\n\x1dTF_COND_CRITBOOSTED_RUNE_TEMP\x10i\x12!\n\x1dTF\
    _COND_PASSTIME_INTERCEPTION\x10j\x12\x1f\n\x1bTF_COND_SWIMMING_NO_EFFECT\
    S\x10k\x12\x15\n\x11TF_COND_PURGATORY\x10l\x12\x15\n\x11TF_COND_RUNE_KIN\
    G\x10m\x12\x17\n\x13TF_COND_RUNE_PLAGUE\x10n\x12\x1a\n\x16TF_COND_RUNE_S\
    UPERNOVA\x10o\x12\x12\n\x0eTF_COND_PLAGUE\x10p\x12\x17\n\x13TF_COND_KING\
    _BUFFED\x10q\x12\x16\n\x12TF_COND_TEAM_GLOWS\x10r\x12\x1c\n\x18TF_COND_K\
    NOCKED_INTO_AIR\x10s\x12\x1e\n\x1aTF_COND_COMPETITIVE_WINNER\x10t\x12\
    \x1d\n\x19TF_COND_COMPETITIVE_LOSER\x10u\x12\x1a\n\x16TF_COND_HEALING_DE\
    BUFF\x10v\x12#\n\x1fTF_COND_PASSTIME_PENALTY_DEBUFF\x10w\x12\x1e\n\x1aTF\
    _COND_PARACHUTE_DEPLOYED\x10x\x12!\n\x1dTF_COND_NO_COMBAT_SPEED_BOOST\
    \x10y\x12\x1b\n\x17TF_COND_TRANQ_SPY_BOOST\x10z\x12\x18\n\x14TF_COND_TRA\
    NQ_MARKED\x10{\x12\x16\n\x12TF_COND_ROCKETPACK\x10~\x12\x20\n\x1cTF_COND\
    _ROCKETPACK_PASSENGER\x10\x7f\x12\x1c\n\x17TF_COND_STEALTHED_PHASE\x10\
    \x80\x01\x12\x1a\n\x15TF_COND_CLIP_OVERLOAD\x10\x81\x01\x12\x1c\n\x17TF_\
    COND_SPY_CLASS_STEAL\x10\x82\x01\x12\x10\n\x0bTF_COND_GAS\x10\x83\x01\"-\
    \n\x08ETF2Team\x12\x0f\n\x0bTF_TEAM_RED\x10\x02\x12\x10\n\x0cTF_TEAM_BLU\
    E\x10\x03\"\x9c\t\n\x0cCMsgQuestDef\x12+\n\x06header\x18\x01\x20\x02(\
    \x0b2\x13.CMsgProtoDefHeaderR\x06header\x12\x20\n\x0cmax_points_0\x18\
    \x02\x20\x01(\rR\nmaxPoints0\x12\x20\n\x0cmax_points_1\x18\x03\x20\x01(\
    \rR\nmaxPoints1\x12\x20\n\x0cmax_points_2\x18\x04\x20\x01(\rR\nmaxPoints\
    2\x12)\n\rname_loctoken\x18\x05\x20\x01(\tR\x0cnameLoctokenB\x04\x90\x97\
    \"\x01\x12\x1c\n\toperation\x18\x07\x20\x01(\tR\toperation\x129\n\x0bmm_\
    criteria\x18\x08\x20\x01(\x0b2\x18.CMsgQuestDef.MMCriteriaR\nmmCriteria\
    \x12_\n\nnode_image\x18\x0c\x20\x01(\tR\tnodeImageB@\xa2\x97\"\nNode\x20\
    Image\xaa\x97\".Filename\x20of\x20the\x20image\x20to\x20show\x20on\x20th\
    e\x20node\x20view\x12M\n\nicon_image\x18\r\x20\x01(\tR\ticonImageB.\xa2\
    \x97\"\tNode\x20Icon\xaa\x97\"\x1dWhich\x20icon\x20to\x20show\x20on\x20t\
    he\x20map\x12+\n\x05theme\x18\x0e\x20\x01(\x0b2\x0f.CMsgProtoDefIDR\x05t\
    hemeB\x04\x80\x97\"\x02\x12S\n\x0cloaner_names\x18\x0f\x20\x03(\tR\x0blo\
    anerNamesB0\xa2\x97\"\x07Loaners\xaa\x97\"!Names\x20of\x20items\x20to\
    \x20give\x20as\x20loaners\x12?\n\nobjectives\x18\x10\x20\x03(\x0b2\x1f.C\
    MsgQuestDef.ObjectiveInstanceR\nobjectives\x12j\n\x03map\x18\x11\x20\x03\
    (\tR\x03mapBX\xa2\x97\"\rMaps\x20Modifier\xaa\x97\"CIf\x20set,\x20the\
    \x20player\x20must\x20be\x20on\x20one\x20of\x20the\x20listed\x20maps\x20\
    to\x20get\x20credit.\x1ak\n\nMMCriteria\x12\x1d\n\ngroup_name\x18\x01\
    \x20\x01(\tR\tgroupName\x12#\n\rcategory_name\x18\x02\x20\x01(\tR\x0ccat\
    egoryName\x12\x19\n\x08map_name\x18\x03\x20\x01(\tR\x07mapName\x1a\xa8\
    \x02\n\x11ObjectiveInstance\x123\n\tobjective\x18\x01\x20\x01(\x0b2\x0f.\
    CMsgProtoDefIDR\tobjectiveB\x04\x80\x97\"\x05\x12A\n\npoint_type\x18\x02\
    \x20\x01(\x0e2\r.EQuestPoints:\x13QUEST_POINTS_NOVICER\tpointType\x12\
    \x9a\x01\n\x0bpoint_value\x18\x03\x20\x01(\rR\npointValueBy\xa2\x97\"\
    \x0fPoints\x20Override\xaa\x97\"bOverride\x20value\x20for\x20the\x20poin\
    t\x20value\x20of\x20the\x20objective.\x20\x20If\x20not\x20set,\x20uses\
    \x20the\x20objective's\x20point\x20value\"\xc7\x03\n\x15CMsgQuestMapStor\
    eItem\x12+\n\x06header\x18\x01\x20\x02(\x0b2\x13.CMsgProtoDefHeaderR\x06\
    header\x12\x1b\n\titem_name\x18\x02\x20\x01(\tR\x08itemName\x12u\n\x14re\
    ward_lootlist_name\x18\x06\x20\x01(\tR\x12rewardLootlistNameBC\xa2\x97\"\
    \x0fReward\x20Lootlist\xaa\x97\",The\x20name\x20of\x20the\x20lootlist\
    \x20to\x20roll\x20as\x20a\x20reward\x12)\n\x05price\x18\x03\x20\x01(\x0b\
    2\r.CMsgVarFieldR\x05priceB\x04\xf0\x97\"\x06\x12h\n\x0epurchase_limit\
    \x18\x04\x20\x01(\rR\rpurchaseLimitBA\xa2\x97\"\x0ePurchase\x20Limit\xaa\
    \x97\"+How\x20many\x20times\x20this\x20reward\x20can\x20be\x20purchased\
    \x12X\n\nsort_group\x18\x05\x20\x01(\rR\tsortGroupB9\xa2\x97\"\nSort\x20\
    group\xaa\x97\"'Sort\x20by\x20this\x20group,\x20then\x20alhpabetically\"\
    \xbd\x06\n\x15CMsgQuestMapRegionDef\x12+\n\x06header\x18\x01\x20\x02(\
    \x0b2\x13.CMsgProtoDefHeaderR\x06header\x12\x18\n\x04name\x18\x02\x20\
    \x01(\tR\x04nameB\x04\x90\x97\"\x01\x12\x18\n\x07resfile\x18\x03\x20\x01\
    (\tR\x07resfile\x127\n\x05links\x18\x04\x20\x03(\x0b2!.CMsgQuestMapRegio\
    nDef.RegionLinkR\x05links\x12\x7f\n\x0breturn_link\x18\x05\x20\x01(\x0b2\
    \x0f.CMsgProtoDefIDR\nreturnLinkBM\x80\x97\"\x03\xa2\x97\"\x0bReturn\x20\
    Link\xaa\x97\"6Which\x20link\x20we\x20go\x20to\x20when\x20right-clicking\
    \x20in\x20this\x20region\x12z\n\nradio_freq\x18\x06\x20\x01(\x02R\tradio\
    FreqB[\xa2\x97\"\x0bRadio\x20Freq.\xaa\x97\"HWhere\x20the\x20radio\x20tu\
    ner\x20goes\x20on\x20the\x20CYOA\x20PDA\x20when\x20this\x20region\x20is\
    \x20selection\x12\x98\x01\n\nzoom_scale\x18\x07\x20\x01(\x02R\tzoomScale\
    By\xa2\x97\"\nZoom\x20Scale\xaa\x97\"gHow\x20zoomed\x20in\x20this\x20pan\
    el\x20should\x20be.\x20\x20Affects\x20the\x20scale\x20of\x20the\x20map\
    \x20grid\x20lines\x20and\x20node\x20link\x20dashed\x20lines\x12u\n\tstar\
    _type\x18\x08\x20\x01(\x0b2\x0f.CMsgProtoDefIDR\x08starTypeBG\x80\x97\"\
    \x0c\xa2\x97\"\tStar\x20Type\xaa\x97\"2What\x20stars\x20(if\x20any)\x20t\
    he\x20nodes\x20within\x20use\x20to\x20unlock\x1a{\n\nRegionLink\x12E\n\
    \x13target_region_defid\x18\x01\x20\x02(\x0b2\x0f.CMsgProtoDefIDR\x11tar\
    getRegionDefidB\x04\x80\x97\"\x03\x12\x12\n\x04xpos\x18\x02\x20\x01(\rR\
    \x04xpos\x12\x12\n\x04ypos\x18\x03\x20\x01(\rR\x04ypos\"\x83\x02\n\x0cCM\
    sgVarField\x12\x20\n\x08variable\x18\x01\x20\x01(\tR\x08variableB\x04\
    \xf8\x97\"\x01\x12\x16\n\x05float\x18\x02\x20\x01(\x02H\0R\x05float\x12\
    \x18\n\x06double\x18\x03\x20\x01(\x01H\0R\x06double\x12\x18\n\x06uint32\
    \x18\x04\x20\x01(\rH\0R\x06uint32\x12\x18\n\x06uint64\x18\x05\x20\x01(\
    \x04H\0R\x06uint64\x12\x18\n\x06sint32\x18\x06\x20\x01(\x11H\0R\x06sint3\
    2\x12\x18\n\x06sint64\x18\x07\x20\x01(\x12H\0R\x06sint64\x12\x14\n\x04bo\
    ol\x18\x08\x20\x01(\x08H\0R\x04bool\x12\x18\n\x06string\x18\t\x20\x01(\t\
    H\0R\x06stringB\x07\n\x05value\"j\n\x14CMsgQuestMapStarType\x12+\n\x06he\
    ader\x18\x01\x20\x02(\x0b2\x13.CMsgProtoDefHeaderR\x06header\x12%\n\x04n\
    ame\x18\x02\x20\x01(\tR\x04nameB\x11\x90\x97\"\x01\xa2\x97\"\tType\x20Na\
    me\"\xbc\n\n\x13CMsgQuestMapNodeDef\x12+\n\x06header\x18\x01\x20\x02(\
    \x0b2\x13.CMsgProtoDefHeaderR\x06header\x12O\n\rname_loctoken\x18\x04\
    \x20\x01(\tR\x0cnameLoctokenB*\x90\x97\"\x01\xa2\x97\"\tNode\x20Name\xaa\
    \x97\"\x15The\x20name\x20of\x20this\x20node\x12A\n\x05x_pos\x18\x06\x20\
    \x01(\x02R\x04xPosB,\xa2\x97\"\tMap\x20X\x20Pos\xaa\x97\"\x1bX\x20positi\
    on\x20on\x20the\x20quest\x20map\x12A\n\x05y_pos\x18\x07\x20\x01(\x02R\
    \x04yPosB,\xa2\x97\"\tMap\x20Y\x20Pos\xaa\x97\"\x1bY\x20position\x20on\
    \x20the\x20quest\x20map\x12\x7f\n\tcondition\x18\t\x20\x01(\x0b2\x1a.CMs\
    gQuestMapNodeConditionR\tconditionBE\xa2\x97\"\nConditions\xaa\x97\"3Log\
    ic\x20to\x20unlock\x20this\x20node.\x20Can\x20be\x20nested\x20with\x20lo\
    gic\x12u\n\rowning_region\x18\n\x20\x01(\x0b2\x0f.CMsgProtoDefIDR\x0cown\
    ingRegionB?\x80\x97\"\x03\xa2\x97\"\x06Region\xaa\x97\"-Which\x20region\
    \x20in\x20the\x20map\x20this\x20node\x20shows\x20up\x20in\x12r\n\rquest_\
    options\x18\x0b\x20\x03(\x0b2\x0f.CMsgProtoDefIDR\x0cquestOptionsB<\x80\
    \x97\"\x04\xaa\x97\"\x1eWhich\x20quests\x20this\x20node\x20offers.\xb8\
    \x97\"\x03\xa2\x97\"\x0eOffered\x20Quests\x12u\n\x14associated_operation\
    \x18\x10\x20\x01(\tR\x13associatedOperationBB\xa2\x97\"\x14Associated\
    \x20Operation\xaa\x97\"&Operation\x20this\x20node\x20is\x20associated\
    \x20with\x12d\n\x10reward_item_name\x18\x12\x20\x01(\tR\x0erewardItemNam\
    eB:\xa2\x97\"\x0bReward\x20Item\xaa\x97\"'The\x20name\x20of\x20an\x20ite\
    m\x20to\x20give\x20as\x20a\x20reward\x12u\n\x14reward_lootlist_name\x18\
    \x16\x20\x01(\tR\x12rewardLootlistNameBC\xa2\x97\"\x0fReward\x20Lootlist\
    \xaa\x97\",The\x20name\x20of\x20the\x20lootlist\x20to\x20roll\x20as\x20a\
    \x20reward\x12\x93\x01\n\x0bcash_reward\x18\x13\x20\x01(\x0e2\x10.ENodeC\
    ashReward:\x10CASH_REWARD_NONER\ncashRewardBN\xa2\x97\"\x0bCash\x20Rewar\
    d\xaa\x97\";How\x20much\x20cash\x20to\x20give\x20when\x20completing\x20t\
    he\x20primary\x20objective\x12d\n\tstar_type\x18\x14\x20\x01(\x0b2\x0f.C\
    MsgProtoDefIDR\x08starTypeB6\x80\x97\"\x0c\xa2\x97\"\tStar\x20Type\xaa\
    \x97\"!Which\x20type\x20of\x20star\x20this\x20node\x20uses\x12e\n\x0fsta\
    rs_to_unlock\x18\x15\x20\x01(\r:\x011R\rstarsToUnlockB:\xa2\x97\"\x0fSta\
    rs\x20to\x20Unlock\xaa\x97\"#Numbers\x20of\x20stars\x20it\x20costs\x20to\
    \x20unlock\"E\n\x16CMsgPaintKit_Variables\x12+\n\x06header\x18\x01\x20\
    \x02(\x0b2\x13.CMsgProtoDefHeaderR\x06header\"\x91\x05\n#CMsgPaintKit_Op\
    eration_TextureStage\x12-\n\x07texture\x18\x01\x20\x01(\x0b2\r.CMsgVarFi\
    eldR\x07textureB\x04\xf0\x97\"\t\x124\n\x0btexture_red\x18\x02\x20\x01(\
    \x0b2\r.CMsgVarFieldR\ntextureRedB\x04\xf0\x97\"\t\x126\n\x0ctexture_blu\
    e\x18\x03\x20\x01(\x0b2\r.CMsgVarFieldR\x0btextureBlueB\x04\xf0\x97\"\t\
    \x126\n\x0cadjust_black\x18\x04\x20\x01(\x0b2\r.CMsgVarFieldR\x0badjustB\
    lackB\x04\xf0\x97\"\t\x128\n\radjust_offset\x18\x05\x20\x01(\x0b2\r.CMsg\
    VarFieldR\x0cadjustOffsetB\x04\xf0\x97\"\t\x126\n\x0cadjust_gamma\x18\
    \x06\x20\x01(\x0b2\r.CMsgVarFieldR\x0badjustGammaB\x04\xf0\x97\"\t\x12/\
    \n\x08rotation\x18\x07\x20\x01(\x0b2\r.CMsgVarFieldR\x08rotationB\x04\
    \xf0\x97\"\t\x124\n\x0btranslate_u\x18\x08\x20\x01(\x0b2\r.CMsgVarFieldR\
    \ntranslateUB\x04\xf0\x97\"\t\x124\n\x0btranslate_v\x18\t\x20\x01(\x0b2\
    \r.CMsgVarFieldR\ntranslateVB\x04\xf0\x97\"\t\x12.\n\x08scale_uv\x18\n\
    \x20\x01(\x0b2\r.CMsgVarFieldR\x07scaleUvB\x04\xf0\x97\"\t\x12*\n\x06fli\
    p_u\x18\x0b\x20\x01(\x0b2\r.CMsgVarFieldR\x05flipUB\x04\xf0\x97\"\t\x12*\
    \n\x06flip_v\x18\x0c\x20\x01(\x0b2\r.CMsgVarFieldR\x05flipVB\x04\xf0\x97\
    \"\t\"\xb8\x04\n#CMsgPaintKit_Operation_CombineStage\x126\n\x0cadjust_bl\
    ack\x18\x01\x20\x01(\x0b2\r.CMsgVarFieldR\x0badjustBlackB\x04\xf0\x97\"\
    \t\x128\n\radjust_offset\x18\x02\x20\x01(\x0b2\r.CMsgVarFieldR\x0cadjust\
    OffsetB\x04\xf0\x97\"\t\x126\n\x0cadjust_gamma\x18\x03\x20\x01(\x0b2\r.C\
    MsgVarFieldR\x0badjustGammaB\x04\xf0\x97\"\t\x12/\n\x08rotation\x18\x04\
    \x20\x01(\x0b2\r.CMsgVarFieldR\x08rotationB\x04\xf0\x97\"\t\x124\n\x0btr\
    anslate_u\x18\x05\x20\x01(\x0b2\r.CMsgVarFieldR\ntranslateUB\x04\xf0\x97\
    \"\t\x124\n\x0btranslate_v\x18\x06\x20\x01(\x0b2\r.CMsgVarFieldR\ntransl\
    ateVB\x04\xf0\x97\"\t\x12.\n\x08scale_uv\x18\x07\x20\x01(\x0b2\r.CMsgVar\
    FieldR\x07scaleUvB\x04\xf0\x97\"\t\x12*\n\x06flip_u\x18\x08\x20\x01(\x0b\
    2\r.CMsgVarFieldR\x05flipUB\x04\xf0\x97\"\t\x12*\n\x06flip_v\x18\t\x20\
    \x01(\x0b2\r.CMsgVarFieldR\x05flipVB\x04\xf0\x97\"\t\x12B\n\x0eoperation\
    _node\x18\x0b\x20\x03(\x0b2\x1b.CMsgPaintKit_OperationNodeR\roperationNo\
    de\"\x82\x01\n\"CMsgPaintKit_Operation_SelectStage\x12+\n\x06groups\x18\
    \x01\x20\x01(\x0b2\r.CMsgVarFieldR\x06groupsB\x04\xf0\x97\"\t\x12/\n\x06\
    select\x18\x02\x20\x03(\x0b2\r.CMsgVarFieldR\x06selectB\x08\xb8\x97\"\
    \x10\xf0\x97\"\t\"\xfa\x02\n\x1eCMsgPaintKit_Operation_Sticker\x12]\n\
    \x04base\x18\x01\x20\x01(\x0b2\r.CMsgVarFieldR\x04baseB:\xf0\x97\"\t\xaa\
    \x97\"2Name\x20of\x20the\x20base\x20file\x20for\x20the\x20sticker\x20(th\
    e\x20albedo)\x12[\n\x06weight\x18\x02\x20\x01(\x0b2\r.CMsgVarFieldR\x06w\
    eightB4\xf0\x97\"\t\xaa\x97\",Random\x20likelihood\x20this\x20one\x20is\
    \x20to\x20be\x20selected\x12\x9b\x01\n\x04spec\x18\x03\x20\x01(\x0b2\r.C\
    MsgVarFieldR\x04specBx\xf0\x97\"\t\xaa\x97\"pName\x20of\x20the\x20specul\
    ar\x20file\x20for\x20the\x20sticker,\x20or\x20if\x20blank\x20we\x20will\
    \x20assume\x20it\x20is\x20baseFilename\x20+\x20_spec\x20+\x20baseExtensi\
    on\"\xd8\x03\n#CMsgPaintKit_Operation_StickerStage\x129\n\x07sticker\x18\
    \x01\x20\x03(\x0b2\x1f.CMsgPaintKit_Operation_StickerR\x07sticker\x12,\n\
    \x07dest_tl\x18\x02\x20\x01(\x0b2\r.CMsgVarFieldR\x06destTlB\x04\xf0\x97\
    \"\t\x12,\n\x07dest_tr\x18\x03\x20\x01(\x0b2\r.CMsgVarFieldR\x06destTrB\
    \x04\xf0\x97\"\t\x12,\n\x07dest_bl\x18\x04\x20\x01(\x0b2\r.CMsgVarFieldR\
    \x06destBlB\x04\xf0\x97\"\t\x126\n\x0cadjust_black\x18\x05\x20\x01(\x0b2\
    \r.CMsgVarFieldR\x0badjustBlackB\x04\xf0\x97\"\t\x128\n\radjust_offset\
    \x18\x06\x20\x01(\x0b2\r.CMsgVarFieldR\x0cadjustOffsetB\x04\xf0\x97\"\t\
    \x126\n\x0cadjust_gamma\x18\x07\x20\x01(\x0b2\r.CMsgVarFieldR\x0badjustG\
    ammaB\x04\xf0\x97\"\t\x12B\n\x0eoperation_node\x18\t\x20\x03(\x0b2\x1b.C\
    MsgPaintKit_OperationNodeR\roperationNode\"\xe8\x03\n\x1bCMsgPaintKit_Op\
    erationStage\x12M\n\x0etexture_lookup\x18\x01\x20\x01(\x0b2$.CMsgPaintKi\
    t_Operation_TextureStageH\0R\rtextureLookup\x12G\n\x0bcombine_add\x18\
    \x02\x20\x01(\x0b2$.CMsgPaintKit_Operation_CombineStageH\0R\ncombineAdd\
    \x12I\n\x0ccombine_lerp\x18\x03\x20\x01(\x0b2$.CMsgPaintKit_Operation_Co\
    mbineStageH\0R\x0bcombineLerp\x12Q\n\x10combine_multiply\x18\x04\x20\x01\
    (\x0b2$.CMsgPaintKit_Operation_CombineStageH\0R\x0fcombineMultiply\x12=\
    \n\x06select\x18\x05\x20\x01(\x0b2#.CMsgPaintKit_Operation_SelectStageH\
    \0R\x06select\x12K\n\rapply_sticker\x18\x06\x20\x01(\x0b2$.CMsgPaintKit_\
    Operation_StickerStageH\0R\x0capplyStickerB\x07\n\x05stage\"\xa6\x01\n\
    \x1aCMsgPaintKit_OperationNode\x124\n\x05stage\x18\x01\x20\x01(\x0b2\x1c\
    .CMsgPaintKit_OperationStageH\0R\x05stage\x12J\n\x12operation_template\
    \x18\x02\x20\x01(\x0b2\x0f.CMsgProtoDefIDH\0R\x11operationTemplateB\x08\
    \x80\x97\"\x07\xe0\x97\"\x01B\x06\n\x04node\"\x89\x01\n\x16CMsgPaintKit_\
    Operation\x12+\n\x06header\x18\x01\x20\x02(\x0b2\x13.CMsgProtoDefHeaderR\
    \x06header\x12B\n\x0eoperation_node\x18\x02\x20\x03(\x0b2\x1b.CMsgPaintK\
    it_OperationNodeR\roperationNode\"\xa3\x03\n\x1bCMsgPaintKit_ItemDefinit\
    ion\x12+\n\x06header\x18\x01\x20\x02(\x0b2\x13.CMsgProtoDefHeaderR\x06he\
    ader\x122\n\x15item_definition_index\x18\x02\x20\x02(\rR\x13itemDefiniti\
    onIndex\x12F\n\x11variable_template\x18\x03\x20\x01(\x0b2\x0f.CMsgProtoD\
    efIDR\x10variableTemplateB\x08\x80\x97\"\x06\xe0\x97\"\x01\x12M\n\ndefin\
    ition\x18\x04\x20\x03(\x0b2'.CMsgPaintKit_ItemDefinition.DefinitionR\nde\
    finitionB\x04\xb8\x97\"\x05\x1a\x8b\x01\n\nDefinition\x12D\n\x12operatio\
    n_template\x18\x01\x20\x01(\x0b2\x0f.CMsgProtoDefIDR\x11operationTemplat\
    eB\x04\x80\x97\"\x07\x127\n\x08variable\x18\x02\x20\x03(\x0b2\r.CMsgVarF\
    ieldR\x08variableB\x0c\xc8\x97\"\0\xf0\x97\"\t\xc0\x97\"\0\"\xa3\x1c\n\
    \x17CMsgPaintKit_Definition\x12+\n\x06header\x18\x01\x20\x02(\x0b2\x13.C\
    MsgProtoDefHeaderR\x06header\x12)\n\rloc_desctoken\x18\x02\x20\x01(\tR\
    \x0clocDesctokenB\x04\x90\x97\"\x01\x12\xc6\x01\n\x12operation_template\
    \x18\x03\x20\x01(\x0b2\x0f.CMsgProtoDefIDR\x11operationTemplateB\x85\x01\
    \x80\x97\"\x07\xe0\x97\"\x01\xaa\x97\"yoperation\x20template\x20which\
    \x20all\x20items\x20in\x20the\x20list\x20will\x20use\x20unless\x20there'\
    s\x20operation_template\x20specified\x20in\x20an\x20item_definition\x12*\
    \n\x11has_team_textures\x18\x04\x20\x01(\x08R\x0fhasTeamTextures\x121\n\
    \x04item\x18\x05\x20\x03(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\x04item\
    \x12B\n\rpaintkit_tool\x18\x06\x20\x01(\x0b2\x1d.CMsgPaintKit_Definition\
    .ItemR\x0cpaintkitTool\x12A\n\x0cflamethrower\x18\x07\x20\x01(\x0b2\x1d.\
    CMsgPaintKit_Definition.ItemR\x0cflamethrower\x12G\n\x0fgrenadelauncher\
    \x18\x08\x20\x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\x0fgrenadelaunc\
    her\x123\n\x05knife\x18\t\x20\x01(\x0b2\x1d.CMsgPaintKit_Definition.Item\
    R\x05knife\x127\n\x07medigun\x18\n\x20\x01(\x0b2\x1d.CMsgPaintKit_Defini\
    tion.ItemR\x07medigun\x127\n\x07minigun\x18\x0b\x20\x01(\x0b2\x1d.CMsgPa\
    intKit_Definition.ItemR\x07minigun\x125\n\x06pistol\x18\x0c\x20\x01(\x0b\
    2\x1d.CMsgPaintKit_Definition.ItemR\x06pistol\x129\n\x08revolver\x18\r\
    \x20\x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\x08revolver\x12E\n\x0er\
    ocketlauncher\x18\x0e\x20\x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\
    \x0erocketlauncher\x12=\n\nscattergun\x18\x0f\x20\x01(\x0b2\x1d.CMsgPain\
    tKit_Definition.ItemR\nscattergun\x127\n\x07shotgun\x18\x10\x20\x01(\x0b\
    2\x1d.CMsgPaintKit_Definition.ItemR\x07shotgun\x12/\n\x03smg\x18\x11\x20\
    \x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\x03smg\x12?\n\x0bsniperrifl\
    e\x18\x12\x20\x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\x0bsniperrifle\
    \x12N\n\x13stickybomb_launcher\x18\x13\x20\x01(\x0b2\x1d.CMsgPaintKit_De\
    finition.ItemR\x12stickybombLauncher\x127\n\x07ubersaw\x18\x14\x20\x01(\
    \x0b2\x1d.CMsgPaintKit_Definition.ItemR\x07ubersaw\x125\n\x06wrench\x18\
    \x15\x20\x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\x06wrench\x12;\n\ta\
    mputator\x18\x16\x20\x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\tamputa\
    tor\x12B\n\ratom_launcher\x18\x17\x20\x01(\x0b2\x1d.CMsgPaintKit_Definit\
    ion.ItemR\x0catomLauncher\x12D\n\x0eback_scratcher\x18\x18\x20\x01(\x0b2\
    \x1d.CMsgPaintKit_Definition.ItemR\rbackScratcher\x12;\n\tbattleaxe\x18\
    \x19\x20\x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\tbattleaxe\x12B\n\r\
    bazaar_sniper\x18\x1a\x20\x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\
    \x0cbazaarSniper\x129\n\x08blackbox\x18\x1b\x20\x01(\x0b2\x1d.CMsgPaintK\
    it_Definition.ItemR\x08blackbox\x12E\n\x0eclaidheamohmor\x18\x1c\x20\x01\
    (\x0b2\x1d.CMsgPaintKit_Definition.ItemR\x0eclaidheamohmor\x12L\n\x12cru\
    saders_crossbow\x18\x1d\x20\x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\
    \x11crusadersCrossbow\x12;\n\tdegreaser\x18\x1e\x20\x01(\x0b2\x1d.CMsgPa\
    intKit_Definition.ItemR\tdegreaser\x12>\n\x0bdemo_cannon\x18\x1f\x20\x01\
    (\x0b2\x1d.CMsgPaintKit_Definition.ItemR\ndemoCannon\x12I\n\x11demo_sult\
    an_sword\x18\x20\x20\x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\x0fdemo\
    SultanSword\x12;\n\tdetonator\x18!\x20\x01(\x0b2\x1d.CMsgPaintKit_Defini\
    tion.ItemR\tdetonator\x12>\n\x0bgatling_gun\x18\"\x20\x01(\x0b2\x1d.CMsg\
    PaintKit_Definition.ItemR\ngatlingGun\x12A\n\x0cholymackerel\x18#\x20\
    \x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\x0cholymackerel\x12/\n\x03j\
    ag\x18$\x20\x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\x03jag\x12;\n\tl\
    ochnload\x18%\x20\x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\tlochnload\
    \x12;\n\tpowerjack\x18&\x20\x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\
    \tpowerjack\x129\n\x08quadball\x18'\x20\x01(\x0b2\x1d.CMsgPaintKit_Defin\
    ition.ItemR\x08quadball\x12F\n\x0freserve_shooter\x18(\x20\x01(\x0b2\x1d\
    .CMsgPaintKit_Definition.ItemR\x0ereserveShooter\x12>\n\x0briding_crop\
    \x18)\x20\x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\nridingCrop\x12@\n\
    \x0crussian_riot\x18*\x20\x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\
    \x0brussianRiot\x129\n\x08scimitar\x18+\x20\x01(\x0b2\x1d.CMsgPaintKit_D\
    efinition.ItemR\x08scimitar\x12>\n\x0bscorch_shot\x18,\x20\x01(\x0b2\x1d\
    .CMsgPaintKit_Definition.ItemR\nscorchShot\x12;\n\tshortstop\x18-\x20\
    \x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\tshortstop\x12>\n\x0bsoda_p\
    opper\x18.\x20\x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\nsodaPopper\
    \x12@\n\x0ctele_shotgun\x18/\x20\x01(\x0b2\x1d.CMsgPaintKit_Definition.I\
    temR\x0bteleShotgun\x129\n\x08tomislav\x180\x20\x01(\x0b2\x1d.CMsgPaintK\
    it_Definition.ItemR\x08tomislav\x12;\n\ttrenchgun\x181\x20\x01(\x0b2\x1d\
    .CMsgPaintKit_Definition.ItemR\ttrenchgun\x12B\n\rwinger_pistol\x182\x20\
    \x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\x0cwingerPistol\x1a\xe7\x02\
    \n\x04Item\x12v\n\x18item_definition_template\x18\x01\x20\x02(\x0b2\x0f.\
    CMsgProtoDefIDR\x16itemDefinitionTemplateB+\x80\x97\"\x08\xd2\x97\"#CPai\
    ntKitDefIdFieldProtoEditorField\x12:\n\x04data\x18\x05\x20\x01(\x0b2&.CM\
    sgPaintKit_Definition.Item.ItemDataR\x04data\x1a\xa4\x01\n\x08ItemData\
    \x122\n\x12can_apply_paintkit\x18\x02\x20\x01(\x08:\x04trueR\x10canApply\
    Paintkit\x12+\n\x11material_override\x18\x03\x20\x01(\tR\x10materialOver\
    ride\x127\n\x08variable\x18\x04\x20\x03(\x0b2\r.CMsgVarFieldR\x08variabl\
    eB\x0c\xc8\x97\"\0\xf0\x97\"\t\xc0\x97\"\0:\x04\x80\x88'\0\"\xb1\x05\n\
    \x0eCMsgQuestTheme\x12+\n\x06header\x18\x01\x20\x02(\x0b2\x13.CMsgProtoD\
    efHeaderR\x06header\x12)\n\x10notification_res\x18\x02\x20\x01(\tR\x0fno\
    tificationRes\x12$\n\x0equest_item_res\x18\x03\x20\x01(\tR\x0cquestItemR\
    es\x12-\n\x13in_game_tracker_res\x18\x04\x20\x01(\tR\x10inGameTrackerRes\
    \x12B\n\x0bgive_sounds\x18\x05\x20\x03(\x0b2!.CMsgQuestTheme.WeightedStr\
    ingSetR\ngiveSounds\x12J\n\x0fcomplete_sounds\x18\x06\x20\x03(\x0b2!.CMs\
    gQuestTheme.WeightedStringSetR\x0ecompleteSounds\x12U\n\x15fully_complet\
    e_sounds\x18\x07\x20\x03(\x0b2!.CMsgQuestTheme.WeightedStringSetR\x13ful\
    lyCompleteSounds\x12!\n\x0creward_sound\x18\x08\x20\x01(\tR\x0brewardSou\
    nd\x12#\n\rdiscard_sound\x18\t\x20\x01(\tR\x0cdiscardSound\x12!\n\x0crev\
    eal_sound\x18\n\x20\x01(\tR\x0brevealSound\x1a@\n\x0eWeightedString\x12\
    \x16\n\x06string\x18\x01\x20\x01(\tR\x06string\x12\x16\n\x06weight\x18\
    \x02\x20\x01(\rR\x06weight\x1a^\n\x11WeightedStringSet\x12I\n\x10weighte\
    d_strings\x18\x01\x20\x03(\x0b2\x1e.CMsgQuestTheme.WeightedStringR\x0fwe\
    ightedStrings\"\xd1\x02\n#CMsgQuestMapNodeCondition_NodeState\x12\x99\
    \x01\n\x19bonus_objectives_required\x18\x01\x20\x01(\r:\x010R\x17bonusOb\
    jectivesRequiredBZ\xa2\x97\"\x0eBonus\x20Required\xaa\x97\"DNumber\x20of\
    \x20bonus\x20objectives\x20required,\x20on\x20top\x20of\x20the\x20primar\
    y\x20objective\x12\x8d\x01\n\x11target_node_defid\x18\x02\x20\x02(\x0b2\
    \x0f.CMsgProtoDefIDR\x0ftargetNodeDefidBP\x80\x97\"\0\xa2\x97\"\x0bTarge\
    t\x20Node\xaa\x97\"9Which\x20node\x20is\x20required\x20to\x20have\x20the\
    \x20above\x20number\x20of\x20medals\"\xf7\x01\n\x1fCMsgQuestMapNodeCondi\
    tion_Logic\x12T\n\toperation\x18\x01\x20\x02(\x0e2\x11.LogicalOperation:\
    \x03ANDR\toperationB\x1e\xa2\x97\"\x05Logic\xaa\x97\"\x11Logical\x20oper\
    ation\x12~\n\x0esub_conditions\x18\x02\x20\x03(\x0b2\x1a.CMsgQuestMapNod\
    eConditionR\rsubConditionsB;\xa2\x97\"\x08Operands\xaa\x97\"+Definitions\
    \x20to\x20use\x20in\x20the\x20logical\x20operation\"\xe3\x02\n\x19CMsgQu\
    estMapNodeCondition\x12\xa2\x01\n\nnode_state\x18\x01\x20\x01(\x0b2$.CMs\
    gQuestMapNodeCondition_NodeStateH\0R\tnodeStateB[\xa2\x97\"\x14Node\x20S\
    tate\x20Condition\xaa\x97\"?Returns\x20true\x20if\x20a\x20specific\x20no\
    de\x20has\x20a\x20required\x20number\x20of\x20medals\x12\x93\x01\n\x07lo\
    gical\x18\x02\x20\x01(\x0b2\x20.CMsgQuestMapNodeCondition_LogicH\0R\x07l\
    ogicalBU\xa2\x97\"\x11Logical\x20Condition\xaa\x97\"<Performs\x20a\x20sp\
    ecified\x20logical\x20operation\x20to\x20all\x20sub\x20conditionsB\x0b\n\
    \toperation\"=\n\x0eCMsgHeaderOnly\x12+\n\x06header\x18\x01\x20\x02(\x0b\
    2\x13.CMsgProtoDefHeaderR\x06header*,\n\x10LogicalOperation\x12\x07\n\
    \x03AND\x10\0\x12\x06\n\x02OR\x10\x01\x12\x07\n\x03NOT\x10\x02*|\n\x16EV\
    alueDefinitionSource\x12\x15\n\x11REFERENCE_DEFINES\x10\0\x12\x12\n\x0eP\
    ARENT_DEFINES\x10\x01\x12\x10\n\x0cTHIS_DEFINES\x10\x02\x12\x14\n\x10VAR\
    IABLE_DEFINES\x10\x03\x12\x0f\n\x0bNOT_DEFINED\x10\x04*\x81\x03\n\rProto\
    DefTypes\x12\x1b\n\x17DEF_TYPE_QUEST_MAP_NODE\x10\0\x12\x18\n\x14DEF_TYP\
    E_QUEST_THEME\x10\x02\x12\x1d\n\x19DEF_TYPE_QUEST_MAP_REGION\x10\x03\x12\
    \x12\n\x0eDEF_TYPE_QUEST\x10\x04\x12\x1c\n\x18DEF_TYPE_QUEST_OBJECTIVE\
    \x10\x05\x12\x1f\n\x1bDEF_TYPE_PAINTKIT_VARIABLES\x10\x06\x12\x1f\n\x1bD\
    EF_TYPE_PAINTKIT_OPERATION\x10\x07\x12%\n!DEF_TYPE_PAINTKIT_ITEM_DEFINIT\
    ION\x10\x08\x12\x20\n\x1cDEF_TYPE_PAINTKIT_DEFINITION\x10\t\x12\x18\n\
    \x14DEF_TYPE_HEADER_ONLY\x10\n\x12!\n\x1dDEF_TYPE_QUEST_MAP_STORE_ITEM\
    \x10\x0b\x12\x20\n\x1cDEF_TYPE_QUEST_MAP_STAR_TYPE\x10\x0c*[\n\x0cEQuest\
    Points\x12\x17\n\x13QUEST_POINTS_NOVICE\x10\0\x12\x19\n\x15QUEST_POINTS_\
    ADVANCED\x10\x01\x12\x17\n\x13QUEST_POINTS_EXPERT\x10\x02*\xca\x01\n\rEV\
    arFieldType\x12\x14\n\x10VAR_TYPE_INVALID\x10\x01\x12\x12\n\x0eVAR_TYPE_\
    FLOAT\x10\x02\x12\x13\n\x0fVAR_TYPE_DOUBLE\x10\x03\x12\x13\n\x0fVAR_TYPE\
    _UINT32\x10\x04\x12\x13\n\x0fVAR_TYPE_UINT64\x10\x05\x12\x13\n\x0fVAR_TY\
    PE_SINT32\x10\x06\x12\x13\n\x0fVAR_TYPE_SINT64\x10\x07\x12\x11\n\rVAR_TY\
    PE_BOOL\x10\x08\x12\x13\n\x0fVAR_TYPE_STRING\x10\t*m\n\x0fENodeCashRewar\
    d\x12\x14\n\x10CASH_REWARD_NONE\x10\x01\x12\x15\n\x11CASH_REWARD_SMALL\
    \x10\x02\x12\x16\n\x12CASH_REWARD_MEDIUM\x10\x03\x12\x15\n\x11CASH_REWAR\
    D_LARGE\x10\x04:N\n\x0estart_expanded\x18\x80\xf1\x04\x20\x01(\x08\x12\
    \x1f.google.protobuf.MessageOptions:\x04trueR\rstartExpanded:g\n\nvalid_\
    type\x18\xf0\xa2\x04\x20\x01(\x0e2\x0e.ProtoDefTypes\x12\x1d.google.prot\
    obuf.FieldOptions:\x17DEF_TYPE_QUEST_MAP_NODER\tvalidType:A\n\x08editabl\
    e\x18\xf1\xa2\x04\x20\x01(\x08\x12\x1d.google.protobuf.FieldOptions:\x04\
    trueR\x08editable:D\n\tlocalized\x18\xf2\xa2\x04\x20\x01(\x08\x12\x1d.go\
    ogle.protobuf.FieldOptions:\x05falseR\tlocalized:L\n\x0edo_not_inherit\
    \x18\xf3\xa2\x04\x20\x01(\x08\x12\x1d.google.protobuf.FieldOptions:\x05f\
    alseR\x0cdoNotInherit:B\n\x0cdisplay_name\x18\xf4\xa2\x04\x20\x01(\t\x12\
    \x1d.google.protobuf.FieldOptionsR\x0bdisplayName:9\n\x07comment\x18\xf5\
    \xa2\x04\x20\x01(\t\x12\x1d.google.protobuf.FieldOptionsR\x07comment:<\n\
    \tmax_count\x18\xf7\xa2\x04\x20\x01(\r\x12\x1d.google.protobuf.FieldOpti\
    onsR\x08maxCount:B\n\tallow_add\x18\xf8\xa2\x04\x20\x01(\x08\x12\x1d.goo\
    gle.protobuf.FieldOptions:\x04trueR\x08allowAdd:H\n\x0callow_delete\x18\
    \xf9\xa2\x04\x20\x01(\x08\x12\x1d.google.protobuf.FieldOptions:\x04trueR\
    \x0ballowDelete:Q\n\x14panel_class_override\x18\xfa\xa2\x04\x20\x01(\t\
    \x12\x1d.google.protobuf.FieldOptionsR\x12panelClassOverride:m\n#message\
    _inherhitance_key_field_name\x18\xfb\xa2\x04\x20\x01(\t\x12\x1d.google.p\
    rotobuf.FieldOptionsR\x1fmessageInherhitanceKeyFieldName:f\n\x1binherit_\
    reference_variables\x18\xfc\xa2\x04\x20\x01(\x08\x12\x1d.google.protobuf\
    .FieldOptions:\x05falseR\x19inheritReferenceVariables:R\n\x11self_inheri\
    t_only\x18\xfd\xa2\x04\x20\x01(\x08\x12\x1d.google.protobuf.FieldOptions\
    :\x05falseR\x0fselfInheritOnly:g\n\x0evar_field_type\x18\xfe\xa2\x04\x20\
    \x01(\x0e2\x0e.EVarFieldType\x12\x1d.google.protobuf.FieldOptions:\x10VA\
    R_TYPE_INVALIDR\x0cvarFieldType:R\n\x11merging_key_field\x18\xff\xa2\x04\
    \x20\x01(\x08\x12\x1d.google.protobuf.FieldOptions:\x05falseR\x0fmerging\
    KeyFieldB\x05H\x01\x80\x01\0J\xfb\x86\x02\n\x07\x12\x05\0\0\xd5\x04\x01\
    \n\t\n\x02\x03\0\x12\x03\0\0*\n\x08\n\x01\x08\x12\x03\x02\0\x1c\n\t\n\
    \x02\x08\t\x12\x03\x02\0\x1c\n\x08\n\x01\x08\x12\x03\x03\0#\n\t\n\x02\
    \x08\x10\x12\x03\x03\0#\n\t\n\x01\x07\x12\x04\x05\0\x07\x01\n\t\n\x02\
    \x07\0\x12\x03\x06\x08>\n\n\n\x03\x07\0\x02\x12\x03\x05\x07&\n\n\n\x03\
    \x07\0\x04\x12\x03\x06\x08\x10\n\n\n\x03\x07\0\x05\x12\x03\x06\x11\x15\n\
    \n\n\x03\x07\0\x01\x12\x03\x06\x16$\n\n\n\x03\x07\0\x03\x12\x03\x06',\n\
    \n\n\x03\x07\0\x08\x12\x03\x06-=\n\n\n\x03\x07\0\x07\x12\x03\x068<\n\t\n\
    \x01\x07\x12\x04\t\0\x19\x01\n\t\n\x02\x07\x01\x12\x03\n\x08W\n\n\n\x03\
    \x07\x01\x02\x12\x03\t\x07$\n\n\n\x03\x07\x01\x04\x12\x03\n\x08\x10\n\n\
    \n\x03\x07\x01\x06\x12\x03\n\x11\x1f\n\n\n\x03\x07\x01\x01\x12\x03\n\x20\
    *\n\n\n\x03\x07\x01\x03\x12\x03\n-2\n\n\n\x03\x07\x01\x08\x12\x03\n3V\n\
    \n\n\x03\x07\x01\x07\x12\x03\n>U\n\t\n\x02\x07\x02\x12\x03\x0b\x088\n\n\
    \n\x03\x07\x02\x02\x12\x03\t\x07$\n\n\n\x03\x07\x02\x04\x12\x03\x0b\x08\
    \x10\n\n\n\x03\x07\x02\x05\x12\x03\x0b\x11\x15\n\n\n\x03\x07\x02\x01\x12\
    \x03\x0b\x16\x1e\n\n\n\x03\x07\x02\x03\x12\x03\x0b!&\n\n\n\x03\x07\x02\
    \x08\x12\x03\x0b'7\n\n\n\x03\x07\x02\x07\x12\x03\x0b26\n\t\n\x02\x07\x03\
    \x12\x03\x0c\x08:\n\n\n\x03\x07\x03\x02\x12\x03\t\x07$\n\n\n\x03\x07\x03\
    \x04\x12\x03\x0c\x08\x10\n\n\n\x03\x07\x03\x05\x12\x03\x0c\x11\x15\n\n\n\
    \x03\x07\x03\x01\x12\x03\x0c\x16\x1f\n\n\n\x03\x07\x03\x03\x12\x03\x0c\"\
    '\n\n\n\x03\x07\x03\x08\x12\x03\x0c(9\n\n\n\x03\x07\x03\x07\x12\x03\x0c3\
    8\n\t\n\x02\x07\x04\x12\x03\r\x08?\n\n\n\x03\x07\x04\x02\x12\x03\t\x07$\
    \n\n\n\x03\x07\x04\x04\x12\x03\r\x08\x10\n\n\n\x03\x07\x04\x05\x12\x03\r\
    \x11\x15\n\n\n\x03\x07\x04\x01\x12\x03\r\x16$\n\n\n\x03\x07\x04\x03\x12\
    \x03\r',\n\n\n\x03\x07\x04\x08\x12\x03\r->\n\n\n\x03\x07\x04\x07\x12\x03\
    \r8=\n\t\n\x02\x07\x05\x12\x03\x0e\x08-\n\n\n\x03\x07\x05\x02\x12\x03\t\
    \x07$\n\n\n\x03\x07\x05\x04\x12\x03\x0e\x08\x10\n\n\n\x03\x07\x05\x05\
    \x12\x03\x0e\x11\x17\n\n\n\x03\x07\x05\x01\x12\x03\x0e\x18$\n\n\n\x03\
    \x07\x05\x03\x12\x03\x0e',\n\t\n\x02\x07\x06\x12\x03\x0f\x08(\n\n\n\x03\
    \x07\x06\x02\x12\x03\t\x07$\n\n\n\x03\x07\x06\x04\x12\x03\x0f\x08\x10\n\
    \n\n\x03\x07\x06\x05\x12\x03\x0f\x11\x17\n\n\n\x03\x07\x06\x01\x12\x03\
    \x0f\x18\x1f\n\n\n\x03\x07\x06\x03\x12\x03\x0f\"'\n\t\n\x02\x07\x07\x12\
    \x03\x10\x08*\n\n\n\x03\x07\x07\x02\x12\x03\t\x07$\n\n\n\x03\x07\x07\x04\
    \x12\x03\x10\x08\x10\n\n\n\x03\x07\x07\x05\x12\x03\x10\x11\x17\n\n\n\x03\
    \x07\x07\x01\x12\x03\x10\x18!\n\n\n\x03\x07\x07\x03\x12\x03\x10$)\n\t\n\
    \x02\x07\x08\x12\x03\x11\x089\n\n\n\x03\x07\x08\x02\x12\x03\t\x07$\n\n\n\
    \x03\x07\x08\x04\x12\x03\x11\x08\x10\n\n\n\x03\x07\x08\x05\x12\x03\x11\
    \x11\x15\n\n\n\x03\x07\x08\x01\x12\x03\x11\x16\x1f\n\n\n\x03\x07\x08\x03\
    \x12\x03\x11\"'\n\n\n\x03\x07\x08\x08\x12\x03\x11(8\n\n\n\x03\x07\x08\
    \x07\x12\x03\x1137\n\t\n\x02\x07\t\x12\x03\x12\x08<\n\n\n\x03\x07\t\x02\
    \x12\x03\t\x07$\n\n\n\x03\x07\t\x04\x12\x03\x12\x08\x10\n\n\n\x03\x07\t\
    \x05\x12\x03\x12\x11\x15\n\n\n\x03\x07\t\x01\x12\x03\x12\x16\"\n\n\n\x03\
    \x07\t\x03\x12\x03\x12%*\n\n\n\x03\x07\t\x08\x12\x03\x12+;\n\n\n\x03\x07\
    \t\x07\x12\x03\x126:\n\t\n\x02\x07\n\x12\x03\x13\x085\n\n\n\x03\x07\n\
    \x02\x12\x03\t\x07$\n\n\n\x03\x07\n\x04\x12\x03\x13\x08\x10\n\n\n\x03\
    \x07\n\x05\x12\x03\x13\x11\x17\n\n\n\x03\x07\n\x01\x12\x03\x13\x18,\n\n\
    \n\x03\x07\n\x03\x12\x03\x13/4\n\t\n\x02\x07\x0b\x12\x03\x14\x08D\n\n\n\
    \x03\x07\x0b\x02\x12\x03\t\x07$\n\n\n\x03\x07\x0b\x04\x12\x03\x14\x08\
    \x10\n\n\n\x03\x07\x0b\x05\x12\x03\x14\x11\x17\n\n\n\x03\x07\x0b\x01\x12\
    \x03\x14\x18;\n\n\n\x03\x07\x0b\x03\x12\x03\x14>C\n\t\n\x02\x07\x0c\x12\
    \x03\x15\x08L\n\n\n\x03\x07\x0c\x02\x12\x03\t\x07$\n\n\n\x03\x07\x0c\x04\
    \x12\x03\x15\x08\x10\n\n\n\x03\x07\x0c\x05\x12\x03\x15\x11\x15\n\n\n\x03\
    \x07\x0c\x01\x12\x03\x15\x161\n\n\n\x03\x07\x0c\x03\x12\x03\x1549\n\n\n\
    \x03\x07\x0c\x08\x12\x03\x15:K\n\n\n\x03\x07\x0c\x07\x12\x03\x15EJ\n\t\n\
    \x02\x07\r\x12\x03\x16\x08B\n\n\n\x03\x07\r\x02\x12\x03\t\x07$\n\n\n\x03\
    \x07\r\x04\x12\x03\x16\x08\x10\n\n\n\x03\x07\r\x05\x12\x03\x16\x11\x15\n\
    \n\n\x03\x07\r\x01\x12\x03\x16\x16'\n\n\n\x03\x07\r\x03\x12\x03\x16*/\n\
    \n\n\x03\x07\r\x08\x12\x03\x160A\n\n\n\x03\x07\r\x07\x12\x03\x16;@\n\t\n\
    \x02\x07\x0e\x12\x03\x17\x08T\n\n\n\x03\x07\x0e\x02\x12\x03\t\x07$\n\n\n\
    \x03\x07\x0e\x04\x12\x03\x17\x08\x10\n\n\n\x03\x07\x0e\x06\x12\x03\x17\
    \x11\x1f\n\n\n\x03\x07\x0e\x01\x12\x03\x17\x20.\n\n\n\x03\x07\x0e\x03\
    \x12\x03\x1716\n\n\n\x03\x07\x0e\x08\x12\x03\x177S\n\n\n\x03\x07\x0e\x07\
    \x12\x03\x17BR\n\t\n\x02\x07\x0f\x12\x03\x18\x08B\n\n\n\x03\x07\x0f\x02\
    \x12\x03\t\x07$\n\n\n\x03\x07\x0f\x04\x12\x03\x18\x08\x10\n\n\n\x03\x07\
    \x0f\x05\x12\x03\x18\x11\x15\n\n\n\x03\x07\x0f\x01\x12\x03\x18\x16'\n\n\
    \n\x03\x07\x0f\x03\x12\x03\x18*/\n\n\n\x03\x07\x0f\x08\x12\x03\x180A\n\n\
    \n\x03\x07\x0f\x07\x12\x03\x18;@\n\n\n\x02\x05\0\x12\x04\x1b\0\x1f\x01\n\
    \n\n\x03\x05\0\x01\x12\x03\x1b\x05\x15\n\x0b\n\x04\x05\0\x02\0\x12\x03\
    \x1c\x08\x10\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\x1c\x08\x0b\n\x0c\n\x05\
    \x05\0\x02\0\x02\x12\x03\x1c\x0e\x0f\n\x0b\n\x04\x05\0\x02\x01\x12\x03\
    \x1d\x08\x0f\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\x1d\x08\n\n\x0c\n\x05\
    \x05\0\x02\x01\x02\x12\x03\x1d\r\x0e\n\x0b\n\x04\x05\0\x02\x02\x12\x03\
    \x1e\x08\x10\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03\x1e\x08\x0b\n\x0c\n\
    \x05\x05\0\x02\x02\x02\x12\x03\x1e\x0e\x0f\n\n\n\x02\x05\x01\x12\x04!\0'\
    \x01\n\n\n\x03\x05\x01\x01\x12\x03!\x05\x1b\n\x0b\n\x04\x05\x01\x02\0\
    \x12\x03\"\x08\x1e\n\x0c\n\x05\x05\x01\x02\0\x01\x12\x03\"\x08\x19\n\x0c\
    \n\x05\x05\x01\x02\0\x02\x12\x03\"\x1c\x1d\n\x0b\n\x04\x05\x01\x02\x01\
    \x12\x03#\x08\x1b\n\x0c\n\x05\x05\x01\x02\x01\x01\x12\x03#\x08\x16\n\x0c\
    \n\x05\x05\x01\x02\x01\x02\x12\x03#\x19\x1a\n\x0b\n\x04\x05\x01\x02\x02\
    \x12\x03$\x08\x19\n\x0c\n\x05\x05\x01\x02\x02\x01\x12\x03$\x08\x14\n\x0c\
    \n\x05\x05\x01\x02\x02\x02\x12\x03$\x17\x18\n\x0b\n\x04\x05\x01\x02\x03\
    \x12\x03%\x08\x1d\n\x0c\n\x05\x05\x01\x02\x03\x01\x12\x03%\x08\x18\n\x0c\
    \n\x05\x05\x01\x02\x03\x02\x12\x03%\x1b\x1c\n\x0b\n\x04\x05\x01\x02\x04\
    \x12\x03&\x08\x18\n\x0c\n\x05\x05\x01\x02\x04\x01\x12\x03&\x08\x13\n\x0c\
    \n\x05\x05\x01\x02\x04\x02\x12\x03&\x16\x17\n\n\n\x02\x05\x02\x12\x04)\0\
    6\x01\n\n\n\x03\x05\x02\x01\x12\x03)\x05\x12\n\x0b\n\x04\x05\x02\x02\0\
    \x12\x03*\x08$\n\x0c\n\x05\x05\x02\x02\0\x01\x12\x03*\x08\x1f\n\x0c\n\
    \x05\x05\x02\x02\0\x02\x12\x03*\"#\n\x0b\n\x04\x05\x02\x02\x01\x12\x03+\
    \x08!\n\x0c\n\x05\x05\x02\x02\x01\x01\x12\x03+\x08\x1c\n\x0c\n\x05\x05\
    \x02\x02\x01\x02\x12\x03+\x1f\x20\n\x0b\n\x04\x05\x02\x02\x02\x12\x03,\
    \x08&\n\x0c\n\x05\x05\x02\x02\x02\x01\x12\x03,\x08!\n\x0c\n\x05\x05\x02\
    \x02\x02\x02\x12\x03,$%\n\x0b\n\x04\x05\x02\x02\x03\x12\x03-\x08\x1b\n\
    \x0c\n\x05\x05\x02\x02\x03\x01\x12\x03-\x08\x16\n\x0c\n\x05\x05\x02\x02\
    \x03\x02\x12\x03-\x19\x1a\n\x0b\n\x04\x05\x02\x02\x04\x12\x03.\x08%\n\
    \x0c\n\x05\x05\x02\x02\x04\x01\x12\x03.\x08\x20\n\x0c\n\x05\x05\x02\x02\
    \x04\x02\x12\x03.#$\n\x0b\n\x04\x05\x02\x02\x05\x12\x03/\x08(\n\x0c\n\
    \x05\x05\x02\x02\x05\x01\x12\x03/\x08#\n\x0c\n\x05\x05\x02\x02\x05\x02\
    \x12\x03/&'\n\x0b\n\x04\x05\x02\x02\x06\x12\x030\x08(\n\x0c\n\x05\x05\
    \x02\x02\x06\x01\x12\x030\x08#\n\x0c\n\x05\x05\x02\x02\x06\x02\x12\x030&\
    '\n\x0b\n\x04\x05\x02\x02\x07\x12\x031\x08.\n\x0c\n\x05\x05\x02\x02\x07\
    \x01\x12\x031\x08)\n\x0c\n\x05\x05\x02\x02\x07\x02\x12\x031,-\n\x0b\n\
    \x04\x05\x02\x02\x08\x12\x032\x08)\n\x0c\n\x05\x05\x02\x02\x08\x01\x12\
    \x032\x08$\n\x0c\n\x05\x05\x02\x02\x08\x02\x12\x032'(\n\x0b\n\x04\x05\
    \x02\x02\t\x12\x033\x08\"\n\x0c\n\x05\x05\x02\x02\t\x01\x12\x033\x08\x1c\
    \n\x0c\n\x05\x05\x02\x02\t\x02\x12\x033\x1f!\n\x0b\n\x04\x05\x02\x02\n\
    \x12\x034\x08+\n\x0c\n\x05\x05\x02\x02\n\x01\x12\x034\x08%\n\x0c\n\x05\
    \x05\x02\x02\n\x02\x12\x034(*\n\x0b\n\x04\x05\x02\x02\x0b\x12\x035\x08*\
    \n\x0c\n\x05\x05\x02\x02\x0b\x01\x12\x035\x08$\n\x0c\n\x05\x05\x02\x02\
    \x0b\x02\x12\x035')\n\n\n\x02\x05\x03\x12\x048\0<\x01\n\n\n\x03\x05\x03\
    \x01\x12\x038\x05\x11\n\x0b\n\x04\x05\x03\x02\0\x12\x039\x08\x20\n\x0c\n\
    \x05\x05\x03\x02\0\x01\x12\x039\x08\x1b\n\x0c\n\x05\x05\x03\x02\0\x02\
    \x12\x039\x1e\x1f\n\x0b\n\x04\x05\x03\x02\x01\x12\x03:\x08\"\n\x0c\n\x05\
    \x05\x03\x02\x01\x01\x12\x03:\x08\x1d\n\x0c\n\x05\x05\x03\x02\x01\x02\
    \x12\x03:\x20!\n\x0b\n\x04\x05\x03\x02\x02\x12\x03;\x08\x20\n\x0c\n\x05\
    \x05\x03\x02\x02\x01\x12\x03;\x08\x1b\n\x0c\n\x05\x05\x03\x02\x02\x02\
    \x12\x03;\x1e\x1f\n\n\n\x02\x05\x04\x12\x04>\0H\x01\n\n\n\x03\x05\x04\
    \x01\x12\x03>\x05\x12\n\x0b\n\x04\x05\x04\x02\0\x12\x03?\x08\x1d\n\x0c\n\
    \x05\x05\x04\x02\0\x01\x12\x03?\x08\x18\n\x0c\n\x05\x05\x04\x02\0\x02\
    \x12\x03?\x1b\x1c\n\x0b\n\x04\x05\x04\x02\x01\x12\x03@\x08\x1b\n\x0c\n\
    \x05\x05\x04\x02\x01\x01\x12\x03@\x08\x16\n\x0c\n\x05\x05\x04\x02\x01\
    \x02\x12\x03@\x19\x1a\n\x0b\n\x04\x05\x04\x02\x02\x12\x03A\x08\x1c\n\x0c\
    \n\x05\x05\x04\x02\x02\x01\x12\x03A\x08\x17\n\x0c\n\x05\x05\x04\x02\x02\
    \x02\x12\x03A\x1a\x1b\n\x0b\n\x04\x05\x04\x02\x03\x12\x03B\x08\x1c\n\x0c\
    \n\x05\x05\x04\x02\x03\x01\x12\x03B\x08\x17\n\x0c\n\x05\x05\x04\x02\x03\
    \x02\x12\x03B\x1a\x1b\n\x0b\n\x04\x05\x04\x02\x04\x12\x03C\x08\x1c\n\x0c\
    \n\x05\x05\x04\x02\x04\x01\x12\x03C\x08\x17\n\x0c\n\x05\x05\x04\x02\x04\
    \x02\x12\x03C\x1a\x1b\n\x0b\n\x04\x05\x04\x02\x05\x12\x03D\x08\x1c\n\x0c\
    \n\x05\x05\x04\x02\x05\x01\x12\x03D\x08\x17\n\x0c\n\x05\x05\x04\x02\x05\
    \x02\x12\x03D\x1a\x1b\n\x0b\n\x04\x05\x04\x02\x06\x12\x03E\x08\x1c\n\x0c\
    \n\x05\x05\x04\x02\x06\x01\x12\x03E\x08\x17\n\x0c\n\x05\x05\x04\x02\x06\
    \x02\x12\x03E\x1a\x1b\n\x0b\n\x04\x05\x04\x02\x07\x12\x03F\x08\x1a\n\x0c\
    \n\x05\x05\x04\x02\x07\x01\x12\x03F\x08\x15\n\x0c\n\x05\x05\x04\x02\x07\
    \x02\x12\x03F\x18\x19\n\x0b\n\x04\x05\x04\x02\x08\x12\x03G\x08\x1c\n\x0c\
    \n\x05\x05\x04\x02\x08\x01\x12\x03G\x08\x17\n\x0c\n\x05\x05\x04\x02\x08\
    \x02\x12\x03G\x1a\x1b\n\n\n\x02\x05\x05\x12\x04J\0O\x01\n\n\n\x03\x05\
    \x05\x01\x12\x03J\x05\x14\n\x0b\n\x04\x05\x05\x02\0\x12\x03K\x08\x1d\n\
    \x0c\n\x05\x05\x05\x02\0\x01\x12\x03K\x08\x18\n\x0c\n\x05\x05\x05\x02\0\
    \x02\x12\x03K\x1b\x1c\n\x0b\n\x04\x05\x05\x02\x01\x12\x03L\x08\x1e\n\x0c\
    \n\x05\x05\x05\x02\x01\x01\x12\x03L\x08\x19\n\x0c\n\x05\x05\x05\x02\x01\
    \x02\x12\x03L\x1c\x1d\n\x0b\n\x04\x05\x05\x02\x02\x12\x03M\x08\x1f\n\x0c\
    \n\x05\x05\x05\x02\x02\x01\x12\x03M\x08\x1a\n\x0c\n\x05\x05\x05\x02\x02\
    \x02\x12\x03M\x1d\x1e\n\x0b\n\x04\x05\x05\x02\x03\x12\x03N\x08\x1e\n\x0c\
    \n\x05\x05\x05\x02\x03\x01\x12\x03N\x08\x19\n\x0c\n\x05\x05\x05\x02\x03\
    \x02\x12\x03N\x1c\x1d\n\n\n\x02\x04\0\x12\x04Q\0X\x01\n\n\n\x03\x04\0\
    \x01\x12\x03Q\x08\x13\n\x0c\n\x04\x04\0\x03\0\x12\x04R\x08U\t\n\x0c\n\
    \x05\x04\0\x03\0\x01\x12\x03R\x10\x19\n\r\n\x06\x04\0\x03\0\x02\0\x12\
    \x03S\x101\n\x0e\n\x07\x04\0\x03\0\x02\0\x04\x12\x03S\x10\x18\n\x0e\n\
    \x07\x04\0\x03\0\x02\0\x05\x12\x03S\x19\x1f\n\x0e\n\x07\x04\0\x03\0\x02\
    \0\x01\x12\x03S\x20,\n\x0e\n\x07\x04\0\x03\0\x02\0\x03\x12\x03S/0\n\r\n\
    \x06\x04\0\x03\0\x02\x01\x12\x03T\x103\n\x0e\n\x07\x04\0\x03\0\x02\x01\
    \x04\x12\x03T\x10\x18\n\x0e\n\x07\x04\0\x03\0\x02\x01\x05\x12\x03T\x19\
    \x1f\n\x0e\n\x07\x04\0\x03\0\x02\x01\x01\x12\x03T\x20.\n\x0e\n\x07\x04\0\
    \x03\0\x02\x01\x03\x12\x03T12\n\x0b\n\x04\x04\0\x02\0\x12\x03W\x082\n\
    \x0c\n\x05\x04\0\x02\0\x04\x12\x03W\x08\x10\n\x0c\n\x05\x04\0\x02\0\x06\
    \x12\x03W\x11'\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03W(-\n\x0c\n\x05\x04\0\
    \x02\0\x03\x12\x03W01\n\n\n\x02\x04\x01\x12\x04Z\0^\x01\n\n\n\x03\x04\
    \x01\x01\x12\x03Z\x08\x1c\n\x0b\n\x04\x04\x01\x02\0\x12\x03[\x08W\n\x0c\
    \n\x05\x04\x01\x02\0\x04\x12\x03[\x08\x10\n\x0c\n\x05\x04\x01\x02\0\x06\
    \x12\x03[\x11(\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03[)4\n\x0c\n\x05\x04\
    \x01\x02\0\x03\x12\x03[78\n\x0c\n\x05\x04\x01\x02\0\x08\x12\x03[9V\n\x0c\
    \n\x05\x04\x01\x02\0\x07\x12\x03[DU\n\x0b\n\x04\x04\x01\x02\x01\x12\x03\
    \\\x085\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x03\\\x08\x10\n\x0c\n\x05\
    \x04\x01\x02\x01\x06\x12\x03\\\x11\x20\n\x0c\n\x05\x04\x01\x02\x01\x01\
    \x12\x03\\!0\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03\\34\n\x0b\n\x04\x04\
    \x01\x02\x02\x12\x03]\x08+\n\x0c\n\x05\x04\x01\x02\x02\x04\x12\x03]\x08\
    \x10\n\x0c\n\x05\x04\x01\x02\x02\x06\x12\x03]\x11\x1d\n\x0c\n\x05\x04\
    \x01\x02\x02\x01\x12\x03]\x1e&\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03])\
    *\n\n\n\x02\x04\x02\x12\x04`\0d\x01\n\n\n\x03\x04\x02\x01\x12\x03`\x08\
    \x1e\n\x0b\n\x04\x04\x02\x02\0\x12\x03a\x08>\n\x0c\n\x05\x04\x02\x02\0\
    \x04\x12\x03a\x08\x10\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03a\x11\x17\n\
    \x0c\n\x05\x04\x02\x02\0\x01\x12\x03a\x18\x1c\n\x0c\n\x05\x04\x02\x02\0\
    \x03\x12\x03a\x1f\x20\n\x0c\n\x05\x04\x02\x02\0\x08\x12\x03a!=\n\x0f\n\
    \x08\x04\x02\x02\0\x08\xff\xa2\x04\x12\x03a\"<\n\x0b\n\x04\x04\x02\x02\
    \x01\x12\x03b\x083\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03b\x08\x10\n\
    \x0c\n\x05\x04\x02\x02\x01\x05\x12\x03b\x11\x15\n\x0c\n\x05\x04\x02\x02\
    \x01\x01\x12\x03b\x16\x1d\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03b\x20!\
    \n\x0c\n\x05\x04\x02\x02\x01\x08\x12\x03b\"2\n\x0c\n\x05\x04\x02\x02\x01\
    \x07\x12\x03b-1\n\x0b\n\x04\x04\x02\x02\x02\x12\x03c\x08\"\n\x0c\n\x05\
    \x04\x02\x02\x02\x04\x12\x03c\x08\x10\n\x0c\n\x05\x04\x02\x02\x02\x05\
    \x12\x03c\x11\x17\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03c\x18\x1d\n\x0c\
    \n\x05\x04\x02\x02\x02\x03\x12\x03c\x20!\n\n\n\x02\x04\x03\x12\x04f\0m\
    \x01\n\n\n\x03\x04\x03\x01\x12\x03f\x08\x1a\n\x0c\n\x04\x04\x03\x02\0\
    \x12\x04g\x08\x90\x01\n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03g\x08\x10\n\
    \x0c\n\x05\x04\x03\x02\0\x05\x12\x03g\x11\x17\n\x0c\n\x05\x04\x03\x02\0\
    \x01\x12\x03g\x18\x20\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03g#$\n\r\n\x05\
    \x04\x03\x02\0\x08\x12\x04g%\x8f\x01\n\x0f\n\x08\x04\x03\x02\0\x08\xf1\
    \xa2\x04\x12\x03g&8\n\x0f\n\x08\x04\x03\x02\0\x08\xf4\xa2\x04\x12\x03g:U\
    \n\x0f\n\x08\x04\x03\x02\0\x08\xf5\xa2\x04\x12\x03gWr\n\x10\n\x08\x04\
    \x03\x02\0\x08\xfd\xa2\x04\x12\x04gt\x8e\x01\n\x0c\n\x04\x04\x03\x02\x01\
    \x12\x04h\x08\x81\x01\n\x0c\n\x05\x04\x03\x02\x01\x04\x12\x03h\x08\x10\n\
    \x0c\n\x05\x04\x03\x02\x01\x05\x12\x03h\x11\x17\n\x0c\n\x05\x04\x03\x02\
    \x01\x01\x12\x03h\x18\x1c\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03h\x1f\
    \x20\n\r\n\x05\x04\x03\x02\x01\x08\x12\x04h!\x80\x01\n\x0f\n\x08\x04\x03\
    \x02\x01\x08\xf4\xa2\x04\x12\x03h\"9\n\x0f\n\x08\x04\x03\x02\x01\x08\xf5\
    \xa2\x04\x12\x03h;c\n\x0f\n\x08\x04\x03\x02\x01\x08\xfd\xa2\x04\x12\x03h\
    e\x7f\n\x0c\n\x04\x04\x03\x02\x02\x12\x04i\x08\xef\x01\n\x0c\n\x05\x04\
    \x03\x02\x02\x04\x12\x03i\x08\x10\n\x0c\n\x05\x04\x03\x02\x02\x06\x12\
    \x03i\x11\x20\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x03i!(\n\x0c\n\x05\x04\
    \x03\x02\x02\x03\x12\x03i+,\n\r\n\x05\x04\x03\x02\x02\x08\x12\x04i-\xee\
    \x01\n\x0f\n\x08\x04\x03\x02\x02\x08\xf4\xa2\x04\x12\x03i.G\n\x10\n\x08\
    \x04\x03\x02\x02\x08\xf5\xa2\x04\x12\x04iI\x9c\x01\n\x11\n\x08\x04\x03\
    \x02\x02\x08\xfa\xa2\x04\x12\x05i\x9e\x01\xd1\x01\n\x11\n\x08\x04\x03\
    \x02\x02\x08\xfd\xa2\x04\x12\x05i\xd3\x01\xed\x01\n\x0c\n\x04\x04\x03\
    \x02\x03\x12\x04j\x08\xa4\x01\n\x0c\n\x05\x04\x03\x02\x03\x04\x12\x03j\
    \x08\x10\n\x0c\n\x05\x04\x03\x02\x03\x05\x12\x03j\x11\x17\n\x0c\n\x05\
    \x04\x03\x02\x03\x01\x12\x03j\x18\x1c\n\x0c\n\x05\x04\x03\x02\x03\x03\
    \x12\x03j\x1f\x20\n\r\n\x05\x04\x03\x02\x03\x08\x12\x04j!\xa3\x01\n\x0f\
    \n\x08\x04\x03\x02\x03\x08\xf4\xa2\x04\x12\x03j\"9\n\x10\n\x08\x04\x03\
    \x02\x03\x08\xf5\xa2\x04\x12\x04j;\xa2\x01\n\x0c\n\x04\x04\x03\x02\x04\
    \x12\x04k\x08\xc6\x01\n\x0c\n\x05\x04\x03\x02\x04\x04\x12\x03k\x08\x10\n\
    \x0c\n\x05\x04\x03\x02\x04\x05\x12\x03k\x11\x15\n\x0c\n\x05\x04\x03\x02\
    \x04\x01\x12\x03k\x16!\n\x0c\n\x05\x04\x03\x02\x04\x03\x12\x03k$%\n\r\n\
    \x05\x04\x03\x02\x04\x08\x12\x04k&\xc5\x01\n\x0c\n\x05\x04\x03\x02\x04\
    \x07\x12\x03k16\n\x0f\n\x08\x04\x03\x02\x04\x08\xf4\xa2\x04\x12\x03k8V\n\
    \x10\n\x08\x04\x03\x02\x04\x08\xf5\xa2\x04\x12\x04kX\xa8\x01\n\x11\n\x08\
    \x04\x03\x02\x04\x08\xfd\xa2\x04\x12\x05k\xaa\x01\xc4\x01\n\x0c\n\x04\
    \x04\x03\x02\x05\x12\x04l\x08\xb0\x01\n\x0c\n\x05\x04\x03\x02\x05\x04\
    \x12\x03l\x08\x10\n\x0c\n\x05\x04\x03\x02\x05\x06\x12\x03l\x11(\n\x0c\n\
    \x05\x04\x03\x02\x05\x01\x12\x03l)2\n\x0c\n\x05\x04\x03\x02\x05\x03\x12\
    \x03l56\n\r\n\x05\x04\x03\x02\x05\x08\x12\x04l7\xaf\x01\n\x0f\n\x08\x04\
    \x03\x02\x05\x08\xf4\xa2\x04\x12\x03l8T\n\x0f\n\x08\x04\x03\x02\x05\x08\
    \xf5\xa2\x04\x12\x03lV~\n\x11\n\x08\x04\x03\x02\x05\x08\xfb\xa2\x04\x12\
    \x05l\x80\x01\xae\x01\n\n\n\x02\x04\x04\x12\x04o\0q\x01\n\n\n\x03\x04\
    \x04\x01\x12\x03o\x08\x16\n\x0b\n\x04\x04\x04\x02\0\x12\x03p\x08*\n\x0c\
    \n\x05\x04\x04\x02\0\x04\x12\x03p\x08\x10\n\x0c\n\x05\x04\x04\x02\0\x06\
    \x12\x03p\x11\x1f\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03p\x20%\n\x0c\n\
    \x05\x04\x04\x02\0\x03\x12\x03p()\n\x0b\n\x02\x04\x05\x12\x05s\0\x83\x01\
    \x01\n\n\n\x03\x04\x05\x01\x12\x03s\x08\x16\n\x0b\n\x04\x04\x05\x02\0\
    \x12\x03t\x08%\n\x0c\n\x05\x04\x05\x02\0\x04\x12\x03t\x08\x10\n\x0c\n\
    \x05\x04\x05\x02\0\x05\x12\x03t\x11\x17\n\x0c\n\x05\x04\x05\x02\0\x01\
    \x12\x03t\x18\x20\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03t#$\n\x0b\n\x04\
    \x04\x05\x02\x01\x12\x03u\x08M\n\x0c\n\x05\x04\x05\x02\x01\x04\x12\x03u\
    \x08\x10\n\x0c\n\x05\x04\x05\x02\x01\x06\x12\x03u\x11\x1f\n\x0c\n\x05\
    \x04\x05\x02\x01\x01\x12\x03u\x20$\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\
    \x03u'(\n\x0c\n\x05\x04\x05\x02\x01\x08\x12\x03u)L\n\x0c\n\x05\x04\x05\
    \x02\x01\x07\x12\x03u4K\n\r\n\x04\x04\x05\x08\0\x12\x05w\x08\x82\x01\t\n\
    \x0c\n\x05\x04\x05\x08\0\x01\x12\x03w\x0e\x16\n\x0b\n\x04\x04\x05\x02\
    \x02\x12\x03x\x10J\n\x0c\n\x05\x04\x05\x02\x02\x06\x12\x03x\x10$\n\x0c\n\
    \x05\x04\x05\x02\x02\x01\x12\x03x%E\n\x0c\n\x05\x04\x05\x02\x02\x03\x12\
    \x03xHI\n\x0b\n\x04\x04\x05\x02\x03\x12\x03y\x10B\n\x0c\n\x05\x04\x05\
    \x02\x03\x06\x12\x03y\x10\x1f\n\x0c\n\x05\x04\x05\x02\x03\x01\x12\x03y\
    \x20=\n\x0c\n\x05\x04\x05\x02\x03\x03\x12\x03y@A\n\x0b\n\x04\x04\x05\x02\
    \x04\x12\x03z\x10N\n\x0c\n\x05\x04\x05\x02\x04\x06\x12\x03z\x10&\n\x0c\n\
    \x05\x04\x05\x02\x04\x01\x12\x03z'I\n\x0c\n\x05\x04\x05\x02\x04\x03\x12\
    \x03zLM\n\x0b\n\x04\x04\x05\x02\x05\x12\x03{\x10:\n\x0c\n\x05\x04\x05\
    \x02\x05\x06\x12\x03{\x10\x1d\n\x0c\n\x05\x04\x05\x02\x05\x01\x12\x03{\
    \x1e5\n\x0c\n\x05\x04\x05\x02\x05\x03\x12\x03{89\n\x0b\n\x04\x04\x05\x02\
    \x06\x12\x03|\x10M\n\x0c\n\x05\x04\x05\x02\x06\x06\x12\x03|\x10&\n\x0c\n\
    \x05\x04\x05\x02\x06\x01\x12\x03|'H\n\x0c\n\x05\x04\x05\x02\x06\x03\x12\
    \x03|KL\n\x0b\n\x04\x04\x05\x02\x07\x12\x03}\x10Q\n\x0c\n\x05\x04\x05\
    \x02\x07\x06\x12\x03}\x10'\n\x0c\n\x05\x04\x05\x02\x07\x01\x12\x03}(L\n\
    \x0c\n\x05\x04\x05\x02\x07\x03\x12\x03}OP\n\x0b\n\x04\x04\x05\x02\x08\
    \x12\x03~\x10R\n\x0c\n\x05\x04\x05\x02\x08\x06\x12\x03~\x10'\n\x0c\n\x05\
    \x04\x05\x02\x08\x01\x12\x03~(L\n\x0c\n\x05\x04\x05\x02\x08\x03\x12\x03~\
    OQ\n\x0b\n\x04\x04\x05\x02\t\x12\x03\x7f\x10]\n\x0c\n\x05\x04\x05\x02\t\
    \x06\x12\x03\x7f\x10,\n\x0c\n\x05\x04\x05\x02\t\x01\x12\x03\x7f-W\n\x0c\
    \n\x05\x04\x05\x02\t\x03\x12\x03\x7fZ\\\n\x0c\n\x04\x04\x05\x02\n\x12\
    \x04\x80\x01\x10T\n\r\n\x05\x04\x05\x02\n\x06\x12\x04\x80\x01\x10(\n\r\n\
    \x05\x04\x05\x02\n\x01\x12\x04\x80\x01)N\n\r\n\x05\x04\x05\x02\n\x03\x12\
    \x04\x80\x01QS\n\x0c\n\x04\x04\x05\x02\x0b\x12\x04\x81\x01\x10C\n\r\n\
    \x05\x04\x05\x02\x0b\x06\x12\x04\x81\x01\x10\x1f\n\r\n\x05\x04\x05\x02\
    \x0b\x01\x12\x04\x81\x01\x20=\n\r\n\x05\x04\x05\x02\x0b\x03\x12\x04\x81\
    \x01@B\n\x0c\n\x02\x04\x06\x12\x06\x85\x01\0\xb5\x02\x01\n\x0b\n\x03\x04\
    \x06\x01\x12\x04\x85\x01\x08\x1d\n\x0e\n\x04\x04\x06\x04\0\x12\x06\x86\
    \x01\x08\x9b\x01\t\n\r\n\x05\x04\x06\x04\0\x01\x12\x04\x86\x01\r\x1a\n\
    \x0e\n\x06\x04\x06\x04\0\x02\0\x12\x04\x87\x01\x10)\n\x0f\n\x07\x04\x06\
    \x04\0\x02\0\x01\x12\x04\x87\x01\x10$\n\x0f\n\x07\x04\x06\x04\0\x02\0\
    \x02\x12\x04\x87\x01'(\n\x0e\n\x06\x04\x06\x04\0\x02\x01\x12\x04\x88\x01\
    \x10&\n\x0f\n\x07\x04\x06\x04\0\x02\x01\x01\x12\x04\x88\x01\x10!\n\x0f\n\
    \x07\x04\x06\x04\0\x02\x01\x02\x12\x04\x88\x01$%\n\x0e\n\x06\x04\x06\x04\
    \0\x02\x02\x12\x04\x89\x01\x100\n\x0f\n\x07\x04\x06\x04\0\x02\x02\x01\
    \x12\x04\x89\x01\x10+\n\x0f\n\x07\x04\x06\x04\0\x02\x02\x02\x12\x04\x89\
    \x01./\n\x0e\n\x06\x04\x06\x04\0\x02\x03\x12\x04\x8a\x01\x10'\n\x0f\n\
    \x07\x04\x06\x04\0\x02\x03\x01\x12\x04\x8a\x01\x10\"\n\x0f\n\x07\x04\x06\
    \x04\0\x02\x03\x02\x12\x04\x8a\x01%&\n\x0e\n\x06\x04\x06\x04\0\x02\x04\
    \x12\x04\x8b\x01\x10%\n\x0f\n\x07\x04\x06\x04\0\x02\x04\x01\x12\x04\x8b\
    \x01\x10\x20\n\x0f\n\x07\x04\x06\x04\0\x02\x04\x02\x12\x04\x8b\x01#$\n\
    \x0e\n\x06\x04\x06\x04\0\x02\x05\x12\x04\x8c\x01\x10-\n\x0f\n\x07\x04\
    \x06\x04\0\x02\x05\x01\x12\x04\x8c\x01\x10(\n\x0f\n\x07\x04\x06\x04\0\
    \x02\x05\x02\x12\x04\x8c\x01+,\n\x0e\n\x06\x04\x06\x04\0\x02\x06\x12\x04\
    \x8d\x01\x10+\n\x0f\n\x07\x04\x06\x04\0\x02\x06\x01\x12\x04\x8d\x01\x10&\
    \n\x0f\n\x07\x04\x06\x04\0\x02\x06\x02\x12\x04\x8d\x01)*\n\x0e\n\x06\x04\
    \x06\x04\0\x02\x07\x12\x04\x8e\x01\x10%\n\x0f\n\x07\x04\x06\x04\0\x02\
    \x07\x01\x12\x04\x8e\x01\x10\x20\n\x0f\n\x07\x04\x06\x04\0\x02\x07\x02\
    \x12\x04\x8e\x01#$\n\x0e\n\x06\x04\x06\x04\0\x02\x08\x12\x04\x8f\x01\x10\
    ,\n\x0f\n\x07\x04\x06\x04\0\x02\x08\x01\x12\x04\x8f\x01\x10'\n\x0f\n\x07\
    \x04\x06\x04\0\x02\x08\x02\x12\x04\x8f\x01*+\n\x0e\n\x06\x04\x06\x04\0\
    \x02\t\x12\x04\x90\x01\x10+\n\x0f\n\x07\x04\x06\x04\0\x02\t\x01\x12\x04\
    \x90\x01\x10&\n\x0f\n\x07\x04\x06\x04\0\x02\t\x02\x12\x04\x90\x01)*\n\
    \x0e\n\x06\x04\x06\x04\0\x02\n\x12\x04\x91\x01\x10)\n\x0f\n\x07\x04\x06\
    \x04\0\x02\n\x01\x12\x04\x91\x01\x10#\n\x0f\n\x07\x04\x06\x04\0\x02\n\
    \x02\x12\x04\x91\x01&(\n\x0e\n\x06\x04\x06\x04\0\x02\x0b\x12\x04\x92\x01\
    \x104\n\x0f\n\x07\x04\x06\x04\0\x02\x0b\x01\x12\x04\x92\x01\x10.\n\x0f\n\
    \x07\x04\x06\x04\0\x02\x0b\x02\x12\x04\x92\x0113\n\x0e\n\x06\x04\x06\x04\
    \0\x02\x0c\x12\x04\x93\x01\x10+\n\x0f\n\x07\x04\x06\x04\0\x02\x0c\x01\
    \x12\x04\x93\x01\x10%\n\x0f\n\x07\x04\x06\x04\0\x02\x0c\x02\x12\x04\x93\
    \x01(*\n\x0e\n\x06\x04\x06\x04\0\x02\r\x12\x04\x94\x01\x10,\n\x0f\n\x07\
    \x04\x06\x04\0\x02\r\x01\x12\x04\x94\x01\x10&\n\x0f\n\x07\x04\x06\x04\0\
    \x02\r\x02\x12\x04\x94\x01)+\n\x0e\n\x06\x04\x06\x04\0\x02\x0e\x12\x04\
    \x95\x01\x10,\n\x0f\n\x07\x04\x06\x04\0\x02\x0e\x01\x12\x04\x95\x01\x10&\
    \n\x0f\n\x07\x04\x06\x04\0\x02\x0e\x02\x12\x04\x95\x01)+\n\x0e\n\x06\x04\
    \x06\x04\0\x02\x0f\x12\x04\x96\x01\x104\n\x0f\n\x07\x04\x06\x04\0\x02\
    \x0f\x01\x12\x04\x96\x01\x10.\n\x0f\n\x07\x04\x06\x04\0\x02\x0f\x02\x12\
    \x04\x96\x0113\n\x0e\n\x06\x04\x06\x04\0\x02\x10\x12\x04\x97\x01\x10(\n\
    \x0f\n\x07\x04\x06\x04\0\x02\x10\x01\x12\x04\x97\x01\x10\"\n\x0f\n\x07\
    \x04\x06\x04\0\x02\x10\x02\x12\x04\x97\x01%'\n\x0e\n\x06\x04\x06\x04\0\
    \x02\x11\x12\x04\x98\x01\x103\n\x0f\n\x07\x04\x06\x04\0\x02\x11\x01\x12\
    \x04\x98\x01\x10-\n\x0f\n\x07\x04\x06\x04\0\x02\x11\x02\x12\x04\x98\x010\
    2\n\x0e\n\x06\x04\x06\x04\0\x02\x12\x12\x04\x99\x01\x10)\n\x0f\n\x07\x04\
    \x06\x04\0\x02\x12\x01\x12\x04\x99\x01\x10#\n\x0f\n\x07\x04\x06\x04\0\
    \x02\x12\x02\x12\x04\x99\x01&(\n\x0e\n\x06\x04\x06\x04\0\x02\x13\x12\x04\
    \x9a\x01\x10-\n\x0f\n\x07\x04\x06\x04\0\x02\x13\x01\x12\x04\x9a\x01\x10'\
    \n\x0f\n\x07\x04\x06\x04\0\x02\x13\x02\x12\x04\x9a\x01*,\n\x0e\n\x04\x04\
    \x06\x04\x01\x12\x06\x9d\x01\x08\xa0\x02\t\n\r\n\x05\x04\x06\x04\x01\x01\
    \x12\x04\x9d\x01\r\x1b\n\x0e\n\x06\x04\x06\x04\x01\x02\0\x12\x04\x9e\x01\
    \x10#\n\x0f\n\x07\x04\x06\x04\x01\x02\0\x01\x12\x04\x9e\x01\x10\x1e\n\
    \x0f\n\x07\x04\x06\x04\x01\x02\0\x02\x12\x04\x9e\x01!\"\n\x0e\n\x06\x04\
    \x06\x04\x01\x02\x01\x12\x04\x9f\x01\x10#\n\x0f\n\x07\x04\x06\x04\x01\
    \x02\x01\x01\x12\x04\x9f\x01\x10\x1e\n\x0f\n\x07\x04\x06\x04\x01\x02\x01\
    \x02\x12\x04\x9f\x01!\"\n\x0e\n\x06\x04\x06\x04\x01\x02\x02\x12\x04\xa0\
    \x01\x10'\n\x0f\n\x07\x04\x06\x04\x01\x02\x02\x01\x12\x04\xa0\x01\x10\"\
    \n\x0f\n\x07\x04\x06\x04\x01\x02\x02\x02\x12\x04\xa0\x01%&\n\x0e\n\x06\
    \x04\x06\x04\x01\x02\x03\x12\x04\xa1\x01\x10&\n\x0f\n\x07\x04\x06\x04\
    \x01\x02\x03\x01\x12\x04\xa1\x01\x10!\n\x0f\n\x07\x04\x06\x04\x01\x02\
    \x03\x02\x12\x04\xa1\x01$%\n\x0e\n\x06\x04\x06\x04\x01\x02\x04\x12\x04\
    \xa2\x01\x10&\n\x0f\n\x07\x04\x06\x04\x01\x02\x04\x01\x12\x04\xa2\x01\
    \x10!\n\x0f\n\x07\x04\x06\x04\x01\x02\x04\x02\x12\x04\xa2\x01$%\n\x0e\n\
    \x06\x04\x06\x04\x01\x02\x05\x12\x04\xa3\x01\x10)\n\x0f\n\x07\x04\x06\
    \x04\x01\x02\x05\x01\x12\x04\xa3\x01\x10$\n\x0f\n\x07\x04\x06\x04\x01\
    \x02\x05\x02\x12\x04\xa3\x01'(\n\x0e\n\x06\x04\x06\x04\x01\x02\x06\x12\
    \x04\xa4\x01\x10'\n\x0f\n\x07\x04\x06\x04\x01\x02\x06\x01\x12\x04\xa4\
    \x01\x10\"\n\x0f\n\x07\x04\x06\x04\x01\x02\x06\x02\x12\x04\xa4\x01%&\n\
    \x0e\n\x06\x04\x06\x04\x01\x02\x07\x12\x04\xa5\x01\x10%\n\x0f\n\x07\x04\
    \x06\x04\x01\x02\x07\x01\x12\x04\xa5\x01\x10\x20\n\x0f\n\x07\x04\x06\x04\
    \x01\x02\x07\x02\x12\x04\xa5\x01#$\n\x0e\n\x06\x04\x06\x04\x01\x02\x08\
    \x12\x04\xa6\x01\x104\n\x0f\n\x07\x04\x06\x04\x01\x02\x08\x01\x12\x04\
    \xa6\x01\x10/\n\x0f\n\x07\x04\x06\x04\x01\x02\x08\x02\x12\x04\xa6\x0123\
    \n\x0e\n\x06\x04\x06\x04\x01\x02\t\x12\x04\xa7\x01\x10,\n\x0f\n\x07\x04\
    \x06\x04\x01\x02\t\x01\x12\x04\xa7\x01\x10'\n\x0f\n\x07\x04\x06\x04\x01\
    \x02\t\x02\x12\x04\xa7\x01*+\n\x0e\n\x06\x04\x06\x04\x01\x02\n\x12\x04\
    \xa8\x01\x102\n\x0f\n\x07\x04\x06\x04\x01\x02\n\x01\x12\x04\xa8\x01\x10,\
    \n\x0f\n\x07\x04\x06\x04\x01\x02\n\x02\x12\x04\xa8\x01/1\n\x0e\n\x06\x04\
    \x06\x04\x01\x02\x0b\x12\x04\xa9\x01\x10)\n\x0f\n\x07\x04\x06\x04\x01\
    \x02\x0b\x01\x12\x04\xa9\x01\x10#\n\x0f\n\x07\x04\x06\x04\x01\x02\x0b\
    \x02\x12\x04\xa9\x01&(\n\x0e\n\x06\x04\x06\x04\x01\x02\x0c\x12\x04\xaa\
    \x01\x10,\n\x0f\n\x07\x04\x06\x04\x01\x02\x0c\x01\x12\x04\xaa\x01\x10&\n\
    \x0f\n\x07\x04\x06\x04\x01\x02\x0c\x02\x12\x04\xaa\x01)+\n\x0e\n\x06\x04\
    \x06\x04\x01\x02\r\x12\x04\xab\x01\x10)\n\x0f\n\x07\x04\x06\x04\x01\x02\
    \r\x01\x12\x04\xab\x01\x10#\n\x0f\n\x07\x04\x06\x04\x01\x02\r\x02\x12\
    \x04\xab\x01&(\n\x0e\n\x06\x04\x06\x04\x01\x02\x0e\x12\x04\xac\x01\x10#\
    \n\x0f\n\x07\x04\x06\x04\x01\x02\x0e\x01\x12\x04\xac\x01\x10\x1d\n\x0f\n\
    \x07\x04\x06\x04\x01\x02\x0e\x02\x12\x04\xac\x01\x20\"\n\x0e\n\x06\x04\
    \x06\x04\x01\x02\x0f\x12\x04\xad\x01\x10%\n\x0f\n\x07\x04\x06\x04\x01\
    \x02\x0f\x01\x12\x04\xad\x01\x10\x1f\n\x0f\n\x07\x04\x06\x04\x01\x02\x0f\
    \x02\x12\x04\xad\x01\"$\n\x0e\n\x06\x04\x06\x04\x01\x02\x10\x12\x04\xae\
    \x01\x10)\n\x0f\n\x07\x04\x06\x04\x01\x02\x10\x01\x12\x04\xae\x01\x10#\n\
    \x0f\n\x07\x04\x06\x04\x01\x02\x10\x02\x12\x04\xae\x01&(\n\x0e\n\x06\x04\
    \x06\x04\x01\x02\x11\x12\x04\xaf\x01\x10+\n\x0f\n\x07\x04\x06\x04\x01\
    \x02\x11\x01\x12\x04\xaf\x01\x10%\n\x0f\n\x07\x04\x06\x04\x01\x02\x11\
    \x02\x12\x04\xaf\x01(*\n\x0e\n\x06\x04\x06\x04\x01\x02\x12\x12\x04\xb0\
    \x01\x10'\n\x0f\n\x07\x04\x06\x04\x01\x02\x12\x01\x12\x04\xb0\x01\x10!\n\
    \x0f\n\x07\x04\x06\x04\x01\x02\x12\x02\x12\x04\xb0\x01$&\n\x0e\n\x06\x04\
    \x06\x04\x01\x02\x13\x12\x04\xb1\x01\x10)\n\x0f\n\x07\x04\x06\x04\x01\
    \x02\x13\x01\x12\x04\xb1\x01\x10#\n\x0f\n\x07\x04\x06\x04\x01\x02\x13\
    \x02\x12\x04\xb1\x01&(\n\x0e\n\x06\x04\x06\x04\x01\x02\x14\x12\x04\xb2\
    \x01\x10(\n\x0f\n\x07\x04\x06\x04\x01\x02\x14\x01\x12\x04\xb2\x01\x10\"\
    \n\x0f\n\x07\x04\x06\x04\x01\x02\x14\x02\x12\x04\xb2\x01%'\n\x0e\n\x06\
    \x04\x06\x04\x01\x02\x15\x12\x04\xb3\x01\x10)\n\x0f\n\x07\x04\x06\x04\
    \x01\x02\x15\x01\x12\x04\xb3\x01\x10#\n\x0f\n\x07\x04\x06\x04\x01\x02\
    \x15\x02\x12\x04\xb3\x01&(\n\x0e\n\x06\x04\x06\x04\x01\x02\x16\x12\x04\
    \xb4\x01\x10%\n\x0f\n\x07\x04\x06\x04\x01\x02\x16\x01\x12\x04\xb4\x01\
    \x10\x1f\n\x0f\n\x07\x04\x06\x04\x01\x02\x16\x02\x12\x04\xb4\x01\"$\n\
    \x0e\n\x06\x04\x06\x04\x01\x02\x17\x12\x04\xb5\x01\x10/\n\x0f\n\x07\x04\
    \x06\x04\x01\x02\x17\x01\x12\x04\xb5\x01\x10)\n\x0f\n\x07\x04\x06\x04\
    \x01\x02\x17\x02\x12\x04\xb5\x01,.\n\x0e\n\x06\x04\x06\x04\x01\x02\x18\
    \x12\x04\xb6\x01\x10#\n\x0f\n\x07\x04\x06\x04\x01\x02\x18\x01\x12\x04\
    \xb6\x01\x10\x1d\n\x0f\n\x07\x04\x06\x04\x01\x02\x18\x02\x12\x04\xb6\x01\
    \x20\"\n\x0e\n\x06\x04\x06\x04\x01\x02\x19\x12\x04\xb7\x01\x10&\n\x0f\n\
    \x07\x04\x06\x04\x01\x02\x19\x01\x12\x04\xb7\x01\x10\x20\n\x0f\n\x07\x04\
    \x06\x04\x01\x02\x19\x02\x12\x04\xb7\x01#%\n\x0e\n\x06\x04\x06\x04\x01\
    \x02\x1a\x12\x04\xb8\x01\x10)\n\x0f\n\x07\x04\x06\x04\x01\x02\x1a\x01\
    \x12\x04\xb8\x01\x10#\n\x0f\n\x07\x04\x06\x04\x01\x02\x1a\x02\x12\x04\
    \xb8\x01&(\n\x0e\n\x06\x04\x06\x04\x01\x02\x1b\x12\x04\xb9\x01\x10&\n\
    \x0f\n\x07\x04\x06\x04\x01\x02\x1b\x01\x12\x04\xb9\x01\x10\x20\n\x0f\n\
    \x07\x04\x06\x04\x01\x02\x1b\x02\x12\x04\xb9\x01#%\n\x0e\n\x06\x04\x06\
    \x04\x01\x02\x1c\x12\x04\xba\x01\x10&\n\x0f\n\x07\x04\x06\x04\x01\x02\
    \x1c\x01\x12\x04\xba\x01\x10\x20\n\x0f\n\x07\x04\x06\x04\x01\x02\x1c\x02\
    \x12\x04\xba\x01#%\n\x0e\n\x06\x04\x06\x04\x01\x02\x1d\x12\x04\xbb\x01\
    \x10/\n\x0f\n\x07\x04\x06\x04\x01\x02\x1d\x01\x12\x04\xbb\x01\x10)\n\x0f\
    \n\x07\x04\x06\x04\x01\x02\x1d\x02\x12\x04\xbb\x01,.\n\x0e\n\x06\x04\x06\
    \x04\x01\x02\x1e\x12\x04\xbc\x01\x10,\n\x0f\n\x07\x04\x06\x04\x01\x02\
    \x1e\x01\x12\x04\xbc\x01\x10&\n\x0f\n\x07\x04\x06\x04\x01\x02\x1e\x02\
    \x12\x04\xbc\x01)+\n\x0e\n\x06\x04\x06\x04\x01\x02\x1f\x12\x04\xbd\x01\
    \x101\n\x0f\n\x07\x04\x06\x04\x01\x02\x1f\x01\x12\x04\xbd\x01\x10+\n\x0f\
    \n\x07\x04\x06\x04\x01\x02\x1f\x02\x12\x04\xbd\x01.0\n\x0e\n\x06\x04\x06\
    \x04\x01\x02\x20\x12\x04\xbe\x01\x10)\n\x0f\n\x07\x04\x06\x04\x01\x02\
    \x20\x01\x12\x04\xbe\x01\x10#\n\x0f\n\x07\x04\x06\x04\x01\x02\x20\x02\
    \x12\x04\xbe\x01&(\n\x0e\n\x06\x04\x06\x04\x01\x02!\x12\x04\xbf\x01\x101\
    \n\x0f\n\x07\x04\x06\x04\x01\x02!\x01\x12\x04\xbf\x01\x10+\n\x0f\n\x07\
    \x04\x06\x04\x01\x02!\x02\x12\x04\xbf\x01.0\n\x0e\n\x06\x04\x06\x04\x01\
    \x02\"\x12\x04\xc0\x01\x103\n\x0f\n\x07\x04\x06\x04\x01\x02\"\x01\x12\
    \x04\xc0\x01\x10-\n\x0f\n\x07\x04\x06\x04\x01\x02\"\x02\x12\x04\xc0\x010\
    2\n\x0e\n\x06\x04\x06\x04\x01\x02#\x12\x04\xc1\x01\x105\n\x0f\n\x07\x04\
    \x06\x04\x01\x02#\x01\x12\x04\xc1\x01\x10/\n\x0f\n\x07\x04\x06\x04\x01\
    \x02#\x02\x12\x04\xc1\x0124\n\x0e\n\x06\x04\x06\x04\x01\x02$\x12\x04\xc2\
    \x01\x10-\n\x0f\n\x07\x04\x06\x04\x01\x02$\x01\x12\x04\xc2\x01\x10'\n\
    \x0f\n\x07\x04\x06\x04\x01\x02$\x02\x12\x04\xc2\x01*,\n\x0e\n\x06\x04\
    \x06\x04\x01\x02%\x12\x04\xc3\x01\x105\n\x0f\n\x07\x04\x06\x04\x01\x02%\
    \x01\x12\x04\xc3\x01\x10/\n\x0f\n\x07\x04\x06\x04\x01\x02%\x02\x12\x04\
    \xc3\x0124\n\x0e\n\x06\x04\x06\x04\x01\x02&\x12\x04\xc4\x01\x104\n\x0f\n\
    \x07\x04\x06\x04\x01\x02&\x01\x12\x04\xc4\x01\x10.\n\x0f\n\x07\x04\x06\
    \x04\x01\x02&\x02\x12\x04\xc4\x0113\n\x0e\n\x06\x04\x06\x04\x01\x02'\x12\
    \x04\xc5\x01\x105\n\x0f\n\x07\x04\x06\x04\x01\x02'\x01\x12\x04\xc5\x01\
    \x10/\n\x0f\n\x07\x04\x06\x04\x01\x02'\x02\x12\x04\xc5\x0124\n\x0e\n\x06\
    \x04\x06\x04\x01\x02(\x12\x04\xc6\x01\x101\n\x0f\n\x07\x04\x06\x04\x01\
    \x02(\x01\x12\x04\xc6\x01\x10+\n\x0f\n\x07\x04\x06\x04\x01\x02(\x02\x12\
    \x04\xc6\x01.0\n\x0e\n\x06\x04\x06\x04\x01\x02)\x12\x04\xc7\x01\x106\n\
    \x0f\n\x07\x04\x06\x04\x01\x02)\x01\x12\x04\xc7\x01\x100\n\x0f\n\x07\x04\
    \x06\x04\x01\x02)\x02\x12\x04\xc7\x0135\n\x0e\n\x06\x04\x06\x04\x01\x02*\
    \x12\x04\xc8\x01\x107\n\x0f\n\x07\x04\x06\x04\x01\x02*\x01\x12\x04\xc8\
    \x01\x101\n\x0f\n\x07\x04\x06\x04\x01\x02*\x02\x12\x04\xc8\x0146\n\x0e\n\
    \x06\x04\x06\x04\x01\x02+\x12\x04\xc9\x01\x10*\n\x0f\n\x07\x04\x06\x04\
    \x01\x02+\x01\x12\x04\xc9\x01\x10$\n\x0f\n\x07\x04\x06\x04\x01\x02+\x02\
    \x12\x04\xc9\x01')\n\x0e\n\x06\x04\x06\x04\x01\x02,\x12\x04\xca\x01\x103\
    \n\x0f\n\x07\x04\x06\x04\x01\x02,\x01\x12\x04\xca\x01\x10-\n\x0f\n\x07\
    \x04\x06\x04\x01\x02,\x02\x12\x04\xca\x0102\n\x0e\n\x06\x04\x06\x04\x01\
    \x02-\x12\x04\xcb\x01\x10.\n\x0f\n\x07\x04\x06\x04\x01\x02-\x01\x12\x04\
    \xcb\x01\x10(\n\x0f\n\x07\x04\x06\x04\x01\x02-\x02\x12\x04\xcb\x01+-\n\
    \x0e\n\x06\x04\x06\x04\x01\x02.\x12\x04\xcc\x01\x104\n\x0f\n\x07\x04\x06\
    \x04\x01\x02.\x01\x12\x04\xcc\x01\x10.\n\x0f\n\x07\x04\x06\x04\x01\x02.\
    \x02\x12\x04\xcc\x0113\n\x0e\n\x06\x04\x06\x04\x01\x02/\x12\x04\xcd\x01\
    \x101\n\x0f\n\x07\x04\x06\x04\x01\x02/\x01\x12\x04\xcd\x01\x10+\n\x0f\n\
    \x07\x04\x06\x04\x01\x02/\x02\x12\x04\xcd\x01.0\n\x0e\n\x06\x04\x06\x04\
    \x01\x020\x12\x04\xce\x01\x103\n\x0f\n\x07\x04\x06\x04\x01\x020\x01\x12\
    \x04\xce\x01\x10-\n\x0f\n\x07\x04\x06\x04\x01\x020\x02\x12\x04\xce\x0102\
    \n\x0e\n\x06\x04\x06\x04\x01\x021\x12\x04\xcf\x01\x104\n\x0f\n\x07\x04\
    \x06\x04\x01\x021\x01\x12\x04\xcf\x01\x10.\n\x0f\n\x07\x04\x06\x04\x01\
    \x021\x02\x12\x04\xcf\x0113\n\x0e\n\x06\x04\x06\x04\x01\x022\x12\x04\xd0\
    \x01\x10$\n\x0f\n\x07\x04\x06\x04\x01\x022\x01\x12\x04\xd0\x01\x10\x1e\n\
    \x0f\n\x07\x04\x06\x04\x01\x022\x02\x12\x04\xd0\x01!#\n\x0e\n\x06\x04\
    \x06\x04\x01\x023\x12\x04\xd1\x01\x10>\n\x0f\n\x07\x04\x06\x04\x01\x023\
    \x01\x12\x04\xd1\x01\x108\n\x0f\n\x07\x04\x06\x04\x01\x023\x02\x12\x04\
    \xd1\x01;=\n\x0e\n\x06\x04\x06\x04\x01\x024\x12\x04\xd2\x01\x104\n\x0f\n\
    \x07\x04\x06\x04\x01\x024\x01\x12\x04\xd2\x01\x10.\n\x0f\n\x07\x04\x06\
    \x04\x01\x024\x02\x12\x04\xd2\x0113\n\x0e\n\x06\x04\x06\x04\x01\x025\x12\
    \x04\xd3\x01\x101\n\x0f\n\x07\x04\x06\x04\x01\x025\x01\x12\x04\xd3\x01\
    \x10+\n\x0f\n\x07\x04\x06\x04\x01\x025\x02\x12\x04\xd3\x01.0\n\x0e\n\x06\
    \x04\x06\x04\x01\x026\x12\x04\xd4\x01\x100\n\x0f\n\x07\x04\x06\x04\x01\
    \x026\x01\x12\x04\xd4\x01\x10*\n\x0f\n\x07\x04\x06\x04\x01\x026\x02\x12\
    \x04\xd4\x01-/\n\x0e\n\x06\x04\x06\x04\x01\x027\x12\x04\xd5\x01\x102\n\
    \x0f\n\x07\x04\x06\x04\x01\x027\x01\x12\x04\xd5\x01\x10,\n\x0f\n\x07\x04\
    \x06\x04\x01\x027\x02\x12\x04\xd5\x01/1\n\x0e\n\x06\x04\x06\x04\x01\x028\
    \x12\x04\xd6\x01\x105\n\x0f\n\x07\x04\x06\x04\x01\x028\x01\x12\x04\xd6\
    \x01\x10/\n\x0f\n\x07\x04\x06\x04\x01\x028\x02\x12\x04\xd6\x0124\n\x0e\n\
    \x06\x04\x06\x04\x01\x029\x12\x04\xd7\x01\x106\n\x0f\n\x07\x04\x06\x04\
    \x01\x029\x01\x12\x04\xd7\x01\x100\n\x0f\n\x07\x04\x06\x04\x01\x029\x02\
    \x12\x04\xd7\x0135\n\x0e\n\x06\x04\x06\x04\x01\x02:\x12\x04\xd8\x01\x108\
    \n\x0f\n\x07\x04\x06\x04\x01\x02:\x01\x12\x04\xd8\x01\x102\n\x0f\n\x07\
    \x04\x06\x04\x01\x02:\x02\x12\x04\xd8\x0157\n\x0e\n\x06\x04\x06\x04\x01\
    \x02;\x12\x04\xd9\x01\x107\n\x0f\n\x07\x04\x06\x04\x01\x02;\x01\x12\x04\
    \xd9\x01\x101\n\x0f\n\x07\x04\x06\x04\x01\x02;\x02\x12\x04\xd9\x0146\n\
    \x0e\n\x06\x04\x06\x04\x01\x02<\x12\x04\xda\x01\x106\n\x0f\n\x07\x04\x06\
    \x04\x01\x02<\x01\x12\x04\xda\x01\x100\n\x0f\n\x07\x04\x06\x04\x01\x02<\
    \x02\x12\x04\xda\x0135\n\x0e\n\x06\x04\x06\x04\x01\x02=\x12\x04\xdb\x01\
    \x109\n\x0f\n\x07\x04\x06\x04\x01\x02=\x01\x12\x04\xdb\x01\x103\n\x0f\n\
    \x07\x04\x06\x04\x01\x02=\x02\x12\x04\xdb\x0168\n\x0e\n\x06\x04\x06\x04\
    \x01\x02>\x12\x04\xdc\x01\x108\n\x0f\n\x07\x04\x06\x04\x01\x02>\x01\x12\
    \x04\xdc\x01\x102\n\x0f\n\x07\x04\x06\x04\x01\x02>\x02\x12\x04\xdc\x0157\
    \n\x0e\n\x06\x04\x06\x04\x01\x02?\x12\x04\xdd\x01\x107\n\x0f\n\x07\x04\
    \x06\x04\x01\x02?\x01\x12\x04\xdd\x01\x101\n\x0f\n\x07\x04\x06\x04\x01\
    \x02?\x02\x12\x04\xdd\x0146\n\x0e\n\x06\x04\x06\x04\x01\x02@\x12\x04\xde\
    \x01\x101\n\x0f\n\x07\x04\x06\x04\x01\x02@\x01\x12\x04\xde\x01\x10+\n\
    \x0f\n\x07\x04\x06\x04\x01\x02@\x02\x12\x04\xde\x01.0\n\x0e\n\x06\x04\
    \x06\x04\x01\x02A\x12\x04\xdf\x01\x10,\n\x0f\n\x07\x04\x06\x04\x01\x02A\
    \x01\x12\x04\xdf\x01\x10&\n\x0f\n\x07\x04\x06\x04\x01\x02A\x02\x12\x04\
    \xdf\x01)+\n\x0e\n\x06\x04\x06\x04\x01\x02B\x12\x04\xe0\x01\x108\n\x0f\n\
    \x07\x04\x06\x04\x01\x02B\x01\x12\x04\xe0\x01\x102\n\x0f\n\x07\x04\x06\
    \x04\x01\x02B\x02\x12\x04\xe0\x0157\n\x0e\n\x06\x04\x06\x04\x01\x02C\x12\
    \x04\xe1\x01\x10+\n\x0f\n\x07\x04\x06\x04\x01\x02C\x01\x12\x04\xe1\x01\
    \x10%\n\x0f\n\x07\x04\x06\x04\x01\x02C\x02\x12\x04\xe1\x01(*\n\x0e\n\x06\
    \x04\x06\x04\x01\x02D\x12\x04\xe2\x01\x10*\n\x0f\n\x07\x04\x06\x04\x01\
    \x02D\x01\x12\x04\xe2\x01\x10$\n\x0f\n\x07\x04\x06\x04\x01\x02D\x02\x12\
    \x04\xe2\x01')\n\x0e\n\x06\x04\x06\x04\x01\x02E\x12\x04\xe3\x01\x10)\n\
    \x0f\n\x07\x04\x06\x04\x01\x02E\x01\x12\x04\xe3\x01\x10#\n\x0f\n\x07\x04\
    \x06\x04\x01\x02E\x02\x12\x04\xe3\x01&(\n\x0e\n\x06\x04\x06\x04\x01\x02F\
    \x12\x04\xe4\x01\x10+\n\x0f\n\x07\x04\x06\x04\x01\x02F\x01\x12\x04\xe4\
    \x01\x10%\n\x0f\n\x07\x04\x06\x04\x01\x02F\x02\x12\x04\xe4\x01(*\n\x0e\n\
    \x06\x04\x06\x04\x01\x02G\x12\x04\xe5\x01\x104\n\x0f\n\x07\x04\x06\x04\
    \x01\x02G\x01\x12\x04\xe5\x01\x10.\n\x0f\n\x07\x04\x06\x04\x01\x02G\x02\
    \x12\x04\xe5\x0113\n\x0e\n\x06\x04\x06\x04\x01\x02H\x12\x04\xe6\x01\x103\
    \n\x0f\n\x07\x04\x06\x04\x01\x02H\x01\x12\x04\xe6\x01\x10-\n\x0f\n\x07\
    \x04\x06\x04\x01\x02H\x02\x12\x04\xe6\x0102\n\x0e\n\x06\x04\x06\x04\x01\
    \x02I\x12\x04\xe7\x01\x102\n\x0f\n\x07\x04\x06\x04\x01\x02I\x01\x12\x04\
    \xe7\x01\x10,\n\x0f\n\x07\x04\x06\x04\x01\x02I\x02\x12\x04\xe7\x01/1\n\
    \x0e\n\x06\x04\x06\x04\x01\x02J\x12\x04\xe8\x01\x10-\n\x0f\n\x07\x04\x06\
    \x04\x01\x02J\x01\x12\x04\xe8\x01\x10'\n\x0f\n\x07\x04\x06\x04\x01\x02J\
    \x02\x12\x04\xe8\x01*,\n\x0e\n\x06\x04\x06\x04\x01\x02K\x12\x04\xe9\x01\
    \x10,\n\x0f\n\x07\x04\x06\x04\x01\x02K\x01\x12\x04\xe9\x01\x10&\n\x0f\n\
    \x07\x04\x06\x04\x01\x02K\x02\x12\x04\xe9\x01)+\n\x0e\n\x06\x04\x06\x04\
    \x01\x02L\x12\x04\xea\x01\x10/\n\x0f\n\x07\x04\x06\x04\x01\x02L\x01\x12\
    \x04\xea\x01\x10)\n\x0f\n\x07\x04\x06\x04\x01\x02L\x02\x12\x04\xea\x01,.\
    \n\x0e\n\x06\x04\x06\x04\x01\x02M\x12\x04\xeb\x01\x102\n\x0f\n\x07\x04\
    \x06\x04\x01\x02M\x01\x12\x04\xeb\x01\x10,\n\x0f\n\x07\x04\x06\x04\x01\
    \x02M\x02\x12\x04\xeb\x01/1\n\x0e\n\x06\x04\x06\x04\x01\x02N\x12\x04\xec\
    \x01\x105\n\x0f\n\x07\x04\x06\x04\x01\x02N\x01\x12\x04\xec\x01\x10/\n\
    \x0f\n\x07\x04\x06\x04\x01\x02N\x02\x12\x04\xec\x0124\n\x0e\n\x06\x04\
    \x06\x04\x01\x02O\x12\x04\xed\x01\x10,\n\x0f\n\x07\x04\x06\x04\x01\x02O\
    \x01\x12\x04\xed\x01\x10&\n\x0f\n\x07\x04\x06\x04\x01\x02O\x02\x12\x04\
    \xed\x01)+\n\x0e\n\x06\x04\x06\x04\x01\x02P\x12\x04\xee\x01\x10.\n\x0f\n\
    \x07\x04\x06\x04\x01\x02P\x01\x12\x04\xee\x01\x10(\n\x0f\n\x07\x04\x06\
    \x04\x01\x02P\x02\x12\x04\xee\x01+-\n\x0e\n\x06\x04\x06\x04\x01\x02Q\x12\
    \x04\xef\x01\x10*\n\x0f\n\x07\x04\x06\x04\x01\x02Q\x01\x12\x04\xef\x01\
    \x10$\n\x0f\n\x07\x04\x06\x04\x01\x02Q\x02\x12\x04\xef\x01')\n\x0e\n\x06\
    \x04\x06\x04\x01\x02R\x12\x04\xf0\x01\x10,\n\x0f\n\x07\x04\x06\x04\x01\
    \x02R\x01\x12\x04\xf0\x01\x10&\n\x0f\n\x07\x04\x06\x04\x01\x02R\x02\x12\
    \x04\xf0\x01)+\n\x0e\n\x06\x04\x06\x04\x01\x02S\x12\x04\xf1\x01\x101\n\
    \x0f\n\x07\x04\x06\x04\x01\x02S\x01\x12\x04\xf1\x01\x10+\n\x0f\n\x07\x04\
    \x06\x04\x01\x02S\x02\x12\x04\xf1\x01.0\n\x0e\n\x06\x04\x06\x04\x01\x02T\
    \x12\x04\xf2\x01\x10*\n\x0f\n\x07\x04\x06\x04\x01\x02T\x01\x12\x04\xf2\
    \x01\x10$\n\x0f\n\x07\x04\x06\x04\x01\x02T\x02\x12\x04\xf2\x01')\n\x0e\n\
    \x06\x04\x06\x04\x01\x02U\x12\x04\xf3\x01\x10(\n\x0f\n\x07\x04\x06\x04\
    \x01\x02U\x01\x12\x04\xf3\x01\x10\"\n\x0f\n\x07\x04\x06\x04\x01\x02U\x02\
    \x12\x04\xf3\x01%'\n\x0e\n\x06\x04\x06\x04\x01\x02V\x12\x04\xf4\x01\x10,\
    \n\x0f\n\x07\x04\x06\x04\x01\x02V\x01\x12\x04\xf4\x01\x10&\n\x0f\n\x07\
    \x04\x06\x04\x01\x02V\x02\x12\x04\xf4\x01)+\n\x0e\n\x06\x04\x06\x04\x01\
    \x02W\x12\x04\xf5\x01\x10*\n\x0f\n\x07\x04\x06\x04\x01\x02W\x01\x12\x04\
    \xf5\x01\x10$\n\x0f\n\x07\x04\x06\x04\x01\x02W\x02\x12\x04\xf5\x01')\n\
    \x0e\n\x06\x04\x06\x04\x01\x02X\x12\x04\xf6\x01\x101\n\x0f\n\x07\x04\x06\
    \x04\x01\x02X\x01\x12\x04\xf6\x01\x10+\n\x0f\n\x07\x04\x06\x04\x01\x02X\
    \x02\x12\x04\xf6\x01.0\n\x0e\n\x06\x04\x06\x04\x01\x02Y\x12\x04\xf7\x01\
    \x10(\n\x0f\n\x07\x04\x06\x04\x01\x02Y\x01\x12\x04\xf7\x01\x10\"\n\x0f\n\
    \x07\x04\x06\x04\x01\x02Y\x02\x12\x04\xf7\x01%'\n\x0e\n\x06\x04\x06\x04\
    \x01\x02Z\x12\x04\xf8\x01\x10+\n\x0f\n\x07\x04\x06\x04\x01\x02Z\x01\x12\
    \x04\xf8\x01\x10%\n\x0f\n\x07\x04\x06\x04\x01\x02Z\x02\x12\x04\xf8\x01(*\
    \n\x0e\n\x06\x04\x06\x04\x01\x02[\x12\x04\xf9\x01\x10(\n\x0f\n\x07\x04\
    \x06\x04\x01\x02[\x01\x12\x04\xf9\x01\x10\"\n\x0f\n\x07\x04\x06\x04\x01\
    \x02[\x02\x12\x04\xf9\x01%'\n\x0e\n\x06\x04\x06\x04\x01\x02\\\x12\x04\
    \xfa\x01\x10(\n\x0f\n\x07\x04\x06\x04\x01\x02\\\x01\x12\x04\xfa\x01\x10\
    \"\n\x0f\n\x07\x04\x06\x04\x01\x02\\\x02\x12\x04\xfa\x01%'\n\x0e\n\x06\
    \x04\x06\x04\x01\x02]\x12\x04\xfb\x01\x10)\n\x0f\n\x07\x04\x06\x04\x01\
    \x02]\x01\x12\x04\xfb\x01\x10#\n\x0f\n\x07\x04\x06\x04\x01\x02]\x02\x12\
    \x04\xfb\x01&(\n\x0e\n\x06\x04\x06\x04\x01\x02^\x12\x04\xfc\x01\x10*\n\
    \x0f\n\x07\x04\x06\x04\x01\x02^\x01\x12\x04\xfc\x01\x10$\n\x0f\n\x07\x04\
    \x06\x04\x01\x02^\x02\x12\x04\xfc\x01')\n\x0e\n\x06\x04\x06\x04\x01\x02_\
    \x12\x04\xfd\x01\x10*\n\x0f\n\x07\x04\x06\x04\x01\x02_\x01\x12\x04\xfd\
    \x01\x10$\n\x0f\n\x07\x04\x06\x04\x01\x02_\x02\x12\x04\xfd\x01')\n\x0e\n\
    \x06\x04\x06\x04\x01\x02`\x12\x04\xfe\x01\x10,\n\x0f\n\x07\x04\x06\x04\
    \x01\x02`\x01\x12\x04\xfe\x01\x10&\n\x0f\n\x07\x04\x06\x04\x01\x02`\x02\
    \x12\x04\xfe\x01)+\n\x0e\n\x06\x04\x06\x04\x01\x02a\x12\x04\xff\x01\x10*\
    \n\x0f\n\x07\x04\x06\x04\x01\x02a\x01\x12\x04\xff\x01\x10$\n\x0f\n\x07\
    \x04\x06\x04\x01\x02a\x02\x12\x04\xff\x01')\n\x0e\n\x06\x04\x06\x04\x01\
    \x02b\x12\x04\x80\x02\x10+\n\x0f\n\x07\x04\x06\x04\x01\x02b\x01\x12\x04\
    \x80\x02\x10%\n\x0f\n\x07\x04\x06\x04\x01\x02b\x02\x12\x04\x80\x02(*\n\
    \x0e\n\x06\x04\x06\x04\x01\x02c\x12\x04\x81\x02\x104\n\x0f\n\x07\x04\x06\
    \x04\x01\x02c\x01\x12\x04\x81\x02\x10.\n\x0f\n\x07\x04\x06\x04\x01\x02c\
    \x02\x12\x04\x81\x0213\n\x0e\n\x06\x04\x06\x04\x01\x02d\x12\x04\x82\x02\
    \x104\n\x0f\n\x07\x04\x06\x04\x01\x02d\x01\x12\x04\x82\x02\x10-\n\x0f\n\
    \x07\x04\x06\x04\x01\x02d\x02\x12\x04\x82\x0203\n\x0e\n\x06\x04\x06\x04\
    \x01\x02e\x12\x04\x83\x02\x105\n\x0f\n\x07\x04\x06\x04\x01\x02e\x01\x12\
    \x04\x83\x02\x10.\n\x0f\n\x07\x04\x06\x04\x01\x02e\x02\x12\x04\x83\x0214\
    \n\x0e\n\x06\x04\x06\x04\x01\x02f\x12\x04\x84\x02\x10/\n\x0f\n\x07\x04\
    \x06\x04\x01\x02f\x01\x12\x04\x84\x02\x10(\n\x0f\n\x07\x04\x06\x04\x01\
    \x02f\x02\x12\x04\x84\x02+.\n\x0e\n\x06\x04\x06\x04\x01\x02g\x12\x04\x85\
    \x02\x10,\n\x0f\n\x07\x04\x06\x04\x01\x02g\x01\x12\x04\x85\x02\x10%\n\
    \x0f\n\x07\x04\x06\x04\x01\x02g\x02\x12\x04\x85\x02(+\n\x0e\n\x06\x04\
    \x06\x04\x01\x02h\x12\x04\x86\x02\x10-\n\x0f\n\x07\x04\x06\x04\x01\x02h\
    \x01\x12\x04\x86\x02\x10&\n\x0f\n\x07\x04\x06\x04\x01\x02h\x02\x12\x04\
    \x86\x02),\n\x0e\n\x06\x04\x06\x04\x01\x02i\x12\x04\x87\x02\x104\n\x0f\n\
    \x07\x04\x06\x04\x01\x02i\x01\x12\x04\x87\x02\x10-\n\x0f\n\x07\x04\x06\
    \x04\x01\x02i\x02\x12\x04\x87\x0203\n\x0e\n\x06\x04\x06\x04\x01\x02j\x12\
    \x04\x88\x02\x104\n\x0f\n\x07\x04\x06\x04\x01\x02j\x01\x12\x04\x88\x02\
    \x10-\n\x0f\n\x07\x04\x06\x04\x01\x02j\x02\x12\x04\x88\x0203\n\x0e\n\x06\
    \x04\x06\x04\x01\x02k\x12\x04\x89\x02\x102\n\x0f\n\x07\x04\x06\x04\x01\
    \x02k\x01\x12\x04\x89\x02\x10+\n\x0f\n\x07\x04\x06\x04\x01\x02k\x02\x12\
    \x04\x89\x02.1\n\x0e\n\x06\x04\x06\x04\x01\x02l\x12\x04\x8a\x02\x10(\n\
    \x0f\n\x07\x04\x06\x04\x01\x02l\x01\x12\x04\x8a\x02\x10!\n\x0f\n\x07\x04\
    \x06\x04\x01\x02l\x02\x12\x04\x8a\x02$'\n\x0e\n\x06\x04\x06\x04\x01\x02m\
    \x12\x04\x8b\x02\x10(\n\x0f\n\x07\x04\x06\x04\x01\x02m\x01\x12\x04\x8b\
    \x02\x10!\n\x0f\n\x07\x04\x06\x04\x01\x02m\x02\x12\x04\x8b\x02$'\n\x0e\n\
    \x06\x04\x06\x04\x01\x02n\x12\x04\x8c\x02\x10*\n\x0f\n\x07\x04\x06\x04\
    \x01\x02n\x01\x12\x04\x8c\x02\x10#\n\x0f\n\x07\x04\x06\x04\x01\x02n\x02\
    \x12\x04\x8c\x02&)\n\x0e\n\x06\x04\x06\x04\x01\x02o\x12\x04\x8d\x02\x10-\
    \n\x0f\n\x07\x04\x06\x04\x01\x02o\x01\x12\x04\x8d\x02\x10&\n\x0f\n\x07\
    \x04\x06\x04\x01\x02o\x02\x12\x04\x8d\x02),\n\x0e\n\x06\x04\x06\x04\x01\
    \x02p\x12\x04\x8e\x02\x10%\n\x0f\n\x07\x04\x06\x04\x01\x02p\x01\x12\x04\
    \x8e\x02\x10\x1e\n\x0f\n\x07\x04\x06\x04\x01\x02p\x02\x12\x04\x8e\x02!$\
    \n\x0e\n\x06\x04\x06\x04\x01\x02q\x12\x04\x8f\x02\x10*\n\x0f\n\x07\x04\
    \x06\x04\x01\x02q\x01\x12\x04\x8f\x02\x10#\n\x0f\n\x07\x04\x06\x04\x01\
    \x02q\x02\x12\x04\x8f\x02&)\n\x0e\n\x06\x04\x06\x04\x01\x02r\x12\x04\x90\
    \x02\x10)\n\x0f\n\x07\x04\x06\x04\x01\x02r\x01\x12\x04\x90\x02\x10\"\n\
    \x0f\n\x07\x04\x06\x04\x01\x02r\x02\x12\x04\x90\x02%(\n\x0e\n\x06\x04\
    \x06\x04\x01\x02s\x12\x04\x91\x02\x10/\n\x0f\n\x07\x04\x06\x04\x01\x02s\
    \x01\x12\x04\x91\x02\x10(\n\x0f\n\x07\x04\x06\x04\x01\x02s\x02\x12\x04\
    \x91\x02+.\n\x0e\n\x06\x04\x06\x04\x01\x02t\x12\x04\x92\x02\x101\n\x0f\n\
    \x07\x04\x06\x04\x01\x02t\x01\x12\x04\x92\x02\x10*\n\x0f\n\x07\x04\x06\
    \x04\x01\x02t\x02\x12\x04\x92\x02-0\n\x0e\n\x06\x04\x06\x04\x01\x02u\x12\
    \x04\x93\x02\x100\n\x0f\n\x07\x04\x06\x04\x01\x02u\x01\x12\x04\x93\x02\
    \x10)\n\x0f\n\x07\x04\x06\x04\x01\x02u\x02\x12\x04\x93\x02,/\n\x0e\n\x06\
    \x04\x06\x04\x01\x02v\x12\x04\x94\x02\x10-\n\x0f\n\x07\x04\x06\x04\x01\
    \x02v\x01\x12\x04\x94\x02\x10&\n\x0f\n\x07\x04\x06\x04\x01\x02v\x02\x12\
    \x04\x94\x02),\n\x0e\n\x06\x04\x06\x04\x01\x02w\x12\x04\x95\x02\x106\n\
    \x0f\n\x07\x04\x06\x04\x01\x02w\x01\x12\x04\x95\x02\x10/\n\x0f\n\x07\x04\
    \x06\x04\x01\x02w\x02\x12\x04\x95\x0225\n\x0e\n\x06\x04\x06\x04\x01\x02x\
    \x12\x04\x96\x02\x101\n\x0f\n\x07\x04\x06\x04\x01\x02x\x01\x12\x04\x96\
    \x02\x10*\n\x0f\n\x07\x04\x06\x04\x01\x02x\x02\x12\x04\x96\x02-0\n\x0e\n\
    \x06\x04\x06\x04\x01\x02y\x12\x04\x97\x02\x104\n\x0f\n\x07\x04\x06\x04\
    \x01\x02y\x01\x12\x04\x97\x02\x10-\n\x0f\n\x07\x04\x06\x04\x01\x02y\x02\
    \x12\x04\x97\x0203\n\x0e\n\x06\x04\x06\x04\x01\x02z\x12\x04\x98\x02\x10.\
    \n\x0f\n\x07\x04\x06\x04\x01\x02z\x01\x12\x04\x98\x02\x10'\n\x0f\n\x07\
    \x04\x06\x04\x01\x02z\x02\x12\x04\x98\x02*-\n\x0e\n\x06\x04\x06\x04\x01\
    \x02{\x12\x04\x99\x02\x10+\n\x0f\n\x07\x04\x06\x04\x01\x02{\x01\x12\x04\
    \x99\x02\x10$\n\x0f\n\x07\x04\x06\x04\x01\x02{\x02\x12\x04\x99\x02'*\n\
    \x0e\n\x06\x04\x06\x04\x01\x02|\x12\x04\x9a\x02\x10)\n\x0f\n\x07\x04\x06\
    \x04\x01\x02|\x01\x12\x04\x9a\x02\x10\"\n\x0f\n\x07\x04\x06\x04\x01\x02|\
    \x02\x12\x04\x9a\x02%(\n\x0e\n\x06\x04\x06\x04\x01\x02}\x12\x04\x9b\x02\
    \x103\n\x0f\n\x07\x04\x06\x04\x01\x02}\x01\x12\x04\x9b\x02\x10,\n\x0f\n\
    \x07\x04\x06\x04\x01\x02}\x02\x12\x04\x9b\x02/2\n\x0e\n\x06\x04\x06\x04\
    \x01\x02~\x12\x04\x9c\x02\x10.\n\x0f\n\x07\x04\x06\x04\x01\x02~\x01\x12\
    \x04\x9c\x02\x10'\n\x0f\n\x07\x04\x06\x04\x01\x02~\x02\x12\x04\x9c\x02*-\
    \n\x0e\n\x06\x04\x06\x04\x01\x02\x7f\x12\x04\x9d\x02\x10,\n\x0f\n\x07\
    \x04\x06\x04\x01\x02\x7f\x01\x12\x04\x9d\x02\x10%\n\x0f\n\x07\x04\x06\
    \x04\x01\x02\x7f\x02\x12\x04\x9d\x02(+\n\x0f\n\x07\x04\x06\x04\x01\x02\
    \x80\x01\x12\x04\x9e\x02\x10.\n\x10\n\x08\x04\x06\x04\x01\x02\x80\x01\
    \x01\x12\x04\x9e\x02\x10'\n\x10\n\x08\x04\x06\x04\x01\x02\x80\x01\x02\
    \x12\x04\x9e\x02*-\n\x0f\n\x07\x04\x06\x04\x01\x02\x81\x01\x12\x04\x9f\
    \x02\x10\"\n\x10\n\x08\x04\x06\x04\x01\x02\x81\x01\x01\x12\x04\x9f\x02\
    \x10\x1b\n\x10\n\x08\x04\x06\x04\x01\x02\x81\x01\x02\x12\x04\x9f\x02\x1e\
    !\n\x0e\n\x04\x04\x06\x04\x02\x12\x06\xa2\x02\x08\xa5\x02\t\n\r\n\x05\
    \x04\x06\x04\x02\x01\x12\x04\xa2\x02\r\x15\n\x0e\n\x06\x04\x06\x04\x02\
    \x02\0\x12\x04\xa3\x02\x10\x20\n\x0f\n\x07\x04\x06\x04\x02\x02\0\x01\x12\
    \x04\xa3\x02\x10\x1b\n\x0f\n\x07\x04\x06\x04\x02\x02\0\x02\x12\x04\xa3\
    \x02\x1e\x1f\n\x0e\n\x06\x04\x06\x04\x02\x02\x01\x12\x04\xa4\x02\x10!\n\
    \x0f\n\x07\x04\x06\x04\x02\x02\x01\x01\x12\x04\xa4\x02\x10\x1c\n\x0f\n\
    \x07\x04\x06\x04\x02\x02\x01\x02\x12\x04\xa4\x02\x1f\x20\n\x0c\n\x04\x04\
    \x06\x02\0\x12\x04\xa7\x02\x080\n\r\n\x05\x04\x06\x02\0\x04\x12\x04\xa7\
    \x02\x08\x10\n\r\n\x05\x04\x06\x02\0\x06\x12\x04\xa7\x02\x11$\n\r\n\x05\
    \x04\x06\x02\0\x01\x12\x04\xa7\x02%+\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\
    \xa7\x02./\n\x0c\n\x04\x04\x06\x02\x01\x12\x04\xa8\x02\x08?\n\r\n\x05\
    \x04\x06\x02\x01\x04\x12\x04\xa8\x02\x08\x10\n\r\n\x05\x04\x06\x02\x01\
    \x05\x12\x04\xa8\x02\x11\x17\n\r\n\x05\x04\x06\x02\x01\x01\x12\x04\xa8\
    \x02\x18%\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\xa8\x02()\n\r\n\x05\x04\
    \x06\x02\x01\x08\x12\x04\xa8\x02*>\n\x10\n\x08\x04\x06\x02\x01\x08\xf2\
    \xa2\x04\x12\x04\xa8\x02+=\n\x0c\n\x04\x04\x06\x02\x02\x12\x04\xa9\x02\
    \x08#\n\r\n\x05\x04\x06\x02\x02\x04\x12\x04\xa9\x02\x08\x10\n\r\n\x05\
    \x04\x06\x02\x02\x05\x12\x04\xa9\x02\x11\x17\n\r\n\x05\x04\x06\x02\x02\
    \x01\x12\x04\xa9\x02\x18\x1e\n\r\n\x05\x04\x06\x02\x02\x03\x12\x04\xa9\
    \x02!\"\n\x0c\n\x04\x04\x06\x02\x03\x12\x04\xaa\x02\x080\n\r\n\x05\x04\
    \x06\x02\x03\x04\x12\x04\xaa\x02\x08\x10\n\r\n\x05\x04\x06\x02\x03\x05\
    \x12\x04\xaa\x02\x11\x17\n\r\n\x05\x04\x06\x02\x03\x01\x12\x04\xaa\x02\
    \x18+\n\r\n\x05\x04\x06\x02\x03\x03\x12\x04\xaa\x02./\n\r\n\x04\x04\x06\
    \x02\x04\x12\x05\xab\x02\x08\x96\x01\n\r\n\x05\x04\x06\x02\x04\x04\x12\
    \x04\xab\x02\x08\x10\n\r\n\x05\x04\x06\x02\x04\x05\x12\x04\xab\x02\x11\
    \x17\n\r\n\x05\x04\x06\x02\x04\x01\x12\x04\xab\x02\x18\x1b\n\r\n\x05\x04\
    \x06\x02\x04\x03\x12\x04\xab\x02\x1e\x1f\n\x0e\n\x05\x04\x06\x02\x04\x08\
    \x12\x05\xab\x02\x20\x95\x01\n\x10\n\x08\x04\x06\x02\x04\x08\xf4\xa2\x04\
    \x12\x04\xab\x02!A\n\x11\n\x08\x04\x06\x02\x04\x08\xf5\xa2\x04\x12\x05\
    \xab\x02C\x94\x01\n\r\n\x04\x04\x06\x02\x05\x12\x05\xac\x02\x08\xc5\x01\
    \n\r\n\x05\x04\x06\x02\x05\x04\x12\x04\xac\x02\x08\x10\n\r\n\x05\x04\x06\
    \x02\x05\x06\x12\x04\xac\x02\x115\n\r\n\x05\x04\x06\x02\x05\x01\x12\x04\
    \xac\x026?\n\r\n\x05\x04\x06\x02\x05\x03\x12\x04\xac\x02BC\n\x0e\n\x05\
    \x04\x06\x02\x05\x08\x12\x05\xac\x02D\xc4\x01\n\x10\n\x08\x04\x06\x02\
    \x05\x08\xf4\xa2\x04\x12\x04\xac\x02Ej\n\x11\n\x08\x04\x06\x02\x05\x08\
    \xf5\xa2\x04\x12\x05\xac\x02l\xc3\x01\n\r\n\x04\x04\x06\x02\x06\x12\x05\
    \xad\x02\x08\xc4\x01\n\r\n\x05\x04\x06\x02\x06\x04\x12\x04\xad\x02\x08\
    \x10\n\r\n\x05\x04\x06\x02\x06\x06\x12\x04\xad\x02\x110\n\r\n\x05\x04\
    \x06\x02\x06\x01\x12\x04\xad\x0215\n\r\n\x05\x04\x06\x02\x06\x03\x12\x04\
    \xad\x028:\n\x0e\n\x05\x04\x06\x02\x06\x08\x12\x05\xad\x02;\xc3\x01\n\r\
    \n\x05\x04\x06\x02\x06\x07\x12\x04\xad\x02FQ\n\x10\n\x08\x04\x06\x02\x06\
    \x08\xf4\xa2\x04\x12\x04\xad\x02Ss\n\x11\n\x08\x04\x06\x02\x06\x08\xf5\
    \xa2\x04\x12\x05\xad\x02u\xc2\x01\n\x0c\n\x04\x04\x06\x02\x07\x12\x04\
    \xae\x02\x08{\n\r\n\x05\x04\x06\x02\x07\x04\x12\x04\xae\x02\x08\x10\n\r\
    \n\x05\x04\x06\x02\x07\x06\x12\x04\xae\x02\x11\x1e\n\r\n\x05\x04\x06\x02\
    \x07\x01\x12\x04\xae\x02\x1f-\n\r\n\x05\x04\x06\x02\x07\x03\x12\x04\xae\
    \x0202\n\r\n\x05\x04\x06\x02\x07\x08\x12\x04\xae\x023z\n\x10\n\x08\x04\
    \x06\x02\x07\x08\xf4\xa2\x04\x12\x04\xae\x024U\n\x10\n\x08\x04\x06\x02\
    \x07\x08\xfe\xa2\x04\x12\x04\xae\x02Wy\n\x0c\n\x04\x04\x06\x02\x08\x12\
    \x04\xaf\x02\x08y\n\r\n\x05\x04\x06\x02\x08\x04\x12\x04\xaf\x02\x08\x10\
    \n\r\n\x05\x04\x06\x02\x08\x06\x12\x04\xaf\x02\x11\x1e\n\r\n\x05\x04\x06\
    \x02\x08\x01\x12\x04\xaf\x02\x1f+\n\r\n\x05\x04\x06\x02\x08\x03\x12\x04\
    \xaf\x02.0\n\r\n\x05\x04\x06\x02\x08\x08\x12\x04\xaf\x021x\n\x10\n\x08\
    \x04\x06\x02\x08\x08\xf4\xa2\x04\x12\x04\xaf\x022S\n\x10\n\x08\x04\x06\
    \x02\x08\x08\xfe\xa2\x04\x12\x04\xaf\x02Uw\n\x0c\n\x04\x04\x06\x02\t\x12\
    \x04\xb0\x02\x08k\n\r\n\x05\x04\x06\x02\t\x04\x12\x04\xb0\x02\x08\x10\n\
    \r\n\x05\x04\x06\x02\t\x06\x12\x04\xb0\x02\x116\n\r\n\x05\x04\x06\x02\t\
    \x01\x12\x04\xb0\x027A\n\r\n\x05\x04\x06\x02\t\x03\x12\x04\xb0\x02DF\n\r\
    \n\x05\x04\x06\x02\t\x08\x12\x04\xb0\x02Gj\n\x10\n\x08\x04\x06\x02\t\x08\
    \xf4\xa2\x04\x12\x04\xb0\x02Hi\n\r\n\x04\x04\x06\x02\n\x12\x05\xb1\x02\
    \x08\xbe\x01\n\r\n\x05\x04\x06\x02\n\x04\x12\x04\xb1\x02\x08\x10\n\r\n\
    \x05\x04\x06\x02\n\x06\x12\x04\xb1\x02\x11\"\n\r\n\x05\x04\x06\x02\n\x01\
    \x12\x04\xb1\x02#2\n\r\n\x05\x04\x06\x02\n\x03\x12\x04\xb1\x0257\n\x0e\n\
    \x05\x04\x06\x02\n\x08\x12\x05\xb1\x028\xbd\x01\n\r\n\x05\x04\x06\x02\n\
    \x07\x12\x04\xb1\x02CF\n\x10\n\x08\x04\x06\x02\n\x08\xf4\xa2\x04\x12\x04\
    \xb1\x02Hj\n\x11\n\x08\x04\x06\x02\n\x08\xf5\xa2\x04\x12\x05\xb1\x02l\
    \xbc\x01\n\r\n\x04\x04\x06\x02\x0b\x12\x05\xb2\x02\x08\x92\x01\n\r\n\x05\
    \x04\x06\x02\x0b\x04\x12\x04\xb2\x02\x08\x10\n\r\n\x05\x04\x06\x02\x0b\
    \x05\x12\x04\xb2\x02\x11\x17\n\r\n\x05\x04\x06\x02\x0b\x01\x12\x04\xb2\
    \x02\x18!\n\r\n\x05\x04\x06\x02\x0b\x03\x12\x04\xb2\x02$&\n\x0e\n\x05\
    \x04\x06\x02\x0b\x08\x12\x05\xb2\x02'\x91\x01\n\x10\n\x08\x04\x06\x02\
    \x0b\x08\xf4\xa2\x04\x12\x04\xb2\x02(Q\n\x11\n\x08\x04\x06\x02\x0b\x08\
    \xf5\xa2\x04\x12\x05\xb2\x02S\x90\x01\n\r\n\x04\x04\x06\x02\x0c\x12\x05\
    \xb3\x02\x08\xaf\x01\n\r\n\x05\x04\x06\x02\x0c\x04\x12\x04\xb3\x02\x08\
    \x10\n\r\n\x05\x04\x06\x02\x0c\x06\x12\x04\xb3\x02\x11\"\n\r\n\x05\x04\
    \x06\x02\x0c\x01\x12\x04\xb3\x02#-\n\r\n\x05\x04\x06\x02\x0c\x03\x12\x04\
    \xb3\x0202\n\x0e\n\x05\x04\x06\x02\x0c\x08\x12\x05\xb3\x023\xae\x01\n\r\
    \n\x05\x04\x06\x02\x0c\x07\x12\x04\xb3\x02>A\n\x10\n\x08\x04\x06\x02\x0c\
    \x08\xf4\xa2\x04\x12\x04\xb3\x02C`\n\x11\n\x08\x04\x06\x02\x0c\x08\xf5\
    \xa2\x04\x12\x05\xb3\x02b\xad\x01\n\r\n\x04\x04\x06\x02\r\x12\x05\xb4\
    \x02\x08\x88\x01\n\r\n\x05\x04\x06\x02\r\x04\x12\x04\xb4\x02\x08\x10\n\r\
    \n\x05\x04\x06\x02\r\x05\x12\x04\xb4\x02\x11\x17\n\r\n\x05\x04\x06\x02\r\
    \x01\x12\x04\xb4\x02\x18\"\n\r\n\x05\x04\x06\x02\r\x03\x12\x04\xb4\x02%'\
    \n\x0e\n\x05\x04\x06\x02\r\x08\x12\x05\xb4\x02(\x87\x01\n\x10\n\x08\x04\
    \x06\x02\r\x08\xf4\xa2\x04\x12\x04\xb4\x02)F\n\x11\n\x08\x04\x06\x02\r\
    \x08\xf5\xa2\x04\x12\x05\xb4\x02H\x86\x01\n\x0c\n\x02\x04\x07\x12\x06\
    \xb7\x02\0\xd1\x02\x01\n\x0b\n\x03\x04\x07\x01\x12\x04\xb7\x02\x08\x14\n\
    \x0e\n\x04\x04\x07\x03\0\x12\x06\xb8\x02\x08\xbc\x02\t\n\r\n\x05\x04\x07\
    \x03\0\x01\x12\x04\xb8\x02\x10\x1a\n\x0e\n\x06\x04\x07\x03\0\x02\0\x12\
    \x04\xb9\x02\x10/\n\x0f\n\x07\x04\x07\x03\0\x02\0\x04\x12\x04\xb9\x02\
    \x10\x18\n\x0f\n\x07\x04\x07\x03\0\x02\0\x05\x12\x04\xb9\x02\x19\x1f\n\
    \x0f\n\x07\x04\x07\x03\0\x02\0\x01\x12\x04\xb9\x02\x20*\n\x0f\n\x07\x04\
    \x07\x03\0\x02\0\x03\x12\x04\xb9\x02-.\n\x0e\n\x06\x04\x07\x03\0\x02\x01\
    \x12\x04\xba\x02\x102\n\x0f\n\x07\x04\x07\x03\0\x02\x01\x04\x12\x04\xba\
    \x02\x10\x18\n\x0f\n\x07\x04\x07\x03\0\x02\x01\x05\x12\x04\xba\x02\x19\
    \x1f\n\x0f\n\x07\x04\x07\x03\0\x02\x01\x01\x12\x04\xba\x02\x20-\n\x0f\n\
    \x07\x04\x07\x03\0\x02\x01\x03\x12\x04\xba\x0201\n\x0e\n\x06\x04\x07\x03\
    \0\x02\x02\x12\x04\xbb\x02\x10-\n\x0f\n\x07\x04\x07\x03\0\x02\x02\x04\
    \x12\x04\xbb\x02\x10\x18\n\x0f\n\x07\x04\x07\x03\0\x02\x02\x05\x12\x04\
    \xbb\x02\x19\x1f\n\x0f\n\x07\x04\x07\x03\0\x02\x02\x01\x12\x04\xbb\x02\
    \x20(\n\x0f\n\x07\x04\x07\x03\0\x02\x02\x03\x12\x04\xbb\x02+,\n\x0e\n\
    \x04\x04\x07\x03\x01\x12\x06\xbe\x02\x08\xc2\x02\t\n\r\n\x05\x04\x07\x03\
    \x01\x01\x12\x04\xbe\x02\x10!\n\x0e\n\x06\x04\x07\x03\x01\x02\0\x12\x04\
    \xbf\x02\x10a\n\x0f\n\x07\x04\x07\x03\x01\x02\0\x04\x12\x04\xbf\x02\x10\
    \x18\n\x0f\n\x07\x04\x07\x03\x01\x02\0\x06\x12\x04\xbf\x02\x19(\n\x0f\n\
    \x07\x04\x07\x03\x01\x02\0\x01\x12\x04\xbf\x02)2\n\x0f\n\x07\x04\x07\x03\
    \x01\x02\0\x03\x12\x04\xbf\x0256\n\x0f\n\x07\x04\x07\x03\x01\x02\0\x08\
    \x12\x04\xbf\x027`\n\x12\n\n\x04\x07\x03\x01\x02\0\x08\xf0\xa2\x04\x12\
    \x04\xbf\x028_\n\x0e\n\x06\x04\x07\x03\x01\x02\x01\x12\x04\xc0\x02\x10V\
    \n\x0f\n\x07\x04\x07\x03\x01\x02\x01\x04\x12\x04\xc0\x02\x10\x18\n\x0f\n\
    \x07\x04\x07\x03\x01\x02\x01\x06\x12\x04\xc0\x02\x19&\n\x0f\n\x07\x04\
    \x07\x03\x01\x02\x01\x01\x12\x04\xc0\x02'1\n\x0f\n\x07\x04\x07\x03\x01\
    \x02\x01\x03\x12\x04\xc0\x0245\n\x0f\n\x07\x04\x07\x03\x01\x02\x01\x08\
    \x12\x04\xc0\x026U\n\x0f\n\x07\x04\x07\x03\x01\x02\x01\x07\x12\x04\xc0\
    \x02AT\n\x0f\n\x06\x04\x07\x03\x01\x02\x02\x12\x05\xc1\x02\x10\xc7\x01\n\
    \x0f\n\x07\x04\x07\x03\x01\x02\x02\x04\x12\x04\xc1\x02\x10\x18\n\x0f\n\
    \x07\x04\x07\x03\x01\x02\x02\x05\x12\x04\xc1\x02\x19\x1f\n\x0f\n\x07\x04\
    \x07\x03\x01\x02\x02\x01\x12\x04\xc1\x02\x20+\n\x0f\n\x07\x04\x07\x03\
    \x01\x02\x02\x03\x12\x04\xc1\x02./\n\x10\n\x07\x04\x07\x03\x01\x02\x02\
    \x08\x12\x05\xc1\x020\xc6\x01\n\x12\n\n\x04\x07\x03\x01\x02\x02\x08\xf4\
    \xa2\x04\x12\x04\xc1\x021S\n\x13\n\n\x04\x07\x03\x01\x02\x02\x08\xf5\xa2\
    \x04\x12\x05\xc1\x02U\xc5\x01\n\x0c\n\x04\x04\x07\x02\0\x12\x04\xc4\x02\
    \x080\n\r\n\x05\x04\x07\x02\0\x04\x12\x04\xc4\x02\x08\x10\n\r\n\x05\x04\
    \x07\x02\0\x06\x12\x04\xc4\x02\x11$\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\
    \xc4\x02%+\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\xc4\x02./\n\x0c\n\x04\x04\
    \x07\x02\x01\x12\x04\xc5\x02\x08)\n\r\n\x05\x04\x07\x02\x01\x04\x12\x04\
    \xc5\x02\x08\x10\n\r\n\x05\x04\x07\x02\x01\x05\x12\x04\xc5\x02\x11\x17\n\
    \r\n\x05\x04\x07\x02\x01\x01\x12\x04\xc5\x02\x18$\n\r\n\x05\x04\x07\x02\
    \x01\x03\x12\x04\xc5\x02'(\n\x0c\n\x04\x04\x07\x02\x02\x12\x04\xc6\x02\
    \x08)\n\r\n\x05\x04\x07\x02\x02\x04\x12\x04\xc6\x02\x08\x10\n\r\n\x05\
    \x04\x07\x02\x02\x05\x12\x04\xc6\x02\x11\x17\n\r\n\x05\x04\x07\x02\x02\
    \x01\x12\x04\xc6\x02\x18$\n\r\n\x05\x04\x07\x02\x02\x03\x12\x04\xc6\x02'\
    (\n\x0c\n\x04\x04\x07\x02\x03\x12\x04\xc7\x02\x08)\n\r\n\x05\x04\x07\x02\
    \x03\x04\x12\x04\xc7\x02\x08\x10\n\r\n\x05\x04\x07\x02\x03\x05\x12\x04\
    \xc7\x02\x11\x17\n\r\n\x05\x04\x07\x02\x03\x01\x12\x04\xc7\x02\x18$\n\r\
    \n\x05\x04\x07\x02\x03\x03\x12\x04\xc7\x02'(\n\x0c\n\x04\x04\x07\x02\x04\
    \x12\x04\xc8\x02\x08?\n\r\n\x05\x04\x07\x02\x04\x04\x12\x04\xc8\x02\x08\
    \x10\n\r\n\x05\x04\x07\x02\x04\x05\x12\x04\xc8\x02\x11\x17\n\r\n\x05\x04\
    \x07\x02\x04\x01\x12\x04\xc8\x02\x18%\n\r\n\x05\x04\x07\x02\x04\x03\x12\
    \x04\xc8\x02()\n\r\n\x05\x04\x07\x02\x04\x08\x12\x04\xc8\x02*>\n\x10\n\
    \x08\x04\x07\x02\x04\x08\xf2\xa2\x04\x12\x04\xc8\x02+=\n\x0c\n\x04\x04\
    \x07\x02\x05\x12\x04\xc9\x02\x08&\n\r\n\x05\x04\x07\x02\x05\x04\x12\x04\
    \xc9\x02\x08\x10\n\r\n\x05\x04\x07\x02\x05\x05\x12\x04\xc9\x02\x11\x17\n\
    \r\n\x05\x04\x07\x02\x05\x01\x12\x04\xc9\x02\x18!\n\r\n\x05\x04\x07\x02\
    \x05\x03\x12\x04\xc9\x02$%\n\x0c\n\x04\x04\x07\x02\x06\x12\x04\xca\x02\
    \x08:\n\r\n\x05\x04\x07\x02\x06\x04\x12\x04\xca\x02\x08\x10\n\r\n\x05\
    \x04\x07\x02\x06\x06\x12\x04\xca\x02\x11)\n\r\n\x05\x04\x07\x02\x06\x01\
    \x12\x04\xca\x02*5\n\r\n\x05\x04\x07\x02\x06\x03\x12\x04\xca\x0289\n\r\n\
    \x04\x04\x07\x02\x07\x12\x05\xcb\x02\x08\x86\x01\n\r\n\x05\x04\x07\x02\
    \x07\x04\x12\x04\xcb\x02\x08\x10\n\r\n\x05\x04\x07\x02\x07\x05\x12\x04\
    \xcb\x02\x11\x17\n\r\n\x05\x04\x07\x02\x07\x01\x12\x04\xcb\x02\x18\"\n\r\
    \n\x05\x04\x07\x02\x07\x03\x12\x04\xcb\x02%'\n\x0e\n\x05\x04\x07\x02\x07\
    \x08\x12\x05\xcb\x02(\x85\x01\n\x10\n\x08\x04\x07\x02\x07\x08\xf4\xa2\
    \x04\x12\x04\xcb\x02)F\n\x11\n\x08\x04\x07\x02\x07\x08\xf5\xa2\x04\x12\
    \x05\xcb\x02H\x84\x01\n\x0c\n\x04\x04\x07\x02\x08\x12\x04\xcc\x02\x08t\n\
    \r\n\x05\x04\x07\x02\x08\x04\x12\x04\xcc\x02\x08\x10\n\r\n\x05\x04\x07\
    \x02\x08\x05\x12\x04\xcc\x02\x11\x17\n\r\n\x05\x04\x07\x02\x08\x01\x12\
    \x04\xcc\x02\x18\"\n\r\n\x05\x04\x07\x02\x08\x03\x12\x04\xcc\x02%'\n\r\n\
    \x05\x04\x07\x02\x08\x08\x12\x04\xcc\x02(s\n\x10\n\x08\x04\x07\x02\x08\
    \x08\xf4\xa2\x04\x12\x04\xcc\x02)E\n\x10\n\x08\x04\x07\x02\x08\x08\xf5\
    \xa2\x04\x12\x04\xcc\x02Gr\n\x0c\n\x04\x04\x07\x02\t\x12\x04\xcd\x02\x08\
    R\n\r\n\x05\x04\x07\x02\t\x04\x12\x04\xcd\x02\x08\x10\n\r\n\x05\x04\x07\
    \x02\t\x06\x12\x04\xcd\x02\x11\x20\n\r\n\x05\x04\x07\x02\t\x01\x12\x04\
    \xcd\x02!&\n\r\n\x05\x04\x07\x02\t\x03\x12\x04\xcd\x02)+\n\r\n\x05\x04\
    \x07\x02\t\x08\x12\x04\xcd\x02,Q\n\x10\n\x08\x04\x07\x02\t\x08\xf0\xa2\
    \x04\x12\x04\xcd\x02-P\n\x0c\n\x04\x04\x07\x02\n\x12\x04\xce\x02\x08x\n\
    \r\n\x05\x04\x07\x02\n\x04\x12\x04\xce\x02\x08\x10\n\r\n\x05\x04\x07\x02\
    \n\x05\x12\x04\xce\x02\x11\x17\n\r\n\x05\x04\x07\x02\n\x01\x12\x04\xce\
    \x02\x18$\n\r\n\x05\x04\x07\x02\n\x03\x12\x04\xce\x02')\n\r\n\x05\x04\
    \x07\x02\n\x08\x12\x04\xce\x02*w\n\x10\n\x08\x04\x07\x02\n\x08\xf4\xa2\
    \x04\x12\x04\xce\x02+E\n\x10\n\x08\x04\x07\x02\n\x08\xf5\xa2\x04\x12\x04\
    \xce\x02Gv\n\x0c\n\x04\x04\x07\x02\x0b\x12\x04\xcf\x02\x08A\n\r\n\x05\
    \x04\x07\x02\x0b\x04\x12\x04\xcf\x02\x08\x10\n\r\n\x05\x04\x07\x02\x0b\
    \x06\x12\x04\xcf\x02\x110\n\r\n\x05\x04\x07\x02\x0b\x01\x12\x04\xcf\x021\
    ;\n\r\n\x05\x04\x07\x02\x0b\x03\x12\x04\xcf\x02>@\n\r\n\x04\x04\x07\x02\
    \x0c\x12\x05\xd0\x02\x08\x97\x01\n\r\n\x05\x04\x07\x02\x0c\x04\x12\x04\
    \xd0\x02\x08\x10\n\r\n\x05\x04\x07\x02\x0c\x05\x12\x04\xd0\x02\x11\x17\n\
    \r\n\x05\x04\x07\x02\x0c\x01\x12\x04\xd0\x02\x18\x1b\n\r\n\x05\x04\x07\
    \x02\x0c\x03\x12\x04\xd0\x02\x1e\x20\n\x0e\n\x05\x04\x07\x02\x0c\x08\x12\
    \x05\xd0\x02!\x96\x01\n\x10\n\x08\x04\x07\x02\x0c\x08\xf4\xa2\x04\x12\
    \x04\xd0\x02\"B\n\x11\n\x08\x04\x07\x02\x0c\x08\xf5\xa2\x04\x12\x05\xd0\
    \x02D\x95\x01\n\x0c\n\x02\x04\x08\x12\x06\xd3\x02\0\xda\x02\x01\n\x0b\n\
    \x03\x04\x08\x01\x12\x04\xd3\x02\x08\x1d\n\x0c\n\x04\x04\x08\x02\0\x12\
    \x04\xd4\x02\x080\n\r\n\x05\x04\x08\x02\0\x04\x12\x04\xd4\x02\x08\x10\n\
    \r\n\x05\x04\x08\x02\0\x06\x12\x04\xd4\x02\x11$\n\r\n\x05\x04\x08\x02\0\
    \x01\x12\x04\xd4\x02%+\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\xd4\x02./\n\
    \x0c\n\x04\x04\x08\x02\x01\x12\x04\xd5\x02\x08&\n\r\n\x05\x04\x08\x02\
    \x01\x04\x12\x04\xd5\x02\x08\x10\n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\
    \xd5\x02\x11\x17\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\xd5\x02\x18!\n\r\
    \n\x05\x04\x08\x02\x01\x03\x12\x04\xd5\x02$%\n\r\n\x04\x04\x08\x02\x02\
    \x12\x05\xd6\x02\x08\x92\x01\n\r\n\x05\x04\x08\x02\x02\x04\x12\x04\xd6\
    \x02\x08\x10\n\r\n\x05\x04\x08\x02\x02\x05\x12\x04\xd6\x02\x11\x17\n\r\n\
    \x05\x04\x08\x02\x02\x01\x12\x04\xd6\x02\x18,\n\r\n\x05\x04\x08\x02\x02\
    \x03\x12\x04\xd6\x02/0\n\x0e\n\x05\x04\x08\x02\x02\x08\x12\x05\xd6\x021\
    \x91\x01\n\x10\n\x08\x04\x08\x02\x02\x08\xf4\xa2\x04\x12\x04\xd6\x022T\n\
    \x11\n\x08\x04\x08\x02\x02\x08\xf5\xa2\x04\x12\x05\xd6\x02V\x90\x01\n\
    \x0c\n\x04\x04\x08\x02\x03\x12\x04\xd7\x02\x08N\n\r\n\x05\x04\x08\x02\
    \x03\x04\x12\x04\xd7\x02\x08\x10\n\r\n\x05\x04\x08\x02\x03\x06\x12\x04\
    \xd7\x02\x11\x1e\n\r\n\x05\x04\x08\x02\x03\x01\x12\x04\xd7\x02\x1f$\n\r\
    \n\x05\x04\x08\x02\x03\x03\x12\x04\xd7\x02'(\n\r\n\x05\x04\x08\x02\x03\
    \x08\x12\x04\xd7\x02)M\n\x10\n\x08\x04\x08\x02\x03\x08\xfe\xa2\x04\x12\
    \x04\xd7\x02*L\n\r\n\x04\x04\x08\x02\x04\x12\x05\xd8\x02\x08\x8a\x01\n\r\
    \n\x05\x04\x08\x02\x04\x04\x12\x04\xd8\x02\x08\x10\n\r\n\x05\x04\x08\x02\
    \x04\x05\x12\x04\xd8\x02\x11\x17\n\r\n\x05\x04\x08\x02\x04\x01\x12\x04\
    \xd8\x02\x18&\n\r\n\x05\x04\x08\x02\x04\x03\x12\x04\xd8\x02)*\n\x0e\n\
    \x05\x04\x08\x02\x04\x08\x12\x05\xd8\x02+\x89\x01\n\x10\n\x08\x04\x08\
    \x02\x04\x08\xf4\xa2\x04\x12\x04\xd8\x02,M\n\x11\n\x08\x04\x08\x02\x04\
    \x08\xf5\xa2\x04\x12\x05\xd8\x02O\x88\x01\n\x0c\n\x04\x04\x08\x02\x05\
    \x12\x04\xd9\x02\x08~\n\r\n\x05\x04\x08\x02\x05\x04\x12\x04\xd9\x02\x08\
    \x10\n\r\n\x05\x04\x08\x02\x05\x05\x12\x04\xd9\x02\x11\x17\n\r\n\x05\x04\
    \x08\x02\x05\x01\x12\x04\xd9\x02\x18\"\n\r\n\x05\x04\x08\x02\x05\x03\x12\
    \x04\xd9\x02%&\n\r\n\x05\x04\x08\x02\x05\x08\x12\x04\xd9\x02'}\n\x10\n\
    \x08\x04\x08\x02\x05\x08\xf4\xa2\x04\x12\x04\xd9\x02(E\n\x10\n\x08\x04\
    \x08\x02\x05\x08\xf5\xa2\x04\x12\x04\xd9\x02G|\n\x0c\n\x02\x04\t\x12\x06\
    \xdc\x02\0\xeb\x02\x01\n\x0b\n\x03\x04\t\x01\x12\x04\xdc\x02\x08\x1d\n\
    \x0e\n\x04\x04\t\x03\0\x12\x06\xdd\x02\x08\xe1\x02\t\n\r\n\x05\x04\t\x03\
    \0\x01\x12\x04\xdd\x02\x10\x1a\n\x0e\n\x06\x04\t\x03\0\x02\0\x12\x04\xde\
    \x02\x10l\n\x0f\n\x07\x04\t\x03\0\x02\0\x04\x12\x04\xde\x02\x10\x18\n\
    \x0f\n\x07\x04\t\x03\0\x02\0\x06\x12\x04\xde\x02\x19(\n\x0f\n\x07\x04\t\
    \x03\0\x02\0\x01\x12\x04\xde\x02)<\n\x0f\n\x07\x04\t\x03\0\x02\0\x03\x12\
    \x04\xde\x02?@\n\x0f\n\x07\x04\t\x03\0\x02\0\x08\x12\x04\xde\x02Ak\n\x12\
    \n\n\x04\t\x03\0\x02\0\x08\xf0\xa2\x04\x12\x04\xde\x02Bj\n\x0e\n\x06\x04\
    \t\x03\0\x02\x01\x12\x04\xdf\x02\x10)\n\x0f\n\x07\x04\t\x03\0\x02\x01\
    \x04\x12\x04\xdf\x02\x10\x18\n\x0f\n\x07\x04\t\x03\0\x02\x01\x05\x12\x04\
    \xdf\x02\x19\x1f\n\x0f\n\x07\x04\t\x03\0\x02\x01\x01\x12\x04\xdf\x02\x20\
    $\n\x0f\n\x07\x04\t\x03\0\x02\x01\x03\x12\x04\xdf\x02'(\n\x0e\n\x06\x04\
    \t\x03\0\x02\x02\x12\x04\xe0\x02\x10)\n\x0f\n\x07\x04\t\x03\0\x02\x02\
    \x04\x12\x04\xe0\x02\x10\x18\n\x0f\n\x07\x04\t\x03\0\x02\x02\x05\x12\x04\
    \xe0\x02\x19\x1f\n\x0f\n\x07\x04\t\x03\0\x02\x02\x01\x12\x04\xe0\x02\x20\
    $\n\x0f\n\x07\x04\t\x03\0\x02\x02\x03\x12\x04\xe0\x02'(\n\x0c\n\x04\x04\
    \t\x02\0\x12\x04\xe3\x02\x080\n\r\n\x05\x04\t\x02\0\x04\x12\x04\xe3\x02\
    \x08\x10\n\r\n\x05\x04\t\x02\0\x06\x12\x04\xe3\x02\x11$\n\r\n\x05\x04\t\
    \x02\0\x01\x12\x04\xe3\x02%+\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xe3\x02./\
    \n\x0c\n\x04\x04\t\x02\x01\x12\x04\xe4\x02\x086\n\r\n\x05\x04\t\x02\x01\
    \x04\x12\x04\xe4\x02\x08\x10\n\r\n\x05\x04\t\x02\x01\x05\x12\x04\xe4\x02\
    \x11\x17\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xe4\x02\x18\x1c\n\r\n\x05\
    \x04\t\x02\x01\x03\x12\x04\xe4\x02\x1f\x20\n\r\n\x05\x04\t\x02\x01\x08\
    \x12\x04\xe4\x02!5\n\x10\n\x08\x04\t\x02\x01\x08\xf2\xa2\x04\x12\x04\xe4\
    \x02\"4\n\x0c\n\x04\x04\t\x02\x02\x12\x04\xe5\x02\x08$\n\r\n\x05\x04\t\
    \x02\x02\x04\x12\x04\xe5\x02\x08\x10\n\r\n\x05\x04\t\x02\x02\x05\x12\x04\
    \xe5\x02\x11\x17\n\r\n\x05\x04\t\x02\x02\x01\x12\x04\xe5\x02\x18\x1f\n\r\
    \n\x05\x04\t\x02\x02\x03\x12\x04\xe5\x02\"#\n\x0c\n\x04\x04\t\x02\x03\
    \x12\x04\xe6\x02\x08=\n\r\n\x05\x04\t\x02\x03\x04\x12\x04\xe6\x02\x08\
    \x10\n\r\n\x05\x04\t\x02\x03\x06\x12\x04\xe6\x02\x112\n\r\n\x05\x04\t\
    \x02\x03\x01\x12\x04\xe6\x0238\n\r\n\x05\x04\t\x02\x03\x03\x12\x04\xe6\
    \x02;<\n\r\n\x04\x04\t\x02\x04\x12\x05\xe7\x02\x08\xc2\x01\n\r\n\x05\x04\
    \t\x02\x04\x04\x12\x04\xe7\x02\x08\x10\n\r\n\x05\x04\t\x02\x04\x06\x12\
    \x04\xe7\x02\x11\x20\n\r\n\x05\x04\t\x02\x04\x01\x12\x04\xe7\x02!,\n\r\n\
    \x05\x04\t\x02\x04\x03\x12\x04\xe7\x02/0\n\x0e\n\x05\x04\t\x02\x04\x08\
    \x12\x05\xe7\x021\xc1\x01\n\x10\n\x08\x04\t\x02\x04\x08\xf0\xa2\x04\x12\
    \x04\xe7\x022Z\n\x10\n\x08\x04\t\x02\x04\x08\xf4\xa2\x04\x12\x04\xe7\x02\
    \\z\n\x11\n\x08\x04\t\x02\x04\x08\xf5\xa2\x04\x12\x05\xe7\x02|\xc0\x01\n\
    \r\n\x04\x04\t\x02\x05\x12\x05\xe8\x02\x08\x9f\x01\n\r\n\x05\x04\t\x02\
    \x05\x04\x12\x04\xe8\x02\x08\x10\n\r\n\x05\x04\t\x02\x05\x05\x12\x04\xe8\
    \x02\x11\x16\n\r\n\x05\x04\t\x02\x05\x01\x12\x04\xe8\x02\x17!\n\r\n\x05\
    \x04\t\x02\x05\x03\x12\x04\xe8\x02$%\n\x0e\n\x05\x04\t\x02\x05\x08\x12\
    \x05\xe8\x02&\x9e\x01\n\x10\n\x08\x04\t\x02\x05\x08\xf4\xa2\x04\x12\x04\
    \xe8\x02'E\n\x11\n\x08\x04\t\x02\x05\x08\xf5\xa2\x04\x12\x05\xe8\x02G\
    \x9d\x01\n\r\n\x04\x04\t\x02\x06\x12\x05\xe9\x02\x08\xbd\x01\n\r\n\x05\
    \x04\t\x02\x06\x04\x12\x04\xe9\x02\x08\x10\n\r\n\x05\x04\t\x02\x06\x05\
    \x12\x04\xe9\x02\x11\x16\n\r\n\x05\x04\t\x02\x06\x01\x12\x04\xe9\x02\x17\
    !\n\r\n\x05\x04\t\x02\x06\x03\x12\x04\xe9\x02$%\n\x0e\n\x05\x04\t\x02\
    \x06\x08\x12\x05\xe9\x02&\xbc\x01\n\x10\n\x08\x04\t\x02\x06\x08\xf4\xa2\
    \x04\x12\x04\xe9\x02'D\n\x11\n\x08\x04\t\x02\x06\x08\xf5\xa2\x04\x12\x05\
    \xe9\x02F\xbb\x01\n\r\n\x04\x04\t\x02\x07\x12\x05\xea\x02\x08\xbd\x01\n\
    \r\n\x05\x04\t\x02\x07\x04\x12\x04\xea\x02\x08\x10\n\r\n\x05\x04\t\x02\
    \x07\x06\x12\x04\xea\x02\x11\x20\n\r\n\x05\x04\t\x02\x07\x01\x12\x04\xea\
    \x02!*\n\r\n\x05\x04\t\x02\x07\x03\x12\x04\xea\x02-.\n\x0e\n\x05\x04\t\
    \x02\x07\x08\x12\x05\xea\x02/\xbc\x01\n\x10\n\x08\x04\t\x02\x07\x08\xf0\
    \xa2\x04\x12\x04\xea\x020[\n\x10\n\x08\x04\t\x02\x07\x08\xf4\xa2\x04\x12\
    \x04\xea\x02]y\n\x11\n\x08\x04\t\x02\x07\x08\xf5\xa2\x04\x12\x05\xea\x02\
    {\xbb\x01\n\x0c\n\x02\x04\n\x12\x06\xed\x02\0\xfa\x02\x01\n\x0b\n\x03\
    \x04\n\x01\x12\x04\xed\x02\x08\x14\n\x0c\n\x04\x04\n\x02\0\x12\x04\xee\
    \x02\x08B\n\r\n\x05\x04\n\x02\0\x04\x12\x04\xee\x02\x08\x10\n\r\n\x05\
    \x04\n\x02\0\x05\x12\x04\xee\x02\x11\x17\n\r\n\x05\x04\n\x02\0\x01\x12\
    \x04\xee\x02\x18\x20\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xee\x02#$\n\r\n\
    \x05\x04\n\x02\0\x08\x12\x04\xee\x02%A\n\x10\n\x08\x04\n\x02\0\x08\xff\
    \xa2\x04\x12\x04\xee\x02&@\n\x0e\n\x04\x04\n\x08\0\x12\x06\xf0\x02\x08\
    \xf9\x02\t\n\r\n\x05\x04\n\x08\0\x01\x12\x04\xf0\x02\x0e\x13\n\x0c\n\x04\
    \x04\n\x02\x01\x12\x04\xf1\x02\x10\x20\n\r\n\x05\x04\n\x02\x01\x05\x12\
    \x04\xf1\x02\x10\x15\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\xf1\x02\x16\x1b\
    \n\r\n\x05\x04\n\x02\x01\x03\x12\x04\xf1\x02\x1e\x1f\n\x0c\n\x04\x04\n\
    \x02\x02\x12\x04\xf2\x02\x10\"\n\r\n\x05\x04\n\x02\x02\x05\x12\x04\xf2\
    \x02\x10\x16\n\r\n\x05\x04\n\x02\x02\x01\x12\x04\xf2\x02\x17\x1d\n\r\n\
    \x05\x04\n\x02\x02\x03\x12\x04\xf2\x02\x20!\n\x0c\n\x04\x04\n\x02\x03\
    \x12\x04\xf3\x02\x10\"\n\r\n\x05\x04\n\x02\x03\x05\x12\x04\xf3\x02\x10\
    \x16\n\r\n\x05\x04\n\x02\x03\x01\x12\x04\xf3\x02\x17\x1d\n\r\n\x05\x04\n\
    \x02\x03\x03\x12\x04\xf3\x02\x20!\n\x0c\n\x04\x04\n\x02\x04\x12\x04\xf4\
    \x02\x10\"\n\r\n\x05\x04\n\x02\x04\x05\x12\x04\xf4\x02\x10\x16\n\r\n\x05\
    \x04\n\x02\x04\x01\x12\x04\xf4\x02\x17\x1d\n\r\n\x05\x04\n\x02\x04\x03\
    \x12\x04\xf4\x02\x20!\n\x0c\n\x04\x04\n\x02\x05\x12\x04\xf5\x02\x10\"\n\
    \r\n\x05\x04\n\x02\x05\x05\x12\x04\xf5\x02\x10\x16\n\r\n\x05\x04\n\x02\
    \x05\x01\x12\x04\xf5\x02\x17\x1d\n\r\n\x05\x04\n\x02\x05\x03\x12\x04\xf5\
    \x02\x20!\n\x0c\n\x04\x04\n\x02\x06\x12\x04\xf6\x02\x10\"\n\r\n\x05\x04\
    \n\x02\x06\x05\x12\x04\xf6\x02\x10\x16\n\r\n\x05\x04\n\x02\x06\x01\x12\
    \x04\xf6\x02\x17\x1d\n\r\n\x05\x04\n\x02\x06\x03\x12\x04\xf6\x02\x20!\n\
    \x0c\n\x04\x04\n\x02\x07\x12\x04\xf7\x02\x10\x1e\n\r\n\x05\x04\n\x02\x07\
    \x05\x12\x04\xf7\x02\x10\x14\n\r\n\x05\x04\n\x02\x07\x01\x12\x04\xf7\x02\
    \x15\x19\n\r\n\x05\x04\n\x02\x07\x03\x12\x04\xf7\x02\x1c\x1d\n\x0c\n\x04\
    \x04\n\x02\x08\x12\x04\xf8\x02\x10\"\n\r\n\x05\x04\n\x02\x08\x05\x12\x04\
    \xf8\x02\x10\x16\n\r\n\x05\x04\n\x02\x08\x01\x12\x04\xf8\x02\x17\x1d\n\r\
    \n\x05\x04\n\x02\x08\x03\x12\x04\xf8\x02\x20!\n\x0c\n\x02\x04\x0b\x12\
    \x06\xfc\x02\0\xff\x02\x01\n\x0b\n\x03\x04\x0b\x01\x12\x04\xfc\x02\x08\
    \x1c\n\x0c\n\x04\x04\x0b\x02\0\x12\x04\xfd\x02\x080\n\r\n\x05\x04\x0b\
    \x02\0\x04\x12\x04\xfd\x02\x08\x10\n\r\n\x05\x04\x0b\x02\0\x06\x12\x04\
    \xfd\x02\x11$\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xfd\x02%+\n\r\n\x05\
    \x04\x0b\x02\0\x03\x12\x04\xfd\x02./\n\x0c\n\x04\x04\x0b\x02\x01\x12\x04\
    \xfe\x02\x08T\n\r\n\x05\x04\x0b\x02\x01\x04\x12\x04\xfe\x02\x08\x10\n\r\
    \n\x05\x04\x0b\x02\x01\x05\x12\x04\xfe\x02\x11\x17\n\r\n\x05\x04\x0b\x02\
    \x01\x01\x12\x04\xfe\x02\x18\x1c\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\
    \xfe\x02\x1f\x20\n\r\n\x05\x04\x0b\x02\x01\x08\x12\x04\xfe\x02!S\n\x10\n\
    \x08\x04\x0b\x02\x01\x08\xf2\xa2\x04\x12\x04\xfe\x02\"4\n\x10\n\x08\x04\
    \x0b\x02\x01\x08\xf4\xa2\x04\x12\x04\xfe\x026R\n\x0c\n\x02\x04\x0c\x12\
    \x06\x81\x03\0\x8f\x03\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\x81\x03\x08\
    \x1b\n\x0c\n\x04\x04\x0c\x02\0\x12\x04\x82\x03\x080\n\r\n\x05\x04\x0c\
    \x02\0\x04\x12\x04\x82\x03\x08\x10\n\r\n\x05\x04\x0c\x02\0\x06\x12\x04\
    \x82\x03\x11$\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\x82\x03%+\n\r\n\x05\
    \x04\x0c\x02\0\x03\x12\x04\x82\x03./\n\r\n\x04\x04\x0c\x02\x01\x12\x05\
    \x83\x03\x08\x82\x01\n\r\n\x05\x04\x0c\x02\x01\x04\x12\x04\x83\x03\x08\
    \x10\n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\x83\x03\x11\x17\n\r\n\x05\x04\
    \x0c\x02\x01\x01\x12\x04\x83\x03\x18%\n\r\n\x05\x04\x0c\x02\x01\x03\x12\
    \x04\x83\x03()\n\x0e\n\x05\x04\x0c\x02\x01\x08\x12\x05\x83\x03*\x81\x01\
    \n\x10\n\x08\x04\x0c\x02\x01\x08\xf2\xa2\x04\x12\x04\x83\x03+=\n\x10\n\
    \x08\x04\x0c\x02\x01\x08\xf4\xa2\x04\x12\x04\x83\x03?[\n\x11\n\x08\x04\
    \x0c\x02\x01\x08\xf5\xa2\x04\x12\x05\x83\x03]\x80\x01\n\x0c\n\x04\x04\
    \x0c\x02\x02\x12\x04\x84\x03\x08k\n\r\n\x05\x04\x0c\x02\x02\x04\x12\x04\
    \x84\x03\x08\x10\n\r\n\x05\x04\x0c\x02\x02\x05\x12\x04\x84\x03\x11\x16\n\
    \r\n\x05\x04\x0c\x02\x02\x01\x12\x04\x84\x03\x17\x1c\n\r\n\x05\x04\x0c\
    \x02\x02\x03\x12\x04\x84\x03\x1f\x20\n\r\n\x05\x04\x0c\x02\x02\x08\x12\
    \x04\x84\x03!j\n\x10\n\x08\x04\x0c\x02\x02\x08\xf4\xa2\x04\x12\x04\x84\
    \x03\">\n\x10\n\x08\x04\x0c\x02\x02\x08\xf5\xa2\x04\x12\x04\x84\x03@i\n\
    \x0c\n\x04\x04\x0c\x02\x03\x12\x04\x85\x03\x08k\n\r\n\x05\x04\x0c\x02\
    \x03\x04\x12\x04\x85\x03\x08\x10\n\r\n\x05\x04\x0c\x02\x03\x05\x12\x04\
    \x85\x03\x11\x16\n\r\n\x05\x04\x0c\x02\x03\x01\x12\x04\x85\x03\x17\x1c\n\
    \r\n\x05\x04\x0c\x02\x03\x03\x12\x04\x85\x03\x1f\x20\n\r\n\x05\x04\x0c\
    \x02\x03\x08\x12\x04\x85\x03!j\n\x10\n\x08\x04\x0c\x02\x03\x08\xf4\xa2\
    \x04\x12\x04\x85\x03\">\n\x10\n\x08\x04\x0c\x02\x03\x08\xf5\xa2\x04\x12\
    \x04\x85\x03@i\n\r\n\x04\x04\x0c\x02\x04\x12\x05\x86\x03\x08\x9d\x01\n\r\
    \n\x05\x04\x0c\x02\x04\x04\x12\x04\x86\x03\x08\x10\n\r\n\x05\x04\x0c\x02\
    \x04\x06\x12\x04\x86\x03\x11+\n\r\n\x05\x04\x0c\x02\x04\x01\x12\x04\x86\
    \x03,5\n\r\n\x05\x04\x0c\x02\x04\x03\x12\x04\x86\x0389\n\x0e\n\x05\x04\
    \x0c\x02\x04\x08\x12\x05\x86\x03:\x9c\x01\n\x10\n\x08\x04\x0c\x02\x04\
    \x08\xf4\xa2\x04\x12\x04\x86\x03;X\n\x11\n\x08\x04\x0c\x02\x04\x08\xf5\
    \xa2\x04\x12\x05\x86\x03Z\x9b\x01\n\r\n\x04\x04\x0c\x02\x05\x12\x05\x87\
    \x03\x08\xb7\x01\n\r\n\x05\x04\x0c\x02\x05\x04\x12\x04\x87\x03\x08\x10\n\
    \r\n\x05\x04\x0c\x02\x05\x06\x12\x04\x87\x03\x11\x20\n\r\n\x05\x04\x0c\
    \x02\x05\x01\x12\x04\x87\x03!.\n\r\n\x05\x04\x0c\x02\x05\x03\x12\x04\x87\
    \x0313\n\x0e\n\x05\x04\x0c\x02\x05\x08\x12\x05\x87\x034\xb6\x01\n\x10\n\
    \x08\x04\x0c\x02\x05\x08\xf0\xa2\x04\x12\x04\x87\x035]\n\x10\n\x08\x04\
    \x0c\x02\x05\x08\xf4\xa2\x04\x12\x04\x87\x03_x\n\x11\n\x08\x04\x0c\x02\
    \x05\x08\xf5\xa2\x04\x12\x05\x87\x03z\xb5\x01\n\r\n\x04\x04\x0c\x02\x06\
    \x12\x05\x88\x03\x08\xb6\x01\n\r\n\x05\x04\x0c\x02\x06\x04\x12\x04\x88\
    \x03\x08\x10\n\r\n\x05\x04\x0c\x02\x06\x06\x12\x04\x88\x03\x11\x20\n\r\n\
    \x05\x04\x0c\x02\x06\x01\x12\x04\x88\x03!.\n\r\n\x05\x04\x0c\x02\x06\x03\
    \x12\x04\x88\x0313\n\x0e\n\x05\x04\x0c\x02\x06\x08\x12\x05\x88\x034\xb5\
    \x01\n\x10\n\x08\x04\x0c\x02\x06\x08\xf0\xa2\x04\x12\x04\x88\x035R\n\x10\
    \n\x08\x04\x0c\x02\x06\x08\xf4\xa2\x04\x12\x04\x88\x03Tu\n\x11\n\x08\x04\
    \x0c\x02\x06\x08\xf5\xa2\x04\x12\x05\x88\x03w\xa3\x01\n\x12\n\x08\x04\
    \x0c\x02\x06\x08\xf7\xa2\x04\x12\x06\x88\x03\xa5\x01\xb4\x01\n\r\n\x04\
    \x04\x0c\x02\x07\x12\x05\x89\x03\x08\x92\x01\n\r\n\x05\x04\x0c\x02\x07\
    \x04\x12\x04\x89\x03\x08\x10\n\r\n\x05\x04\x0c\x02\x07\x05\x12\x04\x89\
    \x03\x11\x17\n\r\n\x05\x04\x0c\x02\x07\x01\x12\x04\x89\x03\x18,\n\r\n\
    \x05\x04\x0c\x02\x07\x03\x12\x04\x89\x03/1\n\x0e\n\x05\x04\x0c\x02\x07\
    \x08\x12\x05\x89\x032\x91\x01\n\x10\n\x08\x04\x0c\x02\x07\x08\xf4\xa2\
    \x04\x12\x04\x89\x033Z\n\x11\n\x08\x04\x0c\x02\x07\x08\xf5\xa2\x04\x12\
    \x05\x89\x03\\\x90\x01\n\r\n\x04\x04\x0c\x02\x08\x12\x05\x8a\x03\x08\x86\
    \x01\n\r\n\x05\x04\x0c\x02\x08\x04\x12\x04\x8a\x03\x08\x10\n\r\n\x05\x04\
    \x0c\x02\x08\x05\x12\x04\x8a\x03\x11\x17\n\r\n\x05\x04\x0c\x02\x08\x01\
    \x12\x04\x8a\x03\x18(\n\r\n\x05\x04\x0c\x02\x08\x03\x12\x04\x8a\x03+-\n\
    \x0e\n\x05\x04\x0c\x02\x08\x08\x12\x05\x8a\x03.\x85\x01\n\x10\n\x08\x04\
    \x0c\x02\x08\x08\xf4\xa2\x04\x12\x04\x8a\x03/M\n\x11\n\x08\x04\x0c\x02\
    \x08\x08\xf5\xa2\x04\x12\x05\x8a\x03O\x84\x01\n\r\n\x04\x04\x0c\x02\t\
    \x12\x05\x8b\x03\x08\x93\x01\n\r\n\x05\x04\x0c\x02\t\x04\x12\x04\x8b\x03\
    \x08\x10\n\r\n\x05\x04\x0c\x02\t\x05\x12\x04\x8b\x03\x11\x17\n\r\n\x05\
    \x04\x0c\x02\t\x01\x12\x04\x8b\x03\x18,\n\r\n\x05\x04\x0c\x02\t\x03\x12\
    \x04\x8b\x03/1\n\x0e\n\x05\x04\x0c\x02\t\x08\x12\x05\x8b\x032\x92\x01\n\
    \x10\n\x08\x04\x0c\x02\t\x08\xf4\xa2\x04\x12\x04\x8b\x033U\n\x11\n\x08\
    \x04\x0c\x02\t\x08\xf5\xa2\x04\x12\x05\x8b\x03W\x91\x01\n\r\n\x04\x04\
    \x0c\x02\n\x12\x05\x8c\x03\x08\xbb\x01\n\r\n\x05\x04\x0c\x02\n\x04\x12\
    \x04\x8c\x03\x08\x10\n\r\n\x05\x04\x0c\x02\n\x06\x12\x04\x8c\x03\x11!\n\
    \r\n\x05\x04\x0c\x02\n\x01\x12\x04\x8c\x03\"-\n\r\n\x05\x04\x0c\x02\n\
    \x03\x12\x04\x8c\x0302\n\x0e\n\x05\x04\x0c\x02\n\x08\x12\x05\x8c\x033\
    \xba\x01\n\r\n\x05\x04\x0c\x02\n\x07\x12\x04\x8c\x03>N\n\x10\n\x08\x04\
    \x0c\x02\n\x08\xf4\xa2\x04\x12\x04\x8c\x03Pn\n\x11\n\x08\x04\x0c\x02\n\
    \x08\xf5\xa2\x04\x12\x05\x8c\x03p\xb9\x01\n\r\n\x04\x04\x0c\x02\x0b\x12\
    \x05\x8d\x03\x08\xad\x01\n\r\n\x05\x04\x0c\x02\x0b\x04\x12\x04\x8d\x03\
    \x08\x10\n\r\n\x05\x04\x0c\x02\x0b\x06\x12\x04\x8d\x03\x11\x20\n\r\n\x05\
    \x04\x0c\x02\x0b\x01\x12\x04\x8d\x03!*\n\r\n\x05\x04\x0c\x02\x0b\x03\x12\
    \x04\x8d\x03-/\n\x0e\n\x05\x04\x0c\x02\x0b\x08\x12\x05\x8d\x030\xac\x01\
    \n\x10\n\x08\x04\x0c\x02\x0b\x08\xf0\xa2\x04\x12\x04\x8d\x031\\\n\x10\n\
    \x08\x04\x0c\x02\x0b\x08\xf4\xa2\x04\x12\x04\x8d\x03^z\n\x11\n\x08\x04\
    \x0c\x02\x0b\x08\xf5\xa2\x04\x12\x05\x8d\x03|\xab\x01\n\r\n\x04\x04\x0c\
    \x02\x0c\x12\x05\x8e\x03\x08\x92\x01\n\r\n\x05\x04\x0c\x02\x0c\x04\x12\
    \x04\x8e\x03\x08\x10\n\r\n\x05\x04\x0c\x02\x0c\x05\x12\x04\x8e\x03\x11\
    \x17\n\r\n\x05\x04\x0c\x02\x0c\x01\x12\x04\x8e\x03\x18'\n\r\n\x05\x04\
    \x0c\x02\x0c\x03\x12\x04\x8e\x03*,\n\x0e\n\x05\x04\x0c\x02\x0c\x08\x12\
    \x05\x8e\x03-\x91\x01\n\r\n\x05\x04\x0c\x02\x0c\x07\x12\x04\x8e\x0389\n\
    \x10\n\x08\x04\x0c\x02\x0c\x08\xf4\xa2\x04\x12\x04\x8e\x03;]\n\x11\n\x08\
    \x04\x0c\x02\x0c\x08\xf5\xa2\x04\x12\x05\x8e\x03_\x90\x01\n\x0c\n\x02\
    \x04\r\x12\x06\x91\x03\0\x93\x03\x01\n\x0b\n\x03\x04\r\x01\x12\x04\x91\
    \x03\x08\x1e\n\x0c\n\x04\x04\r\x02\0\x12\x04\x92\x03\x080\n\r\n\x05\x04\
    \r\x02\0\x04\x12\x04\x92\x03\x08\x10\n\r\n\x05\x04\r\x02\0\x06\x12\x04\
    \x92\x03\x11$\n\r\n\x05\x04\r\x02\0\x01\x12\x04\x92\x03%+\n\r\n\x05\x04\
    \r\x02\0\x03\x12\x04\x92\x03./\n\x0c\n\x02\x04\x0e\x12\x06\x95\x03\0\xa2\
    \x03\x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\x95\x03\x08+\n\x0c\n\x04\x04\
    \x0e\x02\0\x12\x04\x96\x03\x08P\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04\x96\
    \x03\x08\x10\n\r\n\x05\x04\x0e\x02\0\x06\x12\x04\x96\x03\x11\x1e\n\r\n\
    \x05\x04\x0e\x02\0\x01\x12\x04\x96\x03\x1f&\n\r\n\x05\x04\x0e\x02\0\x03\
    \x12\x04\x96\x03)*\n\r\n\x05\x04\x0e\x02\0\x08\x12\x04\x96\x03+O\n\x10\n\
    \x08\x04\x0e\x02\0\x08\xfe\xa2\x04\x12\x04\x96\x03,N\n\x0c\n\x04\x04\x0e\
    \x02\x01\x12\x04\x97\x03\x08T\n\r\n\x05\x04\x0e\x02\x01\x04\x12\x04\x97\
    \x03\x08\x10\n\r\n\x05\x04\x0e\x02\x01\x06\x12\x04\x97\x03\x11\x1e\n\r\n\
    \x05\x04\x0e\x02\x01\x01\x12\x04\x97\x03\x1f*\n\r\n\x05\x04\x0e\x02\x01\
    \x03\x12\x04\x97\x03-.\n\r\n\x05\x04\x0e\x02\x01\x08\x12\x04\x97\x03/S\n\
    \x10\n\x08\x04\x0e\x02\x01\x08\xfe\xa2\x04\x12\x04\x97\x030R\n\x0c\n\x04\
    \x04\x0e\x02\x02\x12\x04\x98\x03\x08U\n\r\n\x05\x04\x0e\x02\x02\x04\x12\
    \x04\x98\x03\x08\x10\n\r\n\x05\x04\x0e\x02\x02\x06\x12\x04\x98\x03\x11\
    \x1e\n\r\n\x05\x04\x0e\x02\x02\x01\x12\x04\x98\x03\x1f+\n\r\n\x05\x04\
    \x0e\x02\x02\x03\x12\x04\x98\x03./\n\r\n\x05\x04\x0e\x02\x02\x08\x12\x04\
    \x98\x030T\n\x10\n\x08\x04\x0e\x02\x02\x08\xfe\xa2\x04\x12\x04\x98\x031S\
    \n\x0c\n\x04\x04\x0e\x02\x03\x12\x04\x99\x03\x08U\n\r\n\x05\x04\x0e\x02\
    \x03\x04\x12\x04\x99\x03\x08\x10\n\r\n\x05\x04\x0e\x02\x03\x06\x12\x04\
    \x99\x03\x11\x1e\n\r\n\x05\x04\x0e\x02\x03\x01\x12\x04\x99\x03\x1f+\n\r\
    \n\x05\x04\x0e\x02\x03\x03\x12\x04\x99\x03./\n\r\n\x05\x04\x0e\x02\x03\
    \x08\x12\x04\x99\x030T\n\x10\n\x08\x04\x0e\x02\x03\x08\xfe\xa2\x04\x12\
    \x04\x99\x031S\n\x0c\n\x04\x04\x0e\x02\x04\x12\x04\x9a\x03\x08V\n\r\n\
    \x05\x04\x0e\x02\x04\x04\x12\x04\x9a\x03\x08\x10\n\r\n\x05\x04\x0e\x02\
    \x04\x06\x12\x04\x9a\x03\x11\x1e\n\r\n\x05\x04\x0e\x02\x04\x01\x12\x04\
    \x9a\x03\x1f,\n\r\n\x05\x04\x0e\x02\x04\x03\x12\x04\x9a\x03/0\n\r\n\x05\
    \x04\x0e\x02\x04\x08\x12\x04\x9a\x031U\n\x10\n\x08\x04\x0e\x02\x04\x08\
    \xfe\xa2\x04\x12\x04\x9a\x032T\n\x0c\n\x04\x04\x0e\x02\x05\x12\x04\x9b\
    \x03\x08U\n\r\n\x05\x04\x0e\x02\x05\x04\x12\x04\x9b\x03\x08\x10\n\r\n\
    \x05\x04\x0e\x02\x05\x06\x12\x04\x9b\x03\x11\x1e\n\r\n\x05\x04\x0e\x02\
    \x05\x01\x12\x04\x9b\x03\x1f+\n\r\n\x05\x04\x0e\x02\x05\x03\x12\x04\x9b\
    \x03./\n\r\n\x05\x04\x0e\x02\x05\x08\x12\x04\x9b\x030T\n\x10\n\x08\x04\
    \x0e\x02\x05\x08\xfe\xa2\x04\x12\x04\x9b\x031S\n\x0c\n\x04\x04\x0e\x02\
    \x06\x12\x04\x9c\x03\x08Q\n\r\n\x05\x04\x0e\x02\x06\x04\x12\x04\x9c\x03\
    \x08\x10\n\r\n\x05\x04\x0e\x02\x06\x06\x12\x04\x9c\x03\x11\x1e\n\r\n\x05\
    \x04\x0e\x02\x06\x01\x12\x04\x9c\x03\x1f'\n\r\n\x05\x04\x0e\x02\x06\x03\
    \x12\x04\x9c\x03*+\n\r\n\x05\x04\x0e\x02\x06\x08\x12\x04\x9c\x03,P\n\x10\
    \n\x08\x04\x0e\x02\x06\x08\xfe\xa2\x04\x12\x04\x9c\x03-O\n\x0c\n\x04\x04\
    \x0e\x02\x07\x12\x04\x9d\x03\x08T\n\r\n\x05\x04\x0e\x02\x07\x04\x12\x04\
    \x9d\x03\x08\x10\n\r\n\x05\x04\x0e\x02\x07\x06\x12\x04\x9d\x03\x11\x1e\n\
    \r\n\x05\x04\x0e\x02\x07\x01\x12\x04\x9d\x03\x1f*\n\r\n\x05\x04\x0e\x02\
    \x07\x03\x12\x04\x9d\x03-.\n\r\n\x05\x04\x0e\x02\x07\x08\x12\x04\x9d\x03\
    /S\n\x10\n\x08\x04\x0e\x02\x07\x08\xfe\xa2\x04\x12\x04\x9d\x030R\n\x0c\n\
    \x04\x04\x0e\x02\x08\x12\x04\x9e\x03\x08T\n\r\n\x05\x04\x0e\x02\x08\x04\
    \x12\x04\x9e\x03\x08\x10\n\r\n\x05\x04\x0e\x02\x08\x06\x12\x04\x9e\x03\
    \x11\x1e\n\r\n\x05\x04\x0e\x02\x08\x01\x12\x04\x9e\x03\x1f*\n\r\n\x05\
    \x04\x0e\x02\x08\x03\x12\x04\x9e\x03-.\n\r\n\x05\x04\x0e\x02\x08\x08\x12\
    \x04\x9e\x03/S\n\x10\n\x08\x04\x0e\x02\x08\x08\xfe\xa2\x04\x12\x04\x9e\
    \x030R\n\x0c\n\x04\x04\x0e\x02\t\x12\x04\x9f\x03\x08R\n\r\n\x05\x04\x0e\
    \x02\t\x04\x12\x04\x9f\x03\x08\x10\n\r\n\x05\x04\x0e\x02\t\x06\x12\x04\
    \x9f\x03\x11\x1e\n\r\n\x05\x04\x0e\x02\t\x01\x12\x04\x9f\x03\x1f'\n\r\n\
    \x05\x04\x0e\x02\t\x03\x12\x04\x9f\x03*,\n\r\n\x05\x04\x0e\x02\t\x08\x12\
    \x04\x9f\x03-Q\n\x10\n\x08\x04\x0e\x02\t\x08\xfe\xa2\x04\x12\x04\x9f\x03\
    .P\n\x0c\n\x04\x04\x0e\x02\n\x12\x04\xa0\x03\x08P\n\r\n\x05\x04\x0e\x02\
    \n\x04\x12\x04\xa0\x03\x08\x10\n\r\n\x05\x04\x0e\x02\n\x06\x12\x04\xa0\
    \x03\x11\x1e\n\r\n\x05\x04\x0e\x02\n\x01\x12\x04\xa0\x03\x1f%\n\r\n\x05\
    \x04\x0e\x02\n\x03\x12\x04\xa0\x03(*\n\r\n\x05\x04\x0e\x02\n\x08\x12\x04\
    \xa0\x03+O\n\x10\n\x08\x04\x0e\x02\n\x08\xfe\xa2\x04\x12\x04\xa0\x03,N\n\
    \x0c\n\x04\x04\x0e\x02\x0b\x12\x04\xa1\x03\x08P\n\r\n\x05\x04\x0e\x02\
    \x0b\x04\x12\x04\xa1\x03\x08\x10\n\r\n\x05\x04\x0e\x02\x0b\x06\x12\x04\
    \xa1\x03\x11\x1e\n\r\n\x05\x04\x0e\x02\x0b\x01\x12\x04\xa1\x03\x1f%\n\r\
    \n\x05\x04\x0e\x02\x0b\x03\x12\x04\xa1\x03(*\n\r\n\x05\x04\x0e\x02\x0b\
    \x08\x12\x04\xa1\x03+O\n\x10\n\x08\x04\x0e\x02\x0b\x08\xfe\xa2\x04\x12\
    \x04\xa1\x03,N\n\x0c\n\x02\x04\x0f\x12\x06\xa4\x03\0\xaf\x03\x01\n\x0b\n\
    \x03\x04\x0f\x01\x12\x04\xa4\x03\x08+\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\
    \xa5\x03\x08U\n\r\n\x05\x04\x0f\x02\0\x04\x12\x04\xa5\x03\x08\x10\n\r\n\
    \x05\x04\x0f\x02\0\x06\x12\x04\xa5\x03\x11\x1e\n\r\n\x05\x04\x0f\x02\0\
    \x01\x12\x04\xa5\x03\x1f+\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xa5\x03./\
    \n\r\n\x05\x04\x0f\x02\0\x08\x12\x04\xa5\x030T\n\x10\n\x08\x04\x0f\x02\0\
    \x08\xfe\xa2\x04\x12\x04\xa5\x031S\n\x0c\n\x04\x04\x0f\x02\x01\x12\x04\
    \xa6\x03\x08V\n\r\n\x05\x04\x0f\x02\x01\x04\x12\x04\xa6\x03\x08\x10\n\r\
    \n\x05\x04\x0f\x02\x01\x06\x12\x04\xa6\x03\x11\x1e\n\r\n\x05\x04\x0f\x02\
    \x01\x01\x12\x04\xa6\x03\x1f,\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\xa6\
    \x03/0\n\r\n\x05\x04\x0f\x02\x01\x08\x12\x04\xa6\x031U\n\x10\n\x08\x04\
    \x0f\x02\x01\x08\xfe\xa2\x04\x12\x04\xa6\x032T\n\x0c\n\x04\x04\x0f\x02\
    \x02\x12\x04\xa7\x03\x08U\n\r\n\x05\x04\x0f\x02\x02\x04\x12\x04\xa7\x03\
    \x08\x10\n\r\n\x05\x04\x0f\x02\x02\x06\x12\x04\xa7\x03\x11\x1e\n\r\n\x05\
    \x04\x0f\x02\x02\x01\x12\x04\xa7\x03\x1f+\n\r\n\x05\x04\x0f\x02\x02\x03\
    \x12\x04\xa7\x03./\n\r\n\x05\x04\x0f\x02\x02\x08\x12\x04\xa7\x030T\n\x10\
    \n\x08\x04\x0f\x02\x02\x08\xfe\xa2\x04\x12\x04\xa7\x031S\n\x0c\n\x04\x04\
    \x0f\x02\x03\x12\x04\xa8\x03\x08Q\n\r\n\x05\x04\x0f\x02\x03\x04\x12\x04\
    \xa8\x03\x08\x10\n\r\n\x05\x04\x0f\x02\x03\x06\x12\x04\xa8\x03\x11\x1e\n\
    \r\n\x05\x04\x0f\x02\x03\x01\x12\x04\xa8\x03\x1f'\n\r\n\x05\x04\x0f\x02\
    \x03\x03\x12\x04\xa8\x03*+\n\r\n\x05\x04\x0f\x02\x03\x08\x12\x04\xa8\x03\
    ,P\n\x10\n\x08\x04\x0f\x02\x03\x08\xfe\xa2\x04\x12\x04\xa8\x03-O\n\x0c\n\
    \x04\x04\x0f\x02\x04\x12\x04\xa9\x03\x08T\n\r\n\x05\x04\x0f\x02\x04\x04\
    \x12\x04\xa9\x03\x08\x10\n\r\n\x05\x04\x0f\x02\x04\x06\x12\x04\xa9\x03\
    \x11\x1e\n\r\n\x05\x04\x0f\x02\x04\x01\x12\x04\xa9\x03\x1f*\n\r\n\x05\
    \x04\x0f\x02\x04\x03\x12\x04\xa9\x03-.\n\r\n\x05\x04\x0f\x02\x04\x08\x12\
    \x04\xa9\x03/S\n\x10\n\x08\x04\x0f\x02\x04\x08\xfe\xa2\x04\x12\x04\xa9\
    \x030R\n\x0c\n\x04\x04\x0f\x02\x05\x12\x04\xaa\x03\x08T\n\r\n\x05\x04\
    \x0f\x02\x05\x04\x12\x04\xaa\x03\x08\x10\n\r\n\x05\x04\x0f\x02\x05\x06\
    \x12\x04\xaa\x03\x11\x1e\n\r\n\x05\x04\x0f\x02\x05\x01\x12\x04\xaa\x03\
    \x1f*\n\r\n\x05\x04\x0f\x02\x05\x03\x12\x04\xaa\x03-.\n\r\n\x05\x04\x0f\
    \x02\x05\x08\x12\x04\xaa\x03/S\n\x10\n\x08\x04\x0f\x02\x05\x08\xfe\xa2\
    \x04\x12\x04\xaa\x030R\n\x0c\n\x04\x04\x0f\x02\x06\x12\x04\xab\x03\x08Q\
    \n\r\n\x05\x04\x0f\x02\x06\x04\x12\x04\xab\x03\x08\x10\n\r\n\x05\x04\x0f\
    \x02\x06\x06\x12\x04\xab\x03\x11\x1e\n\r\n\x05\x04\x0f\x02\x06\x01\x12\
    \x04\xab\x03\x1f'\n\r\n\x05\x04\x0f\x02\x06\x03\x12\x04\xab\x03*+\n\r\n\
    \x05\x04\x0f\x02\x06\x08\x12\x04\xab\x03,P\n\x10\n\x08\x04\x0f\x02\x06\
    \x08\xfe\xa2\x04\x12\x04\xab\x03-O\n\x0c\n\x04\x04\x0f\x02\x07\x12\x04\
    \xac\x03\x08O\n\r\n\x05\x04\x0f\x02\x07\x04\x12\x04\xac\x03\x08\x10\n\r\
    \n\x05\x04\x0f\x02\x07\x06\x12\x04\xac\x03\x11\x1e\n\r\n\x05\x04\x0f\x02\
    \x07\x01\x12\x04\xac\x03\x1f%\n\r\n\x05\x04\x0f\x02\x07\x03\x12\x04\xac\
    \x03()\n\r\n\x05\x04\x0f\x02\x07\x08\x12\x04\xac\x03*N\n\x10\n\x08\x04\
    \x0f\x02\x07\x08\xfe\xa2\x04\x12\x04\xac\x03+M\n\x0c\n\x04\x04\x0f\x02\
    \x08\x12\x04\xad\x03\x08O\n\r\n\x05\x04\x0f\x02\x08\x04\x12\x04\xad\x03\
    \x08\x10\n\r\n\x05\x04\x0f\x02\x08\x06\x12\x04\xad\x03\x11\x1e\n\r\n\x05\
    \x04\x0f\x02\x08\x01\x12\x04\xad\x03\x1f%\n\r\n\x05\x04\x0f\x02\x08\x03\
    \x12\x04\xad\x03()\n\r\n\x05\x04\x0f\x02\x08\x08\x12\x04\xad\x03*N\n\x10\
    \n\x08\x04\x0f\x02\x08\x08\xfe\xa2\x04\x12\x04\xad\x03+M\n\x0c\n\x04\x04\
    \x0f\x02\t\x12\x04\xae\x03\x08A\n\r\n\x05\x04\x0f\x02\t\x04\x12\x04\xae\
    \x03\x08\x10\n\r\n\x05\x04\x0f\x02\t\x06\x12\x04\xae\x03\x11,\n\r\n\x05\
    \x04\x0f\x02\t\x01\x12\x04\xae\x03-;\n\r\n\x05\x04\x0f\x02\t\x03\x12\x04\
    \xae\x03>@\n\x0c\n\x02\x04\x10\x12\x06\xb1\x03\0\xb4\x03\x01\n\x0b\n\x03\
    \x04\x10\x01\x12\x04\xb1\x03\x08*\n\x0c\n\x04\x04\x10\x02\0\x12\x04\xb2\
    \x03\x08O\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\xb2\x03\x08\x10\n\r\n\x05\
    \x04\x10\x02\0\x06\x12\x04\xb2\x03\x11\x1e\n\r\n\x05\x04\x10\x02\0\x01\
    \x12\x04\xb2\x03\x1f%\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xb2\x03()\n\r\
    \n\x05\x04\x10\x02\0\x08\x12\x04\xb2\x03*N\n\x10\n\x08\x04\x10\x02\0\x08\
    \xfe\xa2\x04\x12\x04\xb2\x03+M\n\x0c\n\x04\x04\x10\x02\x01\x12\x04\xb3\
    \x03\x08a\n\r\n\x05\x04\x10\x02\x01\x04\x12\x04\xb3\x03\x08\x10\n\r\n\
    \x05\x04\x10\x02\x01\x06\x12\x04\xb3\x03\x11\x1e\n\r\n\x05\x04\x10\x02\
    \x01\x01\x12\x04\xb3\x03\x1f%\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xb3\
    \x03()\n\r\n\x05\x04\x10\x02\x01\x08\x12\x04\xb3\x03*`\n\x10\n\x08\x04\
    \x10\x02\x01\x08\xf7\xa2\x04\x12\x04\xb3\x03+;\n\x10\n\x08\x04\x10\x02\
    \x01\x08\xfe\xa2\x04\x12\x04\xb3\x03=_\n\x0c\n\x02\x04\x11\x12\x06\xb6\
    \x03\0\xba\x03\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\xb6\x03\x08&\n\r\n\
    \x04\x04\x11\x02\0\x12\x05\xb7\x03\x08\x8f\x01\n\r\n\x05\x04\x11\x02\0\
    \x04\x12\x04\xb7\x03\x08\x10\n\r\n\x05\x04\x11\x02\0\x06\x12\x04\xb7\x03\
    \x11\x1e\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xb7\x03\x1f#\n\r\n\x05\x04\
    \x11\x02\0\x03\x12\x04\xb7\x03&'\n\x0e\n\x05\x04\x11\x02\0\x08\x12\x05\
    \xb7\x03(\x8e\x01\n\x10\n\x08\x04\x11\x02\0\x08\xf5\xa2\x04\x12\x04\xb7\
    \x03)i\n\x11\n\x08\x04\x11\x02\0\x08\xfe\xa2\x04\x12\x05\xb7\x03k\x8d\
    \x01\n\r\n\x04\x04\x11\x02\x01\x12\x05\xb8\x03\x08\x8b\x01\n\r\n\x05\x04\
    \x11\x02\x01\x04\x12\x04\xb8\x03\x08\x10\n\r\n\x05\x04\x11\x02\x01\x06\
    \x12\x04\xb8\x03\x11\x1e\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\xb8\x03\
    \x1f%\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xb8\x03()\n\x0e\n\x05\x04\
    \x11\x02\x01\x08\x12\x05\xb8\x03*\x8a\x01\n\x10\n\x08\x04\x11\x02\x01\
    \x08\xf5\xa2\x04\x12\x04\xb8\x03+e\n\x11\n\x08\x04\x11\x02\x01\x08\xfe\
    \xa2\x04\x12\x05\xb8\x03g\x89\x01\n\r\n\x04\x04\x11\x02\x02\x12\x05\xb9\
    \x03\x08\xcd\x01\n\r\n\x05\x04\x11\x02\x02\x04\x12\x04\xb9\x03\x08\x10\n\
    \r\n\x05\x04\x11\x02\x02\x06\x12\x04\xb9\x03\x11\x1e\n\r\n\x05\x04\x11\
    \x02\x02\x01\x12\x04\xb9\x03\x1f#\n\r\n\x05\x04\x11\x02\x02\x03\x12\x04\
    \xb9\x03&'\n\x0e\n\x05\x04\x11\x02\x02\x08\x12\x05\xb9\x03(\xcc\x01\n\
    \x11\n\x08\x04\x11\x02\x02\x08\xf5\xa2\x04\x12\x05\xb9\x03)\xa7\x01\n\
    \x12\n\x08\x04\x11\x02\x02\x08\xfe\xa2\x04\x12\x06\xb9\x03\xa9\x01\xcb\
    \x01\n\x0c\n\x02\x04\x12\x12\x06\xbc\x03\0\xc5\x03\x01\n\x0b\n\x03\x04\
    \x12\x01\x12\x04\xbc\x03\x08+\n\x0c\n\x04\x04\x12\x02\0\x12\x04\xbd\x03\
    \x08=\n\r\n\x05\x04\x12\x02\0\x04\x12\x04\xbd\x03\x08\x10\n\r\n\x05\x04\
    \x12\x02\0\x06\x12\x04\xbd\x03\x110\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\
    \xbd\x0318\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xbd\x03;<\n\x0c\n\x04\x04\
    \x12\x02\x01\x12\x04\xbe\x03\x08P\n\r\n\x05\x04\x12\x02\x01\x04\x12\x04\
    \xbe\x03\x08\x10\n\r\n\x05\x04\x12\x02\x01\x06\x12\x04\xbe\x03\x11\x1e\n\
    \r\n\x05\x04\x12\x02\x01\x01\x12\x04\xbe\x03\x1f&\n\r\n\x05\x04\x12\x02\
    \x01\x03\x12\x04\xbe\x03)*\n\r\n\x05\x04\x12\x02\x01\x08\x12\x04\xbe\x03\
    +O\n\x10\n\x08\x04\x12\x02\x01\x08\xfe\xa2\x04\x12\x04\xbe\x03,N\n\x0c\n\
    \x04\x04\x12\x02\x02\x12\x04\xbf\x03\x08P\n\r\n\x05\x04\x12\x02\x02\x04\
    \x12\x04\xbf\x03\x08\x10\n\r\n\x05\x04\x12\x02\x02\x06\x12\x04\xbf\x03\
    \x11\x1e\n\r\n\x05\x04\x12\x02\x02\x01\x12\x04\xbf\x03\x1f&\n\r\n\x05\
    \x04\x12\x02\x02\x03\x12\x04\xbf\x03)*\n\r\n\x05\x04\x12\x02\x02\x08\x12\
    \x04\xbf\x03+O\n\x10\n\x08\x04\x12\x02\x02\x08\xfe\xa2\x04\x12\x04\xbf\
    \x03,N\n\x0c\n\x04\x04\x12\x02\x03\x12\x04\xc0\x03\x08P\n\r\n\x05\x04\
    \x12\x02\x03\x04\x12\x04\xc0\x03\x08\x10\n\r\n\x05\x04\x12\x02\x03\x06\
    \x12\x04\xc0\x03\x11\x1e\n\r\n\x05\x04\x12\x02\x03\x01\x12\x04\xc0\x03\
    \x1f&\n\r\n\x05\x04\x12\x02\x03\x03\x12\x04\xc0\x03)*\n\r\n\x05\x04\x12\
    \x02\x03\x08\x12\x04\xc0\x03+O\n\x10\n\x08\x04\x12\x02\x03\x08\xfe\xa2\
    \x04\x12\x04\xc0\x03,N\n\x0c\n\x04\x04\x12\x02\x04\x12\x04\xc1\x03\x08U\
    \n\r\n\x05\x04\x12\x02\x04\x04\x12\x04\xc1\x03\x08\x10\n\r\n\x05\x04\x12\
    \x02\x04\x06\x12\x04\xc1\x03\x11\x1e\n\r\n\x05\x04\x12\x02\x04\x01\x12\
    \x04\xc1\x03\x1f+\n\r\n\x05\x04\x12\x02\x04\x03\x12\x04\xc1\x03./\n\r\n\
    \x05\x04\x12\x02\x04\x08\x12\x04\xc1\x030T\n\x10\n\x08\x04\x12\x02\x04\
    \x08\xfe\xa2\x04\x12\x04\xc1\x031S\n\x0c\n\x04\x04\x12\x02\x05\x12\x04\
    \xc2\x03\x08V\n\r\n\x05\x04\x12\x02\x05\x04\x12\x04\xc2\x03\x08\x10\n\r\
    \n\x05\x04\x12\x02\x05\x06\x12\x04\xc2\x03\x11\x1e\n\r\n\x05\x04\x12\x02\
    \x05\x01\x12\x04\xc2\x03\x1f,\n\r\n\x05\x04\x12\x02\x05\x03\x12\x04\xc2\
    \x03/0\n\r\n\x05\x04\x12\x02\x05\x08\x12\x04\xc2\x031U\n\x10\n\x08\x04\
    \x12\x02\x05\x08\xfe\xa2\x04\x12\x04\xc2\x032T\n\x0c\n\x04\x04\x12\x02\
    \x06\x12\x04\xc3\x03\x08U\n\r\n\x05\x04\x12\x02\x06\x04\x12\x04\xc3\x03\
    \x08\x10\n\r\n\x05\x04\x12\x02\x06\x06\x12\x04\xc3\x03\x11\x1e\n\r\n\x05\
    \x04\x12\x02\x06\x01\x12\x04\xc3\x03\x1f+\n\r\n\x05\x04\x12\x02\x06\x03\
    \x12\x04\xc3\x03./\n\r\n\x05\x04\x12\x02\x06\x08\x12\x04\xc3\x030T\n\x10\
    \n\x08\x04\x12\x02\x06\x08\xfe\xa2\x04\x12\x04\xc3\x031S\n\x0c\n\x04\x04\
    \x12\x02\x07\x12\x04\xc4\x03\x08@\n\r\n\x05\x04\x12\x02\x07\x04\x12\x04\
    \xc4\x03\x08\x10\n\r\n\x05\x04\x12\x02\x07\x06\x12\x04\xc4\x03\x11,\n\r\
    \n\x05\x04\x12\x02\x07\x01\x12\x04\xc4\x03-;\n\r\n\x05\x04\x12\x02\x07\
    \x03\x12\x04\xc4\x03>?\n\x0c\n\x02\x04\x13\x12\x06\xc7\x03\0\xd0\x03\x01\
    \n\x0b\n\x03\x04\x13\x01\x12\x04\xc7\x03\x08#\n\x0e\n\x04\x04\x13\x08\0\
    \x12\x06\xc8\x03\x08\xcf\x03\t\n\r\n\x05\x04\x13\x08\0\x01\x12\x04\xc8\
    \x03\x0e\x13\n\x0c\n\x04\x04\x13\x02\0\x12\x04\xc9\x03\x10H\n\r\n\x05\
    \x04\x13\x02\0\x06\x12\x04\xc9\x03\x104\n\r\n\x05\x04\x13\x02\0\x01\x12\
    \x04\xc9\x035C\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xc9\x03FG\n\x0c\n\x04\
    \x04\x13\x02\x01\x12\x04\xca\x03\x10E\n\r\n\x05\x04\x13\x02\x01\x06\x12\
    \x04\xca\x03\x104\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\xca\x035@\n\r\n\
    \x05\x04\x13\x02\x01\x03\x12\x04\xca\x03CD\n\x0c\n\x04\x04\x13\x02\x02\
    \x12\x04\xcb\x03\x10F\n\r\n\x05\x04\x13\x02\x02\x06\x12\x04\xcb\x03\x104\
    \n\r\n\x05\x04\x13\x02\x02\x01\x12\x04\xcb\x035A\n\r\n\x05\x04\x13\x02\
    \x02\x03\x12\x04\xcb\x03DE\n\x0c\n\x04\x04\x13\x02\x03\x12\x04\xcc\x03\
    \x10J\n\r\n\x05\x04\x13\x02\x03\x06\x12\x04\xcc\x03\x104\n\r\n\x05\x04\
    \x13\x02\x03\x01\x12\x04\xcc\x035E\n\r\n\x05\x04\x13\x02\x03\x03\x12\x04\
    \xcc\x03HI\n\x0c\n\x04\x04\x13\x02\x04\x12\x04\xcd\x03\x10?\n\r\n\x05\
    \x04\x13\x02\x04\x06\x12\x04\xcd\x03\x103\n\r\n\x05\x04\x13\x02\x04\x01\
    \x12\x04\xcd\x034:\n\r\n\x05\x04\x13\x02\x04\x03\x12\x04\xcd\x03=>\n\x0c\
    \n\x04\x04\x13\x02\x05\x12\x04\xce\x03\x10G\n\r\n\x05\x04\x13\x02\x05\
    \x06\x12\x04\xce\x03\x104\n\r\n\x05\x04\x13\x02\x05\x01\x12\x04\xce\x035\
    B\n\r\n\x05\x04\x13\x02\x05\x03\x12\x04\xce\x03EF\n\x0c\n\x02\x04\x14\
    \x12\x06\xd2\x03\0\xd7\x03\x01\n\x0b\n\x03\x04\x14\x01\x12\x04\xd2\x03\
    \x08\"\n\x0e\n\x04\x04\x14\x08\0\x12\x06\xd3\x03\x08\xd6\x03\t\n\r\n\x05\
    \x04\x14\x08\0\x01\x12\x04\xd3\x03\x0e\x12\n\x0c\n\x04\x04\x14\x02\0\x12\
    \x04\xd4\x03\x107\n\r\n\x05\x04\x14\x02\0\x06\x12\x04\xd4\x03\x10,\n\r\n\
    \x05\x04\x14\x02\0\x01\x12\x04\xd4\x03-2\n\r\n\x05\x04\x14\x02\0\x03\x12\
    \x04\xd4\x0356\n\r\n\x04\x04\x14\x02\x01\x12\x05\xd5\x03\x10\x8a\x01\n\r\
    \n\x05\x04\x14\x02\x01\x06\x12\x04\xd5\x03\x10\x1f\n\r\n\x05\x04\x14\x02\
    \x01\x01\x12\x04\xd5\x03\x202\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\xd5\
    \x0356\n\x0e\n\x05\x04\x14\x02\x01\x08\x12\x05\xd5\x037\x89\x01\n\x10\n\
    \x08\x04\x14\x02\x01\x08\xf0\xa2\x04\x12\x04\xd5\x038b\n\x11\n\x08\x04\
    \x14\x02\x01\x08\xfc\xa2\x04\x12\x05\xd5\x03d\x88\x01\n\x0c\n\x02\x04\
    \x15\x12\x06\xd9\x03\0\xdc\x03\x01\n\x0b\n\x03\x04\x15\x01\x12\x04\xd9\
    \x03\x08\x1e\n\x0c\n\x04\x04\x15\x02\0\x12\x04\xda\x03\x080\n\r\n\x05\
    \x04\x15\x02\0\x04\x12\x04\xda\x03\x08\x10\n\r\n\x05\x04\x15\x02\0\x06\
    \x12\x04\xda\x03\x11$\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\xda\x03%+\n\r\
    \n\x05\x04\x15\x02\0\x03\x12\x04\xda\x03./\n\x0c\n\x04\x04\x15\x02\x01\
    \x12\x04\xdb\x03\x08@\n\r\n\x05\x04\x15\x02\x01\x04\x12\x04\xdb\x03\x08\
    \x10\n\r\n\x05\x04\x15\x02\x01\x06\x12\x04\xdb\x03\x11,\n\r\n\x05\x04\
    \x15\x02\x01\x01\x12\x04\xdb\x03-;\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\
    \xdb\x03>?\n\x0c\n\x02\x04\x16\x12\x06\xde\x03\0\xe8\x03\x01\n\x0b\n\x03\
    \x04\x16\x01\x12\x04\xde\x03\x08#\n\x0e\n\x04\x04\x16\x03\0\x12\x06\xdf\
    \x03\x08\xe2\x03\t\n\r\n\x05\x04\x16\x03\0\x01\x12\x04\xdf\x03\x10\x1a\n\
    \x0e\n\x06\x04\x16\x03\0\x02\0\x12\x04\xe0\x03\x10m\n\x0f\n\x07\x04\x16\
    \x03\0\x02\0\x04\x12\x04\xe0\x03\x10\x18\n\x0f\n\x07\x04\x16\x03\0\x02\0\
    \x06\x12\x04\xe0\x03\x19(\n\x0f\n\x07\x04\x16\x03\0\x02\0\x01\x12\x04\
    \xe0\x03);\n\x0f\n\x07\x04\x16\x03\0\x02\0\x03\x12\x04\xe0\x03>?\n\x0f\n\
    \x07\x04\x16\x03\0\x02\0\x08\x12\x04\xe0\x03@l\n\x12\n\n\x04\x16\x03\0\
    \x02\0\x08\xf0\xa2\x04\x12\x04\xe0\x03Ak\n\x0f\n\x06\x04\x16\x03\0\x02\
    \x01\x12\x05\xe1\x03\x10\x86\x01\n\x0f\n\x07\x04\x16\x03\0\x02\x01\x04\
    \x12\x04\xe1\x03\x10\x18\n\x0f\n\x07\x04\x16\x03\0\x02\x01\x06\x12\x04\
    \xe1\x03\x19&\n\x0f\n\x07\x04\x16\x03\0\x02\x01\x01\x12\x04\xe1\x03'/\n\
    \x0f\n\x07\x04\x16\x03\0\x02\x01\x03\x12\x04\xe1\x0323\n\x10\n\x07\x04\
    \x16\x03\0\x02\x01\x08\x12\x05\xe1\x034\x85\x01\n\x12\n\n\x04\x16\x03\0\
    \x02\x01\x08\xf8\xa2\x04\x12\x04\xe1\x035H\n\x12\n\n\x04\x16\x03\0\x02\
    \x01\x08\xf9\xa2\x04\x12\x04\xe1\x03J`\n\x13\n\n\x04\x16\x03\0\x02\x01\
    \x08\xfe\xa2\x04\x12\x05\xe1\x03b\x84\x01\n\x0c\n\x04\x04\x16\x02\0\x12\
    \x04\xe4\x03\x080\n\r\n\x05\x04\x16\x02\0\x04\x12\x04\xe4\x03\x08\x10\n\
    \r\n\x05\x04\x16\x02\0\x06\x12\x04\xe4\x03\x11$\n\r\n\x05\x04\x16\x02\0\
    \x01\x12\x04\xe4\x03%+\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\xe4\x03./\n\
    \x0c\n\x04\x04\x16\x02\x01\x12\x04\xe5\x03\x082\n\r\n\x05\x04\x16\x02\
    \x01\x04\x12\x04\xe5\x03\x08\x10\n\r\n\x05\x04\x16\x02\x01\x05\x12\x04\
    \xe5\x03\x11\x17\n\r\n\x05\x04\x16\x02\x01\x01\x12\x04\xe5\x03\x18-\n\r\
    \n\x05\x04\x16\x02\x01\x03\x12\x04\xe5\x0301\n\r\n\x04\x04\x16\x02\x02\
    \x12\x05\xe6\x03\x08\x8a\x01\n\r\n\x05\x04\x16\x02\x02\x04\x12\x04\xe6\
    \x03\x08\x10\n\r\n\x05\x04\x16\x02\x02\x06\x12\x04\xe6\x03\x11\x20\n\r\n\
    \x05\x04\x16\x02\x02\x01\x12\x04\xe6\x03!2\n\r\n\x05\x04\x16\x02\x02\x03\
    \x12\x04\xe6\x0356\n\x0e\n\x05\x04\x16\x02\x02\x08\x12\x05\xe6\x037\x89\
    \x01\n\x10\n\x08\x04\x16\x02\x02\x08\xf0\xa2\x04\x12\x04\xe6\x038b\n\x11\
    \n\x08\x04\x16\x02\x02\x08\xfc\xa2\x04\x12\x05\xe6\x03d\x88\x01\n\x0c\n\
    \x04\x04\x16\x02\x03\x12\x04\xe7\x03\x08Z\n\r\n\x05\x04\x16\x02\x03\x04\
    \x12\x04\xe7\x03\x08\x10\n\r\n\x05\x04\x16\x02\x03\x06\x12\x04\xe7\x03\
    \x118\n\r\n\x05\x04\x16\x02\x03\x01\x12\x04\xe7\x039C\n\r\n\x05\x04\x16\
    \x02\x03\x03\x12\x04\xe7\x03FG\n\r\n\x05\x04\x16\x02\x03\x08\x12\x04\xe7\
    \x03HY\n\x10\n\x08\x04\x16\x02\x03\x08\xf7\xa2\x04\x12\x04\xe7\x03IX\n\
    \x0c\n\x02\x04\x17\x12\x06\xea\x03\0\xaa\x04\x01\n\x0b\n\x03\x04\x17\x01\
    \x12\x04\xea\x03\x08\x1f\n\x0e\n\x04\x04\x17\x03\0\x12\x06\xeb\x03\x08\
    \xf6\x03\t\n\r\n\x05\x04\x17\x03\0\x01\x12\x04\xeb\x03\x10\x14\n\r\n\x05\
    \x04\x17\x03\0\x07\x12\x04\xec\x03\x100\n\x10\n\x08\x04\x17\x03\0\x07\
    \x80\xf1\x04\x12\x04\xec\x03\x100\n\x10\n\x06\x04\x17\x03\0\x03\0\x12\
    \x06\xee\x03\x10\xf2\x03\x11\n\x0f\n\x07\x04\x17\x03\0\x03\0\x01\x12\x04\
    \xee\x03\x18\x20\n\x10\n\x08\x04\x17\x03\0\x03\0\x02\0\x12\x04\xef\x03\
    \x18N\n\x11\n\t\x04\x17\x03\0\x03\0\x02\0\x04\x12\x04\xef\x03\x18\x20\n\
    \x11\n\t\x04\x17\x03\0\x03\0\x02\0\x05\x12\x04\xef\x03!%\n\x11\n\t\x04\
    \x17\x03\0\x03\0\x02\0\x01\x12\x04\xef\x03&8\n\x11\n\t\x04\x17\x03\0\x03\
    \0\x02\0\x03\x12\x04\xef\x03;<\n\x11\n\t\x04\x17\x03\0\x03\0\x02\0\x08\
    \x12\x04\xef\x03=M\n\x11\n\t\x04\x17\x03\0\x03\0\x02\0\x07\x12\x04\xef\
    \x03HL\n\x10\n\x08\x04\x17\x03\0\x03\0\x02\x01\x12\x04\xf0\x03\x18>\n\
    \x11\n\t\x04\x17\x03\0\x03\0\x02\x01\x04\x12\x04\xf0\x03\x18\x20\n\x11\n\
    \t\x04\x17\x03\0\x03\0\x02\x01\x05\x12\x04\xf0\x03!'\n\x11\n\t\x04\x17\
    \x03\0\x03\0\x02\x01\x01\x12\x04\xf0\x03(9\n\x11\n\t\x04\x17\x03\0\x03\0\
    \x02\x01\x03\x12\x04\xf0\x03<=\n\x11\n\x08\x04\x17\x03\0\x03\0\x02\x02\
    \x12\x05\xf1\x03\x18\x8e\x01\n\x11\n\t\x04\x17\x03\0\x03\0\x02\x02\x04\
    \x12\x04\xf1\x03\x18\x20\n\x11\n\t\x04\x17\x03\0\x03\0\x02\x02\x06\x12\
    \x04\xf1\x03!.\n\x11\n\t\x04\x17\x03\0\x03\0\x02\x02\x01\x12\x04\xf1\x03\
    /7\n\x11\n\t\x04\x17\x03\0\x03\0\x02\x02\x03\x12\x04\xf1\x03:;\n\x12\n\t\
    \x04\x17\x03\0\x03\0\x02\x02\x08\x12\x05\xf1\x03<\x8d\x01\n\x14\n\x0c\
    \x04\x17\x03\0\x03\0\x02\x02\x08\xf8\xa2\x04\x12\x04\xf1\x03=P\n\x14\n\
    \x0c\x04\x17\x03\0\x03\0\x02\x02\x08\xf9\xa2\x04\x12\x04\xf1\x03Rh\n\x15\
    \n\x0c\x04\x17\x03\0\x03\0\x02\x02\x08\xfe\xa2\x04\x12\x05\xf1\x03j\x8c\
    \x01\n\x0f\n\x06\x04\x17\x03\0\x02\0\x12\x05\xf4\x03\x10\xb9\x01\n\x0f\n\
    \x07\x04\x17\x03\0\x02\0\x04\x12\x04\xf4\x03\x10\x18\n\x0f\n\x07\x04\x17\
    \x03\0\x02\0\x06\x12\x04\xf4\x03\x19(\n\x0f\n\x07\x04\x17\x03\0\x02\0\
    \x01\x12\x04\xf4\x03)A\n\x0f\n\x07\x04\x17\x03\0\x02\0\x03\x12\x04\xf4\
    \x03DE\n\x10\n\x07\x04\x17\x03\0\x02\0\x08\x12\x05\xf4\x03F\xb8\x01\n\
    \x12\n\n\x04\x17\x03\0\x02\0\x08\xf0\xa2\x04\x12\x04\xf4\x03Gw\n\x13\n\n\
    \x04\x17\x03\0\x02\0\x08\xfa\xa2\x04\x12\x05\xf4\x03y\xb7\x01\n\x0e\n\
    \x06\x04\x17\x03\0\x02\x01\x12\x04\xf5\x03\x10I\n\x0f\n\x07\x04\x17\x03\
    \0\x02\x01\x04\x12\x04\xf5\x03\x10\x18\n\x0f\n\x07\x04\x17\x03\0\x02\x01\
    \x06\x12\x04\xf5\x03\x19?\n\x0f\n\x07\x04\x17\x03\0\x02\x01\x01\x12\x04\
    \xf5\x03@D\n\x0f\n\x07\x04\x17\x03\0\x02\x01\x03\x12\x04\xf5\x03GH\n\x0c\
    \n\x04\x04\x17\x02\0\x12\x04\xf8\x03\x080\n\r\n\x05\x04\x17\x02\0\x04\
    \x12\x04\xf8\x03\x08\x10\n\r\n\x05\x04\x17\x02\0\x06\x12\x04\xf8\x03\x11\
    $\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xf8\x03%+\n\r\n\x05\x04\x17\x02\0\
    \x03\x12\x04\xf8\x03./\n\x0c\n\x04\x04\x17\x02\x01\x12\x04\xf9\x03\x08?\
    \n\r\n\x05\x04\x17\x02\x01\x04\x12\x04\xf9\x03\x08\x10\n\r\n\x05\x04\x17\
    \x02\x01\x05\x12\x04\xf9\x03\x11\x17\n\r\n\x05\x04\x17\x02\x01\x01\x12\
    \x04\xf9\x03\x18%\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\xf9\x03()\n\r\n\
    \x05\x04\x17\x02\x01\x08\x12\x04\xf9\x03*>\n\x10\n\x08\x04\x17\x02\x01\
    \x08\xf2\xa2\x04\x12\x04\xf9\x03+=\n\r\n\x04\x04\x17\x02\x02\x12\x05\xfa\
    \x03\x08\x94\x02\n\r\n\x05\x04\x17\x02\x02\x04\x12\x04\xfa\x03\x08\x10\n\
    \r\n\x05\x04\x17\x02\x02\x06\x12\x04\xfa\x03\x11\x20\n\r\n\x05\x04\x17\
    \x02\x02\x01\x12\x04\xfa\x03!3\n\r\n\x05\x04\x17\x02\x02\x03\x12\x04\xfa\
    \x0367\n\x0e\n\x05\x04\x17\x02\x02\x08\x12\x05\xfa\x038\x93\x02\n\x10\n\
    \x08\x04\x17\x02\x02\x08\xf0\xa2\x04\x12\x04\xfa\x039c\n\x11\n\x08\x04\
    \x17\x02\x02\x08\xf5\xa2\x04\x12\x05\xfa\x03e\xec\x01\n\x12\n\x08\x04\
    \x17\x02\x02\x08\xfc\xa2\x04\x12\x06\xfa\x03\xee\x01\x92\x02\n\x0c\n\x04\
    \x04\x17\x02\x03\x12\x04\xfb\x03\x08,\n\r\n\x05\x04\x17\x02\x03\x04\x12\
    \x04\xfb\x03\x08\x10\n\r\n\x05\x04\x17\x02\x03\x05\x12\x04\xfb\x03\x11\
    \x15\n\r\n\x05\x04\x17\x02\x03\x01\x12\x04\xfb\x03\x16'\n\r\n\x05\x04\
    \x17\x02\x03\x03\x12\x04\xfb\x03*+\n\x0c\n\x04\x04\x17\x02\x04\x12\x04\
    \xfc\x03\x088\n\r\n\x05\x04\x17\x02\x04\x04\x12\x04\xfc\x03\x08\x10\n\r\
    \n\x05\x04\x17\x02\x04\x06\x12\x04\xfc\x03\x11.\n\r\n\x05\x04\x17\x02\
    \x04\x01\x12\x04\xfc\x03/3\n\r\n\x05\x04\x17\x02\x04\x03\x12\x04\xfc\x03\
    67\n\x0c\n\x04\x04\x17\x02\x05\x12\x04\xfd\x03\x08A\n\r\n\x05\x04\x17\
    \x02\x05\x04\x12\x04\xfd\x03\x08\x10\n\r\n\x05\x04\x17\x02\x05\x06\x12\
    \x04\xfd\x03\x11.\n\r\n\x05\x04\x17\x02\x05\x01\x12\x04\xfd\x03/<\n\r\n\
    \x05\x04\x17\x02\x05\x03\x12\x04\xfd\x03?@\n\x0c\n\x04\x04\x17\x02\x06\
    \x12\x04\xfe\x03\x08@\n\r\n\x05\x04\x17\x02\x06\x04\x12\x04\xfe\x03\x08\
    \x10\n\r\n\x05\x04\x17\x02\x06\x06\x12\x04\xfe\x03\x11.\n\r\n\x05\x04\
    \x17\x02\x06\x01\x12\x04\xfe\x03/;\n\r\n\x05\x04\x17\x02\x06\x03\x12\x04\
    \xfe\x03>?\n\x0c\n\x04\x04\x17\x02\x07\x12\x04\xff\x03\x08C\n\r\n\x05\
    \x04\x17\x02\x07\x04\x12\x04\xff\x03\x08\x10\n\r\n\x05\x04\x17\x02\x07\
    \x06\x12\x04\xff\x03\x11.\n\r\n\x05\x04\x17\x02\x07\x01\x12\x04\xff\x03/\
    >\n\r\n\x05\x04\x17\x02\x07\x03\x12\x04\xff\x03AB\n\x0c\n\x04\x04\x17\
    \x02\x08\x12\x04\x80\x04\x089\n\r\n\x05\x04\x17\x02\x08\x04\x12\x04\x80\
    \x04\x08\x10\n\r\n\x05\x04\x17\x02\x08\x06\x12\x04\x80\x04\x11.\n\r\n\
    \x05\x04\x17\x02\x08\x01\x12\x04\x80\x04/4\n\r\n\x05\x04\x17\x02\x08\x03\
    \x12\x04\x80\x0478\n\x0c\n\x04\x04\x17\x02\t\x12\x04\x81\x04\x08<\n\r\n\
    \x05\x04\x17\x02\t\x04\x12\x04\x81\x04\x08\x10\n\r\n\x05\x04\x17\x02\t\
    \x06\x12\x04\x81\x04\x11.\n\r\n\x05\x04\x17\x02\t\x01\x12\x04\x81\x04/6\
    \n\r\n\x05\x04\x17\x02\t\x03\x12\x04\x81\x049;\n\x0c\n\x04\x04\x17\x02\n\
    \x12\x04\x82\x04\x08<\n\r\n\x05\x04\x17\x02\n\x04\x12\x04\x82\x04\x08\
    \x10\n\r\n\x05\x04\x17\x02\n\x06\x12\x04\x82\x04\x11.\n\r\n\x05\x04\x17\
    \x02\n\x01\x12\x04\x82\x04/6\n\r\n\x05\x04\x17\x02\n\x03\x12\x04\x82\x04\
    9;\n\x0c\n\x04\x04\x17\x02\x0b\x12\x04\x83\x04\x08;\n\r\n\x05\x04\x17\
    \x02\x0b\x04\x12\x04\x83\x04\x08\x10\n\r\n\x05\x04\x17\x02\x0b\x06\x12\
    \x04\x83\x04\x11.\n\r\n\x05\x04\x17\x02\x0b\x01\x12\x04\x83\x04/5\n\r\n\
    \x05\x04\x17\x02\x0b\x03\x12\x04\x83\x048:\n\x0c\n\x04\x04\x17\x02\x0c\
    \x12\x04\x84\x04\x08=\n\r\n\x05\x04\x17\x02\x0c\x04\x12\x04\x84\x04\x08\
    \x10\n\r\n\x05\x04\x17\x02\x0c\x06\x12\x04\x84\x04\x11.\n\r\n\x05\x04\
    \x17\x02\x0c\x01\x12\x04\x84\x04/7\n\r\n\x05\x04\x17\x02\x0c\x03\x12\x04\
    \x84\x04:<\n\x0c\n\x04\x04\x17\x02\r\x12\x04\x85\x04\x08C\n\r\n\x05\x04\
    \x17\x02\r\x04\x12\x04\x85\x04\x08\x10\n\r\n\x05\x04\x17\x02\r\x06\x12\
    \x04\x85\x04\x11.\n\r\n\x05\x04\x17\x02\r\x01\x12\x04\x85\x04/=\n\r\n\
    \x05\x04\x17\x02\r\x03\x12\x04\x85\x04@B\n\x0c\n\x04\x04\x17\x02\x0e\x12\
    \x04\x86\x04\x08?\n\r\n\x05\x04\x17\x02\x0e\x04\x12\x04\x86\x04\x08\x10\
    \n\r\n\x05\x04\x17\x02\x0e\x06\x12\x04\x86\x04\x11.\n\r\n\x05\x04\x17\
    \x02\x0e\x01\x12\x04\x86\x04/9\n\r\n\x05\x04\x17\x02\x0e\x03\x12\x04\x86\
    \x04<>\n\x0c\n\x04\x04\x17\x02\x0f\x12\x04\x87\x04\x08<\n\r\n\x05\x04\
    \x17\x02\x0f\x04\x12\x04\x87\x04\x08\x10\n\r\n\x05\x04\x17\x02\x0f\x06\
    \x12\x04\x87\x04\x11.\n\r\n\x05\x04\x17\x02\x0f\x01\x12\x04\x87\x04/6\n\
    \r\n\x05\x04\x17\x02\x0f\x03\x12\x04\x87\x049;\n\x0c\n\x04\x04\x17\x02\
    \x10\x12\x04\x88\x04\x088\n\r\n\x05\x04\x17\x02\x10\x04\x12\x04\x88\x04\
    \x08\x10\n\r\n\x05\x04\x17\x02\x10\x06\x12\x04\x88\x04\x11.\n\r\n\x05\
    \x04\x17\x02\x10\x01\x12\x04\x88\x04/2\n\r\n\x05\x04\x17\x02\x10\x03\x12\
    \x04\x88\x0457\n\x0c\n\x04\x04\x17\x02\x11\x12\x04\x89\x04\x08@\n\r\n\
    \x05\x04\x17\x02\x11\x04\x12\x04\x89\x04\x08\x10\n\r\n\x05\x04\x17\x02\
    \x11\x06\x12\x04\x89\x04\x11.\n\r\n\x05\x04\x17\x02\x11\x01\x12\x04\x89\
    \x04/:\n\r\n\x05\x04\x17\x02\x11\x03\x12\x04\x89\x04=?\n\x0c\n\x04\x04\
    \x17\x02\x12\x12\x04\x8a\x04\x08H\n\r\n\x05\x04\x17\x02\x12\x04\x12\x04\
    \x8a\x04\x08\x10\n\r\n\x05\x04\x17\x02\x12\x06\x12\x04\x8a\x04\x11.\n\r\
    \n\x05\x04\x17\x02\x12\x01\x12\x04\x8a\x04/B\n\r\n\x05\x04\x17\x02\x12\
    \x03\x12\x04\x8a\x04EG\n\x0c\n\x04\x04\x17\x02\x13\x12\x04\x8b\x04\x08<\
    \n\r\n\x05\x04\x17\x02\x13\x04\x12\x04\x8b\x04\x08\x10\n\r\n\x05\x04\x17\
    \x02\x13\x06\x12\x04\x8b\x04\x11.\n\r\n\x05\x04\x17\x02\x13\x01\x12\x04\
    \x8b\x04/6\n\r\n\x05\x04\x17\x02\x13\x03\x12\x04\x8b\x049;\n\x0c\n\x04\
    \x04\x17\x02\x14\x12\x04\x8c\x04\x08;\n\r\n\x05\x04\x17\x02\x14\x04\x12\
    \x04\x8c\x04\x08\x10\n\r\n\x05\x04\x17\x02\x14\x06\x12\x04\x8c\x04\x11.\
    \n\r\n\x05\x04\x17\x02\x14\x01\x12\x04\x8c\x04/5\n\r\n\x05\x04\x17\x02\
    \x14\x03\x12\x04\x8c\x048:\n\x0c\n\x04\x04\x17\x02\x15\x12\x04\x8d\x04\
    \x08>\n\r\n\x05\x04\x17\x02\x15\x04\x12\x04\x8d\x04\x08\x10\n\r\n\x05\
    \x04\x17\x02\x15\x06\x12\x04\x8d\x04\x11.\n\r\n\x05\x04\x17\x02\x15\x01\
    \x12\x04\x8d\x04/8\n\r\n\x05\x04\x17\x02\x15\x03\x12\x04\x8d\x04;=\n\x0c\
    \n\x04\x04\x17\x02\x16\x12\x04\x8e\x04\x08B\n\r\n\x05\x04\x17\x02\x16\
    \x04\x12\x04\x8e\x04\x08\x10\n\r\n\x05\x04\x17\x02\x16\x06\x12\x04\x8e\
    \x04\x11.\n\r\n\x05\x04\x17\x02\x16\x01\x12\x04\x8e\x04/<\n\r\n\x05\x04\
    \x17\x02\x16\x03\x12\x04\x8e\x04?A\n\x0c\n\x04\x04\x17\x02\x17\x12\x04\
    \x8f\x04\x08C\n\r\n\x05\x04\x17\x02\x17\x04\x12\x04\x8f\x04\x08\x10\n\r\
    \n\x05\x04\x17\x02\x17\x06\x12\x04\x8f\x04\x11.\n\r\n\x05\x04\x17\x02\
    \x17\x01\x12\x04\x8f\x04/=\n\r\n\x05\x04\x17\x02\x17\x03\x12\x04\x8f\x04\
    @B\n\x0c\n\x04\x04\x17\x02\x18\x12\x04\x90\x04\x08>\n\r\n\x05\x04\x17\
    \x02\x18\x04\x12\x04\x90\x04\x08\x10\n\r\n\x05\x04\x17\x02\x18\x06\x12\
    \x04\x90\x04\x11.\n\r\n\x05\x04\x17\x02\x18\x01\x12\x04\x90\x04/8\n\r\n\
    \x05\x04\x17\x02\x18\x03\x12\x04\x90\x04;=\n\x0c\n\x04\x04\x17\x02\x19\
    \x12\x04\x91\x04\x08B\n\r\n\x05\x04\x17\x02\x19\x04\x12\x04\x91\x04\x08\
    \x10\n\r\n\x05\x04\x17\x02\x19\x06\x12\x04\x91\x04\x11.\n\r\n\x05\x04\
    \x17\x02\x19\x01\x12\x04\x91\x04/<\n\r\n\x05\x04\x17\x02\x19\x03\x12\x04\
    \x91\x04?A\n\x0c\n\x04\x04\x17\x02\x1a\x12\x04\x92\x04\x08=\n\r\n\x05\
    \x04\x17\x02\x1a\x04\x12\x04\x92\x04\x08\x10\n\r\n\x05\x04\x17\x02\x1a\
    \x06\x12\x04\x92\x04\x11.\n\r\n\x05\x04\x17\x02\x1a\x01\x12\x04\x92\x04/\
    7\n\r\n\x05\x04\x17\x02\x1a\x03\x12\x04\x92\x04:<\n\x0c\n\x04\x04\x17\
    \x02\x1b\x12\x04\x93\x04\x08C\n\r\n\x05\x04\x17\x02\x1b\x04\x12\x04\x93\
    \x04\x08\x10\n\r\n\x05\x04\x17\x02\x1b\x06\x12\x04\x93\x04\x11.\n\r\n\
    \x05\x04\x17\x02\x1b\x01\x12\x04\x93\x04/=\n\r\n\x05\x04\x17\x02\x1b\x03\
    \x12\x04\x93\x04@B\n\x0c\n\x04\x04\x17\x02\x1c\x12\x04\x94\x04\x08G\n\r\
    \n\x05\x04\x17\x02\x1c\x04\x12\x04\x94\x04\x08\x10\n\r\n\x05\x04\x17\x02\
    \x1c\x06\x12\x04\x94\x04\x11.\n\r\n\x05\x04\x17\x02\x1c\x01\x12\x04\x94\
    \x04/A\n\r\n\x05\x04\x17\x02\x1c\x03\x12\x04\x94\x04DF\n\x0c\n\x04\x04\
    \x17\x02\x1d\x12\x04\x95\x04\x08>\n\r\n\x05\x04\x17\x02\x1d\x04\x12\x04\
    \x95\x04\x08\x10\n\r\n\x05\x04\x17\x02\x1d\x06\x12\x04\x95\x04\x11.\n\r\
    \n\x05\x04\x17\x02\x1d\x01\x12\x04\x95\x04/8\n\r\n\x05\x04\x17\x02\x1d\
    \x03\x12\x04\x95\x04;=\n\x0c\n\x04\x04\x17\x02\x1e\x12\x04\x96\x04\x08@\
    \n\r\n\x05\x04\x17\x02\x1e\x04\x12\x04\x96\x04\x08\x10\n\r\n\x05\x04\x17\
    \x02\x1e\x06\x12\x04\x96\x04\x11.\n\r\n\x05\x04\x17\x02\x1e\x01\x12\x04\
    \x96\x04/:\n\r\n\x05\x04\x17\x02\x1e\x03\x12\x04\x96\x04=?\n\x0c\n\x04\
    \x04\x17\x02\x1f\x12\x04\x97\x04\x08F\n\r\n\x05\x04\x17\x02\x1f\x04\x12\
    \x04\x97\x04\x08\x10\n\r\n\x05\x04\x17\x02\x1f\x06\x12\x04\x97\x04\x11.\
    \n\r\n\x05\x04\x17\x02\x1f\x01\x12\x04\x97\x04/@\n\r\n\x05\x04\x17\x02\
    \x1f\x03\x12\x04\x97\x04CE\n\x0c\n\x04\x04\x17\x02\x20\x12\x04\x98\x04\
    \x08>\n\r\n\x05\x04\x17\x02\x20\x04\x12\x04\x98\x04\x08\x10\n\r\n\x05\
    \x04\x17\x02\x20\x06\x12\x04\x98\x04\x11.\n\r\n\x05\x04\x17\x02\x20\x01\
    \x12\x04\x98\x04/8\n\r\n\x05\x04\x17\x02\x20\x03\x12\x04\x98\x04;=\n\x0c\
    \n\x04\x04\x17\x02!\x12\x04\x99\x04\x08@\n\r\n\x05\x04\x17\x02!\x04\x12\
    \x04\x99\x04\x08\x10\n\r\n\x05\x04\x17\x02!\x06\x12\x04\x99\x04\x11.\n\r\
    \n\x05\x04\x17\x02!\x01\x12\x04\x99\x04/:\n\r\n\x05\x04\x17\x02!\x03\x12\
    \x04\x99\x04=?\n\x0c\n\x04\x04\x17\x02\"\x12\x04\x9a\x04\x08A\n\r\n\x05\
    \x04\x17\x02\"\x04\x12\x04\x9a\x04\x08\x10\n\r\n\x05\x04\x17\x02\"\x06\
    \x12\x04\x9a\x04\x11.\n\r\n\x05\x04\x17\x02\"\x01\x12\x04\x9a\x04/;\n\r\
    \n\x05\x04\x17\x02\"\x03\x12\x04\x9a\x04>@\n\x0c\n\x04\x04\x17\x02#\x12\
    \x04\x9b\x04\x088\n\r\n\x05\x04\x17\x02#\x04\x12\x04\x9b\x04\x08\x10\n\r\
    \n\x05\x04\x17\x02#\x06\x12\x04\x9b\x04\x11.\n\r\n\x05\x04\x17\x02#\x01\
    \x12\x04\x9b\x04/2\n\r\n\x05\x04\x17\x02#\x03\x12\x04\x9b\x0457\n\x0c\n\
    \x04\x04\x17\x02$\x12\x04\x9c\x04\x08>\n\r\n\x05\x04\x17\x02$\x04\x12\
    \x04\x9c\x04\x08\x10\n\r\n\x05\x04\x17\x02$\x06\x12\x04\x9c\x04\x11.\n\r\
    \n\x05\x04\x17\x02$\x01\x12\x04\x9c\x04/8\n\r\n\x05\x04\x17\x02$\x03\x12\
    \x04\x9c\x04;=\n\x0c\n\x04\x04\x17\x02%\x12\x04\x9d\x04\x08>\n\r\n\x05\
    \x04\x17\x02%\x04\x12\x04\x9d\x04\x08\x10\n\r\n\x05\x04\x17\x02%\x06\x12\
    \x04\x9d\x04\x11.\n\r\n\x05\x04\x17\x02%\x01\x12\x04\x9d\x04/8\n\r\n\x05\
    \x04\x17\x02%\x03\x12\x04\x9d\x04;=\n\x0c\n\x04\x04\x17\x02&\x12\x04\x9e\
    \x04\x08=\n\r\n\x05\x04\x17\x02&\x04\x12\x04\x9e\x04\x08\x10\n\r\n\x05\
    \x04\x17\x02&\x06\x12\x04\x9e\x04\x11.\n\r\n\x05\x04\x17\x02&\x01\x12\
    \x04\x9e\x04/7\n\r\n\x05\x04\x17\x02&\x03\x12\x04\x9e\x04:<\n\x0c\n\x04\
    \x04\x17\x02'\x12\x04\x9f\x04\x08D\n\r\n\x05\x04\x17\x02'\x04\x12\x04\
    \x9f\x04\x08\x10\n\r\n\x05\x04\x17\x02'\x06\x12\x04\x9f\x04\x11.\n\r\n\
    \x05\x04\x17\x02'\x01\x12\x04\x9f\x04/>\n\r\n\x05\x04\x17\x02'\x03\x12\
    \x04\x9f\x04AC\n\x0c\n\x04\x04\x17\x02(\x12\x04\xa0\x04\x08@\n\r\n\x05\
    \x04\x17\x02(\x04\x12\x04\xa0\x04\x08\x10\n\r\n\x05\x04\x17\x02(\x06\x12\
    \x04\xa0\x04\x11.\n\r\n\x05\x04\x17\x02(\x01\x12\x04\xa0\x04/:\n\r\n\x05\
    \x04\x17\x02(\x03\x12\x04\xa0\x04=?\n\x0c\n\x04\x04\x17\x02)\x12\x04\xa1\
    \x04\x08A\n\r\n\x05\x04\x17\x02)\x04\x12\x04\xa1\x04\x08\x10\n\r\n\x05\
    \x04\x17\x02)\x06\x12\x04\xa1\x04\x11.\n\r\n\x05\x04\x17\x02)\x01\x12\
    \x04\xa1\x04/;\n\r\n\x05\x04\x17\x02)\x03\x12\x04\xa1\x04>@\n\x0c\n\x04\
    \x04\x17\x02*\x12\x04\xa2\x04\x08=\n\r\n\x05\x04\x17\x02*\x04\x12\x04\
    \xa2\x04\x08\x10\n\r\n\x05\x04\x17\x02*\x06\x12\x04\xa2\x04\x11.\n\r\n\
    \x05\x04\x17\x02*\x01\x12\x04\xa2\x04/7\n\r\n\x05\x04\x17\x02*\x03\x12\
    \x04\xa2\x04:<\n\x0c\n\x04\x04\x17\x02+\x12\x04\xa3\x04\x08@\n\r\n\x05\
    \x04\x17\x02+\x04\x12\x04\xa3\x04\x08\x10\n\r\n\x05\x04\x17\x02+\x06\x12\
    \x04\xa3\x04\x11.\n\r\n\x05\x04\x17\x02+\x01\x12\x04\xa3\x04/:\n\r\n\x05\
    \x04\x17\x02+\x03\x12\x04\xa3\x04=?\n\x0c\n\x04\x04\x17\x02,\x12\x04\xa4\
    \x04\x08>\n\r\n\x05\x04\x17\x02,\x04\x12\x04\xa4\x04\x08\x10\n\r\n\x05\
    \x04\x17\x02,\x06\x12\x04\xa4\x04\x11.\n\r\n\x05\x04\x17\x02,\x01\x12\
    \x04\xa4\x04/8\n\r\n\x05\x04\x17\x02,\x03\x12\x04\xa4\x04;=\n\x0c\n\x04\
    \x04\x17\x02-\x12\x04\xa5\x04\x08@\n\r\n\x05\x04\x17\x02-\x04\x12\x04\
    \xa5\x04\x08\x10\n\r\n\x05\x04\x17\x02-\x06\x12\x04\xa5\x04\x11.\n\r\n\
    \x05\x04\x17\x02-\x01\x12\x04\xa5\x04/:\n\r\n\x05\x04\x17\x02-\x03\x12\
    \x04\xa5\x04=?\n\x0c\n\x04\x04\x17\x02.\x12\x04\xa6\x04\x08A\n\r\n\x05\
    \x04\x17\x02.\x04\x12\x04\xa6\x04\x08\x10\n\r\n\x05\x04\x17\x02.\x06\x12\
    \x04\xa6\x04\x11.\n\r\n\x05\x04\x17\x02.\x01\x12\x04\xa6\x04/;\n\r\n\x05\
    \x04\x17\x02.\x03\x12\x04\xa6\x04>@\n\x0c\n\x04\x04\x17\x02/\x12\x04\xa7\
    \x04\x08=\n\r\n\x05\x04\x17\x02/\x04\x12\x04\xa7\x04\x08\x10\n\r\n\x05\
    \x04\x17\x02/\x06\x12\x04\xa7\x04\x11.\n\r\n\x05\x04\x17\x02/\x01\x12\
    \x04\xa7\x04/7\n\r\n\x05\x04\x17\x02/\x03\x12\x04\xa7\x04:<\n\x0c\n\x04\
    \x04\x17\x020\x12\x04\xa8\x04\x08>\n\r\n\x05\x04\x17\x020\x04\x12\x04\
    \xa8\x04\x08\x10\n\r\n\x05\x04\x17\x020\x06\x12\x04\xa8\x04\x11.\n\r\n\
    \x05\x04\x17\x020\x01\x12\x04\xa8\x04/8\n\r\n\x05\x04\x17\x020\x03\x12\
    \x04\xa8\x04;=\n\x0c\n\x04\x04\x17\x021\x12\x04\xa9\x04\x08B\n\r\n\x05\
    \x04\x17\x021\x04\x12\x04\xa9\x04\x08\x10\n\r\n\x05\x04\x17\x021\x06\x12\
    \x04\xa9\x04\x11.\n\r\n\x05\x04\x17\x021\x01\x12\x04\xa9\x04/<\n\r\n\x05\
    \x04\x17\x021\x03\x12\x04\xa9\x04?A\n\x0c\n\x02\x04\x18\x12\x06\xac\x04\
    \0\xc0\x04\x01\n\x0b\n\x03\x04\x18\x01\x12\x04\xac\x04\x08\x16\n\x0e\n\
    \x04\x04\x18\x03\0\x12\x06\xad\x04\x08\xb0\x04\t\n\r\n\x05\x04\x18\x03\0\
    \x01\x12\x04\xad\x04\x10\x1e\n\x0e\n\x06\x04\x18\x03\0\x02\0\x12\x04\xae\
    \x04\x10+\n\x0f\n\x07\x04\x18\x03\0\x02\0\x04\x12\x04\xae\x04\x10\x18\n\
    \x0f\n\x07\x04\x18\x03\0\x02\0\x05\x12\x04\xae\x04\x19\x1f\n\x0f\n\x07\
    \x04\x18\x03\0\x02\0\x01\x12\x04\xae\x04\x20&\n\x0f\n\x07\x04\x18\x03\0\
    \x02\0\x03\x12\x04\xae\x04)*\n\x0e\n\x06\x04\x18\x03\0\x02\x01\x12\x04\
    \xaf\x04\x10+\n\x0f\n\x07\x04\x18\x03\0\x02\x01\x04\x12\x04\xaf\x04\x10\
    \x18\n\x0f\n\x07\x04\x18\x03\0\x02\x01\x05\x12\x04\xaf\x04\x19\x1f\n\x0f\
    \n\x07\x04\x18\x03\0\x02\x01\x01\x12\x04\xaf\x04\x20&\n\x0f\n\x07\x04\
    \x18\x03\0\x02\x01\x03\x12\x04\xaf\x04)*\n\x0e\n\x04\x04\x18\x03\x01\x12\
    \x06\xb2\x04\x08\xb4\x04\t\n\r\n\x05\x04\x18\x03\x01\x01\x12\x04\xb2\x04\
    \x10!\n\x0e\n\x06\x04\x18\x03\x01\x02\0\x12\x04\xb3\x04\x10M\n\x0f\n\x07\
    \x04\x18\x03\x01\x02\0\x04\x12\x04\xb3\x04\x10\x18\n\x0f\n\x07\x04\x18\
    \x03\x01\x02\0\x06\x12\x04\xb3\x04\x197\n\x0f\n\x07\x04\x18\x03\x01\x02\
    \0\x01\x12\x04\xb3\x048H\n\x0f\n\x07\x04\x18\x03\x01\x02\0\x03\x12\x04\
    \xb3\x04KL\n\x0c\n\x04\x04\x18\x02\0\x12\x04\xb6\x04\x080\n\r\n\x05\x04\
    \x18\x02\0\x04\x12\x04\xb6\x04\x08\x10\n\r\n\x05\x04\x18\x02\0\x06\x12\
    \x04\xb6\x04\x11$\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\xb6\x04%+\n\r\n\
    \x05\x04\x18\x02\0\x03\x12\x04\xb6\x04./\n\x0c\n\x04\x04\x18\x02\x01\x12\
    \x04\xb7\x04\x08-\n\r\n\x05\x04\x18\x02\x01\x04\x12\x04\xb7\x04\x08\x10\
    \n\r\n\x05\x04\x18\x02\x01\x05\x12\x04\xb7\x04\x11\x17\n\r\n\x05\x04\x18\
    \x02\x01\x01\x12\x04\xb7\x04\x18(\n\r\n\x05\x04\x18\x02\x01\x03\x12\x04\
    \xb7\x04+,\n\x0c\n\x04\x04\x18\x02\x02\x12\x04\xb8\x04\x08+\n\r\n\x05\
    \x04\x18\x02\x02\x04\x12\x04\xb8\x04\x08\x10\n\r\n\x05\x04\x18\x02\x02\
    \x05\x12\x04\xb8\x04\x11\x17\n\r\n\x05\x04\x18\x02\x02\x01\x12\x04\xb8\
    \x04\x18&\n\r\n\x05\x04\x18\x02\x02\x03\x12\x04\xb8\x04)*\n\x0c\n\x04\
    \x04\x18\x02\x03\x12\x04\xb9\x04\x080\n\r\n\x05\x04\x18\x02\x03\x04\x12\
    \x04\xb9\x04\x08\x10\n\r\n\x05\x04\x18\x02\x03\x05\x12\x04\xb9\x04\x11\
    \x17\n\r\n\x05\x04\x18\x02\x03\x01\x12\x04\xb9\x04\x18+\n\r\n\x05\x04\
    \x18\x02\x03\x03\x12\x04\xb9\x04./\n\x0c\n\x04\x04\x18\x02\x04\x12\x04\
    \xba\x04\x08C\n\r\n\x05\x04\x18\x02\x04\x04\x12\x04\xba\x04\x08\x10\n\r\
    \n\x05\x04\x18\x02\x04\x06\x12\x04\xba\x04\x112\n\r\n\x05\x04\x18\x02\
    \x04\x01\x12\x04\xba\x043>\n\r\n\x05\x04\x18\x02\x04\x03\x12\x04\xba\x04\
    AB\n\x0c\n\x04\x04\x18\x02\x05\x12\x04\xbb\x04\x08G\n\r\n\x05\x04\x18\
    \x02\x05\x04\x12\x04\xbb\x04\x08\x10\n\r\n\x05\x04\x18\x02\x05\x06\x12\
    \x04\xbb\x04\x112\n\r\n\x05\x04\x18\x02\x05\x01\x12\x04\xbb\x043B\n\r\n\
    \x05\x04\x18\x02\x05\x03\x12\x04\xbb\x04EF\n\x0c\n\x04\x04\x18\x02\x06\
    \x12\x04\xbc\x04\x08M\n\r\n\x05\x04\x18\x02\x06\x04\x12\x04\xbc\x04\x08\
    \x10\n\r\n\x05\x04\x18\x02\x06\x06\x12\x04\xbc\x04\x112\n\r\n\x05\x04\
    \x18\x02\x06\x01\x12\x04\xbc\x043H\n\r\n\x05\x04\x18\x02\x06\x03\x12\x04\
    \xbc\x04KL\n\x0c\n\x04\x04\x18\x02\x07\x12\x04\xbd\x04\x08)\n\r\n\x05\
    \x04\x18\x02\x07\x04\x12\x04\xbd\x04\x08\x10\n\r\n\x05\x04\x18\x02\x07\
    \x05\x12\x04\xbd\x04\x11\x17\n\r\n\x05\x04\x18\x02\x07\x01\x12\x04\xbd\
    \x04\x18$\n\r\n\x05\x04\x18\x02\x07\x03\x12\x04\xbd\x04'(\n\x0c\n\x04\
    \x04\x18\x02\x08\x12\x04\xbe\x04\x08*\n\r\n\x05\x04\x18\x02\x08\x04\x12\
    \x04\xbe\x04\x08\x10\n\r\n\x05\x04\x18\x02\x08\x05\x12\x04\xbe\x04\x11\
    \x17\n\r\n\x05\x04\x18\x02\x08\x01\x12\x04\xbe\x04\x18%\n\r\n\x05\x04\
    \x18\x02\x08\x03\x12\x04\xbe\x04()\n\x0c\n\x04\x04\x18\x02\t\x12\x04\xbf\
    \x04\x08*\n\r\n\x05\x04\x18\x02\t\x04\x12\x04\xbf\x04\x08\x10\n\r\n\x05\
    \x04\x18\x02\t\x05\x12\x04\xbf\x04\x11\x17\n\r\n\x05\x04\x18\x02\t\x01\
    \x12\x04\xbf\x04\x18$\n\r\n\x05\x04\x18\x02\t\x03\x12\x04\xbf\x04')\n\
    \x0c\n\x02\x04\x19\x12\x06\xc2\x04\0\xc5\x04\x01\n\x0b\n\x03\x04\x19\x01\
    \x12\x04\xc2\x04\x08+\n\r\n\x04\x04\x19\x02\0\x12\x05\xc3\x04\x08\xbb\
    \x01\n\r\n\x05\x04\x19\x02\0\x04\x12\x04\xc3\x04\x08\x10\n\r\n\x05\x04\
    \x19\x02\0\x05\x12\x04\xc3\x04\x11\x17\n\r\n\x05\x04\x19\x02\0\x01\x12\
    \x04\xc3\x04\x181\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\xc3\x0445\n\x0e\n\
    \x05\x04\x19\x02\0\x08\x12\x05\xc3\x046\xba\x01\n\r\n\x05\x04\x19\x02\0\
    \x07\x12\x04\xc3\x04AB\n\x10\n\x08\x04\x19\x02\0\x08\xf4\xa2\x04\x12\x04\
    \xc3\x04De\n\x11\n\x08\x04\x19\x02\0\x08\xf5\xa2\x04\x12\x05\xc3\x04g\
    \xb9\x01\n\r\n\x04\x04\x19\x02\x01\x12\x05\xc4\x04\x08\xc9\x01\n\r\n\x05\
    \x04\x19\x02\x01\x04\x12\x04\xc4\x04\x08\x10\n\r\n\x05\x04\x19\x02\x01\
    \x06\x12\x04\xc4\x04\x11\x20\n\r\n\x05\x04\x19\x02\x01\x01\x12\x04\xc4\
    \x04!2\n\r\n\x05\x04\x19\x02\x01\x03\x12\x04\xc4\x0456\n\x0e\n\x05\x04\
    \x19\x02\x01\x08\x12\x05\xc4\x047\xc8\x01\n\x10\n\x08\x04\x19\x02\x01\
    \x08\xf0\xa2\x04\x12\x04\xc4\x048^\n\x10\n\x08\x04\x19\x02\x01\x08\xf4\
    \xa2\x04\x12\x04\xc4\x04`~\n\x12\n\x08\x04\x19\x02\x01\x08\xf5\xa2\x04\
    \x12\x06\xc4\x04\x80\x01\xc7\x01\n\x0c\n\x02\x04\x1a\x12\x06\xc7\x04\0\
    \xca\x04\x01\n\x0b\n\x03\x04\x1a\x01\x12\x04\xc7\x04\x08'\n\x0c\n\x04\
    \x04\x1a\x02\0\x12\x04\xc8\x04\x08|\n\r\n\x05\x04\x1a\x02\0\x04\x12\x04\
    \xc8\x04\x08\x10\n\r\n\x05\x04\x1a\x02\0\x06\x12\x04\xc8\x04\x11\"\n\r\n\
    \x05\x04\x1a\x02\0\x01\x12\x04\xc8\x04#,\n\r\n\x05\x04\x1a\x02\0\x03\x12\
    \x04\xc8\x04/0\n\r\n\x05\x04\x1a\x02\0\x08\x12\x04\xc8\x041{\n\r\n\x05\
    \x04\x1a\x02\0\x07\x12\x04\xc8\x04<?\n\x10\n\x08\x04\x1a\x02\0\x08\xf4\
    \xa2\x04\x12\x04\xc8\x04AY\n\x10\n\x08\x04\x1a\x02\0\x08\xf5\xa2\x04\x12\
    \x04\xc8\x04[z\n\r\n\x04\x04\x1a\x02\x01\x12\x05\xc9\x04\x08\x98\x01\n\r\
    \n\x05\x04\x1a\x02\x01\x04\x12\x04\xc9\x04\x08\x10\n\r\n\x05\x04\x1a\x02\
    \x01\x06\x12\x04\xc9\x04\x11+\n\r\n\x05\x04\x1a\x02\x01\x01\x12\x04\xc9\
    \x04,:\n\r\n\x05\x04\x1a\x02\x01\x03\x12\x04\xc9\x04=>\n\x0e\n\x05\x04\
    \x1a\x02\x01\x08\x12\x05\xc9\x04?\x97\x01\n\x10\n\x08\x04\x1a\x02\x01\
    \x08\xf4\xa2\x04\x12\x04\xc9\x04@[\n\x11\n\x08\x04\x1a\x02\x01\x08\xf5\
    \xa2\x04\x12\x05\xc9\x04]\x96\x01\n\x0c\n\x02\x04\x1b\x12\x06\xcc\x04\0\
    \xd1\x04\x01\n\x0b\n\x03\x04\x1b\x01\x12\x04\xcc\x04\x08!\n\x0e\n\x04\
    \x04\x1b\x08\0\x12\x06\xcd\x04\x08\xd0\x04\t\n\r\n\x05\x04\x1b\x08\0\x01\
    \x12\x04\xcd\x04\x0e\x17\n\r\n\x04\x04\x1b\x02\0\x12\x05\xce\x04\x10\xbd\
    \x01\n\r\n\x05\x04\x1b\x02\0\x06\x12\x04\xce\x04\x104\n\r\n\x05\x04\x1b\
    \x02\0\x01\x12\x04\xce\x045?\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\xce\x04\
    BC\n\x0e\n\x05\x04\x1b\x02\0\x08\x12\x05\xce\x04D\xbc\x01\n\x10\n\x08\
    \x04\x1b\x02\0\x08\xf4\xa2\x04\x12\x04\xce\x04El\n\x11\n\x08\x04\x1b\x02\
    \0\x08\xf5\xa2\x04\x12\x05\xce\x04n\xbb\x01\n\r\n\x04\x04\x1b\x02\x01\
    \x12\x05\xcf\x04\x10\xb0\x01\n\r\n\x05\x04\x1b\x02\x01\x06\x12\x04\xcf\
    \x04\x100\n\r\n\x05\x04\x1b\x02\x01\x01\x12\x04\xcf\x0418\n\r\n\x05\x04\
    \x1b\x02\x01\x03\x12\x04\xcf\x04;<\n\x0e\n\x05\x04\x1b\x02\x01\x08\x12\
    \x05\xcf\x04=\xaf\x01\n\x10\n\x08\x04\x1b\x02\x01\x08\xf4\xa2\x04\x12\
    \x04\xcf\x04>b\n\x11\n\x08\x04\x1b\x02\x01\x08\xf5\xa2\x04\x12\x05\xcf\
    \x04d\xae\x01\n\x0c\n\x02\x04\x1c\x12\x06\xd3\x04\0\xd5\x04\x01\n\x0b\n\
    \x03\x04\x1c\x01\x12\x04\xd3\x04\x08\x16\n\x0c\n\x04\x04\x1c\x02\0\x12\
    \x04\xd4\x04\x080\n\r\n\x05\x04\x1c\x02\0\x04\x12\x04\xd4\x04\x08\x10\n\
    \r\n\x05\x04\x1c\x02\0\x06\x12\x04\xd4\x04\x11$\n\r\n\x05\x04\x1c\x02\0\
    \x01\x12\x04\xd4\x04%+\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xd4\x04./\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(::protobuf::descriptor::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(38);
            messages.push(CMsgFieldID::generated_message_descriptor_data());
            messages.push(CMsgUniversalFieldID::generated_message_descriptor_data());
            messages.push(CMsgVariableDefinition::generated_message_descriptor_data());
            messages.push(CMsgProtoDefHeader::generated_message_descriptor_data());
            messages.push(CMsgValidTypes::generated_message_descriptor_data());
            messages.push(CMsgProtoDefID::generated_message_descriptor_data());
            messages.push(CMsgQuestObjectiveDef::generated_message_descriptor_data());
            messages.push(CMsgQuestDef::generated_message_descriptor_data());
            messages.push(CMsgQuestMapStoreItem::generated_message_descriptor_data());
            messages.push(CMsgQuestMapRegionDef::generated_message_descriptor_data());
            messages.push(CMsgVarField::generated_message_descriptor_data());
            messages.push(CMsgQuestMapStarType::generated_message_descriptor_data());
            messages.push(CMsgQuestMapNodeDef::generated_message_descriptor_data());
            messages.push(CMsgPaintKit_Variables::generated_message_descriptor_data());
            messages.push(CMsgPaintKit_Operation_TextureStage::generated_message_descriptor_data());
            messages.push(CMsgPaintKit_Operation_CombineStage::generated_message_descriptor_data());
            messages.push(CMsgPaintKit_Operation_SelectStage::generated_message_descriptor_data());
            messages.push(CMsgPaintKit_Operation_Sticker::generated_message_descriptor_data());
            messages.push(CMsgPaintKit_Operation_StickerStage::generated_message_descriptor_data());
            messages.push(CMsgPaintKit_OperationStage::generated_message_descriptor_data());
            messages.push(CMsgPaintKit_OperationNode::generated_message_descriptor_data());
            messages.push(CMsgPaintKit_Operation::generated_message_descriptor_data());
            messages.push(CMsgPaintKit_ItemDefinition::generated_message_descriptor_data());
            messages.push(CMsgPaintKit_Definition::generated_message_descriptor_data());
            messages.push(CMsgQuestTheme::generated_message_descriptor_data());
            messages.push(CMsgQuestMapNodeCondition_NodeState::generated_message_descriptor_data());
            messages.push(CMsgQuestMapNodeCondition_Logic::generated_message_descriptor_data());
            messages.push(CMsgQuestMapNodeCondition::generated_message_descriptor_data());
            messages.push(CMsgHeaderOnly::generated_message_descriptor_data());
            messages.push(cmsg_field_id::CMsgField::generated_message_descriptor_data());
            messages.push(cmsg_quest_def::MMCriteria::generated_message_descriptor_data());
            messages.push(cmsg_quest_def::ObjectiveInstance::generated_message_descriptor_data());
            messages.push(cmsg_quest_map_region_def::RegionLink::generated_message_descriptor_data());
            messages.push(cmsg_paint_kit_item_definition::Definition::generated_message_descriptor_data());
            messages.push(cmsg_paint_kit_definition::Item::generated_message_descriptor_data());
            messages.push(cmsg_paint_kit_definition::item::ItemData::generated_message_descriptor_data());
            messages.push(cmsg_quest_theme::WeightedString::generated_message_descriptor_data());
            messages.push(cmsg_quest_theme::WeightedStringSet::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(9);
            enums.push(LogicalOperation::generated_enum_descriptor_data());
            enums.push(EValueDefinitionSource::generated_enum_descriptor_data());
            enums.push(ProtoDefTypes::generated_enum_descriptor_data());
            enums.push(EQuestPoints::generated_enum_descriptor_data());
            enums.push(EVarFieldType::generated_enum_descriptor_data());
            enums.push(ENodeCashReward::generated_enum_descriptor_data());
            enums.push(cmsg_quest_objective_def::ETF2GameModes::generated_enum_descriptor_data());
            enums.push(cmsg_quest_objective_def::ETF2Conditions::generated_enum_descriptor_data());
            enums.push(cmsg_quest_objective_def::ETF2Team::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
