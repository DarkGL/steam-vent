// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `tf2/gcsdk_gcmessages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:CMsgSOIDOwner)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOIDOwner {
    // message fields
    // @@protoc_insertion_point(field:CMsgSOIDOwner.type)
    pub type_: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSOIDOwner.id)
    pub id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSOIDOwner.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOIDOwner {
    fn default() -> &'a CMsgSOIDOwner {
        <CMsgSOIDOwner as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOIDOwner {
    pub fn new() -> CMsgSOIDOwner {
        ::std::default::Default::default()
    }

    // optional uint32 type = 1;

    pub fn type_(&self) -> u32 {
        self.type_.unwrap_or(0)
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: u32) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // optional uint64 id = 2;

    pub fn id(&self) -> u64 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CMsgSOIDOwner| { &m.type_ },
            |m: &mut CMsgSOIDOwner| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &CMsgSOIDOwner| { &m.id },
            |m: &mut CMsgSOIDOwner| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSOIDOwner>(
            "CMsgSOIDOwner",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSOIDOwner {
    const NAME: &'static str = "CMsgSOIDOwner";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOIDOwner {
        CMsgSOIDOwner::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOIDOwner {
        static instance: CMsgSOIDOwner = CMsgSOIDOwner {
            type_: ::std::option::Option::None,
            id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSOIDOwner {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSOIDOwner").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSOIDOwner {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOIDOwner {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSOSingleObject)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOSingleObject {
    // message fields
    // @@protoc_insertion_point(field:CMsgSOSingleObject.owner)
    pub owner: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSOSingleObject.type_id)
    pub type_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSOSingleObject.object_data)
    pub object_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgSOSingleObject.version)
    pub version: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSOSingleObject.owner_soid)
    pub owner_soid: ::protobuf::MessageField<CMsgSOIDOwner>,
    // @@protoc_insertion_point(field:CMsgSOSingleObject.service_id)
    pub service_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSOSingleObject.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOSingleObject {
    fn default() -> &'a CMsgSOSingleObject {
        <CMsgSOSingleObject as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOSingleObject {
    pub fn new() -> CMsgSOSingleObject {
        ::std::default::Default::default()
    }

    // optional fixed64 owner = 1;

    pub fn owner(&self) -> u64 {
        self.owner.unwrap_or(0)
    }

    pub fn clear_owner(&mut self) {
        self.owner = ::std::option::Option::None;
    }

    pub fn has_owner(&self) -> bool {
        self.owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: u64) {
        self.owner = ::std::option::Option::Some(v);
    }

    // optional int32 type_id = 2;

    pub fn type_id(&self) -> i32 {
        self.type_id.unwrap_or(0)
    }

    pub fn clear_type_id(&mut self) {
        self.type_id = ::std::option::Option::None;
    }

    pub fn has_type_id(&self) -> bool {
        self.type_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type_id(&mut self, v: i32) {
        self.type_id = ::std::option::Option::Some(v);
    }

    // optional bytes object_data = 3;

    pub fn object_data(&self) -> &[u8] {
        match self.object_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_object_data(&mut self) {
        self.object_data = ::std::option::Option::None;
    }

    pub fn has_object_data(&self) -> bool {
        self.object_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_object_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.object_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.object_data.is_none() {
            self.object_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.object_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_object_data(&mut self) -> ::std::vec::Vec<u8> {
        self.object_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed64 version = 4;

    pub fn version(&self) -> u64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 service_id = 6;

    pub fn service_id(&self) -> u32 {
        self.service_id.unwrap_or(0)
    }

    pub fn clear_service_id(&mut self) {
        self.service_id = ::std::option::Option::None;
    }

    pub fn has_service_id(&self) -> bool {
        self.service_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service_id(&mut self, v: u32) {
        self.service_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "owner",
            |m: &CMsgSOSingleObject| { &m.owner },
            |m: &mut CMsgSOSingleObject| { &mut m.owner },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type_id",
            |m: &CMsgSOSingleObject| { &m.type_id },
            |m: &mut CMsgSOSingleObject| { &mut m.type_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "object_data",
            |m: &CMsgSOSingleObject| { &m.object_data },
            |m: &mut CMsgSOSingleObject| { &mut m.object_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgSOSingleObject| { &m.version },
            |m: &mut CMsgSOSingleObject| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSOIDOwner>(
            "owner_soid",
            |m: &CMsgSOSingleObject| { &m.owner_soid },
            |m: &mut CMsgSOSingleObject| { &mut m.owner_soid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "service_id",
            |m: &CMsgSOSingleObject| { &m.service_id },
            |m: &mut CMsgSOSingleObject| { &mut m.service_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSOSingleObject>(
            "CMsgSOSingleObject",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSOSingleObject {
    const NAME: &'static str = "CMsgSOSingleObject";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.owner = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.type_id = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.object_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                33 => {
                    self.version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.owner_soid)?;
                },
                48 => {
                    self.service_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.owner {
            my_size += 1 + 8;
        }
        if let Some(v) = self.type_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.object_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.version {
            my_size += 1 + 8;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.service_id {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.owner {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.type_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.object_data.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.version {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.service_id {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOSingleObject {
        CMsgSOSingleObject::new()
    }

    fn clear(&mut self) {
        self.owner = ::std::option::Option::None;
        self.type_id = ::std::option::Option::None;
        self.object_data = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.owner_soid.clear();
        self.service_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOSingleObject {
        static instance: CMsgSOSingleObject = CMsgSOSingleObject {
            owner: ::std::option::Option::None,
            type_id: ::std::option::Option::None,
            object_data: ::std::option::Option::None,
            version: ::std::option::Option::None,
            owner_soid: ::protobuf::MessageField::none(),
            service_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSOSingleObject {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSOSingleObject").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSOSingleObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOSingleObject {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSOMultipleObjects)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOMultipleObjects {
    // message fields
    // @@protoc_insertion_point(field:CMsgSOMultipleObjects.owner)
    pub owner: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSOMultipleObjects.objects)
    pub objects: ::std::vec::Vec<cmsg_somultiple_objects::SingleObject>,
    // @@protoc_insertion_point(field:CMsgSOMultipleObjects.version)
    pub version: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSOMultipleObjects.owner_soid)
    pub owner_soid: ::protobuf::MessageField<CMsgSOIDOwner>,
    // @@protoc_insertion_point(field:CMsgSOMultipleObjects.service_id)
    pub service_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSOMultipleObjects.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOMultipleObjects {
    fn default() -> &'a CMsgSOMultipleObjects {
        <CMsgSOMultipleObjects as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOMultipleObjects {
    pub fn new() -> CMsgSOMultipleObjects {
        ::std::default::Default::default()
    }

    // optional fixed64 owner = 1;

    pub fn owner(&self) -> u64 {
        self.owner.unwrap_or(0)
    }

    pub fn clear_owner(&mut self) {
        self.owner = ::std::option::Option::None;
    }

    pub fn has_owner(&self) -> bool {
        self.owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: u64) {
        self.owner = ::std::option::Option::Some(v);
    }

    // optional fixed64 version = 3;

    pub fn version(&self) -> u64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 service_id = 7;

    pub fn service_id(&self) -> u32 {
        self.service_id.unwrap_or(0)
    }

    pub fn clear_service_id(&mut self) {
        self.service_id = ::std::option::Option::None;
    }

    pub fn has_service_id(&self) -> bool {
        self.service_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service_id(&mut self, v: u32) {
        self.service_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "owner",
            |m: &CMsgSOMultipleObjects| { &m.owner },
            |m: &mut CMsgSOMultipleObjects| { &mut m.owner },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "objects",
            |m: &CMsgSOMultipleObjects| { &m.objects },
            |m: &mut CMsgSOMultipleObjects| { &mut m.objects },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgSOMultipleObjects| { &m.version },
            |m: &mut CMsgSOMultipleObjects| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSOIDOwner>(
            "owner_soid",
            |m: &CMsgSOMultipleObjects| { &m.owner_soid },
            |m: &mut CMsgSOMultipleObjects| { &mut m.owner_soid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "service_id",
            |m: &CMsgSOMultipleObjects| { &m.service_id },
            |m: &mut CMsgSOMultipleObjects| { &mut m.service_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSOMultipleObjects>(
            "CMsgSOMultipleObjects",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSOMultipleObjects {
    const NAME: &'static str = "CMsgSOMultipleObjects";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.owner = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.objects.push(is.read_message()?);
                },
                25 => {
                    self.version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.owner_soid)?;
                },
                56 => {
                    self.service_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.owner {
            my_size += 1 + 8;
        }
        for value in &self.objects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.version {
            my_size += 1 + 8;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.service_id {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.owner {
            os.write_fixed64(1, v)?;
        }
        for v in &self.objects {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.version {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.service_id {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOMultipleObjects {
        CMsgSOMultipleObjects::new()
    }

    fn clear(&mut self) {
        self.owner = ::std::option::Option::None;
        self.objects.clear();
        self.version = ::std::option::Option::None;
        self.owner_soid.clear();
        self.service_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOMultipleObjects {
        static instance: CMsgSOMultipleObjects = CMsgSOMultipleObjects {
            owner: ::std::option::Option::None,
            objects: ::std::vec::Vec::new(),
            version: ::std::option::Option::None,
            owner_soid: ::protobuf::MessageField::none(),
            service_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSOMultipleObjects {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSOMultipleObjects").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSOMultipleObjects {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOMultipleObjects {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSOMultipleObjects`
pub mod cmsg_somultiple_objects {
    // @@protoc_insertion_point(message:CMsgSOMultipleObjects.SingleObject)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SingleObject {
        // message fields
        // @@protoc_insertion_point(field:CMsgSOMultipleObjects.SingleObject.type_id)
        pub type_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSOMultipleObjects.SingleObject.object_data)
        pub object_data: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSOMultipleObjects.SingleObject.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SingleObject {
        fn default() -> &'a SingleObject {
            <SingleObject as ::protobuf::Message>::default_instance()
        }
    }

    impl SingleObject {
        pub fn new() -> SingleObject {
            ::std::default::Default::default()
        }

        // optional int32 type_id = 1;

        pub fn type_id(&self) -> i32 {
            self.type_id.unwrap_or(0)
        }

        pub fn clear_type_id(&mut self) {
            self.type_id = ::std::option::Option::None;
        }

        pub fn has_type_id(&self) -> bool {
            self.type_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type_id(&mut self, v: i32) {
            self.type_id = ::std::option::Option::Some(v);
        }

        // optional bytes object_data = 2;

        pub fn object_data(&self) -> &[u8] {
            match self.object_data.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_object_data(&mut self) {
            self.object_data = ::std::option::Option::None;
        }

        pub fn has_object_data(&self) -> bool {
            self.object_data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_object_data(&mut self, v: ::std::vec::Vec<u8>) {
            self.object_data = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_object_data(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.object_data.is_none() {
                self.object_data = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.object_data.as_mut().unwrap()
        }

        // Take field
        pub fn take_object_data(&mut self) -> ::std::vec::Vec<u8> {
            self.object_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "type_id",
                |m: &SingleObject| { &m.type_id },
                |m: &mut SingleObject| { &mut m.type_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "object_data",
                |m: &SingleObject| { &m.object_data },
                |m: &mut SingleObject| { &mut m.object_data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleObject>(
                "CMsgSOMultipleObjects.SingleObject",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SingleObject {
        const NAME: &'static str = "SingleObject";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.object_data = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_id {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.object_data.as_ref() {
                my_size += ::protobuf::rt::bytes_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.type_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.object_data.as_ref() {
                os.write_bytes(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SingleObject {
            SingleObject::new()
        }

        fn clear(&mut self) {
            self.type_id = ::std::option::Option::None;
            self.object_data = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SingleObject {
            static instance: SingleObject = SingleObject {
                type_id: ::std::option::Option::None,
                object_data: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SingleObject {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSOMultipleObjects.SingleObject").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SingleObject {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SingleObject {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgSOCacheSubscribed)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOCacheSubscribed {
    // message fields
    // @@protoc_insertion_point(field:CMsgSOCacheSubscribed.owner)
    pub owner: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSOCacheSubscribed.objects)
    pub objects: ::std::vec::Vec<cmsg_socache_subscribed::SubscribedType>,
    // @@protoc_insertion_point(field:CMsgSOCacheSubscribed.version)
    pub version: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSOCacheSubscribed.owner_soid)
    pub owner_soid: ::protobuf::MessageField<CMsgSOIDOwner>,
    // @@protoc_insertion_point(field:CMsgSOCacheSubscribed.service_id)
    pub service_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSOCacheSubscribed.service_list)
    pub service_list: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSOCacheSubscribed.sync_version)
    pub sync_version: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSOCacheSubscribed.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheSubscribed {
    fn default() -> &'a CMsgSOCacheSubscribed {
        <CMsgSOCacheSubscribed as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheSubscribed {
    pub fn new() -> CMsgSOCacheSubscribed {
        ::std::default::Default::default()
    }

    // optional fixed64 owner = 1;

    pub fn owner(&self) -> u64 {
        self.owner.unwrap_or(0)
    }

    pub fn clear_owner(&mut self) {
        self.owner = ::std::option::Option::None;
    }

    pub fn has_owner(&self) -> bool {
        self.owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: u64) {
        self.owner = ::std::option::Option::Some(v);
    }

    // optional fixed64 version = 3;

    pub fn version(&self) -> u64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 service_id = 5;

    pub fn service_id(&self) -> u32 {
        self.service_id.unwrap_or(0)
    }

    pub fn clear_service_id(&mut self) {
        self.service_id = ::std::option::Option::None;
    }

    pub fn has_service_id(&self) -> bool {
        self.service_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service_id(&mut self, v: u32) {
        self.service_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 sync_version = 7;

    pub fn sync_version(&self) -> u64 {
        self.sync_version.unwrap_or(0)
    }

    pub fn clear_sync_version(&mut self) {
        self.sync_version = ::std::option::Option::None;
    }

    pub fn has_sync_version(&self) -> bool {
        self.sync_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sync_version(&mut self, v: u64) {
        self.sync_version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "owner",
            |m: &CMsgSOCacheSubscribed| { &m.owner },
            |m: &mut CMsgSOCacheSubscribed| { &mut m.owner },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "objects",
            |m: &CMsgSOCacheSubscribed| { &m.objects },
            |m: &mut CMsgSOCacheSubscribed| { &mut m.objects },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgSOCacheSubscribed| { &m.version },
            |m: &mut CMsgSOCacheSubscribed| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSOIDOwner>(
            "owner_soid",
            |m: &CMsgSOCacheSubscribed| { &m.owner_soid },
            |m: &mut CMsgSOCacheSubscribed| { &mut m.owner_soid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "service_id",
            |m: &CMsgSOCacheSubscribed| { &m.service_id },
            |m: &mut CMsgSOCacheSubscribed| { &mut m.service_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "service_list",
            |m: &CMsgSOCacheSubscribed| { &m.service_list },
            |m: &mut CMsgSOCacheSubscribed| { &mut m.service_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sync_version",
            |m: &CMsgSOCacheSubscribed| { &m.sync_version },
            |m: &mut CMsgSOCacheSubscribed| { &mut m.sync_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSOCacheSubscribed>(
            "CMsgSOCacheSubscribed",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSOCacheSubscribed {
    const NAME: &'static str = "CMsgSOCacheSubscribed";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.owner = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.objects.push(is.read_message()?);
                },
                25 => {
                    self.version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.owner_soid)?;
                },
                40 => {
                    self.service_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    is.read_repeated_packed_uint32_into(&mut self.service_list)?;
                },
                48 => {
                    self.service_list.push(is.read_uint32()?);
                },
                57 => {
                    self.sync_version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.owner {
            my_size += 1 + 8;
        }
        for value in &self.objects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.version {
            my_size += 1 + 8;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.service_id {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        for value in &self.service_list {
            my_size += ::protobuf::rt::uint32_size(6, *value);
        };
        if let Some(v) = self.sync_version {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.owner {
            os.write_fixed64(1, v)?;
        }
        for v in &self.objects {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.version {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.service_id {
            os.write_uint32(5, v)?;
        }
        for v in &self.service_list {
            os.write_uint32(6, *v)?;
        };
        if let Some(v) = self.sync_version {
            os.write_fixed64(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOCacheSubscribed {
        CMsgSOCacheSubscribed::new()
    }

    fn clear(&mut self) {
        self.owner = ::std::option::Option::None;
        self.objects.clear();
        self.version = ::std::option::Option::None;
        self.owner_soid.clear();
        self.service_id = ::std::option::Option::None;
        self.service_list.clear();
        self.sync_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOCacheSubscribed {
        static instance: CMsgSOCacheSubscribed = CMsgSOCacheSubscribed {
            owner: ::std::option::Option::None,
            objects: ::std::vec::Vec::new(),
            version: ::std::option::Option::None,
            owner_soid: ::protobuf::MessageField::none(),
            service_id: ::std::option::Option::None,
            service_list: ::std::vec::Vec::new(),
            sync_version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSOCacheSubscribed {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSOCacheSubscribed").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSOCacheSubscribed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOCacheSubscribed {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSOCacheSubscribed`
pub mod cmsg_socache_subscribed {
    // @@protoc_insertion_point(message:CMsgSOCacheSubscribed.SubscribedType)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SubscribedType {
        // message fields
        // @@protoc_insertion_point(field:CMsgSOCacheSubscribed.SubscribedType.type_id)
        pub type_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSOCacheSubscribed.SubscribedType.object_data)
        pub object_data: ::std::vec::Vec<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSOCacheSubscribed.SubscribedType.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SubscribedType {
        fn default() -> &'a SubscribedType {
            <SubscribedType as ::protobuf::Message>::default_instance()
        }
    }

    impl SubscribedType {
        pub fn new() -> SubscribedType {
            ::std::default::Default::default()
        }

        // optional int32 type_id = 1;

        pub fn type_id(&self) -> i32 {
            self.type_id.unwrap_or(0)
        }

        pub fn clear_type_id(&mut self) {
            self.type_id = ::std::option::Option::None;
        }

        pub fn has_type_id(&self) -> bool {
            self.type_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type_id(&mut self, v: i32) {
            self.type_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "type_id",
                |m: &SubscribedType| { &m.type_id },
                |m: &mut SubscribedType| { &mut m.type_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "object_data",
                |m: &SubscribedType| { &m.object_data },
                |m: &mut SubscribedType| { &mut m.object_data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscribedType>(
                "CMsgSOCacheSubscribed.SubscribedType",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SubscribedType {
        const NAME: &'static str = "SubscribedType";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.object_data.push(is.read_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_id {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            for value in &self.object_data {
                my_size += ::protobuf::rt::bytes_size(2, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.type_id {
                os.write_int32(1, v)?;
            }
            for v in &self.object_data {
                os.write_bytes(2, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SubscribedType {
            SubscribedType::new()
        }

        fn clear(&mut self) {
            self.type_id = ::std::option::Option::None;
            self.object_data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SubscribedType {
            static instance: SubscribedType = SubscribedType {
                type_id: ::std::option::Option::None,
                object_data: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SubscribedType {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSOCacheSubscribed.SubscribedType").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SubscribedType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SubscribedType {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgSOCacheSubscribedUpToDate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOCacheSubscribedUpToDate {
    // message fields
    // @@protoc_insertion_point(field:CMsgSOCacheSubscribedUpToDate.version)
    pub version: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSOCacheSubscribedUpToDate.owner_soid)
    pub owner_soid: ::protobuf::MessageField<CMsgSOIDOwner>,
    // @@protoc_insertion_point(field:CMsgSOCacheSubscribedUpToDate.service_id)
    pub service_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSOCacheSubscribedUpToDate.service_list)
    pub service_list: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSOCacheSubscribedUpToDate.sync_version)
    pub sync_version: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSOCacheSubscribedUpToDate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheSubscribedUpToDate {
    fn default() -> &'a CMsgSOCacheSubscribedUpToDate {
        <CMsgSOCacheSubscribedUpToDate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheSubscribedUpToDate {
    pub fn new() -> CMsgSOCacheSubscribedUpToDate {
        ::std::default::Default::default()
    }

    // optional fixed64 version = 1;

    pub fn version(&self) -> u64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 service_id = 3;

    pub fn service_id(&self) -> u32 {
        self.service_id.unwrap_or(0)
    }

    pub fn clear_service_id(&mut self) {
        self.service_id = ::std::option::Option::None;
    }

    pub fn has_service_id(&self) -> bool {
        self.service_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service_id(&mut self, v: u32) {
        self.service_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 sync_version = 5;

    pub fn sync_version(&self) -> u64 {
        self.sync_version.unwrap_or(0)
    }

    pub fn clear_sync_version(&mut self) {
        self.sync_version = ::std::option::Option::None;
    }

    pub fn has_sync_version(&self) -> bool {
        self.sync_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sync_version(&mut self, v: u64) {
        self.sync_version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgSOCacheSubscribedUpToDate| { &m.version },
            |m: &mut CMsgSOCacheSubscribedUpToDate| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSOIDOwner>(
            "owner_soid",
            |m: &CMsgSOCacheSubscribedUpToDate| { &m.owner_soid },
            |m: &mut CMsgSOCacheSubscribedUpToDate| { &mut m.owner_soid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "service_id",
            |m: &CMsgSOCacheSubscribedUpToDate| { &m.service_id },
            |m: &mut CMsgSOCacheSubscribedUpToDate| { &mut m.service_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "service_list",
            |m: &CMsgSOCacheSubscribedUpToDate| { &m.service_list },
            |m: &mut CMsgSOCacheSubscribedUpToDate| { &mut m.service_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sync_version",
            |m: &CMsgSOCacheSubscribedUpToDate| { &m.sync_version },
            |m: &mut CMsgSOCacheSubscribedUpToDate| { &mut m.sync_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSOCacheSubscribedUpToDate>(
            "CMsgSOCacheSubscribedUpToDate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSOCacheSubscribedUpToDate {
    const NAME: &'static str = "CMsgSOCacheSubscribedUpToDate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.owner_soid)?;
                },
                24 => {
                    self.service_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    is.read_repeated_packed_uint32_into(&mut self.service_list)?;
                },
                32 => {
                    self.service_list.push(is.read_uint32()?);
                },
                41 => {
                    self.sync_version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += 1 + 8;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.service_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        for value in &self.service_list {
            my_size += ::protobuf::rt::uint32_size(4, *value);
        };
        if let Some(v) = self.sync_version {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.service_id {
            os.write_uint32(3, v)?;
        }
        for v in &self.service_list {
            os.write_uint32(4, *v)?;
        };
        if let Some(v) = self.sync_version {
            os.write_fixed64(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOCacheSubscribedUpToDate {
        CMsgSOCacheSubscribedUpToDate::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.owner_soid.clear();
        self.service_id = ::std::option::Option::None;
        self.service_list.clear();
        self.sync_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOCacheSubscribedUpToDate {
        static instance: CMsgSOCacheSubscribedUpToDate = CMsgSOCacheSubscribedUpToDate {
            version: ::std::option::Option::None,
            owner_soid: ::protobuf::MessageField::none(),
            service_id: ::std::option::Option::None,
            service_list: ::std::vec::Vec::new(),
            sync_version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSOCacheSubscribedUpToDate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSOCacheSubscribedUpToDate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSOCacheSubscribedUpToDate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOCacheSubscribedUpToDate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSOCacheUnsubscribed)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOCacheUnsubscribed {
    // message fields
    // @@protoc_insertion_point(field:CMsgSOCacheUnsubscribed.owner)
    pub owner: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSOCacheUnsubscribed.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheUnsubscribed {
    fn default() -> &'a CMsgSOCacheUnsubscribed {
        <CMsgSOCacheUnsubscribed as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheUnsubscribed {
    pub fn new() -> CMsgSOCacheUnsubscribed {
        ::std::default::Default::default()
    }

    // optional fixed64 owner = 1;

    pub fn owner(&self) -> u64 {
        self.owner.unwrap_or(0)
    }

    pub fn clear_owner(&mut self) {
        self.owner = ::std::option::Option::None;
    }

    pub fn has_owner(&self) -> bool {
        self.owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: u64) {
        self.owner = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "owner",
            |m: &CMsgSOCacheUnsubscribed| { &m.owner },
            |m: &mut CMsgSOCacheUnsubscribed| { &mut m.owner },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSOCacheUnsubscribed>(
            "CMsgSOCacheUnsubscribed",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSOCacheUnsubscribed {
    const NAME: &'static str = "CMsgSOCacheUnsubscribed";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.owner = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.owner {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.owner {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOCacheUnsubscribed {
        CMsgSOCacheUnsubscribed::new()
    }

    fn clear(&mut self) {
        self.owner = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOCacheUnsubscribed {
        static instance: CMsgSOCacheUnsubscribed = CMsgSOCacheUnsubscribed {
            owner: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSOCacheUnsubscribed {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSOCacheUnsubscribed").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSOCacheUnsubscribed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOCacheUnsubscribed {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSOCacheSubscriptionCheck)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOCacheSubscriptionCheck {
    // message fields
    // @@protoc_insertion_point(field:CMsgSOCacheSubscriptionCheck.owner)
    pub owner: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSOCacheSubscriptionCheck.version)
    pub version: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSOCacheSubscriptionCheck.owner_soid)
    pub owner_soid: ::protobuf::MessageField<CMsgSOIDOwner>,
    // @@protoc_insertion_point(field:CMsgSOCacheSubscriptionCheck.service_id)
    pub service_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSOCacheSubscriptionCheck.service_list)
    pub service_list: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSOCacheSubscriptionCheck.sync_version)
    pub sync_version: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSOCacheSubscriptionCheck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheSubscriptionCheck {
    fn default() -> &'a CMsgSOCacheSubscriptionCheck {
        <CMsgSOCacheSubscriptionCheck as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheSubscriptionCheck {
    pub fn new() -> CMsgSOCacheSubscriptionCheck {
        ::std::default::Default::default()
    }

    // optional fixed64 owner = 1;

    pub fn owner(&self) -> u64 {
        self.owner.unwrap_or(0)
    }

    pub fn clear_owner(&mut self) {
        self.owner = ::std::option::Option::None;
    }

    pub fn has_owner(&self) -> bool {
        self.owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: u64) {
        self.owner = ::std::option::Option::Some(v);
    }

    // optional fixed64 version = 2;

    pub fn version(&self) -> u64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 service_id = 4;

    pub fn service_id(&self) -> u32 {
        self.service_id.unwrap_or(0)
    }

    pub fn clear_service_id(&mut self) {
        self.service_id = ::std::option::Option::None;
    }

    pub fn has_service_id(&self) -> bool {
        self.service_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service_id(&mut self, v: u32) {
        self.service_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 sync_version = 6;

    pub fn sync_version(&self) -> u64 {
        self.sync_version.unwrap_or(0)
    }

    pub fn clear_sync_version(&mut self) {
        self.sync_version = ::std::option::Option::None;
    }

    pub fn has_sync_version(&self) -> bool {
        self.sync_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sync_version(&mut self, v: u64) {
        self.sync_version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "owner",
            |m: &CMsgSOCacheSubscriptionCheck| { &m.owner },
            |m: &mut CMsgSOCacheSubscriptionCheck| { &mut m.owner },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgSOCacheSubscriptionCheck| { &m.version },
            |m: &mut CMsgSOCacheSubscriptionCheck| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSOIDOwner>(
            "owner_soid",
            |m: &CMsgSOCacheSubscriptionCheck| { &m.owner_soid },
            |m: &mut CMsgSOCacheSubscriptionCheck| { &mut m.owner_soid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "service_id",
            |m: &CMsgSOCacheSubscriptionCheck| { &m.service_id },
            |m: &mut CMsgSOCacheSubscriptionCheck| { &mut m.service_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "service_list",
            |m: &CMsgSOCacheSubscriptionCheck| { &m.service_list },
            |m: &mut CMsgSOCacheSubscriptionCheck| { &mut m.service_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sync_version",
            |m: &CMsgSOCacheSubscriptionCheck| { &m.sync_version },
            |m: &mut CMsgSOCacheSubscriptionCheck| { &mut m.sync_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSOCacheSubscriptionCheck>(
            "CMsgSOCacheSubscriptionCheck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSOCacheSubscriptionCheck {
    const NAME: &'static str = "CMsgSOCacheSubscriptionCheck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.owner = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.owner_soid)?;
                },
                32 => {
                    self.service_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    is.read_repeated_packed_uint32_into(&mut self.service_list)?;
                },
                40 => {
                    self.service_list.push(is.read_uint32()?);
                },
                49 => {
                    self.sync_version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.owner {
            my_size += 1 + 8;
        }
        if let Some(v) = self.version {
            my_size += 1 + 8;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.service_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.service_list {
            my_size += ::protobuf::rt::uint32_size(5, *value);
        };
        if let Some(v) = self.sync_version {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.owner {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.version {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.service_id {
            os.write_uint32(4, v)?;
        }
        for v in &self.service_list {
            os.write_uint32(5, *v)?;
        };
        if let Some(v) = self.sync_version {
            os.write_fixed64(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOCacheSubscriptionCheck {
        CMsgSOCacheSubscriptionCheck::new()
    }

    fn clear(&mut self) {
        self.owner = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.owner_soid.clear();
        self.service_id = ::std::option::Option::None;
        self.service_list.clear();
        self.sync_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOCacheSubscriptionCheck {
        static instance: CMsgSOCacheSubscriptionCheck = CMsgSOCacheSubscriptionCheck {
            owner: ::std::option::Option::None,
            version: ::std::option::Option::None,
            owner_soid: ::protobuf::MessageField::none(),
            service_id: ::std::option::Option::None,
            service_list: ::std::vec::Vec::new(),
            sync_version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSOCacheSubscriptionCheck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSOCacheSubscriptionCheck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSOCacheSubscriptionCheck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOCacheSubscriptionCheck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSOCacheSubscriptionRefresh)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOCacheSubscriptionRefresh {
    // message fields
    // @@protoc_insertion_point(field:CMsgSOCacheSubscriptionRefresh.owner)
    pub owner: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSOCacheSubscriptionRefresh.owner_soid)
    pub owner_soid: ::protobuf::MessageField<CMsgSOIDOwner>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSOCacheSubscriptionRefresh.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheSubscriptionRefresh {
    fn default() -> &'a CMsgSOCacheSubscriptionRefresh {
        <CMsgSOCacheSubscriptionRefresh as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheSubscriptionRefresh {
    pub fn new() -> CMsgSOCacheSubscriptionRefresh {
        ::std::default::Default::default()
    }

    // optional fixed64 owner = 1;

    pub fn owner(&self) -> u64 {
        self.owner.unwrap_or(0)
    }

    pub fn clear_owner(&mut self) {
        self.owner = ::std::option::Option::None;
    }

    pub fn has_owner(&self) -> bool {
        self.owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: u64) {
        self.owner = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "owner",
            |m: &CMsgSOCacheSubscriptionRefresh| { &m.owner },
            |m: &mut CMsgSOCacheSubscriptionRefresh| { &mut m.owner },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSOIDOwner>(
            "owner_soid",
            |m: &CMsgSOCacheSubscriptionRefresh| { &m.owner_soid },
            |m: &mut CMsgSOCacheSubscriptionRefresh| { &mut m.owner_soid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSOCacheSubscriptionRefresh>(
            "CMsgSOCacheSubscriptionRefresh",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSOCacheSubscriptionRefresh {
    const NAME: &'static str = "CMsgSOCacheSubscriptionRefresh";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.owner = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.owner_soid)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.owner {
            my_size += 1 + 8;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.owner {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOCacheSubscriptionRefresh {
        CMsgSOCacheSubscriptionRefresh::new()
    }

    fn clear(&mut self) {
        self.owner = ::std::option::Option::None;
        self.owner_soid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOCacheSubscriptionRefresh {
        static instance: CMsgSOCacheSubscriptionRefresh = CMsgSOCacheSubscriptionRefresh {
            owner: ::std::option::Option::None,
            owner_soid: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSOCacheSubscriptionRefresh {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSOCacheSubscriptionRefresh").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSOCacheSubscriptionRefresh {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOCacheSubscriptionRefresh {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSOCacheVersion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOCacheVersion {
    // message fields
    // @@protoc_insertion_point(field:CMsgSOCacheVersion.version)
    pub version: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSOCacheVersion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheVersion {
    fn default() -> &'a CMsgSOCacheVersion {
        <CMsgSOCacheVersion as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheVersion {
    pub fn new() -> CMsgSOCacheVersion {
        ::std::default::Default::default()
    }

    // optional fixed64 version = 1;

    pub fn version(&self) -> u64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgSOCacheVersion| { &m.version },
            |m: &mut CMsgSOCacheVersion| { &mut m.version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSOCacheVersion>(
            "CMsgSOCacheVersion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSOCacheVersion {
    const NAME: &'static str = "CMsgSOCacheVersion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOCacheVersion {
        CMsgSOCacheVersion::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOCacheVersion {
        static instance: CMsgSOCacheVersion = CMsgSOCacheVersion {
            version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSOCacheVersion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSOCacheVersion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSOCacheVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOCacheVersion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCMultiplexMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCMultiplexMessage {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCMultiplexMessage.msgtype)
    pub msgtype: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCMultiplexMessage.payload)
    pub payload: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgGCMultiplexMessage.steamids)
    pub steamids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCMultiplexMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCMultiplexMessage {
    fn default() -> &'a CMsgGCMultiplexMessage {
        <CMsgGCMultiplexMessage as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCMultiplexMessage {
    pub fn new() -> CMsgGCMultiplexMessage {
        ::std::default::Default::default()
    }

    // optional uint32 msgtype = 1;

    pub fn msgtype(&self) -> u32 {
        self.msgtype.unwrap_or(0)
    }

    pub fn clear_msgtype(&mut self) {
        self.msgtype = ::std::option::Option::None;
    }

    pub fn has_msgtype(&self) -> bool {
        self.msgtype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msgtype(&mut self, v: u32) {
        self.msgtype = ::std::option::Option::Some(v);
    }

    // optional bytes payload = 2;

    pub fn payload(&self) -> &[u8] {
        match self.payload.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_payload(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.payload.is_none() {
            self.payload = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        self.payload.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msgtype",
            |m: &CMsgGCMultiplexMessage| { &m.msgtype },
            |m: &mut CMsgGCMultiplexMessage| { &mut m.msgtype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payload",
            |m: &CMsgGCMultiplexMessage| { &m.payload },
            |m: &mut CMsgGCMultiplexMessage| { &mut m.payload },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "steamids",
            |m: &CMsgGCMultiplexMessage| { &m.steamids },
            |m: &mut CMsgGCMultiplexMessage| { &mut m.steamids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCMultiplexMessage>(
            "CMsgGCMultiplexMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCMultiplexMessage {
    const NAME: &'static str = "CMsgGCMultiplexMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msgtype = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.payload = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    is.read_repeated_packed_fixed64_into(&mut self.steamids)?;
                },
                25 => {
                    self.steamids.push(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msgtype {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.payload.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += 9 * self.steamids.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.msgtype {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.payload.as_ref() {
            os.write_bytes(2, v)?;
        }
        for v in &self.steamids {
            os.write_fixed64(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCMultiplexMessage {
        CMsgGCMultiplexMessage::new()
    }

    fn clear(&mut self) {
        self.msgtype = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.steamids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCMultiplexMessage {
        static instance: CMsgGCMultiplexMessage = CMsgGCMultiplexMessage {
            msgtype: ::std::option::Option::None,
            payload: ::std::option::Option::None,
            steamids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCMultiplexMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCMultiplexMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCMultiplexMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCMultiplexMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CGCToGCMsgMasterAck)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCToGCMsgMasterAck {
    // message fields
    // @@protoc_insertion_point(field:CGCToGCMsgMasterAck.dir_index)
    pub dir_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCToGCMsgMasterAck.machine_name)
    pub machine_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGCToGCMsgMasterAck.process_name)
    pub process_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGCToGCMsgMasterAck.type_instances)
    pub type_instances: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCToGCMsgMasterAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCToGCMsgMasterAck {
    fn default() -> &'a CGCToGCMsgMasterAck {
        <CGCToGCMsgMasterAck as ::protobuf::Message>::default_instance()
    }
}

impl CGCToGCMsgMasterAck {
    pub fn new() -> CGCToGCMsgMasterAck {
        ::std::default::Default::default()
    }

    // optional uint32 dir_index = 1;

    pub fn dir_index(&self) -> u32 {
        self.dir_index.unwrap_or(0)
    }

    pub fn clear_dir_index(&mut self) {
        self.dir_index = ::std::option::Option::None;
    }

    pub fn has_dir_index(&self) -> bool {
        self.dir_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dir_index(&mut self, v: u32) {
        self.dir_index = ::std::option::Option::Some(v);
    }

    // optional string machine_name = 3;

    pub fn machine_name(&self) -> &str {
        match self.machine_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_machine_name(&mut self) {
        self.machine_name = ::std::option::Option::None;
    }

    pub fn has_machine_name(&self) -> bool {
        self.machine_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine_name(&mut self, v: ::std::string::String) {
        self.machine_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machine_name(&mut self) -> &mut ::std::string::String {
        if self.machine_name.is_none() {
            self.machine_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.machine_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_machine_name(&mut self) -> ::std::string::String {
        self.machine_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string process_name = 4;

    pub fn process_name(&self) -> &str {
        match self.process_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_process_name(&mut self) {
        self.process_name = ::std::option::Option::None;
    }

    pub fn has_process_name(&self) -> bool {
        self.process_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_process_name(&mut self, v: ::std::string::String) {
        self.process_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_process_name(&mut self) -> &mut ::std::string::String {
        if self.process_name.is_none() {
            self.process_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.process_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_process_name(&mut self) -> ::std::string::String {
        self.process_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dir_index",
            |m: &CGCToGCMsgMasterAck| { &m.dir_index },
            |m: &mut CGCToGCMsgMasterAck| { &mut m.dir_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "machine_name",
            |m: &CGCToGCMsgMasterAck| { &m.machine_name },
            |m: &mut CGCToGCMsgMasterAck| { &mut m.machine_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "process_name",
            |m: &CGCToGCMsgMasterAck| { &m.process_name },
            |m: &mut CGCToGCMsgMasterAck| { &mut m.process_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "type_instances",
            |m: &CGCToGCMsgMasterAck| { &m.type_instances },
            |m: &mut CGCToGCMsgMasterAck| { &mut m.type_instances },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGCToGCMsgMasterAck>(
            "CGCToGCMsgMasterAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGCToGCMsgMasterAck {
    const NAME: &'static str = "CGCToGCMsgMasterAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dir_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.machine_name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.process_name = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    is.read_repeated_packed_uint32_into(&mut self.type_instances)?;
                },
                40 => {
                    self.type_instances.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dir_index {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.machine_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.process_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.type_instances {
            my_size += ::protobuf::rt::uint32_size(5, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dir_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.machine_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.process_name.as_ref() {
            os.write_string(4, v)?;
        }
        for v in &self.type_instances {
            os.write_uint32(5, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCToGCMsgMasterAck {
        CGCToGCMsgMasterAck::new()
    }

    fn clear(&mut self) {
        self.dir_index = ::std::option::Option::None;
        self.machine_name = ::std::option::Option::None;
        self.process_name = ::std::option::Option::None;
        self.type_instances.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCToGCMsgMasterAck {
        static instance: CGCToGCMsgMasterAck = CGCToGCMsgMasterAck {
            dir_index: ::std::option::Option::None,
            machine_name: ::std::option::Option::None,
            process_name: ::std::option::Option::None,
            type_instances: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGCToGCMsgMasterAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGCToGCMsgMasterAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGCToGCMsgMasterAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCToGCMsgMasterAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CGCToGCMsgMasterAck_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCToGCMsgMasterAck_Response {
    // message fields
    // @@protoc_insertion_point(field:CGCToGCMsgMasterAck_Response.eresult)
    pub eresult: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCToGCMsgMasterAck_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCToGCMsgMasterAck_Response {
    fn default() -> &'a CGCToGCMsgMasterAck_Response {
        <CGCToGCMsgMasterAck_Response as ::protobuf::Message>::default_instance()
    }
}

impl CGCToGCMsgMasterAck_Response {
    pub fn new() -> CGCToGCMsgMasterAck_Response {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CGCToGCMsgMasterAck_Response| { &m.eresult },
            |m: &mut CGCToGCMsgMasterAck_Response| { &mut m.eresult },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGCToGCMsgMasterAck_Response>(
            "CGCToGCMsgMasterAck_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGCToGCMsgMasterAck_Response {
    const NAME: &'static str = "CGCToGCMsgMasterAck_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCToGCMsgMasterAck_Response {
        CGCToGCMsgMasterAck_Response::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCToGCMsgMasterAck_Response {
        static instance: CGCToGCMsgMasterAck_Response = CGCToGCMsgMasterAck_Response {
            eresult: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGCToGCMsgMasterAck_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGCToGCMsgMasterAck_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGCToGCMsgMasterAck_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCToGCMsgMasterAck_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CGCToGCMsgMasterStartupComplete)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCToGCMsgMasterStartupComplete {
    // message fields
    // @@protoc_insertion_point(field:CGCToGCMsgMasterStartupComplete.gc_info)
    pub gc_info: ::std::vec::Vec<cgcto_gcmsg_master_startup_complete::GCInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCToGCMsgMasterStartupComplete.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCToGCMsgMasterStartupComplete {
    fn default() -> &'a CGCToGCMsgMasterStartupComplete {
        <CGCToGCMsgMasterStartupComplete as ::protobuf::Message>::default_instance()
    }
}

impl CGCToGCMsgMasterStartupComplete {
    pub fn new() -> CGCToGCMsgMasterStartupComplete {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "gc_info",
            |m: &CGCToGCMsgMasterStartupComplete| { &m.gc_info },
            |m: &mut CGCToGCMsgMasterStartupComplete| { &mut m.gc_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGCToGCMsgMasterStartupComplete>(
            "CGCToGCMsgMasterStartupComplete",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGCToGCMsgMasterStartupComplete {
    const NAME: &'static str = "CGCToGCMsgMasterStartupComplete";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.gc_info.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.gc_info {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.gc_info {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCToGCMsgMasterStartupComplete {
        CGCToGCMsgMasterStartupComplete::new()
    }

    fn clear(&mut self) {
        self.gc_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCToGCMsgMasterStartupComplete {
        static instance: CGCToGCMsgMasterStartupComplete = CGCToGCMsgMasterStartupComplete {
            gc_info: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGCToGCMsgMasterStartupComplete {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGCToGCMsgMasterStartupComplete").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGCToGCMsgMasterStartupComplete {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCToGCMsgMasterStartupComplete {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CGCToGCMsgMasterStartupComplete`
pub mod cgcto_gcmsg_master_startup_complete {
    // @@protoc_insertion_point(message:CGCToGCMsgMasterStartupComplete.GCInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct GCInfo {
        // message fields
        // @@protoc_insertion_point(field:CGCToGCMsgMasterStartupComplete.GCInfo.dir_index)
        pub dir_index: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CGCToGCMsgMasterStartupComplete.GCInfo.machine_name)
        pub machine_name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CGCToGCMsgMasterStartupComplete.GCInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GCInfo {
        fn default() -> &'a GCInfo {
            <GCInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl GCInfo {
        pub fn new() -> GCInfo {
            ::std::default::Default::default()
        }

        // optional uint32 dir_index = 1;

        pub fn dir_index(&self) -> u32 {
            self.dir_index.unwrap_or(0)
        }

        pub fn clear_dir_index(&mut self) {
            self.dir_index = ::std::option::Option::None;
        }

        pub fn has_dir_index(&self) -> bool {
            self.dir_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_dir_index(&mut self, v: u32) {
            self.dir_index = ::std::option::Option::Some(v);
        }

        // optional string machine_name = 2;

        pub fn machine_name(&self) -> &str {
            match self.machine_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_machine_name(&mut self) {
            self.machine_name = ::std::option::Option::None;
        }

        pub fn has_machine_name(&self) -> bool {
            self.machine_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_machine_name(&mut self, v: ::std::string::String) {
            self.machine_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_machine_name(&mut self) -> &mut ::std::string::String {
            if self.machine_name.is_none() {
                self.machine_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.machine_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_machine_name(&mut self) -> ::std::string::String {
            self.machine_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "dir_index",
                |m: &GCInfo| { &m.dir_index },
                |m: &mut GCInfo| { &mut m.dir_index },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "machine_name",
                |m: &GCInfo| { &m.machine_name },
                |m: &mut GCInfo| { &mut m.machine_name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GCInfo>(
                "CGCToGCMsgMasterStartupComplete.GCInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for GCInfo {
        const NAME: &'static str = "GCInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.dir_index = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.machine_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.dir_index {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.machine_name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.dir_index {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.machine_name.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GCInfo {
            GCInfo::new()
        }

        fn clear(&mut self) {
            self.dir_index = ::std::option::Option::None;
            self.machine_name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GCInfo {
            static instance: GCInfo = GCInfo {
                dir_index: ::std::option::Option::None,
                machine_name: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for GCInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CGCToGCMsgMasterStartupComplete.GCInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for GCInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for GCInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CGCToGCMsgRouted)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCToGCMsgRouted {
    // message fields
    // @@protoc_insertion_point(field:CGCToGCMsgRouted.msg_type)
    pub msg_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCToGCMsgRouted.sender_id)
    pub sender_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CGCToGCMsgRouted.net_message)
    pub net_message: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCToGCMsgRouted.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCToGCMsgRouted {
    fn default() -> &'a CGCToGCMsgRouted {
        <CGCToGCMsgRouted as ::protobuf::Message>::default_instance()
    }
}

impl CGCToGCMsgRouted {
    pub fn new() -> CGCToGCMsgRouted {
        ::std::default::Default::default()
    }

    // optional uint32 msg_type = 1;

    pub fn msg_type(&self) -> u32 {
        self.msg_type.unwrap_or(0)
    }

    pub fn clear_msg_type(&mut self) {
        self.msg_type = ::std::option::Option::None;
    }

    pub fn has_msg_type(&self) -> bool {
        self.msg_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_type(&mut self, v: u32) {
        self.msg_type = ::std::option::Option::Some(v);
    }

    // optional fixed64 sender_id = 2;

    pub fn sender_id(&self) -> u64 {
        self.sender_id.unwrap_or(0)
    }

    pub fn clear_sender_id(&mut self) {
        self.sender_id = ::std::option::Option::None;
    }

    pub fn has_sender_id(&self) -> bool {
        self.sender_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_id(&mut self, v: u64) {
        self.sender_id = ::std::option::Option::Some(v);
    }

    // optional bytes net_message = 3;

    pub fn net_message(&self) -> &[u8] {
        match self.net_message.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_net_message(&mut self) {
        self.net_message = ::std::option::Option::None;
    }

    pub fn has_net_message(&self) -> bool {
        self.net_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.net_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_net_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.net_message.is_none() {
            self.net_message = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.net_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_net_message(&mut self) -> ::std::vec::Vec<u8> {
        self.net_message.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msg_type",
            |m: &CGCToGCMsgRouted| { &m.msg_type },
            |m: &mut CGCToGCMsgRouted| { &mut m.msg_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sender_id",
            |m: &CGCToGCMsgRouted| { &m.sender_id },
            |m: &mut CGCToGCMsgRouted| { &mut m.sender_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "net_message",
            |m: &CGCToGCMsgRouted| { &m.net_message },
            |m: &mut CGCToGCMsgRouted| { &mut m.net_message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGCToGCMsgRouted>(
            "CGCToGCMsgRouted",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGCToGCMsgRouted {
    const NAME: &'static str = "CGCToGCMsgRouted";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msg_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.sender_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.net_message = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msg_type {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.sender_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.net_message.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.msg_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.sender_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.net_message.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCToGCMsgRouted {
        CGCToGCMsgRouted::new()
    }

    fn clear(&mut self) {
        self.msg_type = ::std::option::Option::None;
        self.sender_id = ::std::option::Option::None;
        self.net_message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCToGCMsgRouted {
        static instance: CGCToGCMsgRouted = CGCToGCMsgRouted {
            msg_type: ::std::option::Option::None,
            sender_id: ::std::option::Option::None,
            net_message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGCToGCMsgRouted {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGCToGCMsgRouted").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGCToGCMsgRouted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCToGCMsgRouted {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CGCToGCMsgRoutedReply)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCToGCMsgRoutedReply {
    // message fields
    // @@protoc_insertion_point(field:CGCToGCMsgRoutedReply.msg_type)
    pub msg_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCToGCMsgRoutedReply.net_message)
    pub net_message: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCToGCMsgRoutedReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCToGCMsgRoutedReply {
    fn default() -> &'a CGCToGCMsgRoutedReply {
        <CGCToGCMsgRoutedReply as ::protobuf::Message>::default_instance()
    }
}

impl CGCToGCMsgRoutedReply {
    pub fn new() -> CGCToGCMsgRoutedReply {
        ::std::default::Default::default()
    }

    // optional uint32 msg_type = 1;

    pub fn msg_type(&self) -> u32 {
        self.msg_type.unwrap_or(0)
    }

    pub fn clear_msg_type(&mut self) {
        self.msg_type = ::std::option::Option::None;
    }

    pub fn has_msg_type(&self) -> bool {
        self.msg_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_type(&mut self, v: u32) {
        self.msg_type = ::std::option::Option::Some(v);
    }

    // optional bytes net_message = 2;

    pub fn net_message(&self) -> &[u8] {
        match self.net_message.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_net_message(&mut self) {
        self.net_message = ::std::option::Option::None;
    }

    pub fn has_net_message(&self) -> bool {
        self.net_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.net_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_net_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.net_message.is_none() {
            self.net_message = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.net_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_net_message(&mut self) -> ::std::vec::Vec<u8> {
        self.net_message.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msg_type",
            |m: &CGCToGCMsgRoutedReply| { &m.msg_type },
            |m: &mut CGCToGCMsgRoutedReply| { &mut m.msg_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "net_message",
            |m: &CGCToGCMsgRoutedReply| { &m.net_message },
            |m: &mut CGCToGCMsgRoutedReply| { &mut m.net_message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGCToGCMsgRoutedReply>(
            "CGCToGCMsgRoutedReply",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGCToGCMsgRoutedReply {
    const NAME: &'static str = "CGCToGCMsgRoutedReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msg_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.net_message = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msg_type {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.net_message.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.msg_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.net_message.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCToGCMsgRoutedReply {
        CGCToGCMsgRoutedReply::new()
    }

    fn clear(&mut self) {
        self.msg_type = ::std::option::Option::None;
        self.net_message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCToGCMsgRoutedReply {
        static instance: CGCToGCMsgRoutedReply = CGCToGCMsgRoutedReply {
            msg_type: ::std::option::Option::None,
            net_message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGCToGCMsgRoutedReply {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGCToGCMsgRoutedReply").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGCToGCMsgRoutedReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCToGCMsgRoutedReply {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCUpdateSubGCSessionInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCUpdateSubGCSessionInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCUpdateSubGCSessionInfo.updates)
    pub updates: ::std::vec::Vec<cmsg_gcupdate_sub_gcsession_info::CMsgUpdate>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCUpdateSubGCSessionInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCUpdateSubGCSessionInfo {
    fn default() -> &'a CMsgGCUpdateSubGCSessionInfo {
        <CMsgGCUpdateSubGCSessionInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCUpdateSubGCSessionInfo {
    pub fn new() -> CMsgGCUpdateSubGCSessionInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "updates",
            |m: &CMsgGCUpdateSubGCSessionInfo| { &m.updates },
            |m: &mut CMsgGCUpdateSubGCSessionInfo| { &mut m.updates },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCUpdateSubGCSessionInfo>(
            "CMsgGCUpdateSubGCSessionInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCUpdateSubGCSessionInfo {
    const NAME: &'static str = "CMsgGCUpdateSubGCSessionInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.updates.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.updates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.updates {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCUpdateSubGCSessionInfo {
        CMsgGCUpdateSubGCSessionInfo::new()
    }

    fn clear(&mut self) {
        self.updates.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCUpdateSubGCSessionInfo {
        static instance: CMsgGCUpdateSubGCSessionInfo = CMsgGCUpdateSubGCSessionInfo {
            updates: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCUpdateSubGCSessionInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCUpdateSubGCSessionInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCUpdateSubGCSessionInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCUpdateSubGCSessionInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGCUpdateSubGCSessionInfo`
pub mod cmsg_gcupdate_sub_gcsession_info {
    // @@protoc_insertion_point(message:CMsgGCUpdateSubGCSessionInfo.CMsgUpdate)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CMsgUpdate {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCUpdateSubGCSessionInfo.CMsgUpdate.steamid)
        pub steamid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgGCUpdateSubGCSessionInfo.CMsgUpdate.ip)
        pub ip: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCUpdateSubGCSessionInfo.CMsgUpdate.trusted)
        pub trusted: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCUpdateSubGCSessionInfo.CMsgUpdate.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CMsgUpdate {
        fn default() -> &'a CMsgUpdate {
            <CMsgUpdate as ::protobuf::Message>::default_instance()
        }
    }

    impl CMsgUpdate {
        pub fn new() -> CMsgUpdate {
            ::std::default::Default::default()
        }

        // optional fixed64 steamid = 1;

        pub fn steamid(&self) -> u64 {
            self.steamid.unwrap_or(0)
        }

        pub fn clear_steamid(&mut self) {
            self.steamid = ::std::option::Option::None;
        }

        pub fn has_steamid(&self) -> bool {
            self.steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid(&mut self, v: u64) {
            self.steamid = ::std::option::Option::Some(v);
        }

        // optional fixed32 ip = 2;

        pub fn ip(&self) -> u32 {
            self.ip.unwrap_or(0)
        }

        pub fn clear_ip(&mut self) {
            self.ip = ::std::option::Option::None;
        }

        pub fn has_ip(&self) -> bool {
            self.ip.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ip(&mut self, v: u32) {
            self.ip = ::std::option::Option::Some(v);
        }

        // optional bool trusted = 3;

        pub fn trusted(&self) -> bool {
            self.trusted.unwrap_or(false)
        }

        pub fn clear_trusted(&mut self) {
            self.trusted = ::std::option::Option::None;
        }

        pub fn has_trusted(&self) -> bool {
            self.trusted.is_some()
        }

        // Param is passed by value, moved
        pub fn set_trusted(&mut self, v: bool) {
            self.trusted = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "steamid",
                |m: &CMsgUpdate| { &m.steamid },
                |m: &mut CMsgUpdate| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ip",
                |m: &CMsgUpdate| { &m.ip },
                |m: &mut CMsgUpdate| { &mut m.ip },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "trusted",
                |m: &CMsgUpdate| { &m.trusted },
                |m: &mut CMsgUpdate| { &mut m.trusted },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgUpdate>(
                "CMsgGCUpdateSubGCSessionInfo.CMsgUpdate",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CMsgUpdate {
        const NAME: &'static str = "CMsgUpdate";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    21 => {
                        self.ip = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    24 => {
                        self.trusted = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steamid {
                my_size += 1 + 8;
            }
            if let Some(v) = self.ip {
                my_size += 1 + 4;
            }
            if let Some(v) = self.trusted {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steamid {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.ip {
                os.write_fixed32(2, v)?;
            }
            if let Some(v) = self.trusted {
                os.write_bool(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CMsgUpdate {
            CMsgUpdate::new()
        }

        fn clear(&mut self) {
            self.steamid = ::std::option::Option::None;
            self.ip = ::std::option::Option::None;
            self.trusted = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CMsgUpdate {
            static instance: CMsgUpdate = CMsgUpdate {
                steamid: ::std::option::Option::None,
                ip: ::std::option::Option::None,
                trusted: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CMsgUpdate {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGCUpdateSubGCSessionInfo.CMsgUpdate").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CMsgUpdate {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CMsgUpdate {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgGCRequestSubGCSessionInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCRequestSubGCSessionInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCRequestSubGCSessionInfo.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCRequestSubGCSessionInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCRequestSubGCSessionInfo {
    fn default() -> &'a CMsgGCRequestSubGCSessionInfo {
        <CMsgGCRequestSubGCSessionInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRequestSubGCSessionInfo {
    pub fn new() -> CMsgGCRequestSubGCSessionInfo {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CMsgGCRequestSubGCSessionInfo| { &m.steamid },
            |m: &mut CMsgGCRequestSubGCSessionInfo| { &mut m.steamid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCRequestSubGCSessionInfo>(
            "CMsgGCRequestSubGCSessionInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCRequestSubGCSessionInfo {
    const NAME: &'static str = "CMsgGCRequestSubGCSessionInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCRequestSubGCSessionInfo {
        CMsgGCRequestSubGCSessionInfo::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCRequestSubGCSessionInfo {
        static instance: CMsgGCRequestSubGCSessionInfo = CMsgGCRequestSubGCSessionInfo {
            steamid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCRequestSubGCSessionInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCRequestSubGCSessionInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCRequestSubGCSessionInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCRequestSubGCSessionInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCRequestSubGCSessionInfoResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCRequestSubGCSessionInfoResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCRequestSubGCSessionInfoResponse.ip)
    pub ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCRequestSubGCSessionInfoResponse.trusted)
    pub trusted: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCRequestSubGCSessionInfoResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCRequestSubGCSessionInfoResponse {
    fn default() -> &'a CMsgGCRequestSubGCSessionInfoResponse {
        <CMsgGCRequestSubGCSessionInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRequestSubGCSessionInfoResponse {
    pub fn new() -> CMsgGCRequestSubGCSessionInfoResponse {
        ::std::default::Default::default()
    }

    // optional fixed32 ip = 1;

    pub fn ip(&self) -> u32 {
        self.ip.unwrap_or(0)
    }

    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: u32) {
        self.ip = ::std::option::Option::Some(v);
    }

    // optional bool trusted = 2;

    pub fn trusted(&self) -> bool {
        self.trusted.unwrap_or(false)
    }

    pub fn clear_trusted(&mut self) {
        self.trusted = ::std::option::Option::None;
    }

    pub fn has_trusted(&self) -> bool {
        self.trusted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trusted(&mut self, v: bool) {
        self.trusted = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ip",
            |m: &CMsgGCRequestSubGCSessionInfoResponse| { &m.ip },
            |m: &mut CMsgGCRequestSubGCSessionInfoResponse| { &mut m.ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trusted",
            |m: &CMsgGCRequestSubGCSessionInfoResponse| { &m.trusted },
            |m: &mut CMsgGCRequestSubGCSessionInfoResponse| { &mut m.trusted },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCRequestSubGCSessionInfoResponse>(
            "CMsgGCRequestSubGCSessionInfoResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCRequestSubGCSessionInfoResponse {
    const NAME: &'static str = "CMsgGCRequestSubGCSessionInfoResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                16 => {
                    self.trusted = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ip {
            my_size += 1 + 4;
        }
        if let Some(v) = self.trusted {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ip {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.trusted {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCRequestSubGCSessionInfoResponse {
        CMsgGCRequestSubGCSessionInfoResponse::new()
    }

    fn clear(&mut self) {
        self.ip = ::std::option::Option::None;
        self.trusted = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCRequestSubGCSessionInfoResponse {
        static instance: CMsgGCRequestSubGCSessionInfoResponse = CMsgGCRequestSubGCSessionInfoResponse {
            ip: ::std::option::Option::None,
            trusted: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCRequestSubGCSessionInfoResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCRequestSubGCSessionInfoResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCRequestSubGCSessionInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCRequestSubGCSessionInfoResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCToGCIncrementRecruitmentLevel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCIncrementRecruitmentLevel {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCIncrementRecruitmentLevel.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCIncrementRecruitmentLevel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCIncrementRecruitmentLevel {
    fn default() -> &'a CMsgGCToGCIncrementRecruitmentLevel {
        <CMsgGCToGCIncrementRecruitmentLevel as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCIncrementRecruitmentLevel {
    pub fn new() -> CMsgGCToGCIncrementRecruitmentLevel {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CMsgGCToGCIncrementRecruitmentLevel| { &m.steamid },
            |m: &mut CMsgGCToGCIncrementRecruitmentLevel| { &mut m.steamid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCIncrementRecruitmentLevel>(
            "CMsgGCToGCIncrementRecruitmentLevel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCIncrementRecruitmentLevel {
    const NAME: &'static str = "CMsgGCToGCIncrementRecruitmentLevel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCIncrementRecruitmentLevel {
        CMsgGCToGCIncrementRecruitmentLevel::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCIncrementRecruitmentLevel {
        static instance: CMsgGCToGCIncrementRecruitmentLevel = CMsgGCToGCIncrementRecruitmentLevel {
            steamid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCIncrementRecruitmentLevel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCIncrementRecruitmentLevel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCIncrementRecruitmentLevel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCIncrementRecruitmentLevel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSOCacheHaveVersion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOCacheHaveVersion {
    // message fields
    // @@protoc_insertion_point(field:CMsgSOCacheHaveVersion.soid)
    pub soid: ::protobuf::MessageField<CMsgSOIDOwner>,
    // @@protoc_insertion_point(field:CMsgSOCacheHaveVersion.version)
    pub version: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSOCacheHaveVersion.service_id)
    pub service_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSOCacheHaveVersion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheHaveVersion {
    fn default() -> &'a CMsgSOCacheHaveVersion {
        <CMsgSOCacheHaveVersion as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheHaveVersion {
    pub fn new() -> CMsgSOCacheHaveVersion {
        ::std::default::Default::default()
    }

    // optional fixed64 version = 2;

    pub fn version(&self) -> u64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 service_id = 3;

    pub fn service_id(&self) -> u32 {
        self.service_id.unwrap_or(0)
    }

    pub fn clear_service_id(&mut self) {
        self.service_id = ::std::option::Option::None;
    }

    pub fn has_service_id(&self) -> bool {
        self.service_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service_id(&mut self, v: u32) {
        self.service_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSOIDOwner>(
            "soid",
            |m: &CMsgSOCacheHaveVersion| { &m.soid },
            |m: &mut CMsgSOCacheHaveVersion| { &mut m.soid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgSOCacheHaveVersion| { &m.version },
            |m: &mut CMsgSOCacheHaveVersion| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "service_id",
            |m: &CMsgSOCacheHaveVersion| { &m.service_id },
            |m: &mut CMsgSOCacheHaveVersion| { &mut m.service_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSOCacheHaveVersion>(
            "CMsgSOCacheHaveVersion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSOCacheHaveVersion {
    const NAME: &'static str = "CMsgSOCacheHaveVersion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.soid)?;
                },
                17 => {
                    self.version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.service_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.version {
            my_size += 1 + 8;
        }
        if let Some(v) = self.service_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.soid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.version {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.service_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOCacheHaveVersion {
        CMsgSOCacheHaveVersion::new()
    }

    fn clear(&mut self) {
        self.soid.clear();
        self.version = ::std::option::Option::None;
        self.service_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOCacheHaveVersion {
        static instance: CMsgSOCacheHaveVersion = CMsgSOCacheHaveVersion {
            soid: ::protobuf::MessageField::none(),
            version: ::std::option::Option::None,
            service_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSOCacheHaveVersion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSOCacheHaveVersion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSOCacheHaveVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOCacheHaveVersion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgConnectionStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgConnectionStatus {
    // message fields
    // @@protoc_insertion_point(field:CMsgConnectionStatus.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<GCConnectionStatus>>,
    // @@protoc_insertion_point(field:CMsgConnectionStatus.client_session_need)
    pub client_session_need: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgConnectionStatus.queue_position)
    pub queue_position: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgConnectionStatus.queue_size)
    pub queue_size: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgConnectionStatus.wait_seconds)
    pub wait_seconds: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgConnectionStatus.estimated_wait_seconds_remaining)
    pub estimated_wait_seconds_remaining: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgConnectionStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgConnectionStatus {
    fn default() -> &'a CMsgConnectionStatus {
        <CMsgConnectionStatus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgConnectionStatus {
    pub fn new() -> CMsgConnectionStatus {
        ::std::default::Default::default()
    }

    // optional .GCConnectionStatus status = 1;

    pub fn status(&self) -> GCConnectionStatus {
        match self.status {
            Some(e) => e.enum_value_or(GCConnectionStatus::GCConnectionStatus_HAVE_SESSION),
            None => GCConnectionStatus::GCConnectionStatus_HAVE_SESSION,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: GCConnectionStatus) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 client_session_need = 2;

    pub fn client_session_need(&self) -> u32 {
        self.client_session_need.unwrap_or(0)
    }

    pub fn clear_client_session_need(&mut self) {
        self.client_session_need = ::std::option::Option::None;
    }

    pub fn has_client_session_need(&self) -> bool {
        self.client_session_need.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_session_need(&mut self, v: u32) {
        self.client_session_need = ::std::option::Option::Some(v);
    }

    // optional int32 queue_position = 3;

    pub fn queue_position(&self) -> i32 {
        self.queue_position.unwrap_or(0)
    }

    pub fn clear_queue_position(&mut self) {
        self.queue_position = ::std::option::Option::None;
    }

    pub fn has_queue_position(&self) -> bool {
        self.queue_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queue_position(&mut self, v: i32) {
        self.queue_position = ::std::option::Option::Some(v);
    }

    // optional int32 queue_size = 4;

    pub fn queue_size(&self) -> i32 {
        self.queue_size.unwrap_or(0)
    }

    pub fn clear_queue_size(&mut self) {
        self.queue_size = ::std::option::Option::None;
    }

    pub fn has_queue_size(&self) -> bool {
        self.queue_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queue_size(&mut self, v: i32) {
        self.queue_size = ::std::option::Option::Some(v);
    }

    // optional int32 wait_seconds = 5;

    pub fn wait_seconds(&self) -> i32 {
        self.wait_seconds.unwrap_or(0)
    }

    pub fn clear_wait_seconds(&mut self) {
        self.wait_seconds = ::std::option::Option::None;
    }

    pub fn has_wait_seconds(&self) -> bool {
        self.wait_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wait_seconds(&mut self, v: i32) {
        self.wait_seconds = ::std::option::Option::Some(v);
    }

    // optional int32 estimated_wait_seconds_remaining = 6;

    pub fn estimated_wait_seconds_remaining(&self) -> i32 {
        self.estimated_wait_seconds_remaining.unwrap_or(0)
    }

    pub fn clear_estimated_wait_seconds_remaining(&mut self) {
        self.estimated_wait_seconds_remaining = ::std::option::Option::None;
    }

    pub fn has_estimated_wait_seconds_remaining(&self) -> bool {
        self.estimated_wait_seconds_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_estimated_wait_seconds_remaining(&mut self, v: i32) {
        self.estimated_wait_seconds_remaining = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &CMsgConnectionStatus| { &m.status },
            |m: &mut CMsgConnectionStatus| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_session_need",
            |m: &CMsgConnectionStatus| { &m.client_session_need },
            |m: &mut CMsgConnectionStatus| { &mut m.client_session_need },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "queue_position",
            |m: &CMsgConnectionStatus| { &m.queue_position },
            |m: &mut CMsgConnectionStatus| { &mut m.queue_position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "queue_size",
            |m: &CMsgConnectionStatus| { &m.queue_size },
            |m: &mut CMsgConnectionStatus| { &mut m.queue_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "wait_seconds",
            |m: &CMsgConnectionStatus| { &m.wait_seconds },
            |m: &mut CMsgConnectionStatus| { &mut m.wait_seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "estimated_wait_seconds_remaining",
            |m: &CMsgConnectionStatus| { &m.estimated_wait_seconds_remaining },
            |m: &mut CMsgConnectionStatus| { &mut m.estimated_wait_seconds_remaining },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgConnectionStatus>(
            "CMsgConnectionStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgConnectionStatus {
    const NAME: &'static str = "CMsgConnectionStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.client_session_need = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.queue_position = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.queue_size = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.wait_seconds = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.estimated_wait_seconds_remaining = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.client_session_need {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.queue_position {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.queue_size {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.wait_seconds {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.estimated_wait_seconds_remaining {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.client_session_need {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.queue_position {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.queue_size {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.wait_seconds {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.estimated_wait_seconds_remaining {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgConnectionStatus {
        CMsgConnectionStatus::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.client_session_need = ::std::option::Option::None;
        self.queue_position = ::std::option::Option::None;
        self.queue_size = ::std::option::Option::None;
        self.wait_seconds = ::std::option::Option::None;
        self.estimated_wait_seconds_remaining = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgConnectionStatus {
        static instance: CMsgConnectionStatus = CMsgConnectionStatus {
            status: ::std::option::Option::None,
            client_session_need: ::std::option::Option::None,
            queue_position: ::std::option::Option::None,
            queue_size: ::std::option::Option::None,
            wait_seconds: ::std::option::Option::None,
            estimated_wait_seconds_remaining: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgConnectionStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgConnectionStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgConnectionStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgConnectionStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCToGCSOCacheSubscribe)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCSOCacheSubscribe {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCSOCacheSubscribe.subscriber)
    pub subscriber: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCToGCSOCacheSubscribe.subscribe_to)
    pub subscribe_to: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCToGCSOCacheSubscribe.sync_version)
    pub sync_version: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCToGCSOCacheSubscribe.have_versions)
    pub have_versions: ::std::vec::Vec<cmsg_gcto_gcsocache_subscribe::CMsgHaveVersions>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCSOCacheSubscribe.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCSOCacheSubscribe {
    fn default() -> &'a CMsgGCToGCSOCacheSubscribe {
        <CMsgGCToGCSOCacheSubscribe as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCSOCacheSubscribe {
    pub fn new() -> CMsgGCToGCSOCacheSubscribe {
        ::std::default::Default::default()
    }

    // optional fixed64 subscriber = 1;

    pub fn subscriber(&self) -> u64 {
        self.subscriber.unwrap_or(0)
    }

    pub fn clear_subscriber(&mut self) {
        self.subscriber = ::std::option::Option::None;
    }

    pub fn has_subscriber(&self) -> bool {
        self.subscriber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscriber(&mut self, v: u64) {
        self.subscriber = ::std::option::Option::Some(v);
    }

    // optional fixed64 subscribe_to = 2;

    pub fn subscribe_to(&self) -> u64 {
        self.subscribe_to.unwrap_or(0)
    }

    pub fn clear_subscribe_to(&mut self) {
        self.subscribe_to = ::std::option::Option::None;
    }

    pub fn has_subscribe_to(&self) -> bool {
        self.subscribe_to.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscribe_to(&mut self, v: u64) {
        self.subscribe_to = ::std::option::Option::Some(v);
    }

    // optional fixed64 sync_version = 3;

    pub fn sync_version(&self) -> u64 {
        self.sync_version.unwrap_or(0)
    }

    pub fn clear_sync_version(&mut self) {
        self.sync_version = ::std::option::Option::None;
    }

    pub fn has_sync_version(&self) -> bool {
        self.sync_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sync_version(&mut self, v: u64) {
        self.sync_version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subscriber",
            |m: &CMsgGCToGCSOCacheSubscribe| { &m.subscriber },
            |m: &mut CMsgGCToGCSOCacheSubscribe| { &mut m.subscriber },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subscribe_to",
            |m: &CMsgGCToGCSOCacheSubscribe| { &m.subscribe_to },
            |m: &mut CMsgGCToGCSOCacheSubscribe| { &mut m.subscribe_to },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sync_version",
            |m: &CMsgGCToGCSOCacheSubscribe| { &m.sync_version },
            |m: &mut CMsgGCToGCSOCacheSubscribe| { &mut m.sync_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "have_versions",
            |m: &CMsgGCToGCSOCacheSubscribe| { &m.have_versions },
            |m: &mut CMsgGCToGCSOCacheSubscribe| { &mut m.have_versions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCSOCacheSubscribe>(
            "CMsgGCToGCSOCacheSubscribe",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCSOCacheSubscribe {
    const NAME: &'static str = "CMsgGCToGCSOCacheSubscribe";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.subscriber = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.subscribe_to = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.sync_version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                34 => {
                    self.have_versions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.subscriber {
            my_size += 1 + 8;
        }
        if let Some(v) = self.subscribe_to {
            my_size += 1 + 8;
        }
        if let Some(v) = self.sync_version {
            my_size += 1 + 8;
        }
        for value in &self.have_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.subscriber {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.subscribe_to {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.sync_version {
            os.write_fixed64(3, v)?;
        }
        for v in &self.have_versions {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCSOCacheSubscribe {
        CMsgGCToGCSOCacheSubscribe::new()
    }

    fn clear(&mut self) {
        self.subscriber = ::std::option::Option::None;
        self.subscribe_to = ::std::option::Option::None;
        self.sync_version = ::std::option::Option::None;
        self.have_versions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCSOCacheSubscribe {
        static instance: CMsgGCToGCSOCacheSubscribe = CMsgGCToGCSOCacheSubscribe {
            subscriber: ::std::option::Option::None,
            subscribe_to: ::std::option::Option::None,
            sync_version: ::std::option::Option::None,
            have_versions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCSOCacheSubscribe {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCSOCacheSubscribe").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCSOCacheSubscribe {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCSOCacheSubscribe {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGCToGCSOCacheSubscribe`
pub mod cmsg_gcto_gcsocache_subscribe {
    // @@protoc_insertion_point(message:CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CMsgHaveVersions {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions.service_id)
        pub service_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions.version)
        pub version: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CMsgHaveVersions {
        fn default() -> &'a CMsgHaveVersions {
            <CMsgHaveVersions as ::protobuf::Message>::default_instance()
        }
    }

    impl CMsgHaveVersions {
        pub fn new() -> CMsgHaveVersions {
            ::std::default::Default::default()
        }

        // optional uint32 service_id = 1;

        pub fn service_id(&self) -> u32 {
            self.service_id.unwrap_or(0)
        }

        pub fn clear_service_id(&mut self) {
            self.service_id = ::std::option::Option::None;
        }

        pub fn has_service_id(&self) -> bool {
            self.service_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_service_id(&mut self, v: u32) {
            self.service_id = ::std::option::Option::Some(v);
        }

        // optional uint64 version = 2;

        pub fn version(&self) -> u64 {
            self.version.unwrap_or(0)
        }

        pub fn clear_version(&mut self) {
            self.version = ::std::option::Option::None;
        }

        pub fn has_version(&self) -> bool {
            self.version.is_some()
        }

        // Param is passed by value, moved
        pub fn set_version(&mut self, v: u64) {
            self.version = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "service_id",
                |m: &CMsgHaveVersions| { &m.service_id },
                |m: &mut CMsgHaveVersions| { &mut m.service_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "version",
                |m: &CMsgHaveVersions| { &m.version },
                |m: &mut CMsgHaveVersions| { &mut m.version },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgHaveVersions>(
                "CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CMsgHaveVersions {
        const NAME: &'static str = "CMsgHaveVersions";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.service_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.version = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.service_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.version {
                my_size += ::protobuf::rt::uint64_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.service_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.version {
                os.write_uint64(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CMsgHaveVersions {
            CMsgHaveVersions::new()
        }

        fn clear(&mut self) {
            self.service_id = ::std::option::Option::None;
            self.version = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CMsgHaveVersions {
            static instance: CMsgHaveVersions = CMsgHaveVersions {
                service_id: ::std::option::Option::None,
                version: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CMsgHaveVersions {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CMsgHaveVersions {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CMsgHaveVersions {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCSOCacheUnsubscribe)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCSOCacheUnsubscribe {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCSOCacheUnsubscribe.subscriber)
    pub subscriber: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCToGCSOCacheUnsubscribe.unsubscribe_from)
    pub unsubscribe_from: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCSOCacheUnsubscribe.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCSOCacheUnsubscribe {
    fn default() -> &'a CMsgGCToGCSOCacheUnsubscribe {
        <CMsgGCToGCSOCacheUnsubscribe as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCSOCacheUnsubscribe {
    pub fn new() -> CMsgGCToGCSOCacheUnsubscribe {
        ::std::default::Default::default()
    }

    // optional fixed64 subscriber = 1;

    pub fn subscriber(&self) -> u64 {
        self.subscriber.unwrap_or(0)
    }

    pub fn clear_subscriber(&mut self) {
        self.subscriber = ::std::option::Option::None;
    }

    pub fn has_subscriber(&self) -> bool {
        self.subscriber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscriber(&mut self, v: u64) {
        self.subscriber = ::std::option::Option::Some(v);
    }

    // optional fixed64 unsubscribe_from = 2;

    pub fn unsubscribe_from(&self) -> u64 {
        self.unsubscribe_from.unwrap_or(0)
    }

    pub fn clear_unsubscribe_from(&mut self) {
        self.unsubscribe_from = ::std::option::Option::None;
    }

    pub fn has_unsubscribe_from(&self) -> bool {
        self.unsubscribe_from.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unsubscribe_from(&mut self, v: u64) {
        self.unsubscribe_from = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subscriber",
            |m: &CMsgGCToGCSOCacheUnsubscribe| { &m.subscriber },
            |m: &mut CMsgGCToGCSOCacheUnsubscribe| { &mut m.subscriber },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unsubscribe_from",
            |m: &CMsgGCToGCSOCacheUnsubscribe| { &m.unsubscribe_from },
            |m: &mut CMsgGCToGCSOCacheUnsubscribe| { &mut m.unsubscribe_from },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCSOCacheUnsubscribe>(
            "CMsgGCToGCSOCacheUnsubscribe",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCSOCacheUnsubscribe {
    const NAME: &'static str = "CMsgGCToGCSOCacheUnsubscribe";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.subscriber = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.unsubscribe_from = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.subscriber {
            my_size += 1 + 8;
        }
        if let Some(v) = self.unsubscribe_from {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.subscriber {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.unsubscribe_from {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCSOCacheUnsubscribe {
        CMsgGCToGCSOCacheUnsubscribe::new()
    }

    fn clear(&mut self) {
        self.subscriber = ::std::option::Option::None;
        self.unsubscribe_from = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCSOCacheUnsubscribe {
        static instance: CMsgGCToGCSOCacheUnsubscribe = CMsgGCToGCSOCacheUnsubscribe {
            subscriber: ::std::option::Option::None,
            unsubscribe_from: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCSOCacheUnsubscribe {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCSOCacheUnsubscribe").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCSOCacheUnsubscribe {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCSOCacheUnsubscribe {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCClientPing)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCClientPing {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCClientPing.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCClientPing {
    fn default() -> &'a CMsgGCClientPing {
        <CMsgGCClientPing as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCClientPing {
    pub fn new() -> CMsgGCClientPing {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCClientPing>(
            "CMsgGCClientPing",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCClientPing {
    const NAME: &'static str = "CMsgGCClientPing";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCClientPing {
        CMsgGCClientPing::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCClientPing {
        static instance: CMsgGCClientPing = CMsgGCClientPing {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCClientPing {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCClientPing").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCClientPing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCClientPing {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:PartnerAccountType)
pub enum PartnerAccountType {
    // @@protoc_insertion_point(enum_value:PartnerAccountType.PARTNER_NONE)
    PARTNER_NONE = 0,
    // @@protoc_insertion_point(enum_value:PartnerAccountType.PARTNER_PERFECT_WORLD)
    PARTNER_PERFECT_WORLD = 1,
    // @@protoc_insertion_point(enum_value:PartnerAccountType.PARTNER_NEXON)
    PARTNER_NEXON = 2,
}

impl ::protobuf::Enum for PartnerAccountType {
    const NAME: &'static str = "PartnerAccountType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PartnerAccountType> {
        match value {
            0 => ::std::option::Option::Some(PartnerAccountType::PARTNER_NONE),
            1 => ::std::option::Option::Some(PartnerAccountType::PARTNER_PERFECT_WORLD),
            2 => ::std::option::Option::Some(PartnerAccountType::PARTNER_NEXON),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<PartnerAccountType> {
        match str {
            "PARTNER_NONE" => ::std::option::Option::Some(PartnerAccountType::PARTNER_NONE),
            "PARTNER_PERFECT_WORLD" => ::std::option::Option::Some(PartnerAccountType::PARTNER_PERFECT_WORLD),
            "PARTNER_NEXON" => ::std::option::Option::Some(PartnerAccountType::PARTNER_NEXON),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [PartnerAccountType] = &[
        PartnerAccountType::PARTNER_NONE,
        PartnerAccountType::PARTNER_PERFECT_WORLD,
        PartnerAccountType::PARTNER_NEXON,
    ];
}

impl ::protobuf::EnumFull for PartnerAccountType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("PartnerAccountType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for PartnerAccountType {
    fn default() -> Self {
        PartnerAccountType::PARTNER_NONE
    }
}

impl PartnerAccountType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PartnerAccountType>("PartnerAccountType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:GCConnectionStatus)
pub enum GCConnectionStatus {
    // @@protoc_insertion_point(enum_value:GCConnectionStatus.GCConnectionStatus_HAVE_SESSION)
    GCConnectionStatus_HAVE_SESSION = 0,
    // @@protoc_insertion_point(enum_value:GCConnectionStatus.GCConnectionStatus_GC_GOING_DOWN)
    GCConnectionStatus_GC_GOING_DOWN = 1,
    // @@protoc_insertion_point(enum_value:GCConnectionStatus.GCConnectionStatus_NO_SESSION)
    GCConnectionStatus_NO_SESSION = 2,
    // @@protoc_insertion_point(enum_value:GCConnectionStatus.GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE)
    GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE = 3,
    // @@protoc_insertion_point(enum_value:GCConnectionStatus.GCConnectionStatus_NO_STEAM)
    GCConnectionStatus_NO_STEAM = 4,
    // @@protoc_insertion_point(enum_value:GCConnectionStatus.GCConnectionStatus_SUSPENDED)
    GCConnectionStatus_SUSPENDED = 5,
}

impl ::protobuf::Enum for GCConnectionStatus {
    const NAME: &'static str = "GCConnectionStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GCConnectionStatus> {
        match value {
            0 => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_HAVE_SESSION),
            1 => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_GC_GOING_DOWN),
            2 => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_NO_SESSION),
            3 => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE),
            4 => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_NO_STEAM),
            5 => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_SUSPENDED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<GCConnectionStatus> {
        match str {
            "GCConnectionStatus_HAVE_SESSION" => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_HAVE_SESSION),
            "GCConnectionStatus_GC_GOING_DOWN" => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_GC_GOING_DOWN),
            "GCConnectionStatus_NO_SESSION" => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_NO_SESSION),
            "GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE" => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE),
            "GCConnectionStatus_NO_STEAM" => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_NO_STEAM),
            "GCConnectionStatus_SUSPENDED" => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_SUSPENDED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [GCConnectionStatus] = &[
        GCConnectionStatus::GCConnectionStatus_HAVE_SESSION,
        GCConnectionStatus::GCConnectionStatus_GC_GOING_DOWN,
        GCConnectionStatus::GCConnectionStatus_NO_SESSION,
        GCConnectionStatus::GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE,
        GCConnectionStatus::GCConnectionStatus_NO_STEAM,
        GCConnectionStatus::GCConnectionStatus_SUSPENDED,
    ];
}

impl ::protobuf::EnumFull for GCConnectionStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("GCConnectionStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for GCConnectionStatus {
    fn default() -> Self {
        GCConnectionStatus::GCConnectionStatus_HAVE_SESSION
    }
}

impl GCConnectionStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<GCConnectionStatus>("GCConnectionStatus")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1atf2/gcsdk_gcmessages.proto\x1a\x13steammessages.proto\"3\n\rCMsgSO\
    IDOwner\x12\x12\n\x04type\x18\x01\x20\x01(\rR\x04type\x12\x0e\n\x02id\
    \x18\x02\x20\x01(\x04R\x02id\"\xcc\x01\n\x12CMsgSOSingleObject\x12\x14\n\
    \x05owner\x18\x01\x20\x01(\x06R\x05owner\x12\x17\n\x07type_id\x18\x02\
    \x20\x01(\x05R\x06typeId\x12\x1f\n\x0bobject_data\x18\x03\x20\x01(\x0cR\
    \nobjectData\x12\x18\n\x07version\x18\x04\x20\x01(\x06R\x07version\x12-\
    \n\nowner_soid\x18\x05\x20\x01(\x0b2\x0e.CMsgSOIDOwnerR\townerSoid\x12\
    \x1d\n\nservice_id\x18\x06\x20\x01(\rR\tserviceId\"\x9e\x02\n\x15CMsgSOM\
    ultipleObjects\x12\x14\n\x05owner\x18\x01\x20\x01(\x06R\x05owner\x12=\n\
    \x07objects\x18\x02\x20\x03(\x0b2#.CMsgSOMultipleObjects.SingleObjectR\
    \x07objects\x12\x18\n\x07version\x18\x03\x20\x01(\x06R\x07version\x12-\n\
    \nowner_soid\x18\x06\x20\x01(\x0b2\x0e.CMsgSOIDOwnerR\townerSoid\x12\x1d\
    \n\nservice_id\x18\x07\x20\x01(\rR\tserviceId\x1aH\n\x0cSingleObject\x12\
    \x17\n\x07type_id\x18\x01\x20\x01(\x05R\x06typeId\x12\x1f\n\x0bobject_da\
    ta\x18\x02\x20\x01(\x0cR\nobjectData\"\xe8\x02\n\x15CMsgSOCacheSubscribe\
    d\x12\x14\n\x05owner\x18\x01\x20\x01(\x06R\x05owner\x12?\n\x07objects\
    \x18\x02\x20\x03(\x0b2%.CMsgSOCacheSubscribed.SubscribedTypeR\x07objects\
    \x12\x18\n\x07version\x18\x03\x20\x01(\x06R\x07version\x12-\n\nowner_soi\
    d\x18\x04\x20\x01(\x0b2\x0e.CMsgSOIDOwnerR\townerSoid\x12\x1d\n\nservice\
    _id\x18\x05\x20\x01(\rR\tserviceId\x12!\n\x0cservice_list\x18\x06\x20\
    \x03(\rR\x0bserviceList\x12!\n\x0csync_version\x18\x07\x20\x01(\x06R\x0b\
    syncVersion\x1aJ\n\x0eSubscribedType\x12\x17\n\x07type_id\x18\x01\x20\
    \x01(\x05R\x06typeId\x12\x1f\n\x0bobject_data\x18\x02\x20\x03(\x0cR\nobj\
    ectData\"\xcd\x01\n\x1dCMsgSOCacheSubscribedUpToDate\x12\x18\n\x07versio\
    n\x18\x01\x20\x01(\x06R\x07version\x12-\n\nowner_soid\x18\x02\x20\x01(\
    \x0b2\x0e.CMsgSOIDOwnerR\townerSoid\x12\x1d\n\nservice_id\x18\x03\x20\
    \x01(\rR\tserviceId\x12!\n\x0cservice_list\x18\x04\x20\x03(\rR\x0bservic\
    eList\x12!\n\x0csync_version\x18\x05\x20\x01(\x06R\x0bsyncVersion\"/\n\
    \x17CMsgSOCacheUnsubscribed\x12\x14\n\x05owner\x18\x01\x20\x01(\x06R\x05\
    owner\"\xe2\x01\n\x1cCMsgSOCacheSubscriptionCheck\x12\x14\n\x05owner\x18\
    \x01\x20\x01(\x06R\x05owner\x12\x18\n\x07version\x18\x02\x20\x01(\x06R\
    \x07version\x12-\n\nowner_soid\x18\x03\x20\x01(\x0b2\x0e.CMsgSOIDOwnerR\
    \townerSoid\x12\x1d\n\nservice_id\x18\x04\x20\x01(\rR\tserviceId\x12!\n\
    \x0cservice_list\x18\x05\x20\x03(\rR\x0bserviceList\x12!\n\x0csync_versi\
    on\x18\x06\x20\x01(\x06R\x0bsyncVersion\"e\n\x1eCMsgSOCacheSubscriptionR\
    efresh\x12\x14\n\x05owner\x18\x01\x20\x01(\x06R\x05owner\x12-\n\nowner_s\
    oid\x18\x02\x20\x01(\x0b2\x0e.CMsgSOIDOwnerR\townerSoid\".\n\x12CMsgSOCa\
    cheVersion\x12\x18\n\x07version\x18\x01\x20\x01(\x06R\x07version\"h\n\
    \x16CMsgGCMultiplexMessage\x12\x18\n\x07msgtype\x18\x01\x20\x01(\rR\x07m\
    sgtype\x12\x18\n\x07payload\x18\x02\x20\x01(\x0cR\x07payload\x12\x1a\n\
    \x08steamids\x18\x03\x20\x03(\x06R\x08steamids\"\x9f\x01\n\x13CGCToGCMsg\
    MasterAck\x12\x1b\n\tdir_index\x18\x01\x20\x01(\rR\x08dirIndex\x12!\n\
    \x0cmachine_name\x18\x03\x20\x01(\tR\x0bmachineName\x12!\n\x0cprocess_na\
    me\x18\x04\x20\x01(\tR\x0bprocessName\x12%\n\x0etype_instances\x18\x05\
    \x20\x03(\rR\rtypeInstances\";\n\x1cCGCToGCMsgMasterAck_Response\x12\x1b\
    \n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\"\xad\x01\n\x1fCGCT\
    oGCMsgMasterStartupComplete\x12@\n\x07gc_info\x18\x01\x20\x03(\x0b2'.CGC\
    ToGCMsgMasterStartupComplete.GCInfoR\x06gcInfo\x1aH\n\x06GCInfo\x12\x1b\
    \n\tdir_index\x18\x01\x20\x01(\rR\x08dirIndex\x12!\n\x0cmachine_name\x18\
    \x02\x20\x01(\tR\x0bmachineName\"k\n\x10CGCToGCMsgRouted\x12\x19\n\x08ms\
    g_type\x18\x01\x20\x01(\rR\x07msgType\x12\x1b\n\tsender_id\x18\x02\x20\
    \x01(\x06R\x08senderId\x12\x1f\n\x0bnet_message\x18\x03\x20\x01(\x0cR\nn\
    etMessage\"S\n\x15CGCToGCMsgRoutedReply\x12\x19\n\x08msg_type\x18\x01\
    \x20\x01(\rR\x07msgType\x12\x1f\n\x0bnet_message\x18\x02\x20\x01(\x0cR\n\
    netMessage\"\xb4\x01\n\x1cCMsgGCUpdateSubGCSessionInfo\x12B\n\x07updates\
    \x18\x01\x20\x03(\x0b2(.CMsgGCUpdateSubGCSessionInfo.CMsgUpdateR\x07upda\
    tes\x1aP\n\nCMsgUpdate\x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07ste\
    amid\x12\x0e\n\x02ip\x18\x02\x20\x01(\x07R\x02ip\x12\x18\n\x07trusted\
    \x18\x03\x20\x01(\x08R\x07trusted\"9\n\x1dCMsgGCRequestSubGCSessionInfo\
    \x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\"Q\n%CMsgGCReques\
    tSubGCSessionInfoResponse\x12\x0e\n\x02ip\x18\x01\x20\x01(\x07R\x02ip\
    \x12\x18\n\x07trusted\x18\x02\x20\x01(\x08R\x07trusted\"?\n#CMsgGCToGCIn\
    crementRecruitmentLevel\x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07st\
    eamid\"u\n\x16CMsgSOCacheHaveVersion\x12\"\n\x04soid\x18\x01\x20\x01(\
    \x0b2\x0e.CMsgSOIDOwnerR\x04soid\x12\x18\n\x07version\x18\x02\x20\x01(\
    \x06R\x07version\x12\x1d\n\nservice_id\x18\x03\x20\x01(\rR\tserviceId\"\
    \xc6\x02\n\x14CMsgConnectionStatus\x12L\n\x06status\x18\x01\x20\x01(\x0e\
    2\x13.GCConnectionStatus:\x1fGCConnectionStatus_HAVE_SESSIONR\x06status\
    \x12.\n\x13client_session_need\x18\x02\x20\x01(\rR\x11clientSessionNeed\
    \x12%\n\x0equeue_position\x18\x03\x20\x01(\x05R\rqueuePosition\x12\x1d\n\
    \nqueue_size\x18\x04\x20\x01(\x05R\tqueueSize\x12!\n\x0cwait_seconds\x18\
    \x05\x20\x01(\x05R\x0bwaitSeconds\x12G\n\x20estimated_wait_seconds_remai\
    ning\x18\x06\x20\x01(\x05R\x1destimatedWaitSecondsRemaining\"\xa2\x02\n\
    \x1aCMsgGCToGCSOCacheSubscribe\x12\x1e\n\nsubscriber\x18\x01\x20\x01(\
    \x06R\nsubscriber\x12!\n\x0csubscribe_to\x18\x02\x20\x01(\x06R\x0bsubscr\
    ibeTo\x12!\n\x0csync_version\x18\x03\x20\x01(\x06R\x0bsyncVersion\x12Q\n\
    \rhave_versions\x18\x04\x20\x03(\x0b2,.CMsgGCToGCSOCacheSubscribe.CMsgHa\
    veVersionsR\x0chaveVersions\x1aK\n\x10CMsgHaveVersions\x12\x1d\n\nservic\
    e_id\x18\x01\x20\x01(\rR\tserviceId\x12\x18\n\x07version\x18\x02\x20\x01\
    (\x04R\x07version\"i\n\x1cCMsgGCToGCSOCacheUnsubscribe\x12\x1e\n\nsubscr\
    iber\x18\x01\x20\x01(\x06R\nsubscriber\x12)\n\x10unsubscribe_from\x18\
    \x02\x20\x01(\x06R\x0funsubscribeFrom\"\x12\n\x10CMsgGCClientPing*T\n\
    \x12PartnerAccountType\x12\x10\n\x0cPARTNER_NONE\x10\0\x12\x19\n\x15PART\
    NER_PERFECT_WORLD\x10\x01\x12\x11\n\rPARTNER_NEXON\x10\x02*\xf7\x01\n\
    \x12GCConnectionStatus\x12#\n\x1fGCConnectionStatus_HAVE_SESSION\x10\0\
    \x12$\n\x20GCConnectionStatus_GC_GOING_DOWN\x10\x01\x12!\n\x1dGCConnecti\
    onStatus_NO_SESSION\x10\x02\x120\n,GCConnectionStatus_NO_SESSION_IN_LOGO\
    N_QUEUE\x10\x03\x12\x1f\n\x1bGCConnectionStatus_NO_STEAM\x10\x04\x12\x20\
    \n\x1cGCConnectionStatus_SUSPENDED\x10\x05B\x05H\x01\x80\x01\0J\x817\n\
    \x07\x12\x05\0\0\xb9\x01\x01\n\t\n\x02\x03\0\x12\x03\0\0\x1d\n\x08\n\x01\
    \x08\x12\x03\x02\0\x1c\n\t\n\x02\x08\t\x12\x03\x02\0\x1c\n\x08\n\x01\x08\
    \x12\x03\x03\0#\n\t\n\x02\x08\x10\x12\x03\x03\0#\n\n\n\x02\x05\0\x12\x04\
    \x05\0\t\x01\n\n\n\x03\x05\0\x01\x12\x03\x05\x05\x17\n\x0b\n\x04\x05\0\
    \x02\0\x12\x03\x06\x08\x19\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\x06\x08\
    \x14\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\x06\x17\x18\n\x0b\n\x04\x05\0\
    \x02\x01\x12\x03\x07\x08\"\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\x07\x08\
    \x1d\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\x07\x20!\n\x0b\n\x04\x05\0\
    \x02\x02\x12\x03\x08\x08\x1a\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03\x08\
    \x08\x15\n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03\x08\x18\x19\n\n\n\x02\x05\
    \x01\x12\x04\x0b\0\x12\x01\n\n\n\x03\x05\x01\x01\x12\x03\x0b\x05\x17\n\
    \x0b\n\x04\x05\x01\x02\0\x12\x03\x0c\x08,\n\x0c\n\x05\x05\x01\x02\0\x01\
    \x12\x03\x0c\x08'\n\x0c\n\x05\x05\x01\x02\0\x02\x12\x03\x0c*+\n\x0b\n\
    \x04\x05\x01\x02\x01\x12\x03\r\x08-\n\x0c\n\x05\x05\x01\x02\x01\x01\x12\
    \x03\r\x08(\n\x0c\n\x05\x05\x01\x02\x01\x02\x12\x03\r+,\n\x0b\n\x04\x05\
    \x01\x02\x02\x12\x03\x0e\x08*\n\x0c\n\x05\x05\x01\x02\x02\x01\x12\x03\
    \x0e\x08%\n\x0c\n\x05\x05\x01\x02\x02\x02\x12\x03\x0e()\n\x0b\n\x04\x05\
    \x01\x02\x03\x12\x03\x0f\x089\n\x0c\n\x05\x05\x01\x02\x03\x01\x12\x03\
    \x0f\x084\n\x0c\n\x05\x05\x01\x02\x03\x02\x12\x03\x0f78\n\x0b\n\x04\x05\
    \x01\x02\x04\x12\x03\x10\x08(\n\x0c\n\x05\x05\x01\x02\x04\x01\x12\x03\
    \x10\x08#\n\x0c\n\x05\x05\x01\x02\x04\x02\x12\x03\x10&'\n\x0b\n\x04\x05\
    \x01\x02\x05\x12\x03\x11\x08)\n\x0c\n\x05\x05\x01\x02\x05\x01\x12\x03\
    \x11\x08$\n\x0c\n\x05\x05\x01\x02\x05\x02\x12\x03\x11'(\n\n\n\x02\x04\0\
    \x12\x04\x14\0\x17\x01\n\n\n\x03\x04\0\x01\x12\x03\x14\x08\x15\n\x0b\n\
    \x04\x04\0\x02\0\x12\x03\x15\x08!\n\x0c\n\x05\x04\0\x02\0\x04\x12\x03\
    \x15\x08\x10\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x15\x11\x17\n\x0c\n\x05\
    \x04\0\x02\0\x01\x12\x03\x15\x18\x1c\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\
    \x15\x1f\x20\n\x0b\n\x04\x04\0\x02\x01\x12\x03\x16\x08\x1f\n\x0c\n\x05\
    \x04\0\x02\x01\x04\x12\x03\x16\x08\x10\n\x0c\n\x05\x04\0\x02\x01\x05\x12\
    \x03\x16\x11\x17\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x16\x18\x1a\n\x0c\
    \n\x05\x04\0\x02\x01\x03\x12\x03\x16\x1d\x1e\n\n\n\x02\x04\x01\x12\x04\
    \x19\0\x20\x01\n\n\n\x03\x04\x01\x01\x12\x03\x19\x08\x1a\n\x0b\n\x04\x04\
    \x01\x02\0\x12\x03\x1a\x08#\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03\x1a\
    \x08\x10\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03\x1a\x11\x18\n\x0c\n\x05\
    \x04\x01\x02\0\x01\x12\x03\x1a\x19\x1e\n\x0c\n\x05\x04\x01\x02\0\x03\x12\
    \x03\x1a!\"\n\x0b\n\x04\x04\x01\x02\x01\x12\x03\x1b\x08#\n\x0c\n\x05\x04\
    \x01\x02\x01\x04\x12\x03\x1b\x08\x10\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\
    \x03\x1b\x11\x16\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\x1b\x17\x1e\n\
    \x0c\n\x05\x04\x01\x02\x01\x03\x12\x03\x1b!\"\n\x0b\n\x04\x04\x01\x02\
    \x02\x12\x03\x1c\x08'\n\x0c\n\x05\x04\x01\x02\x02\x04\x12\x03\x1c\x08\
    \x10\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03\x1c\x11\x16\n\x0c\n\x05\x04\
    \x01\x02\x02\x01\x12\x03\x1c\x17\"\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\
    \x03\x1c%&\n\x0b\n\x04\x04\x01\x02\x03\x12\x03\x1d\x08%\n\x0c\n\x05\x04\
    \x01\x02\x03\x04\x12\x03\x1d\x08\x10\n\x0c\n\x05\x04\x01\x02\x03\x05\x12\
    \x03\x1d\x11\x18\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x03\x1d\x19\x20\n\
    \x0c\n\x05\x04\x01\x02\x03\x03\x12\x03\x1d#$\n\x0b\n\x04\x04\x01\x02\x04\
    \x12\x03\x1e\x08/\n\x0c\n\x05\x04\x01\x02\x04\x04\x12\x03\x1e\x08\x10\n\
    \x0c\n\x05\x04\x01\x02\x04\x06\x12\x03\x1e\x11\x1f\n\x0c\n\x05\x04\x01\
    \x02\x04\x01\x12\x03\x1e\x20*\n\x0c\n\x05\x04\x01\x02\x04\x03\x12\x03\
    \x1e-.\n\x0b\n\x04\x04\x01\x02\x05\x12\x03\x1f\x08'\n\x0c\n\x05\x04\x01\
    \x02\x05\x04\x12\x03\x1f\x08\x10\n\x0c\n\x05\x04\x01\x02\x05\x05\x12\x03\
    \x1f\x11\x17\n\x0c\n\x05\x04\x01\x02\x05\x01\x12\x03\x1f\x18\"\n\x0c\n\
    \x05\x04\x01\x02\x05\x03\x12\x03\x1f%&\n\n\n\x02\x04\x02\x12\x04\"\0-\
    \x01\n\n\n\x03\x04\x02\x01\x12\x03\"\x08\x1d\n\x0c\n\x04\x04\x02\x03\0\
    \x12\x04#\x08&\t\n\x0c\n\x05\x04\x02\x03\0\x01\x12\x03#\x10\x1c\n\r\n\
    \x06\x04\x02\x03\0\x02\0\x12\x03$\x10+\n\x0e\n\x07\x04\x02\x03\0\x02\0\
    \x04\x12\x03$\x10\x18\n\x0e\n\x07\x04\x02\x03\0\x02\0\x05\x12\x03$\x19\
    \x1e\n\x0e\n\x07\x04\x02\x03\0\x02\0\x01\x12\x03$\x1f&\n\x0e\n\x07\x04\
    \x02\x03\0\x02\0\x03\x12\x03$)*\n\r\n\x06\x04\x02\x03\0\x02\x01\x12\x03%\
    \x10/\n\x0e\n\x07\x04\x02\x03\0\x02\x01\x04\x12\x03%\x10\x18\n\x0e\n\x07\
    \x04\x02\x03\0\x02\x01\x05\x12\x03%\x19\x1e\n\x0e\n\x07\x04\x02\x03\0\
    \x02\x01\x01\x12\x03%\x1f*\n\x0e\n\x07\x04\x02\x03\0\x02\x01\x03\x12\x03\
    %-.\n\x0b\n\x04\x04\x02\x02\0\x12\x03(\x08#\n\x0c\n\x05\x04\x02\x02\0\
    \x04\x12\x03(\x08\x10\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03(\x11\x18\n\
    \x0c\n\x05\x04\x02\x02\0\x01\x12\x03(\x19\x1e\n\x0c\n\x05\x04\x02\x02\0\
    \x03\x12\x03(!\"\n\x0b\n\x04\x04\x02\x02\x01\x12\x03)\x08A\n\x0c\n\x05\
    \x04\x02\x02\x01\x04\x12\x03)\x08\x10\n\x0c\n\x05\x04\x02\x02\x01\x06\
    \x12\x03)\x114\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03)5<\n\x0c\n\x05\
    \x04\x02\x02\x01\x03\x12\x03)?@\n\x0b\n\x04\x04\x02\x02\x02\x12\x03*\x08\
    %\n\x0c\n\x05\x04\x02\x02\x02\x04\x12\x03*\x08\x10\n\x0c\n\x05\x04\x02\
    \x02\x02\x05\x12\x03*\x11\x18\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03*\
    \x19\x20\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x03*#$\n\x0b\n\x04\x04\x02\
    \x02\x03\x12\x03+\x08/\n\x0c\n\x05\x04\x02\x02\x03\x04\x12\x03+\x08\x10\
    \n\x0c\n\x05\x04\x02\x02\x03\x06\x12\x03+\x11\x1f\n\x0c\n\x05\x04\x02\
    \x02\x03\x01\x12\x03+\x20*\n\x0c\n\x05\x04\x02\x02\x03\x03\x12\x03+-.\n\
    \x0b\n\x04\x04\x02\x02\x04\x12\x03,\x08'\n\x0c\n\x05\x04\x02\x02\x04\x04\
    \x12\x03,\x08\x10\n\x0c\n\x05\x04\x02\x02\x04\x05\x12\x03,\x11\x17\n\x0c\
    \n\x05\x04\x02\x02\x04\x01\x12\x03,\x18\"\n\x0c\n\x05\x04\x02\x02\x04\
    \x03\x12\x03,%&\n\n\n\x02\x04\x03\x12\x04/\0<\x01\n\n\n\x03\x04\x03\x01\
    \x12\x03/\x08\x1d\n\x0c\n\x04\x04\x03\x03\0\x12\x040\x083\t\n\x0c\n\x05\
    \x04\x03\x03\0\x01\x12\x030\x10\x1e\n\r\n\x06\x04\x03\x03\0\x02\0\x12\
    \x031\x10+\n\x0e\n\x07\x04\x03\x03\0\x02\0\x04\x12\x031\x10\x18\n\x0e\n\
    \x07\x04\x03\x03\0\x02\0\x05\x12\x031\x19\x1e\n\x0e\n\x07\x04\x03\x03\0\
    \x02\0\x01\x12\x031\x1f&\n\x0e\n\x07\x04\x03\x03\0\x02\0\x03\x12\x031)*\
    \n\r\n\x06\x04\x03\x03\0\x02\x01\x12\x032\x10/\n\x0e\n\x07\x04\x03\x03\0\
    \x02\x01\x04\x12\x032\x10\x18\n\x0e\n\x07\x04\x03\x03\0\x02\x01\x05\x12\
    \x032\x19\x1e\n\x0e\n\x07\x04\x03\x03\0\x02\x01\x01\x12\x032\x1f*\n\x0e\
    \n\x07\x04\x03\x03\0\x02\x01\x03\x12\x032-.\n\x0b\n\x04\x04\x03\x02\0\
    \x12\x035\x08#\n\x0c\n\x05\x04\x03\x02\0\x04\x12\x035\x08\x10\n\x0c\n\
    \x05\x04\x03\x02\0\x05\x12\x035\x11\x18\n\x0c\n\x05\x04\x03\x02\0\x01\
    \x12\x035\x19\x1e\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x035!\"\n\x0b\n\x04\
    \x04\x03\x02\x01\x12\x036\x08C\n\x0c\n\x05\x04\x03\x02\x01\x04\x12\x036\
    \x08\x10\n\x0c\n\x05\x04\x03\x02\x01\x06\x12\x036\x116\n\x0c\n\x05\x04\
    \x03\x02\x01\x01\x12\x0367>\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x036AB\n\
    \x0b\n\x04\x04\x03\x02\x02\x12\x037\x08%\n\x0c\n\x05\x04\x03\x02\x02\x04\
    \x12\x037\x08\x10\n\x0c\n\x05\x04\x03\x02\x02\x05\x12\x037\x11\x18\n\x0c\
    \n\x05\x04\x03\x02\x02\x01\x12\x037\x19\x20\n\x0c\n\x05\x04\x03\x02\x02\
    \x03\x12\x037#$\n\x0b\n\x04\x04\x03\x02\x03\x12\x038\x08/\n\x0c\n\x05\
    \x04\x03\x02\x03\x04\x12\x038\x08\x10\n\x0c\n\x05\x04\x03\x02\x03\x06\
    \x12\x038\x11\x1f\n\x0c\n\x05\x04\x03\x02\x03\x01\x12\x038\x20*\n\x0c\n\
    \x05\x04\x03\x02\x03\x03\x12\x038-.\n\x0b\n\x04\x04\x03\x02\x04\x12\x039\
    \x08'\n\x0c\n\x05\x04\x03\x02\x04\x04\x12\x039\x08\x10\n\x0c\n\x05\x04\
    \x03\x02\x04\x05\x12\x039\x11\x17\n\x0c\n\x05\x04\x03\x02\x04\x01\x12\
    \x039\x18\"\n\x0c\n\x05\x04\x03\x02\x04\x03\x12\x039%&\n\x0b\n\x04\x04\
    \x03\x02\x05\x12\x03:\x08)\n\x0c\n\x05\x04\x03\x02\x05\x04\x12\x03:\x08\
    \x10\n\x0c\n\x05\x04\x03\x02\x05\x05\x12\x03:\x11\x17\n\x0c\n\x05\x04\
    \x03\x02\x05\x01\x12\x03:\x18$\n\x0c\n\x05\x04\x03\x02\x05\x03\x12\x03:'\
    (\n\x0b\n\x04\x04\x03\x02\x06\x12\x03;\x08*\n\x0c\n\x05\x04\x03\x02\x06\
    \x04\x12\x03;\x08\x10\n\x0c\n\x05\x04\x03\x02\x06\x05\x12\x03;\x11\x18\n\
    \x0c\n\x05\x04\x03\x02\x06\x01\x12\x03;\x19%\n\x0c\n\x05\x04\x03\x02\x06\
    \x03\x12\x03;()\n\n\n\x02\x04\x04\x12\x04>\0D\x01\n\n\n\x03\x04\x04\x01\
    \x12\x03>\x08%\n\x0b\n\x04\x04\x04\x02\0\x12\x03?\x08%\n\x0c\n\x05\x04\
    \x04\x02\0\x04\x12\x03?\x08\x10\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03?\
    \x11\x18\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03?\x19\x20\n\x0c\n\x05\x04\
    \x04\x02\0\x03\x12\x03?#$\n\x0b\n\x04\x04\x04\x02\x01\x12\x03@\x08/\n\
    \x0c\n\x05\x04\x04\x02\x01\x04\x12\x03@\x08\x10\n\x0c\n\x05\x04\x04\x02\
    \x01\x06\x12\x03@\x11\x1f\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03@\x20*\
    \n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03@-.\n\x0b\n\x04\x04\x04\x02\x02\
    \x12\x03A\x08'\n\x0c\n\x05\x04\x04\x02\x02\x04\x12\x03A\x08\x10\n\x0c\n\
    \x05\x04\x04\x02\x02\x05\x12\x03A\x11\x17\n\x0c\n\x05\x04\x04\x02\x02\
    \x01\x12\x03A\x18\"\n\x0c\n\x05\x04\x04\x02\x02\x03\x12\x03A%&\n\x0b\n\
    \x04\x04\x04\x02\x03\x12\x03B\x08)\n\x0c\n\x05\x04\x04\x02\x03\x04\x12\
    \x03B\x08\x10\n\x0c\n\x05\x04\x04\x02\x03\x05\x12\x03B\x11\x17\n\x0c\n\
    \x05\x04\x04\x02\x03\x01\x12\x03B\x18$\n\x0c\n\x05\x04\x04\x02\x03\x03\
    \x12\x03B'(\n\x0b\n\x04\x04\x04\x02\x04\x12\x03C\x08*\n\x0c\n\x05\x04\
    \x04\x02\x04\x04\x12\x03C\x08\x10\n\x0c\n\x05\x04\x04\x02\x04\x05\x12\
    \x03C\x11\x18\n\x0c\n\x05\x04\x04\x02\x04\x01\x12\x03C\x19%\n\x0c\n\x05\
    \x04\x04\x02\x04\x03\x12\x03C()\n\n\n\x02\x04\x05\x12\x04F\0H\x01\n\n\n\
    \x03\x04\x05\x01\x12\x03F\x08\x1f\n\x0b\n\x04\x04\x05\x02\0\x12\x03G\x08\
    #\n\x0c\n\x05\x04\x05\x02\0\x04\x12\x03G\x08\x10\n\x0c\n\x05\x04\x05\x02\
    \0\x05\x12\x03G\x11\x18\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03G\x19\x1e\n\
    \x0c\n\x05\x04\x05\x02\0\x03\x12\x03G!\"\n\n\n\x02\x04\x06\x12\x04J\0Q\
    \x01\n\n\n\x03\x04\x06\x01\x12\x03J\x08$\n\x0b\n\x04\x04\x06\x02\0\x12\
    \x03K\x08#\n\x0c\n\x05\x04\x06\x02\0\x04\x12\x03K\x08\x10\n\x0c\n\x05\
    \x04\x06\x02\0\x05\x12\x03K\x11\x18\n\x0c\n\x05\x04\x06\x02\0\x01\x12\
    \x03K\x19\x1e\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03K!\"\n\x0b\n\x04\x04\
    \x06\x02\x01\x12\x03L\x08%\n\x0c\n\x05\x04\x06\x02\x01\x04\x12\x03L\x08\
    \x10\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x03L\x11\x18\n\x0c\n\x05\x04\
    \x06\x02\x01\x01\x12\x03L\x19\x20\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\
    \x03L#$\n\x0b\n\x04\x04\x06\x02\x02\x12\x03M\x08/\n\x0c\n\x05\x04\x06\
    \x02\x02\x04\x12\x03M\x08\x10\n\x0c\n\x05\x04\x06\x02\x02\x06\x12\x03M\
    \x11\x1f\n\x0c\n\x05\x04\x06\x02\x02\x01\x12\x03M\x20*\n\x0c\n\x05\x04\
    \x06\x02\x02\x03\x12\x03M-.\n\x0b\n\x04\x04\x06\x02\x03\x12\x03N\x08'\n\
    \x0c\n\x05\x04\x06\x02\x03\x04\x12\x03N\x08\x10\n\x0c\n\x05\x04\x06\x02\
    \x03\x05\x12\x03N\x11\x17\n\x0c\n\x05\x04\x06\x02\x03\x01\x12\x03N\x18\"\
    \n\x0c\n\x05\x04\x06\x02\x03\x03\x12\x03N%&\n\x0b\n\x04\x04\x06\x02\x04\
    \x12\x03O\x08)\n\x0c\n\x05\x04\x06\x02\x04\x04\x12\x03O\x08\x10\n\x0c\n\
    \x05\x04\x06\x02\x04\x05\x12\x03O\x11\x17\n\x0c\n\x05\x04\x06\x02\x04\
    \x01\x12\x03O\x18$\n\x0c\n\x05\x04\x06\x02\x04\x03\x12\x03O'(\n\x0b\n\
    \x04\x04\x06\x02\x05\x12\x03P\x08*\n\x0c\n\x05\x04\x06\x02\x05\x04\x12\
    \x03P\x08\x10\n\x0c\n\x05\x04\x06\x02\x05\x05\x12\x03P\x11\x18\n\x0c\n\
    \x05\x04\x06\x02\x05\x01\x12\x03P\x19%\n\x0c\n\x05\x04\x06\x02\x05\x03\
    \x12\x03P()\n\n\n\x02\x04\x07\x12\x04S\0V\x01\n\n\n\x03\x04\x07\x01\x12\
    \x03S\x08&\n\x0b\n\x04\x04\x07\x02\0\x12\x03T\x08#\n\x0c\n\x05\x04\x07\
    \x02\0\x04\x12\x03T\x08\x10\n\x0c\n\x05\x04\x07\x02\0\x05\x12\x03T\x11\
    \x18\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03T\x19\x1e\n\x0c\n\x05\x04\x07\
    \x02\0\x03\x12\x03T!\"\n\x0b\n\x04\x04\x07\x02\x01\x12\x03U\x08/\n\x0c\n\
    \x05\x04\x07\x02\x01\x04\x12\x03U\x08\x10\n\x0c\n\x05\x04\x07\x02\x01\
    \x06\x12\x03U\x11\x1f\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03U\x20*\n\
    \x0c\n\x05\x04\x07\x02\x01\x03\x12\x03U-.\n\n\n\x02\x04\x08\x12\x04X\0Z\
    \x01\n\n\n\x03\x04\x08\x01\x12\x03X\x08\x1a\n\x0b\n\x04\x04\x08\x02\0\
    \x12\x03Y\x08%\n\x0c\n\x05\x04\x08\x02\0\x04\x12\x03Y\x08\x10\n\x0c\n\
    \x05\x04\x08\x02\0\x05\x12\x03Y\x11\x18\n\x0c\n\x05\x04\x08\x02\0\x01\
    \x12\x03Y\x19\x20\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03Y#$\n\n\n\x02\x04\
    \t\x12\x04\\\0`\x01\n\n\n\x03\x04\t\x01\x12\x03\\\x08\x1e\n\x0b\n\x04\
    \x04\t\x02\0\x12\x03]\x08$\n\x0c\n\x05\x04\t\x02\0\x04\x12\x03]\x08\x10\
    \n\x0c\n\x05\x04\t\x02\0\x05\x12\x03]\x11\x17\n\x0c\n\x05\x04\t\x02\0\
    \x01\x12\x03]\x18\x1f\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03]\"#\n\x0b\n\
    \x04\x04\t\x02\x01\x12\x03^\x08#\n\x0c\n\x05\x04\t\x02\x01\x04\x12\x03^\
    \x08\x10\n\x0c\n\x05\x04\t\x02\x01\x05\x12\x03^\x11\x16\n\x0c\n\x05\x04\
    \t\x02\x01\x01\x12\x03^\x17\x1e\n\x0c\n\x05\x04\t\x02\x01\x03\x12\x03^!\
    \"\n\x0b\n\x04\x04\t\x02\x02\x12\x03_\x08&\n\x0c\n\x05\x04\t\x02\x02\x04\
    \x12\x03_\x08\x10\n\x0c\n\x05\x04\t\x02\x02\x05\x12\x03_\x11\x18\n\x0c\n\
    \x05\x04\t\x02\x02\x01\x12\x03_\x19!\n\x0c\n\x05\x04\t\x02\x02\x03\x12\
    \x03_$%\n\n\n\x02\x04\n\x12\x04b\0g\x01\n\n\n\x03\x04\n\x01\x12\x03b\x08\
    \x1b\n\x0b\n\x04\x04\n\x02\0\x12\x03c\x08&\n\x0c\n\x05\x04\n\x02\0\x04\
    \x12\x03c\x08\x10\n\x0c\n\x05\x04\n\x02\0\x05\x12\x03c\x11\x17\n\x0c\n\
    \x05\x04\n\x02\0\x01\x12\x03c\x18!\n\x0c\n\x05\x04\n\x02\0\x03\x12\x03c$\
    %\n\x0b\n\x04\x04\n\x02\x01\x12\x03d\x08)\n\x0c\n\x05\x04\n\x02\x01\x04\
    \x12\x03d\x08\x10\n\x0c\n\x05\x04\n\x02\x01\x05\x12\x03d\x11\x17\n\x0c\n\
    \x05\x04\n\x02\x01\x01\x12\x03d\x18$\n\x0c\n\x05\x04\n\x02\x01\x03\x12\
    \x03d'(\n\x0b\n\x04\x04\n\x02\x02\x12\x03e\x08)\n\x0c\n\x05\x04\n\x02\
    \x02\x04\x12\x03e\x08\x10\n\x0c\n\x05\x04\n\x02\x02\x05\x12\x03e\x11\x17\
    \n\x0c\n\x05\x04\n\x02\x02\x01\x12\x03e\x18$\n\x0c\n\x05\x04\n\x02\x02\
    \x03\x12\x03e'(\n\x0b\n\x04\x04\n\x02\x03\x12\x03f\x08+\n\x0c\n\x05\x04\
    \n\x02\x03\x04\x12\x03f\x08\x10\n\x0c\n\x05\x04\n\x02\x03\x05\x12\x03f\
    \x11\x17\n\x0c\n\x05\x04\n\x02\x03\x01\x12\x03f\x18&\n\x0c\n\x05\x04\n\
    \x02\x03\x03\x12\x03f)*\n\n\n\x02\x04\x0b\x12\x04i\0k\x01\n\n\n\x03\x04\
    \x0b\x01\x12\x03i\x08$\n\x0b\n\x04\x04\x0b\x02\0\x12\x03j\x081\n\x0c\n\
    \x05\x04\x0b\x02\0\x04\x12\x03j\x08\x10\n\x0c\n\x05\x04\x0b\x02\0\x05\
    \x12\x03j\x11\x16\n\x0c\n\x05\x04\x0b\x02\0\x01\x12\x03j\x17\x1e\n\x0c\n\
    \x05\x04\x0b\x02\0\x03\x12\x03j!\"\n\x0c\n\x05\x04\x0b\x02\0\x08\x12\x03\
    j#0\n\x0c\n\x05\x04\x0b\x02\0\x07\x12\x03j./\n\n\n\x02\x04\x0c\x12\x04m\
    \0t\x01\n\n\n\x03\x04\x0c\x01\x12\x03m\x08'\n\x0c\n\x04\x04\x0c\x03\0\
    \x12\x04n\x08q\t\n\x0c\n\x05\x04\x0c\x03\0\x01\x12\x03n\x10\x16\n\r\n\
    \x06\x04\x0c\x03\0\x02\0\x12\x03o\x10.\n\x0e\n\x07\x04\x0c\x03\0\x02\0\
    \x04\x12\x03o\x10\x18\n\x0e\n\x07\x04\x0c\x03\0\x02\0\x05\x12\x03o\x19\
    \x1f\n\x0e\n\x07\x04\x0c\x03\0\x02\0\x01\x12\x03o\x20)\n\x0e\n\x07\x04\
    \x0c\x03\0\x02\0\x03\x12\x03o,-\n\r\n\x06\x04\x0c\x03\0\x02\x01\x12\x03p\
    \x101\n\x0e\n\x07\x04\x0c\x03\0\x02\x01\x04\x12\x03p\x10\x18\n\x0e\n\x07\
    \x04\x0c\x03\0\x02\x01\x05\x12\x03p\x19\x1f\n\x0e\n\x07\x04\x0c\x03\0\
    \x02\x01\x01\x12\x03p\x20,\n\x0e\n\x07\x04\x0c\x03\0\x02\x01\x03\x12\x03\
    p/0\n\x0b\n\x04\x04\x0c\x02\0\x12\x03s\x08E\n\x0c\n\x05\x04\x0c\x02\0\
    \x04\x12\x03s\x08\x10\n\x0c\n\x05\x04\x0c\x02\0\x06\x12\x03s\x118\n\x0c\
    \n\x05\x04\x0c\x02\0\x01\x12\x03s9@\n\x0c\n\x05\x04\x0c\x02\0\x03\x12\
    \x03sCD\n\n\n\x02\x04\r\x12\x04v\0z\x01\n\n\n\x03\x04\r\x01\x12\x03v\x08\
    \x18\n\x0b\n\x04\x04\r\x02\0\x12\x03w\x08%\n\x0c\n\x05\x04\r\x02\0\x04\
    \x12\x03w\x08\x10\n\x0c\n\x05\x04\r\x02\0\x05\x12\x03w\x11\x17\n\x0c\n\
    \x05\x04\r\x02\0\x01\x12\x03w\x18\x20\n\x0c\n\x05\x04\r\x02\0\x03\x12\
    \x03w#$\n\x0b\n\x04\x04\r\x02\x01\x12\x03x\x08'\n\x0c\n\x05\x04\r\x02\
    \x01\x04\x12\x03x\x08\x10\n\x0c\n\x05\x04\r\x02\x01\x05\x12\x03x\x11\x18\
    \n\x0c\n\x05\x04\r\x02\x01\x01\x12\x03x\x19\"\n\x0c\n\x05\x04\r\x02\x01\
    \x03\x12\x03x%&\n\x0b\n\x04\x04\r\x02\x02\x12\x03y\x08'\n\x0c\n\x05\x04\
    \r\x02\x02\x04\x12\x03y\x08\x10\n\x0c\n\x05\x04\r\x02\x02\x05\x12\x03y\
    \x11\x16\n\x0c\n\x05\x04\r\x02\x02\x01\x12\x03y\x17\"\n\x0c\n\x05\x04\r\
    \x02\x02\x03\x12\x03y%&\n\n\n\x02\x04\x0e\x12\x04|\0\x7f\x01\n\n\n\x03\
    \x04\x0e\x01\x12\x03|\x08\x1d\n\x0b\n\x04\x04\x0e\x02\0\x12\x03}\x08%\n\
    \x0c\n\x05\x04\x0e\x02\0\x04\x12\x03}\x08\x10\n\x0c\n\x05\x04\x0e\x02\0\
    \x05\x12\x03}\x11\x17\n\x0c\n\x05\x04\x0e\x02\0\x01\x12\x03}\x18\x20\n\
    \x0c\n\x05\x04\x0e\x02\0\x03\x12\x03}#$\n\x0b\n\x04\x04\x0e\x02\x01\x12\
    \x03~\x08'\n\x0c\n\x05\x04\x0e\x02\x01\x04\x12\x03~\x08\x10\n\x0c\n\x05\
    \x04\x0e\x02\x01\x05\x12\x03~\x11\x16\n\x0c\n\x05\x04\x0e\x02\x01\x01\
    \x12\x03~\x17\"\n\x0c\n\x05\x04\x0e\x02\x01\x03\x12\x03~%&\n\x0c\n\x02\
    \x04\x0f\x12\x06\x81\x01\0\x89\x01\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\
    \x81\x01\x08$\n\x0e\n\x04\x04\x0f\x03\0\x12\x06\x82\x01\x08\x86\x01\t\n\
    \r\n\x05\x04\x0f\x03\0\x01\x12\x04\x82\x01\x10\x1a\n\x0e\n\x06\x04\x0f\
    \x03\0\x02\0\x12\x04\x83\x01\x10-\n\x0f\n\x07\x04\x0f\x03\0\x02\0\x04\
    \x12\x04\x83\x01\x10\x18\n\x0f\n\x07\x04\x0f\x03\0\x02\0\x05\x12\x04\x83\
    \x01\x19\x20\n\x0f\n\x07\x04\x0f\x03\0\x02\0\x01\x12\x04\x83\x01!(\n\x0f\
    \n\x07\x04\x0f\x03\0\x02\0\x03\x12\x04\x83\x01+,\n\x0e\n\x06\x04\x0f\x03\
    \0\x02\x01\x12\x04\x84\x01\x10(\n\x0f\n\x07\x04\x0f\x03\0\x02\x01\x04\
    \x12\x04\x84\x01\x10\x18\n\x0f\n\x07\x04\x0f\x03\0\x02\x01\x05\x12\x04\
    \x84\x01\x19\x20\n\x0f\n\x07\x04\x0f\x03\0\x02\x01\x01\x12\x04\x84\x01!#\
    \n\x0f\n\x07\x04\x0f\x03\0\x02\x01\x03\x12\x04\x84\x01&'\n\x0e\n\x06\x04\
    \x0f\x03\0\x02\x02\x12\x04\x85\x01\x10*\n\x0f\n\x07\x04\x0f\x03\0\x02\
    \x02\x04\x12\x04\x85\x01\x10\x18\n\x0f\n\x07\x04\x0f\x03\0\x02\x02\x05\
    \x12\x04\x85\x01\x19\x1d\n\x0f\n\x07\x04\x0f\x03\0\x02\x02\x01\x12\x04\
    \x85\x01\x1e%\n\x0f\n\x07\x04\x0f\x03\0\x02\x02\x03\x12\x04\x85\x01()\n\
    \x0c\n\x04\x04\x0f\x02\0\x12\x04\x88\x01\x08F\n\r\n\x05\x04\x0f\x02\0\
    \x04\x12\x04\x88\x01\x08\x10\n\r\n\x05\x04\x0f\x02\0\x06\x12\x04\x88\x01\
    \x119\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\x88\x01:A\n\r\n\x05\x04\x0f\
    \x02\0\x03\x12\x04\x88\x01DE\n\x0c\n\x02\x04\x10\x12\x06\x8b\x01\0\x8d\
    \x01\x01\n\x0b\n\x03\x04\x10\x01\x12\x04\x8b\x01\x08%\n\x0c\n\x04\x04\
    \x10\x02\0\x12\x04\x8c\x01\x08%\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\x8c\
    \x01\x08\x10\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\x8c\x01\x11\x18\n\r\n\
    \x05\x04\x10\x02\0\x01\x12\x04\x8c\x01\x19\x20\n\r\n\x05\x04\x10\x02\0\
    \x03\x12\x04\x8c\x01#$\n\x0c\n\x02\x04\x11\x12\x06\x8f\x01\0\x92\x01\x01\
    \n\x0b\n\x03\x04\x11\x01\x12\x04\x8f\x01\x08-\n\x0c\n\x04\x04\x11\x02\0\
    \x12\x04\x90\x01\x08\x20\n\r\n\x05\x04\x11\x02\0\x04\x12\x04\x90\x01\x08\
    \x10\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\x90\x01\x11\x18\n\r\n\x05\x04\
    \x11\x02\0\x01\x12\x04\x90\x01\x19\x1b\n\r\n\x05\x04\x11\x02\0\x03\x12\
    \x04\x90\x01\x1e\x1f\n\x0c\n\x04\x04\x11\x02\x01\x12\x04\x91\x01\x08\"\n\
    \r\n\x05\x04\x11\x02\x01\x04\x12\x04\x91\x01\x08\x10\n\r\n\x05\x04\x11\
    \x02\x01\x05\x12\x04\x91\x01\x11\x15\n\r\n\x05\x04\x11\x02\x01\x01\x12\
    \x04\x91\x01\x16\x1d\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\x91\x01\x20!\
    \n\x0c\n\x02\x04\x12\x12\x06\x94\x01\0\x96\x01\x01\n\x0b\n\x03\x04\x12\
    \x01\x12\x04\x94\x01\x08+\n\x0c\n\x04\x04\x12\x02\0\x12\x04\x95\x01\x08%\
    \n\r\n\x05\x04\x12\x02\0\x04\x12\x04\x95\x01\x08\x10\n\r\n\x05\x04\x12\
    \x02\0\x05\x12\x04\x95\x01\x11\x18\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\
    \x95\x01\x19\x20\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\x95\x01#$\n\x0c\n\
    \x02\x04\x13\x12\x06\x98\x01\0\x9c\x01\x01\n\x0b\n\x03\x04\x13\x01\x12\
    \x04\x98\x01\x08\x1e\n\x0c\n\x04\x04\x13\x02\0\x12\x04\x99\x01\x08)\n\r\
    \n\x05\x04\x13\x02\0\x04\x12\x04\x99\x01\x08\x10\n\r\n\x05\x04\x13\x02\0\
    \x06\x12\x04\x99\x01\x11\x1f\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\x99\x01\
    \x20$\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\x99\x01'(\n\x0c\n\x04\x04\x13\
    \x02\x01\x12\x04\x9a\x01\x08%\n\r\n\x05\x04\x13\x02\x01\x04\x12\x04\x9a\
    \x01\x08\x10\n\r\n\x05\x04\x13\x02\x01\x05\x12\x04\x9a\x01\x11\x18\n\r\n\
    \x05\x04\x13\x02\x01\x01\x12\x04\x9a\x01\x19\x20\n\r\n\x05\x04\x13\x02\
    \x01\x03\x12\x04\x9a\x01#$\n\x0c\n\x04\x04\x13\x02\x02\x12\x04\x9b\x01\
    \x08'\n\r\n\x05\x04\x13\x02\x02\x04\x12\x04\x9b\x01\x08\x10\n\r\n\x05\
    \x04\x13\x02\x02\x05\x12\x04\x9b\x01\x11\x17\n\r\n\x05\x04\x13\x02\x02\
    \x01\x12\x04\x9b\x01\x18\"\n\r\n\x05\x04\x13\x02\x02\x03\x12\x04\x9b\x01\
    %&\n\x0c\n\x02\x04\x14\x12\x06\x9e\x01\0\xa5\x01\x01\n\x0b\n\x03\x04\x14\
    \x01\x12\x04\x9e\x01\x08\x1c\n\x0c\n\x04\x04\x14\x02\0\x12\x04\x9f\x01\
    \x08\\\n\r\n\x05\x04\x14\x02\0\x04\x12\x04\x9f\x01\x08\x10\n\r\n\x05\x04\
    \x14\x02\0\x06\x12\x04\x9f\x01\x11$\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\
    \x9f\x01%+\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\x9f\x01./\n\r\n\x05\x04\
    \x14\x02\0\x08\x12\x04\x9f\x010[\n\r\n\x05\x04\x14\x02\0\x07\x12\x04\x9f\
    \x01;Z\n\x0c\n\x04\x04\x14\x02\x01\x12\x04\xa0\x01\x080\n\r\n\x05\x04\
    \x14\x02\x01\x04\x12\x04\xa0\x01\x08\x10\n\r\n\x05\x04\x14\x02\x01\x05\
    \x12\x04\xa0\x01\x11\x17\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\xa0\x01\
    \x18+\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\xa0\x01./\n\x0c\n\x04\x04\
    \x14\x02\x02\x12\x04\xa1\x01\x08*\n\r\n\x05\x04\x14\x02\x02\x04\x12\x04\
    \xa1\x01\x08\x10\n\r\n\x05\x04\x14\x02\x02\x05\x12\x04\xa1\x01\x11\x16\n\
    \r\n\x05\x04\x14\x02\x02\x01\x12\x04\xa1\x01\x17%\n\r\n\x05\x04\x14\x02\
    \x02\x03\x12\x04\xa1\x01()\n\x0c\n\x04\x04\x14\x02\x03\x12\x04\xa2\x01\
    \x08&\n\r\n\x05\x04\x14\x02\x03\x04\x12\x04\xa2\x01\x08\x10\n\r\n\x05\
    \x04\x14\x02\x03\x05\x12\x04\xa2\x01\x11\x16\n\r\n\x05\x04\x14\x02\x03\
    \x01\x12\x04\xa2\x01\x17!\n\r\n\x05\x04\x14\x02\x03\x03\x12\x04\xa2\x01$\
    %\n\x0c\n\x04\x04\x14\x02\x04\x12\x04\xa3\x01\x08(\n\r\n\x05\x04\x14\x02\
    \x04\x04\x12\x04\xa3\x01\x08\x10\n\r\n\x05\x04\x14\x02\x04\x05\x12\x04\
    \xa3\x01\x11\x16\n\r\n\x05\x04\x14\x02\x04\x01\x12\x04\xa3\x01\x17#\n\r\
    \n\x05\x04\x14\x02\x04\x03\x12\x04\xa3\x01&'\n\x0c\n\x04\x04\x14\x02\x05\
    \x12\x04\xa4\x01\x08<\n\r\n\x05\x04\x14\x02\x05\x04\x12\x04\xa4\x01\x08\
    \x10\n\r\n\x05\x04\x14\x02\x05\x05\x12\x04\xa4\x01\x11\x16\n\r\n\x05\x04\
    \x14\x02\x05\x01\x12\x04\xa4\x01\x177\n\r\n\x05\x04\x14\x02\x05\x03\x12\
    \x04\xa4\x01:;\n\x0c\n\x02\x04\x15\x12\x06\xa7\x01\0\xb1\x01\x01\n\x0b\n\
    \x03\x04\x15\x01\x12\x04\xa7\x01\x08\"\n\x0e\n\x04\x04\x15\x03\0\x12\x06\
    \xa8\x01\x08\xab\x01\t\n\r\n\x05\x04\x15\x03\0\x01\x12\x04\xa8\x01\x10\
    \x20\n\x0e\n\x06\x04\x15\x03\0\x02\0\x12\x04\xa9\x01\x10/\n\x0f\n\x07\
    \x04\x15\x03\0\x02\0\x04\x12\x04\xa9\x01\x10\x18\n\x0f\n\x07\x04\x15\x03\
    \0\x02\0\x05\x12\x04\xa9\x01\x19\x1f\n\x0f\n\x07\x04\x15\x03\0\x02\0\x01\
    \x12\x04\xa9\x01\x20*\n\x0f\n\x07\x04\x15\x03\0\x02\0\x03\x12\x04\xa9\
    \x01-.\n\x0e\n\x06\x04\x15\x03\0\x02\x01\x12\x04\xaa\x01\x10,\n\x0f\n\
    \x07\x04\x15\x03\0\x02\x01\x04\x12\x04\xaa\x01\x10\x18\n\x0f\n\x07\x04\
    \x15\x03\0\x02\x01\x05\x12\x04\xaa\x01\x19\x1f\n\x0f\n\x07\x04\x15\x03\0\
    \x02\x01\x01\x12\x04\xaa\x01\x20'\n\x0f\n\x07\x04\x15\x03\0\x02\x01\x03\
    \x12\x04\xaa\x01*+\n\x0c\n\x04\x04\x15\x02\0\x12\x04\xad\x01\x08(\n\r\n\
    \x05\x04\x15\x02\0\x04\x12\x04\xad\x01\x08\x10\n\r\n\x05\x04\x15\x02\0\
    \x05\x12\x04\xad\x01\x11\x18\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\xad\x01\
    \x19#\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xad\x01&'\n\x0c\n\x04\x04\x15\
    \x02\x01\x12\x04\xae\x01\x08*\n\r\n\x05\x04\x15\x02\x01\x04\x12\x04\xae\
    \x01\x08\x10\n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\xae\x01\x11\x18\n\r\n\
    \x05\x04\x15\x02\x01\x01\x12\x04\xae\x01\x19%\n\r\n\x05\x04\x15\x02\x01\
    \x03\x12\x04\xae\x01()\n\x0c\n\x04\x04\x15\x02\x02\x12\x04\xaf\x01\x08*\
    \n\r\n\x05\x04\x15\x02\x02\x04\x12\x04\xaf\x01\x08\x10\n\r\n\x05\x04\x15\
    \x02\x02\x05\x12\x04\xaf\x01\x11\x18\n\r\n\x05\x04\x15\x02\x02\x01\x12\
    \x04\xaf\x01\x19%\n\r\n\x05\x04\x15\x02\x02\x03\x12\x04\xaf\x01()\n\x0c\
    \n\x04\x04\x15\x02\x03\x12\x04\xb0\x01\x08P\n\r\n\x05\x04\x15\x02\x03\
    \x04\x12\x04\xb0\x01\x08\x10\n\r\n\x05\x04\x15\x02\x03\x06\x12\x04\xb0\
    \x01\x11=\n\r\n\x05\x04\x15\x02\x03\x01\x12\x04\xb0\x01>K\n\r\n\x05\x04\
    \x15\x02\x03\x03\x12\x04\xb0\x01NO\n\x0c\n\x02\x04\x16\x12\x06\xb3\x01\0\
    \xb6\x01\x01\n\x0b\n\x03\x04\x16\x01\x12\x04\xb3\x01\x08$\n\x0c\n\x04\
    \x04\x16\x02\0\x12\x04\xb4\x01\x08(\n\r\n\x05\x04\x16\x02\0\x04\x12\x04\
    \xb4\x01\x08\x10\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\xb4\x01\x11\x18\n\r\
    \n\x05\x04\x16\x02\0\x01\x12\x04\xb4\x01\x19#\n\r\n\x05\x04\x16\x02\0\
    \x03\x12\x04\xb4\x01&'\n\x0c\n\x04\x04\x16\x02\x01\x12\x04\xb5\x01\x08.\
    \n\r\n\x05\x04\x16\x02\x01\x04\x12\x04\xb5\x01\x08\x10\n\r\n\x05\x04\x16\
    \x02\x01\x05\x12\x04\xb5\x01\x11\x18\n\r\n\x05\x04\x16\x02\x01\x01\x12\
    \x04\xb5\x01\x19)\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\xb5\x01,-\n\x0c\
    \n\x02\x04\x17\x12\x06\xb8\x01\0\xb9\x01\x01\n\x0b\n\x03\x04\x17\x01\x12\
    \x04\xb8\x01\x08\x18\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::steammessages::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(29);
            messages.push(CMsgSOIDOwner::generated_message_descriptor_data());
            messages.push(CMsgSOSingleObject::generated_message_descriptor_data());
            messages.push(CMsgSOMultipleObjects::generated_message_descriptor_data());
            messages.push(CMsgSOCacheSubscribed::generated_message_descriptor_data());
            messages.push(CMsgSOCacheSubscribedUpToDate::generated_message_descriptor_data());
            messages.push(CMsgSOCacheUnsubscribed::generated_message_descriptor_data());
            messages.push(CMsgSOCacheSubscriptionCheck::generated_message_descriptor_data());
            messages.push(CMsgSOCacheSubscriptionRefresh::generated_message_descriptor_data());
            messages.push(CMsgSOCacheVersion::generated_message_descriptor_data());
            messages.push(CMsgGCMultiplexMessage::generated_message_descriptor_data());
            messages.push(CGCToGCMsgMasterAck::generated_message_descriptor_data());
            messages.push(CGCToGCMsgMasterAck_Response::generated_message_descriptor_data());
            messages.push(CGCToGCMsgMasterStartupComplete::generated_message_descriptor_data());
            messages.push(CGCToGCMsgRouted::generated_message_descriptor_data());
            messages.push(CGCToGCMsgRoutedReply::generated_message_descriptor_data());
            messages.push(CMsgGCUpdateSubGCSessionInfo::generated_message_descriptor_data());
            messages.push(CMsgGCRequestSubGCSessionInfo::generated_message_descriptor_data());
            messages.push(CMsgGCRequestSubGCSessionInfoResponse::generated_message_descriptor_data());
            messages.push(CMsgGCToGCIncrementRecruitmentLevel::generated_message_descriptor_data());
            messages.push(CMsgSOCacheHaveVersion::generated_message_descriptor_data());
            messages.push(CMsgConnectionStatus::generated_message_descriptor_data());
            messages.push(CMsgGCToGCSOCacheSubscribe::generated_message_descriptor_data());
            messages.push(CMsgGCToGCSOCacheUnsubscribe::generated_message_descriptor_data());
            messages.push(CMsgGCClientPing::generated_message_descriptor_data());
            messages.push(cmsg_somultiple_objects::SingleObject::generated_message_descriptor_data());
            messages.push(cmsg_socache_subscribed::SubscribedType::generated_message_descriptor_data());
            messages.push(cgcto_gcmsg_master_startup_complete::GCInfo::generated_message_descriptor_data());
            messages.push(cmsg_gcupdate_sub_gcsession_info::CMsgUpdate::generated_message_descriptor_data());
            messages.push(cmsg_gcto_gcsocache_subscribe::CMsgHaveVersions::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(PartnerAccountType::generated_enum_descriptor_data());
            enums.push(GCConnectionStatus::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
